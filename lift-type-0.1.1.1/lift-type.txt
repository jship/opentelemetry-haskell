-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lift a type from a Typeable constraint to a Template Haskell type
--   
--   Lift your types from a Typeable constraint to a Template Haskell type
@package lift-type
@version 0.1.1.1


-- | Template Haskell has a class <a>Lift</a> that allows you to promote
--   values from Haskell-land into the land of metaprogramming - <a>Q</a>.
--   
--   <pre>
--   class <a>Lift</a> a where
--       <a>lift</a> :: a -&gt; <a>Q</a> <a>Exp</a>
--   
--       <a>liftTyped</a> :: a -&gt; <a>Q</a> (<a>TExp</a> a)
--   </pre>
--   
--   However, there wasn't a way to promote a *type* into a <tt><a>Q</a>
--   <a>Type</a></tt>.
--   
--   This library provides exactly that function. It requires a
--   <a>Typeable</a> constraint, but this is automatically satisfied by
--   GHC.
module LiftType

-- | <a>liftType</a> promoted to the <a>Q</a> monad.
liftTypeQ :: forall t. Typeable t => Q Type

-- | Promote a <a>SomeTypeRep</a> into a <a>Type</a>.
typeRepToType :: SomeTypeRep -> Type

-- | Convert a type argument into a Template Haskell <a>Type</a>.
--   
--   Use with <tt>TypeApplications</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   &gt;&gt;&gt; liftType @Bool
--   ConT GHC.Types.Bool
--   &gt;&gt;&gt; liftType @[Char]
--   AppT (ConT GHC.Types.[]) (ConT GHC.Types.Char)
--   </pre>
--   
--   This works with data kinds, too.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   &gt;&gt;&gt; liftType @3
--   LitT (NumTyLit 3)
--   &gt;&gt;&gt; liftType @"hello"
--   LitT (StrTyLit "hello")
--   &gt;&gt;&gt; liftType @'[Int, Char]
--   AppT (AppT (PromotedT GHC.Types.:) (ConT GHC.Types.Int)) (AppT (AppT (PromotedT GHC.Types.:) (ConT GHC.Types.Char)) (PromotedT GHC.Types.[]))
--   &gt;&gt;&gt; liftType @'(Int, Char)
--   AppT (AppT (PromotedT GHC.Tuple.(,)) (ConT GHC.Types.Int)) (ConT GHC.Types.Char)
--   </pre>
liftType :: forall t. Typeable t => Type
