-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Collection of tools for numeric computations
--   
--   This library contain collection of various utilities for numerical
--   computing. So far there're special mathematical functions, compensated
--   summation algorithm, summation of series, root finding for real
--   functions, polynomial summation and Chebyshev polynomials.
@package math-functions
@version 0.3.4.2


-- | Functions for approximate comparison of floating point numbers.
--   
--   Approximate floating point comparison, based on Bruce Dawson's
--   "Comparing floating point numbers":
--   <a>http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>
module Numeric.MathFunctions.Comparison

-- | Calculate relative error of two numbers:
--   
--   &lt;math&gt;
--   
--   It lies in [0,1) interval for numbers with same sign and (1,2] for
--   numbers with different sign. If both arguments are zero or negative
--   zero function returns 0. If at least one argument is transfinite it
--   returns NaN
relativeError :: Double -> Double -> Double

-- | Check that relative error between two numbers <tt>a</tt> and
--   <tt>b</tt>. If <a>relativeError</a> returns NaN it returns
--   <tt>False</tt>.
eqRelErr :: Double -> Double -> Double -> Bool

-- | Add N ULPs (units of least precision) to <tt>Double</tt> number.
addUlps :: Int -> Double -> Double

-- | Measure distance between two <tt>Double</tt>s in ULPs (units of least
--   precision). Note that it's different from <tt>abs (ulpDelta a b)</tt>
--   since it returns correct result even when <a>ulpDelta</a> overflows.
ulpDistance :: Double -> Double -> Word64

-- | Measure signed distance between two <tt>Double</tt>s in ULPs (units of
--   least precision). Note that unlike <a>ulpDistance</a> it can overflow.
--   
--   <pre>
--   &gt;&gt;&gt; ulpDelta 1 (1 + m_epsilon)
--   1
--   </pre>
ulpDelta :: Double -> Double -> Int64

-- | Compare two <a>Double</a> values for approximate equality, using
--   Dawson's method.
--   
--   The required accuracy is specified in ULPs (units of least precision).
--   If the two numbers differ by the given number of ULPs or less, this
--   function returns <tt>True</tt>.
within :: Int -> Double -> Double -> Bool


-- | Constant values common to much numeric code.
module Numeric.MathFunctions.Constants

-- | The smallest <a>Double</a> ε such that 1 + ε ≠ 1.
m_epsilon :: Double

-- | <pre>
--   sqrt m_epsilon
--   </pre>
m_sqrt_eps :: Double

-- | Largest representable finite value.
m_huge :: Double

-- | The smallest representable positive normalized value.
m_tiny :: Double

-- | The largest <a>Int</a> <i>x</i> such that 2**(<i>x</i>-1) is
--   approximately representable as a <a>Double</a>.
m_max_exp :: Int

-- | Positive infinity.
m_pos_inf :: Double

-- | Negative infinity.
m_neg_inf :: Double

-- | Not a number.
m_NaN :: Double

-- | Maximum possible finite value of <tt>log x</tt>
m_max_log :: Double

-- | Logarithm of smallest normalized double (<a>m_tiny</a>)
m_min_log :: Double

-- | <pre>
--   1 / sqrt 2
--   </pre>
m_1_sqrt_2 :: Double

-- | <pre>
--   2 / sqrt pi
--   </pre>
m_2_sqrt_pi :: Double

-- | <pre>
--   log(sqrt((2*pi))
--   </pre>
m_ln_sqrt_2_pi :: Double

-- | <pre>
--   sqrt 2
--   </pre>
m_sqrt_2 :: Double

-- | <pre>
--   sqrt (2 * pi)
--   </pre>
m_sqrt_2_pi :: Double

-- | Euler–Mascheroni constant (γ = 0.57721...)
m_eulerMascheroni :: Double


-- | Function for evaluating polynomials using Horher's method.
module Numeric.Polynomial

-- | Evaluate polynomial using Horner's method. Coefficients starts from
--   lowest. In pseudocode:
--   
--   <pre>
--   evaluateOddPolynomial x [1,2,3] = 1 + 2*x + 3*x^2
--   </pre>
evaluatePolynomial :: (Vector v a, Num a) => a -> v a -> a

-- | Evaluate polynomial with only even powers using Horner's method.
--   Coefficients starts from lowest. In pseudocode:
--   
--   <pre>
--   evaluateOddPolynomial x [1,2,3] = 1 + 2*x^2 + 3*x^4
--   </pre>
evaluateEvenPolynomial :: (Vector v a, Num a) => a -> v a -> a

-- | Evaluate polynomial with only odd powers using Horner's method.
--   Coefficients starts from lowest. In pseudocode:
--   
--   <pre>
--   evaluateOddPolynomial x [1,2,3] = 1*x + 2*x^3 + 3*x^5
--   </pre>
evaluateOddPolynomial :: (Vector v a, Num a) => a -> v a -> a
evaluatePolynomialL :: Num a => a -> [a] -> a
evaluateEvenPolynomialL :: Num a => a -> [a] -> a
evaluateOddPolynomialL :: Num a => a -> [a] -> a


-- | Chebyshev polynomials.
module Numeric.Polynomial.Chebyshev

-- | Evaluate a Chebyshev polynomial of the first kind. Uses Clenshaw's
--   algorithm.
chebyshev :: Vector v Double => Double -> v Double -> Double

-- | Evaluate a Chebyshev polynomial of the first kind. Uses Broucke's
--   ECHEB algorithm, and his convention for coefficient handling. It treat
--   0th coefficient different so
--   
--   <pre>
--   chebyshev x [a0,a1,a2...] == chebyshevBroucke [2*a0,a1,a2...]
--   </pre>
chebyshevBroucke :: Vector v Double => Double -> v Double -> Double


-- | Haskell functions for finding the roots of real functions of real
--   arguments. These algorithms are iterative so we provide both function
--   returning root (or failure to find root) and list of iterations.
module Numeric.RootFinding

-- | The result of searching for a root of a mathematical function.
data Root a

-- | The function does not have opposite signs when evaluated at the lower
--   and upper bounds of the search.
NotBracketed :: Root a

-- | The search failed to converge to within the given error tolerance
--   after the given number of iterations.
SearchFailed :: Root a

-- | A root was successfully found.
Root :: !a -> Root a

-- | Returns either the result of a search for a root, or the default value
--   if the search failed.
fromRoot :: a -> Root a -> a

-- | Error tolerance for finding root. It describes when root finding
--   algorithm should stop trying to improve approximation.
data Tolerance

-- | Relative error tolerance. Given <tt>RelTol ε</tt> two values are
--   considered approximately equal if &lt;math&gt;
RelTol :: !Double -> Tolerance

-- | Absolute error tolerance. Given <tt>AbsTol δ</tt> two values are
--   considered approximately equal if &lt;math&gt;. Note that <tt>AbsTol
--   0</tt> could be used to require to find approximation within machine
--   precision.
AbsTol :: !Double -> Tolerance

-- | Check that two values are approximately equal. In addition to
--   specification values are considered equal if they're within 1ulp of
--   precision. No further improvement could be done anyway.
withinTolerance :: Tolerance -> Double -> Double -> Bool

-- | Type class for checking whether iteration converged already.
class IterationStep a

-- | Return <tt>Just root</tt> is current iteration converged within
--   required error tolerance. Returns <tt>Nothing</tt> otherwise.
matchRoot :: IterationStep a => Tolerance -> a -> Maybe (Root Double)

-- | Find root in lazy list of iterations.
findRoot :: IterationStep a => Int -> Tolerance -> [a] -> Root Double

-- | Parameters for <a>ridders</a> root finding
data RiddersParam
RiddersParam :: !Int -> !Tolerance -> RiddersParam

-- | Maximum number of iterations. Default = 100
[riddersMaxIter] :: RiddersParam -> !Int

-- | Error tolerance for root approximation. Default is relative error 4·ε,
--   where ε is machine precision.
[riddersTol] :: RiddersParam -> !Tolerance

-- | Use the method of Ridders[Ridders1979] to compute a root of a
--   function. It doesn't require derivative and provide quadratic
--   convergence (number of significant digits grows quadratically with
--   number of iterations).
--   
--   The function must have opposite signs when evaluated at the lower and
--   upper bounds of the search (i.e. the root must be bracketed). If
--   there's more that one root in the bracket iteration will converge to
--   some root in the bracket.
ridders :: RiddersParam -> (Double, Double) -> (Double -> Double) -> Root Double

-- | List of iterations for Ridders methods. See <a>ridders</a> for
--   documentation of parameters
riddersIterations :: (Double, Double) -> (Double -> Double) -> [RiddersStep]

-- | Single Ridders step. It's a bracket of root
data RiddersStep

-- | Ridders step. Parameters are bracket for the root
RiddersStep :: !Double -> !Double -> RiddersStep

-- | Bisection step. It's fallback which is taken when Ridders update takes
--   us out of bracket
RiddersBisect :: !Double -> !Double -> RiddersStep

-- | Root found
RiddersRoot :: !Double -> RiddersStep

-- | Root is not bracketed
RiddersNoBracket :: RiddersStep

-- | Parameters for <a>ridders</a> root finding
data NewtonParam
NewtonParam :: !Int -> !Tolerance -> NewtonParam

-- | Maximum number of iterations. Default = 50
[newtonMaxIter] :: NewtonParam -> !Int

-- | Error tolerance for root approximation. Default is relative error 4·ε,
--   where ε is machine precision
[newtonTol] :: NewtonParam -> !Tolerance

-- | Solve equation using Newton-Raphson iterations.
--   
--   This method require both initial guess and bounds for root. If Newton
--   step takes us out of bounds on root function reverts to bisection.
newtonRaphson :: NewtonParam -> (Double, Double, Double) -> (Double -> (Double, Double)) -> Root Double

-- | List of iteration for Newton-Raphson algorithm. See documentation for
--   <a>newtonRaphson</a> for meaning of parameters.
newtonRaphsonIterations :: (Double, Double, Double) -> (Double -> (Double, Double)) -> [NewtonStep]

-- | Steps for Newton iterations
data NewtonStep

-- | Normal Newton-Raphson update. Parameters are: old guess, new guess
NewtonStep :: !Double -> !Double -> NewtonStep

-- | Bisection fallback when Newton-Raphson iteration doesn't work.
--   Parameters are bracket on root
NewtonBisection :: !Double -> !Double -> NewtonStep

-- | Root is found
NewtonRoot :: !Double -> NewtonStep

-- | Root is not bracketed
NewtonNoBracket :: NewtonStep
instance GHC.Generics.Generic (Numeric.RootFinding.Root a)
instance Data.Traversable.Traversable Numeric.RootFinding.Root
instance Data.Foldable.Foldable Numeric.RootFinding.Root
instance Data.Data.Data a => Data.Data.Data (Numeric.RootFinding.Root a)
instance GHC.Show.Show a => GHC.Show.Show (Numeric.RootFinding.Root a)
instance GHC.Read.Read a => GHC.Read.Read (Numeric.RootFinding.Root a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Numeric.RootFinding.Root a)
instance GHC.Generics.Generic Numeric.RootFinding.Tolerance
instance Data.Data.Data Numeric.RootFinding.Tolerance
instance GHC.Show.Show Numeric.RootFinding.Tolerance
instance GHC.Read.Read Numeric.RootFinding.Tolerance
instance GHC.Classes.Eq Numeric.RootFinding.Tolerance
instance GHC.Generics.Generic Numeric.RootFinding.RiddersParam
instance Data.Data.Data Numeric.RootFinding.RiddersParam
instance GHC.Show.Show Numeric.RootFinding.RiddersParam
instance GHC.Read.Read Numeric.RootFinding.RiddersParam
instance GHC.Classes.Eq Numeric.RootFinding.RiddersParam
instance GHC.Generics.Generic Numeric.RootFinding.RiddersStep
instance Data.Data.Data Numeric.RootFinding.RiddersStep
instance GHC.Show.Show Numeric.RootFinding.RiddersStep
instance GHC.Read.Read Numeric.RootFinding.RiddersStep
instance GHC.Classes.Eq Numeric.RootFinding.RiddersStep
instance GHC.Generics.Generic Numeric.RootFinding.NewtonParam
instance Data.Data.Data Numeric.RootFinding.NewtonParam
instance GHC.Show.Show Numeric.RootFinding.NewtonParam
instance GHC.Read.Read Numeric.RootFinding.NewtonParam
instance GHC.Classes.Eq Numeric.RootFinding.NewtonParam
instance GHC.Generics.Generic Numeric.RootFinding.NewtonStep
instance Data.Data.Data Numeric.RootFinding.NewtonStep
instance GHC.Show.Show Numeric.RootFinding.NewtonStep
instance GHC.Read.Read Numeric.RootFinding.NewtonStep
instance GHC.Classes.Eq Numeric.RootFinding.NewtonStep
instance Control.DeepSeq.NFData Numeric.RootFinding.NewtonStep
instance Numeric.RootFinding.IterationStep Numeric.RootFinding.NewtonStep
instance Data.Default.Class.Default Numeric.RootFinding.NewtonParam
instance Control.DeepSeq.NFData Numeric.RootFinding.RiddersStep
instance Numeric.RootFinding.IterationStep Numeric.RootFinding.RiddersStep
instance Data.Default.Class.Default Numeric.RootFinding.RiddersParam
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Numeric.RootFinding.Root a)
instance GHC.Base.Functor Numeric.RootFinding.Root
instance GHC.Base.Applicative Numeric.RootFinding.Root
instance GHC.Base.Monad Numeric.RootFinding.Root
instance GHC.Base.MonadPlus Numeric.RootFinding.Root
instance GHC.Base.Alternative Numeric.RootFinding.Root


-- | Functions for working with infinite sequences. In particular summation
--   of series and evaluation of continued fractions.
module Numeric.Series

-- | Infinite series. It's represented as opaque state and step function.
data Sequence a
Sequence :: s -> (s -> (a, s)) -> Sequence a

-- | <tt>enumSequenceFrom x</tt> generate sequence:
--   
--   &lt;math&gt;
enumSequenceFrom :: Num a => a -> Sequence a

-- | <tt>enumSequenceFromStep x d</tt> generate sequence:
--   
--   &lt;math&gt;
enumSequenceFromStep :: Num a => a -> a -> Sequence a

-- | Analog of <a>scanl</a> for sequence.
scanSequence :: (b -> a -> b) -> b -> Sequence a -> Sequence b

-- | Calculate sum of series
--   
--   &lt;math&gt;
--   
--   Summation is stopped when
--   
--   &lt;math&gt;
--   
--   where ε is machine precision (<a>m_epsilon</a>)
sumSeries :: Sequence Double -> Double

-- | Calculate sum of series
--   
--   &lt;math&gt;
--   
--   Calculation is stopped when next value in series is less than ε·sum.
sumPowerSeries :: Double -> Sequence Double -> Double

-- | Convert series to infinite list
sequenceToList :: Sequence a -> [a]

-- | Evaluate continued fraction using modified Lentz algorithm. Sequence
--   contain pairs (a[i],b[i]) which form following expression:
--   
--   &lt;math&gt;
--   
--   Modified Lentz algorithm is described in Numerical recipes 5.2
--   "Evaluation of Continued Fractions"
evalContFractionB :: Sequence (Double, Double) -> Double
instance GHC.Base.Functor Numeric.Series.Sequence
instance GHC.Base.Applicative Numeric.Series.Sequence
instance GHC.Num.Num a => GHC.Num.Num (Numeric.Series.Sequence a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Numeric.Series.Sequence a)


-- | Less common mathematical functions.
module Numeric.SpecFunctions.Extra

-- | Evaluate the deviance term <tt>x log(x/np) + np - x</tt>.
bd0 :: Double -> Double -> Double

-- | Calculate binomial coefficient using exact formula
chooseExact :: Int -> Int -> Double

-- | Quickly compute the natural logarithm of <i>n</i>
--   <tt><a>choose</a></tt> <i>k</i>, with no checking.
--   
--   Less numerically stable:
--   
--   <pre>
--   exp $ lg (n+1) - lg (k+1) - lg (n-k+1)
--     where lg = logGamma . fromIntegral
--   </pre>
logChooseFast :: Double -> Double -> Double

-- | Compute the logarithm of the gamma function Γ(<i>x</i>). Uses
--   Algorithm AS 245 by Macleod.
--   
--   Gives an accuracy of 10-12 significant decimal digits, except for
--   small regions around <i>x</i> = 1 and <i>x</i> = 2, where the function
--   goes to zero. For greater accuracy, use <tt>logGammaL</tt>.
--   
--   Returns ∞ if the input is outside of the range (0 &lt; <i>x</i> ≤
--   1e305).
logGammaAS245 :: Double -> Double

-- | Compute the log gamma correction factor for Stirling approximation for
--   <tt>x</tt> ≥ 10. This correction factor is suitable for an alternate
--   (but less numerically accurate) definition of <a>logGamma</a>:
--   
--   &lt;math&gt;
logGammaCorrection :: Double -> Double


-- | Special functions and factorials.
module Numeric.SpecFunctions

-- | Error function.
--   
--   &lt;math&gt;
--   
--   Function limits are:
--   
--   &lt;math&gt;
erf :: Double -> Double

-- | Complementary error function.
--   
--   &lt;math&gt;
--   
--   Function limits are:
--   
--   &lt;math&gt;
erfc :: Double -> Double

-- | Inverse of <a>erf</a>.
invErf :: Double -> Double

-- | Inverse of <a>erfc</a>.
invErfc :: Double -> Double

-- | Compute the logarithm of the gamma function, Γ(<i>x</i>).
--   
--   &lt;math&gt;
--   
--   This implementation uses Lanczos approximation. It gives 14 or more
--   significant decimal digits, except around <i>x</i> = 1 and <i>x</i> =
--   2, where the function goes to zero.
--   
--   Returns ∞ if the input is outside of the range (0 &lt; <i>x</i> ≤
--   1e305).
logGamma :: Double -> Double

-- | Synonym for <a>logGamma</a>. Retained for compatibility

-- | <i>Deprecated: Use logGamma instead</i>
logGammaL :: Double -> Double

-- | Compute the normalized lower incomplete gamma function
--   γ(<i>z</i>,<i>x</i>). Normalization means that γ(<i>z</i>,∞)=1
--   
--   &lt;math&gt;
--   
--   Uses Algorithm AS 239 by Shea.
incompleteGamma :: Double -> Double -> Double

-- | Inverse incomplete gamma function. It's approximately inverse of
--   <a>incompleteGamma</a> for the same <i>z</i>. So following equality
--   approximately holds:
--   
--   <pre>
--   invIncompleteGamma z . incompleteGamma z ≈ id
--   </pre>
invIncompleteGamma :: Double -> Double -> Double

-- | Compute ψ(<i>x</i>), the first logarithmic derivative of the gamma
--   function.
--   
--   &lt;math&gt;
--   
--   Uses Algorithm AS 103 by Bernardo, based on Minka's C implementation.
digamma :: Double -> Double

-- | Compute the natural logarithm of the beta function.
--   
--   &lt;math&gt;
logBeta :: Double -> Double -> Double

-- | Regularized incomplete beta function.
--   
--   &lt;math&gt;
--   
--   Uses algorithm AS63 by Majumder and Bhattachrjee and quadrature
--   approximation for large <i>p</i> and <i>q</i>.
incompleteBeta :: Double -> Double -> Double -> Double

-- | Regularized incomplete beta function. Same as <a>incompleteBeta</a>
--   but also takes logarithm of beta function as parameter.
incompleteBeta_ :: Double -> Double -> Double -> Double -> Double

-- | Compute inverse of regularized incomplete beta function. Uses initial
--   approximation from AS109, AS64 and Halley method to solve equation.
invIncompleteBeta :: Double -> Double -> Double -> Double

-- | Compute sinc function <tt>sin(x)/x</tt>
sinc :: Double -> Double

-- | <tt><a>log1p</a> x</tt> computes <tt><a>log</a> (1 + x)</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
log1p :: Floating a => a -> a

-- | Compute log(1+x)-x:
log1pmx :: Double -> Double

-- | <i>O(log n)</i> Compute the logarithm in base 2 of the given value.
log2 :: Int -> Int

-- | <tt><a>expm1</a> x</tt> computes <tt><a>exp</a> x - 1</tt>, but
--   provides more precise results for small (absolute) values of
--   <tt>x</tt> if possible.
expm1 :: Floating a => a -> a

-- | Compute the factorial function <i>n</i>!. Returns +∞ if the input is
--   above 170 (above which the result cannot be represented by a 64-bit
--   <a>Double</a>).
factorial :: Int -> Double

-- | Compute the natural logarithm of the factorial function. Gives 16
--   decimal digits of precision.
logFactorial :: Integral a => a -> Double

-- | Calculate the error term of the Stirling approximation. This is only
--   defined for non-negative values.
--   
--   &lt;math&gt;
stirlingError :: Double -> Double

-- | Compute the binomial coefficient <i>n</i> <tt>`<a>choose</a>`</tt>
--   <i>k</i>. For values of <i>k</i> &gt; 50, this uses an approximation
--   for performance reasons. The approximation is accurate to 12 decimal
--   places in the worst case
--   
--   Example:
--   
--   <pre>
--   7 `choose` 3 == 35
--   </pre>
choose :: Int -> Int -> Double

-- | Compute logarithm of the binomial coefficient.
logChoose :: Int -> Int -> Double


-- | Functions for summing floating point numbers more accurately than the
--   naive <a>sum</a> function and its counterparts in the <tt>vector</tt>
--   package and elsewhere.
--   
--   When used with floating point numbers, in the worst case, the
--   <a>sum</a> function accumulates numeric error at a rate proportional
--   to the number of values being summed. The algorithms in this module
--   implement different methods of /compensated summation/, which reduce
--   the accumulation of numeric error so that it either grows much more
--   slowly than the number of inputs (e.g. logarithmically), or remains
--   constant.
module Numeric.Sum

-- | A class for summation of floating point numbers.
class Summation s

-- | The identity for summation.
zero :: Summation s => s

-- | Add a value to a sum.
add :: Summation s => s -> Double -> s

-- | Sum a collection of values.
--   
--   Example: <tt>foo = <a>sum</a> <a>kbn</a> [1,2,3]</tt>
sum :: (Summation s, Foldable f) => (s -> Double) -> f Double -> Double

-- | <i>O(n)</i> Sum a vector of values.
sumVector :: (Vector v Double, Summation s) => (s -> Double) -> v Double -> Double

-- | Kahan-Babuška-Neumaier summation. This is a little more
--   computationally costly than plain Kahan summation, but is
--   <i>always</i> at least as accurate.
data KBNSum
KBNSum :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> KBNSum

-- | Return the result of a Kahan-Babuška-Neumaier sum.
kbn :: KBNSum -> Double

-- | Second-order Kahan-Babuška summation. This is more computationally
--   costly than Kahan-Babuška-Neumaier summation, running at about a third
--   the speed. Its advantage is that it can lose less precision (in
--   admittedly obscure cases).
--   
--   This method compensates for error in both the sum and the first-order
--   compensation term, hence the use of "second order" in the name.
data KB2Sum
KB2Sum :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> KB2Sum

-- | Return the result of an order-2 Kahan-Babuška sum.
kb2 :: KB2Sum -> Double

-- | Kahan summation. This is the least accurate of the compensated
--   summation methods. In practice, it only beats naive summation for
--   inputs with large magnitude. Kahan summation can be <i>less</i>
--   accurate than naive summation for small-magnitude inputs.
--   
--   This summation method is included for completeness. Its use is not
--   recommended. In practice, <a>KBNSum</a> is both 30% faster and more
--   accurate.
data KahanSum
KahanSum :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> KahanSum

-- | Return the result of a Kahan sum.
kahan :: KahanSum -> Double

-- | <i>O(n)</i> Sum a vector of values using pairwise summation.
--   
--   This approach is perhaps 10% faster than <a>KBNSum</a>, but has poorer
--   bounds on its error growth. Instead of having roughly constant error
--   regardless of the size of the input vector, in the worst case its
--   accumulated error grows with <i>O(log n)</i>.
pairwiseSum :: Vector v Double => v Double -> Double
instance Data.Data.Data Numeric.Sum.KahanSum
instance GHC.Show.Show Numeric.Sum.KahanSum
instance GHC.Classes.Eq Numeric.Sum.KahanSum
instance Data.Data.Data Numeric.Sum.KBNSum
instance GHC.Show.Show Numeric.Sum.KBNSum
instance GHC.Classes.Eq Numeric.Sum.KBNSum
instance Data.Data.Data Numeric.Sum.KB2Sum
instance GHC.Show.Show Numeric.Sum.KB2Sum
instance GHC.Classes.Eq Numeric.Sum.KB2Sum
instance Data.Vector.Unboxed.Base.Unbox Numeric.Sum.KB2Sum
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Sum.KB2Sum
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Sum.KB2Sum
instance Numeric.Sum.Summation Numeric.Sum.KB2Sum
instance Control.DeepSeq.NFData Numeric.Sum.KB2Sum
instance GHC.Base.Monoid Numeric.Sum.KB2Sum
instance GHC.Base.Semigroup Numeric.Sum.KB2Sum
instance Data.Vector.Unboxed.Base.Unbox Numeric.Sum.KBNSum
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Sum.KBNSum
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Sum.KBNSum
instance Numeric.Sum.Summation Numeric.Sum.KBNSum
instance Control.DeepSeq.NFData Numeric.Sum.KBNSum
instance GHC.Base.Monoid Numeric.Sum.KBNSum
instance GHC.Base.Semigroup Numeric.Sum.KBNSum
instance Data.Vector.Unboxed.Base.Unbox Numeric.Sum.KahanSum
instance Data.Vector.Generic.Mutable.Base.MVector Data.Vector.Unboxed.Base.MVector Numeric.Sum.KahanSum
instance Data.Vector.Generic.Base.Vector Data.Vector.Unboxed.Base.Vector Numeric.Sum.KahanSum
instance Numeric.Sum.Summation Numeric.Sum.KahanSum
instance Control.DeepSeq.NFData Numeric.Sum.KahanSum
instance GHC.Base.Monoid Numeric.Sum.KahanSum
instance GHC.Base.Semigroup Numeric.Sum.KahanSum
instance Numeric.Sum.Summation GHC.Types.Double
