-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A lens-based implementation of protocol buffers in Haskell.
--   
--   The proto-lens library provides an API for protocol buffers using
--   modern Haskell language and library patterns. Specifically, it
--   provides:
--   
--   <ul>
--   <li>Composable field accessors via lenses</li>
--   <li>Simple field name resolution/overloading via type-level
--   literals</li>
--   <li>Type-safe reflection and encoding/decoding of messages via
--   GADTs</li>
--   </ul>
@package proto-lens
@version 0.7.1.2


-- | A mutable vector that grows in size.
--   
--   Example usage:
--   
--   <pre>
--   import qualified Data.ProtoLens.Encoding.Growing as Growing
--   import qualified Data.Vector.Unboxed as V
--   test :: IO (V.Vector Int)
--   test = do
--       v &lt;- Growing.new
--       v' &lt;- Growing.append v 1
--       v'' &lt;- Growing.append v' 2
--       v''' &lt;- Growing.append v'' 3
--       unsafeFreeze v'''
--   </pre>
module Data.ProtoLens.Encoding.Growing

-- | A mutable vector which can increase in capacity.
data Growing v s a

-- | Create a new empty growing vector.
new :: (PrimMonad m, Vector v a) => m (Growing v (PrimState m) a)

-- | Returns a new growing vector with a new element at the end. Note that
--   the return value may share storage with the input value. Furthermore,
--   calling <tt>append</tt> twice on the same input may result in two
--   vectors that share the same storage.
append :: (PrimMonad m, Vector v a) => Growing v (PrimState m) a -> a -> m (Growing v (PrimState m) a)

-- | Unsafely convert a growing vector to an immutable one without copying.
--   After this call, you may not use the growing vector nor any other
--   growing vectors that were used to produce this one.
unsafeFreeze :: (PrimMonad m, Vector v a) => Growing v (PrimState m) a -> m (v a)

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld


-- | A custom parsing monad, optimized for speed.
module Data.ProtoLens.Encoding.Parser

-- | A monad for parsing an input buffer.
data Parser a

-- | Evaluates a parser on the given input.
--   
--   If the parser does not consume all of the input, the rest of the input
--   is discarded and the parser still succeeds. Parsers may use
--   <a>atEnd</a> to detect whether they are at the end of the input.
--   
--   Values returned from actions in this monad will not hold onto the
--   original ByteString, but rather make immutable copies of subsets of
--   its bytes.
runParser :: Parser a -> ByteString -> Either String a

-- | Returns True if there is no more input left to consume.
atEnd :: Parser Bool

-- | Run the given parsing action as if there are only <tt>len</tt> bytes
--   remaining. That is, once <tt>len</tt> bytes have been consumed,
--   <a>atEnd</a> will return <a>True</a> and other actions like
--   <a>getWord8</a> will act like there is no input remaining.
--   
--   Fails the parse if given a negative length.
isolate :: Int -> Parser a -> Parser a

-- | Parse a one-byte word.
getWord8 :: Parser Word8

-- | Parser a 4-byte word in little-endian order.
getWord32le :: Parser Word32

-- | Parse a sequence of zero or more bytes of the given length.
--   
--   The new ByteString is an immutable copy of the bytes in the input and
--   will be managed separately on the Haskell heap from the original input
--   <a>ByteString</a>.
--   
--   Fails the parse if given a negative length.
getBytes :: Int -> Parser ByteString

-- | If the parser fails, prepend an error message.
(<?>) :: Parser a -> String -> Parser a


-- | Utility functions for parsing and encoding individual types.
module Data.ProtoLens.Encoding.Bytes

-- | A monad for parsing an input buffer.
data Parser a

-- | <a>Builder</a>s denote sequences of bytes. They are <a>Monoid</a>s
--   where <a>mempty</a> is the zero-length sequence and <a>mappend</a> is
--   concatenation, which runs in <i>O(1)</i>.
data Builder

-- | Evaluates a parser on the given input.
--   
--   If the parser does not consume all of the input, the rest of the input
--   is discarded and the parser still succeeds. Parsers may use
--   <a>atEnd</a> to detect whether they are at the end of the input.
--   
--   Values returned from actions in this monad will not hold onto the
--   original ByteString, but rather make immutable copies of subsets of
--   its bytes.
runParser :: Parser a -> ByteString -> Either String a

-- | Run the given parsing action as if there are only <tt>len</tt> bytes
--   remaining. That is, once <tt>len</tt> bytes have been consumed,
--   <a>atEnd</a> will return <a>True</a> and other actions like
--   <a>getWord8</a> will act like there is no input remaining.
--   
--   Fails the parse if given a negative length.
isolate :: Int -> Parser a -> Parser a

-- | Constructs a strict <a>ByteString</a> from the given <a>Builder</a>.
runBuilder :: Builder -> ByteString

-- | Parse a sequence of zero or more bytes of the given length.
--   
--   The new ByteString is an immutable copy of the bytes in the input and
--   will be managed separately on the Haskell heap from the original input
--   <a>ByteString</a>.
--   
--   Fails the parse if given a negative length.
getBytes :: Int -> Parser ByteString

-- | Emit a given <tt>ByteString</tt>.
putBytes :: ByteString -> Builder
getVarInt :: Parser Word64
getVarIntH :: Handle -> ExceptT String IO Word64
putVarInt :: Word64 -> Builder
getFixed32 :: Parser Word32
getFixed64 :: Parser Word64
putFixed32 :: Word32 -> Builder
putFixed64 :: Word64 -> Builder
wordToFloat :: Word32 -> Float
wordToDouble :: Word64 -> Double
floatToWord :: Float -> Word32
doubleToWord :: Double -> Word64
signedInt32ToWord :: Int32 -> Word32
wordToSignedInt32 :: Word32 -> Int32
signedInt64ToWord :: Int64 -> Word64
wordToSignedInt64 :: Word64 -> Int64

-- | Returns True if there is no more input left to consume.
atEnd :: Parser Bool
runEither :: Either String a -> Parser a

-- | If the parser fails, prepend an error message.
(<?>) :: Parser a -> String -> Parser a

-- | Loop over the elements of a vector and concatenate the resulting
--   <tt>Builder</tt>s.
--   
--   This function has been hand-tuned to perform better than a naive
--   implementation using, e.g., Vector.foldr or a manual loop.
foldMapBuilder :: Vector v a => (a -> Builder) -> v a -> Builder

module Data.ProtoLens.Encoding.Parser.Unsafe

-- | Runs an arbitrary <tt>IO</tt> action inside a <tt>Parser</tt>. The
--   generated code uses this function to construct vectors efficiently by
--   incrementally building up mutable vectors.
--   
--   NOTE: This is unsafe since <tt>runParser</tt> is a pure function,
--   which lets us lift arbitrary IO into pure operations. However, here
--   are some guarantees that we do get:
--   
--   <ul>
--   <li>For each individual call to <tt>runParser</tt>, the action wrapped
--   by <a>unsafeLiftIO</a> will be called exactly once.</li>
--   <li>Different calls to <a>unsafeLiftIO</a> within the same call to
--   <tt>runParser</tt> will be sequenced according to their order in the
--   Parser monad.</li>
--   </ul>
unsafeLiftIO :: IO a -> Parser a


-- | Module defining the individual base wire types (e.g. VarInt, Fixed64).
--   
--   They are used to represent the <tt>unknownFields</tt> within the proto
--   message.
--   
--   Upstream docs:
--   <a>https://developers.google.com/protocol-buffers/docs/encoding#structure</a>
module Data.ProtoLens.Encoding.Wire

-- | A tag that identifies a particular field of the message when
--   converting to/from the wire format.
newtype Tag
Tag :: Int -> Tag
[unTag] :: Tag -> Int

-- | A pair of an encoded field and a value.
data TaggedValue
TaggedValue :: !Tag -> !WireValue -> TaggedValue

-- | The encoding of some unknown field on the wire.
data WireValue
VarInt :: !Word64 -> WireValue
Fixed64 :: !Word64 -> WireValue
Lengthy :: !ByteString -> WireValue
StartGroup :: WireValue
EndGroup :: WireValue
Fixed32 :: !Word32 -> WireValue
type FieldSet = [TaggedValue]
splitTypeAndTag :: Word64 -> (Tag, Word8)
joinTypeAndTag :: Tag -> Word8 -> Word64
parseFieldSet :: Parser FieldSet
buildFieldSet :: FieldSet -> Builder
buildMessageSet :: FieldSet -> Builder
parseTaggedValueFromWire :: Word64 -> Parser TaggedValue
parseMessageSetTaggedValueFromWire :: Word64 -> Parser TaggedValue
instance Control.DeepSeq.NFData Data.ProtoLens.Encoding.Wire.Tag
instance GHC.Num.Num Data.ProtoLens.Encoding.Wire.Tag
instance GHC.Classes.Ord Data.ProtoLens.Encoding.Wire.Tag
instance GHC.Classes.Eq Data.ProtoLens.Encoding.Wire.Tag
instance GHC.Show.Show Data.ProtoLens.Encoding.Wire.Tag
instance GHC.Classes.Ord Data.ProtoLens.Encoding.Wire.WireValue
instance GHC.Classes.Eq Data.ProtoLens.Encoding.Wire.WireValue
instance GHC.Classes.Ord Data.ProtoLens.Encoding.Wire.TaggedValue
instance GHC.Classes.Eq Data.ProtoLens.Encoding.Wire.TaggedValue
instance Control.DeepSeq.NFData Data.ProtoLens.Encoding.Wire.TaggedValue
instance Control.DeepSeq.NFData Data.ProtoLens.Encoding.Wire.WireValue


-- | An implementation of overloaded record fields. This module enables
--   different types in the same module to have fields of the same name.
--   
--   To use instances from this class, either:
--   
--   <ul>
--   <li>Enable the <tt>OverloadedLabels</tt> extension and <tt>import
--   Data.ProtoLens.Labels ()</tt>;</li>
--   <li>Use the <a>field</a> function along with the
--   <tt>TypeApplications</tt> extension; or,</li>
--   <li>Import the corresponding names from the autogenerated
--   <tt>*_Fields</tt> module.</li>
--   </ul>
--   
--   For more information, see
--   <a>https://google.github.io/proto-lens/tutorial.html#field-overloading</a>.
module Data.ProtoLens.Field

-- | A type class for lens fields.
--   
--   The instance <tt>HasField s x a</tt> can be understood as "<tt>s</tt>
--   has a field named <tt>x</tt> of type <tt>a</tt>".
class HasField s (x :: Symbol) a | s x -> a
fieldOf :: (HasField s x a, Functor f) => Proxy# x -> (a -> f a) -> s -> f s

-- | A lens for a given field. For example:
--   
--   <pre>
--   view field@"abc" x
--   set field@"abc" 42 x
--   </pre>
field :: forall x s a f. (HasField s x a, Functor f) => (a -> f a) -> s -> f s


-- | This module provides OverloadedLabels <a>IsLabel</a> support via an
--   orphan instance. This means a <tt>Lens.Family.Lens</tt> can be
--   referenced as <tt>#foo</tt> whenever we have an instance of
--   <a>HasField</a> with the label <tt>"foo"</tt>."
--   
--   To use these labels, enable the <tt>OverloadedLabels</tt> extension,
--   and then import:
--   
--   <pre>
--   import Data.ProtoLens.Labels()
--   </pre>
module Data.ProtoLens.Labels
instance (Data.ProtoLens.Field.HasField s x a, p GHC.Types.~ (a -> f a), q GHC.Types.~ (s -> f s), GHC.Base.Functor f, a GHC.Types.~ b) => GHC.OverloadedLabels.IsLabel x (p -> q)


-- | Datatypes for reflection of protocol buffer messages.
module Data.ProtoLens.Message

-- | Every protocol buffer is an instance of <a>Message</a>. This class
--   enables serialization by providing reflection of all of the fields
--   that may be used by this type.
class Message msg

-- | A unique identifier for this type, of the format
--   <tt>"packagename.messagename"</tt>.
messageName :: Message msg => Proxy msg -> Text

-- | The serialized protobuffer message descriptor for this type.
--   
--   For a friendlier version which returns the actual descriptor type, use
--   <tt>Data.ProtoLens.Descriptor.messageDescriptor</tt> from the
--   <tt>proto-lens-protobuf-types</tt> package.
packedMessageDescriptor :: Message msg => Proxy msg -> ByteString

-- | The serialized protobuffer file message descriptor containing this
--   type.
--   
--   For a friendlier version which returns the actual file descriptor
--   type, use <tt>Data.ProtoLens.Descriptor.fileDescriptor</tt> from the
--   <tt>proto-lens-protobuf-types</tt> package.
packedFileDescriptor :: Message msg => Proxy msg -> ByteString

-- | A message with all fields set to their default values.
--   
--   Satisfies <tt>encodeMessage defMessage == ""</tt> and
--   <tt>decodeMessage "" == Right defMessage</tt>.
defMessage :: Message msg => msg

-- | The fields of the proto, indexed by their (integer) tag.
fieldsByTag :: Message msg => Map Tag (FieldDescriptor msg)

-- | This map is keyed by the name of the field used for text format
--   protos. This is just the field name for every field except for group
--   fields, which use their Message type name in text protos instead of
--   their field name. For example, "optional group Foo" has the field name
--   "foo" but in this map it is stored with the key <a>Foo</a>.
fieldsByTextFormatName :: Message msg => Map String (FieldDescriptor msg)

-- | Access the unknown fields of a Message.
unknownFields :: Message msg => Lens' msg FieldSet

-- | Decode a message value.
--   
--   See also the functions in <a>Data.ProtoLens.Encoding</a>.
parseMessage :: Message msg => Parser msg

-- | Encode a message value.
--   
--   See also the functions in <a>Data.ProtoLens.Encoding</a>.
buildMessage :: Message msg => msg -> Builder

-- | A tag that identifies a particular field of the message when
--   converting to/from the wire format.
newtype Tag
Tag :: Int -> Tag
[unTag] :: Tag -> Int
allFields :: Message msg => [FieldDescriptor msg]

-- | A description of a specific field of a protocol buffer.
--   
--   The <a>String</a> parameter is the name of the field from the .proto
--   file, as used in TextFormat, with the same behavior for groups as
--   <a>fieldsByTextFormatName</a>. (Haddock doesn't support per-argument
--   docs for GADTs.)
data FieldDescriptor msg
[FieldDescriptor] :: String -> FieldTypeDescriptor value -> FieldAccessor msg value -> FieldDescriptor msg

-- | The original name of the field in the .proto file.
fieldDescriptorName :: FieldDescriptor msg -> String

-- | Whether the given field is required. Specifically, if its
--   <a>FieldAccessor</a> is a <a>Required</a> <a>PlainField</a>.
isRequired :: FieldDescriptor msg -> Bool

-- | A Lens for accessing the value of an individual field in a protocol
--   buffer message.
data FieldAccessor msg value
[PlainField] :: WireDefault value -> Lens' msg value -> FieldAccessor msg value
[OptionalField] :: Lens' msg (Maybe value) -> FieldAccessor msg value
[RepeatedField] :: Packing -> Lens' msg [value] -> FieldAccessor msg value
[MapField] :: (Ord key, Message entry) => Lens' entry key -> Lens' entry value -> Lens' msg (Map key value) -> FieldAccessor msg entry

-- | The default value (if any) for a <a>PlainField</a> on the wire.
data WireDefault value
[Required] :: WireDefault value
[Optional] :: (FieldDefault value, Eq value) => WireDefault value

-- | How a given repeated field is transmitted on the wire format.
data Packing
Packed :: Packing
Unpacked :: Packing

-- | A description of the type of a given field value.
data FieldTypeDescriptor value
[MessageField] :: Message value => MessageOrGroup -> FieldTypeDescriptor value
[ScalarField] :: ScalarField value -> FieldTypeDescriptor value
data ScalarField t
[EnumField] :: MessageEnum value => ScalarField value
[Int32Field] :: ScalarField Int32
[Int64Field] :: ScalarField Int64
[UInt32Field] :: ScalarField Word32
[UInt64Field] :: ScalarField Word64
[SInt32Field] :: ScalarField Int32
[SInt64Field] :: ScalarField Int64
[Fixed32Field] :: ScalarField Word32
[Fixed64Field] :: ScalarField Word64
[SFixed32Field] :: ScalarField Int32
[SFixed64Field] :: ScalarField Int64
[FloatField] :: ScalarField Float
[DoubleField] :: ScalarField Double
[BoolField] :: ScalarField Bool
[StringField] :: ScalarField Text
[BytesField] :: ScalarField ByteString
data MessageOrGroup
MessageType :: MessageOrGroup
GroupType :: MessageOrGroup

-- | A proto3 field type with an implicit default value.
--   
--   This is distinct from, say, <a>Default</a> to avoid orphan instances,
--   and because <a>Bool</a> doesn't necessarily have a good Default
--   instance for general usage.
class FieldDefault value
fieldDefault :: FieldDefault value => value

-- | A class for protocol buffer enums that enables safe decoding.
class (Enum a, Bounded a) => MessageEnum a

-- | Convert the given <a>Int</a> to an enum value. Returns <a>Nothing</a>
--   if no corresponding value was defined in the .proto file.
maybeToEnum :: MessageEnum a => Int -> Maybe a

-- | Get the name of this enum as defined in the .proto file. Used for the
--   human-readable output in <tt>Data.ProtoLens.TextFormat</tt>.
showEnum :: MessageEnum a => a -> String

-- | Convert the given <a>String</a> to an enum value. Returns
--   <a>Nothing</a> if no corresponding value was defined in the .proto
--   file.
readEnum :: MessageEnum a => String -> Maybe a

-- | Utility function for building a message from a default value. For
--   example:
--   
--   <pre>
--   instance Default A where ...
--   x, y :: Lens' A Int
--   m :: A
--   m = build ((x .~ 5) . (y .~ 7))
--   </pre>
build :: Message a => (a -> a) -> a

-- | A set of known message types. Can help encode/decode protobufs
--   containing <tt>Data.ProtoLens.Any</tt> values in a more human-readable
--   text format.
--   
--   Registries can be combined using their <a>Monoid</a> instance.
--   
--   See the <tt>withRegistry</tt> functions in <a>TextFormat</a>
data Registry

-- | Build a <a>Registry</a> containing a single proto type.
--   
--   Example: &gt; register (Proxy :: Proxy Proto.My.Proto.Type)
register :: forall msg. Message msg => Proxy msg -> Registry

-- | Look up a message type by name (e.g.,
--   <tt>"type.googleapis.com/google.protobuf.FloatValue"</tt>). The URL
--   corresponds to the field <tt>google.protobuf.Any.type_url</tt>.
lookupRegistered :: Text -> Registry -> Maybe SomeMessageType
data SomeMessageType
[SomeMessageType] :: Message msg => Proxy msg -> SomeMessageType
matchAnyMessage :: forall value. FieldTypeDescriptor value -> Maybe (AnyMessageDescriptor value)
data AnyMessageDescriptor msg
AnyMessageDescriptor :: Lens' msg Text -> Lens' msg ByteString -> AnyMessageDescriptor msg
[anyTypeUrlLens] :: AnyMessageDescriptor msg -> Lens' msg Text
[anyValueLens] :: AnyMessageDescriptor msg -> Lens' msg ByteString

-- | A helper lens for accessing optional fields. This is used as part of
--   code generation, and should generally not be needed explicitly.
--   
--   Note that <a>maybeLens</a> does not satisfy the lens laws, which
--   expect that <tt>set l (view l x) == x</tt>. For example,
--   
--   <pre>
--   set (maybeLens 'a') (view (maybeLens 'a') Nothing) == Just 'a'
--   </pre>
--   
--   However, this is the behavior generally expected by users, and only
--   matters if we're explicitly checking whether a field is set.
maybeLens :: b -> Lens' (Maybe b) b

-- | Reverse every repeated (list) field in the message.
--   
--   During parsing, we store fields temporarily in reverse order, and then
--   un-reverse them at the end. This helps avoid the quadratic blowup from
--   repeatedly appending to lists. TODO: Benchmark how much of a problem
--   this is in practice, and whether it's still a net win for small
--   protobufs. If we decide on it more permanently, consider moving it to
--   a more internal module.
reverseRepeatedFields :: Map k (FieldDescriptor msg) -> msg -> msg
type FieldSet = [TaggedValue]

-- | A pair of an encoded field and a value.
data TaggedValue
TaggedValue :: !Tag -> !WireValue -> TaggedValue
discardUnknownFields :: Message msg => msg -> msg
instance GHC.Show.Show Data.ProtoLens.Message.MessageOrGroup
instance GHC.Base.Monoid Data.ProtoLens.Message.Registry
instance GHC.Base.Semigroup Data.ProtoLens.Message.Registry
instance GHC.Show.Show (Data.ProtoLens.Message.FieldTypeDescriptor value)
instance GHC.Show.Show (Data.ProtoLens.Message.ScalarField value)
instance Data.ProtoLens.Message.FieldDefault GHC.Types.Bool
instance Data.ProtoLens.Message.FieldDefault GHC.Int.Int32
instance Data.ProtoLens.Message.FieldDefault GHC.Int.Int64
instance Data.ProtoLens.Message.FieldDefault GHC.Word.Word32
instance Data.ProtoLens.Message.FieldDefault GHC.Word.Word64
instance Data.ProtoLens.Message.FieldDefault GHC.Types.Float
instance Data.ProtoLens.Message.FieldDefault GHC.Types.Double
instance Data.ProtoLens.Message.FieldDefault Data.ByteString.Internal.Type.ByteString
instance Data.ProtoLens.Message.FieldDefault Data.Text.Internal.Text

module Data.ProtoLens.Encoding

-- | Encode a message to the wire format as a strict <tt>ByteString</tt>.
encodeMessage :: Message msg => msg -> ByteString

-- | Encode a message value.
--   
--   See also the functions in <a>Data.ProtoLens.Encoding</a>.
buildMessage :: Message msg => msg -> Builder

-- | Decode a message from its wire format. Returns <a>Left</a> if the
--   decoding fails.
decodeMessage :: Message msg => ByteString -> Either String msg

-- | Decode a message value.
--   
--   See also the functions in <a>Data.ProtoLens.Encoding</a>.
parseMessage :: Message msg => Parser msg

-- | Decode a message from its wire format. Throws an error if the decoding
--   fails.
decodeMessageOrDie :: Message msg => ByteString -> msg

-- | Encode a message to the wire format, prefixed by its size as a VarInt,
--   as part of a <a>Builder</a>.
--   
--   This can be used to build up streams of messages in the size-delimited
--   format expected by some protocols.
buildMessageDelimited :: Message msg => msg -> Builder
parseMessageDelimited :: Message msg => Parser msg

-- | Same as <tt>decodeMessage</tt> but for delimited messages read through
--   a Handle
decodeMessageDelimitedH :: Message msg => Handle -> IO (Either String msg)


-- | A compatibility layer for older code to create default protocol buffer
--   messages.
--   
--   In older versions of <tt>proto-lens</tt>, messages could be
--   constructed with <tt>Data.Default.Class.def</tt>. However, for
--   <tt>proto-lens &gt;= 0.4</tt>, that is no longer the case and
--   <tt>Data.ProtoLens.defMessage</tt> should be used instead.
--   
--   This module provides a compatibility layer that may be used to upgrade
--   older code without substantial code changes.
module Data.ProtoLens.Default

-- | A message with all fields set to their default values.
--   
--   For new code, prefer <a>defMessage</a>.
def :: Message a => a

-- | Every protocol buffer is an instance of <a>Message</a>. This class
--   enables serialization by providing reflection of all of the fields
--   that may be used by this type.
class Message msg


-- | This internal module provides functions used to define the various
--   <tt>enumFrom*</tt> functions of <a>Enum</a>.
--   
--   We expect <a>fromEnum</a> to be an ordering homomorphism, that is:
--   
--   <pre>
--   forall a b. Enum a b
--   succ a == b =&gt; fromEnum a &lt; fromEnum b
--   </pre>
--   
--   Note that this homomorphism is most likely not surjective. Note
--   further that one cannot assume:
--   
--   <pre>
--   CANNOT BE ASSUMED !
--   succ a == b =&gt; fromEnum a + 1 == fromEnum b
--   </pre>
--   
--   The <a>succ</a> essor of a given message enum value <tt>A</tt> that's
--   not <a>maxBound</a> is the enum value <tt>B</tt> whose <a>fromEnum</a>
--   value is the one immediately after <tt>A</tt>'s <a>fromEnum</a> value.
--   That is, <a>fromEnum</a> determines order, but not distance.
--   
--   As an example, consider the enum in the test suite:
--   
--   <pre>
--   enum Baz {
--       BAZ1 = 1; BAZ2 = 2; BAZ3 = 4; BAZ4 = 6;
--       BAZ5 = 7; BAZ6 = 9; BAZ7 = 10; BAZ8 = 12;
--   }
--   </pre>
--   
--   In this case, <tt>succ BAZ2</tt> is <tt>BAZ3</tt> despite their
--   fromEnum values differing by 2. Further, <tt>[BAZ2, BAZ4 ..]</tt> or
--   equivalently <tt>messageEnumFromThen BAZ2 BAZ4</tt> is every other
--   enum (i.e. a distance of 2) when taken as a list, i.e. <tt>[BAZ2,
--   BAZ4, BAZ6, BAZ8]</tt> despite the <a>fromEnum</a> distances being
--   <tt>[4, 3, 3]</tt>.
--   
--   That said, it is highly unwise to use any of the <tt>[a,b ..*]</tt>
--   patterns or <tt>enumFromThen*</tt> functions since adding or removing
--   enums values can cause previously functioning code to fail. I.e.
--   removing <tt>BAZ3</tt> in the above example makes the result
--   equivalent <tt>fromEnum BAZ2</tt> and the sequence now includes every
--   enum value save <tt>BAZ1</tt>. This is all despite the fact that
--   <tt>BAZ3</tt> was never referenced.
module Data.ProtoLens.Message.Enum
messageEnumFrom :: (Enum a, Bounded a) => a -> [a]
messageEnumFromTo :: Enum a => a -> a -> [a]
messageEnumFromThen :: (Enum a, Bounded a) => a -> a -> [a]
messageEnumFromThenTo :: forall a. Enum a => a -> a -> a -> [a]


-- | This module defines the <a>Prism</a> type and combinators. Used for
--   building <a>Prism</a>s for oneof fields.
module Data.ProtoLens.Prism
type Prism s t a b = forall p f. (Choice p, Applicative f) => p a (f b) -> p s (f t)
type Prism' s a = Prism s s a a
type AReview t b = Optic' Tagged Identity t b

-- | Used for constructing <a>Prism</a> values.
--   
--   <pre>
--   <a>_Just</a> <a>#</a> 5 == <a>Just</a> 5
--   </pre>
(#) :: AReview t b -> b -> t
infixr 8 #

-- | Build a <a>Prism</a>.
--   
--   <tt><a>Either</a> t a</tt> is used instead of <tt><a>Maybe</a> a</tt>
--   to permit the types of <tt>s</tt> and <tt>t</tt> to differ.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b
_Left :: Prism (Either a c) (Either b c) a b
_Right :: Prism (Either c a) (Either c b) a b
_Just :: Prism (Maybe a) (Maybe b) a b
_Nothing :: Prism' (Maybe a) ()


-- | This module provides typeclasses for describing protobuf service
--   metadata. It is intended to be used by library authors to generating
--   bindings against proto services for specific RPC backends.
module Data.ProtoLens.Service.Types

-- | Metadata describing a protobuf service. The <tt>s</tt> parameter is a
--   phantom type generated by proto-lens.
--   
--   The <a>ServiceName</a> and <a>ServicePackage</a> associated type can
--   be used to generate RPC endpoint paths.
--   
--   <a>ServiceMethods</a> is a promoted list containing every method
--   defined on the service. As witnessed by the <a>HasAllMethods</a>
--   superclass constraint here, this type can be used to discover every
--   instance of <a>HasMethod</a> available for the service.
class (KnownSymbol (ServiceName s), KnownSymbol (ServicePackage s), HasAllMethods s (ServiceMethods s)) => Service s where {
    type ServiceName s :: Symbol;
    type ServicePackage s :: Symbol;
    type ServiceMethods s :: [Symbol];
}
packedServiceDescriptor :: Service s => Proxy s -> ByteString

-- | Reifies the fact that there is a <a>HasMethod</a> instance for every
--   symbol claimed by the <a>ServiceMethods</a> associated type.
class HasAllMethods s (ms :: [Symbol])

-- | Metadata describing a service method. The <a>MethodInput</a> and
--   <a>MethodOutput</a> type families correspond to the <a>Message</a>s
--   generated by proto-lens for the RPC as described in the protobuf.
--   
--   <tt>IsClientStreaming</tt> and <tt>IsServerStreaming</tt> can be used
--   to dispatch on library code which wishes to provide different
--   interfaces depending on the type of streaming of the method.
--   
--   Library code should use <a>HasMethod</a> instead of this class
--   directly whenever the constraint will be exposed to the end user.
--   <a>HasMethod</a> provides substantially friendlier error messages when
--   used incorrectly.
class (KnownSymbol m, KnownSymbol (MethodName s m), Service s, Message (MethodInput s m), Message (MethodOutput s m)) => HasMethodImpl s (m :: Symbol) where {
    type MethodName s m :: Symbol;
    type MethodInput s m :: Type;
    type MethodOutput s m :: Type;
    type MethodStreamingType s m :: StreamingType;
}

-- | Helper constraint that expands to a user-friendly error message when
--   <tt>m</tt> isn't actually a method provided by service <tt>s</tt>.
type HasMethod s m = (RequireHasMethod s m (ListContains m (ServiceMethods s)), HasMethodImpl s m)

-- | Data type to be used as a promoted type for
--   <a>MethodStreamingType</a>.
data StreamingType
NonStreaming :: StreamingType
ClientStreaming :: StreamingType
ServerStreaming :: StreamingType
BiDiStreaming :: StreamingType
instance GHC.Show.Show Data.ProtoLens.Service.Types.StreamingType
instance GHC.Read.Read Data.ProtoLens.Service.Types.StreamingType
instance GHC.Enum.Bounded Data.ProtoLens.Service.Types.StreamingType
instance GHC.Enum.Enum Data.ProtoLens.Service.Types.StreamingType
instance GHC.Classes.Ord Data.ProtoLens.Service.Types.StreamingType
instance GHC.Classes.Eq Data.ProtoLens.Service.Types.StreamingType
instance forall k (s :: k) (ms :: [GHC.Types.Symbol]) (m :: GHC.Types.Symbol). (Data.ProtoLens.Service.Types.HasAllMethods s ms, Data.ProtoLens.Service.Types.HasMethodImpl s m) => Data.ProtoLens.Service.Types.HasAllMethods s (m : ms)
instance forall k (s :: k). Data.ProtoLens.Service.Types.HasAllMethods s '[]


-- | Functions for converting protocol buffers to a human-readable text
--   format.
module Data.ProtoLens.TextFormat

-- | Convert the given message into a human-readable <a>String</a>.
showMessage :: Message msg => msg -> String

-- | Convert the given message into a human-readable <a>String</a>, using
--   the <a>Registry</a> to encode <tt>google.protobuf.Any</tt> values.
showMessageWithRegistry :: Message msg => Registry -> msg -> String

-- | Serializes a proto as a string on a single line. Useful for debugging
--   and error messages like <tt>.DebugString()</tt> in other languages.
showMessageShort :: Message msg => msg -> String

-- | Pretty-print the given message into a human-readable form.
pprintMessage :: Message msg => msg -> Doc

-- | Pretty-print the given message into human-readable form, using the
--   given <a>Registry</a> to decode <tt>google.protobuf.Any</tt> values.
pprintMessageWithRegistry :: Message msg => Registry -> msg -> Doc

-- | Parse a <a>Message</a> from the human-readable protocol buffer text
--   format.
readMessage :: Message msg => Text -> Either String msg

-- | Parse a <a>Message</a> from a human-readable protocol buffer text
--   format, using the given <a>Registry</a> to decode <tt>Any</tt> fields
readMessageWithRegistry :: Message msg => Registry -> Text -> Either String msg

-- | Parse a <a>Message</a> from the human-readable protocol buffer text
--   format. Throws an error if the parse was not successful.
readMessageOrDie :: Message msg => Text -> msg


-- | The proto-lens package is a new implementation of protocol buffers in
--   Haskell.
module Data.ProtoLens


-- | An assorted collection of functions useful when working with ProtoLens
--   protocol buffers. These functions are inspired by functionality found
--   in the protobuf implementation in other languages.
module Data.ProtoLens.Combinators

-- | Turns a <a>LensLike</a> getting a <a>Maybe</a> into a <tt>Getter</tt>
--   of a <a>Bool</a> that returns <tt>True</tt> when the <a>Maybe</a> is
--   <tt>Just</tt> something.
--   
--   I.e., makes a getter for a <a>Maybe</a> field that returns whether
--   it's set.
has :: Phantom f => LensLike f a a' (Maybe b) b' -> LensLike f a a' Bool b''

-- | Sets the provided lens in <tt>a</tt> to <tt>Nothing</tt>.
clear :: Setter a a' b (Maybe b') -> a -> a'

-- | Creates a <tt>Default</tt> and then applies the provided <a>State</a>
--   to it. This is convenient for creating complicated structures.
make :: Message msg => State msg a -> msg

-- | Allows one to modify a value in the <a>State</a> monad. Note that this
--   is just for syntactic convenience with <tt>do</tt> blocks, e.g.
--   
--   <pre>
--   newThing = modifyInState thing $ do
--       ...
--   </pre>
modifyInState :: s -> State s a -> s
