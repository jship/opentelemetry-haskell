<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Lens.Family.Unchecked</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">lens-family-core-2.1.2: Haskell 2022 Lens Families</span><ul class="links" id="page-menu"><li><a href="src/Lens.Family.Unchecked.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Lens.Family.Unchecked</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Adapters</a></li><li><a href="#g:2">Lenses</a></li><li><a href="#g:3">Traversals</a></li><li><a href="#g:4">Prisms</a></li><li><a href="#g:5">Grates</a></li><li><a href="#g:6">Grids</a></li><li><a href="#g:7">Documentation</a></li><li><a href="#g:8">Types</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><em>Caution</em>: Improper use of this module can lead to unexpected behaviour if the preconditions of the functions are not met.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:adapter">adapter</a> :: (<a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> g) =&gt; (s -&gt; a) -&gt; (b -&gt; t) -&gt; <a href="Lens-Family-Unchecked.html#t:AdapterLike" title="Lens.Family.Unchecked">AdapterLike</a> f g s t a b</li><li class="src short"><a href="#v:lens">lens</a> :: <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f =&gt; (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; <a href="Lens-Family-Unchecked.html#t:LensLike" title="Lens.Family.Unchecked">LensLike</a> f s t a b</li><li class="src short"><a href="#v:prism">prism</a> :: (<a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.16.4.0/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> g) =&gt; (s -&gt; <a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> t a) -&gt; (b -&gt; t) -&gt; <a href="Lens-Family-Unchecked.html#t:AdapterLike" title="Lens.Family.Unchecked">AdapterLike</a> f g s t a b</li><li class="src short"><a href="#v:grate">grate</a> :: <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> g =&gt; (((s -&gt; a) -&gt; b) -&gt; t) -&gt; <a href="Lens-Family-Unchecked.html#t:GrateLike" title="Lens.Family.Unchecked">GrateLike</a> g s t a b</li><li class="src short"><a href="#v:setting">setting</a> :: <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> f =&gt; ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a href="Lens-Family-Unchecked.html#t:LensLike" title="Lens.Family.Unchecked">LensLike</a> f s t a b</li><li class="src short"><a href="#v:resetting">resetting</a> :: <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> g =&gt; ((a -&gt; b) -&gt; s -&gt; t) -&gt; <a href="Lens-Family-Unchecked.html#t:GrateLike" title="Lens.Family.Unchecked">GrateLike</a> g s t a b</li><li class="src short"><span class="keyword">type</span> <a href="#t:AdapterLike">AdapterLike</a> f g s t a b = (g a -&gt; f b) -&gt; g s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:AdapterLike-39-">AdapterLike'</a> f g s a = (g a -&gt; f a) -&gt; g s -&gt; f s</li><li class="src short"><span class="keyword">type</span> <a href="#t:LensLike">LensLike</a> f s t a b = (a -&gt; f b) -&gt; s -&gt; f t</li><li class="src short"><span class="keyword">type</span> <a href="#t:LensLike-39-">LensLike'</a> f s a = (a -&gt; f a) -&gt; s -&gt; f s</li><li class="src short"><span class="keyword">type</span> <a href="#t:GrateLike">GrateLike</a> g s t a b = (g a -&gt; b) -&gt; g s -&gt; t</li><li class="src short"><span class="keyword">type</span> <a href="#t:GrateLike-39-">GrateLike'</a> g s a = (g a -&gt; a) -&gt; g s -&gt; s</li><li class="src short"><span class="keyword">class</span> (<a href="../base-4.16.4.0/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> f, <a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a href="#t:Identical">Identical</a> f</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Adapters</h1></a><div class="doc"><p>An adapter represents a isomorphism between two types or a parametric isomorphism between two families of types.
 For example we can build an adapter between the type families <code><code><a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a></code> a a</code> and <code>(<code><a href="../base-4.16.4.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>, a)</code> as follows:</p><pre>timesTwo :: (Functor f, Functor g) =&gt; AdapterLike f g (Either a a) (Either b b) (Bool, a) (Bool b)
timesTwo f x = fmap yang . f . fmap yin
 where
  yin (True, a) = Left a
  yin (False, a) = Right a
  yang (Left a) = (True, a)
  yang (Right a) = (False, a)</pre><p><em>Note</em>: It is possible to adapters without even depending on <code>lens-family-core</code> by expanding away the type synonym.</p><pre>timesTwo :: (Functor f, Functor g) =&gt; (g (Either a a) -&gt; f (Either b b)) -&gt; g (Bool, a) -&gt; f (Bool, b)</pre><p>The function <code><a href="Lens-Family-Unchecked.html#v:adapter" title="Lens.Family.Unchecked">adapter</a></code> can also be used to construct adapters from a pair of mutually inverse functions.</p></div><a href="#g:2" id="g:2"><h1>Lenses</h1></a><div class="doc"><p>A lens focuses on a field of record type.
 Lenses can be used to get and/or set the focused field.
 How to create a lens family is best illustrated by the common example of a field of a record:</p><pre>data MyRecord a = MyRecord { _myA :: a, _myInt :: Int }

-- The use of type variables a and b allow for polymorphic updates.
myA :: Functor f =&gt; LensLike f (MyRecord a) (MyRecord b) a b
myA f (MyRecord a i) = (\b -&gt; MyRecord b i) &lt;$&gt; f a

-- The field _myInt is monomorphic, so we can use a 'LensLike''  type.
-- However, the structure of the function is exactly the same as for LensLike.
myInt :: Functor f =&gt; LensLike' f (MyRecord a) Int
myInt f (MyRecord a i) = (\i' -&gt; MyRecord a i') &lt;$&gt; f i</pre><p>See the <code>lens-family-th</code> package to generate this sort of code using Template Haskell.</p><p><em>Note</em>: It is possible to build lenses without even depending on <code>lens-family-core</code> by expanding away the type synonym.</p><pre>myA :: Functor f =&gt; (a -&gt; f b) -&gt; (MyRecord a) -&gt; f (MyRecord b)</pre><p>You can build lenses for more than just fields of records.
 Any value <code>l :: Functor f =&gt; LensLike f s t a b</code> is well-defined when it satisfies the two van Laarhoven lens laws:</p><ul><li><pre>l Identity === Identity</pre></li><li><pre>l (Compose . fmap f . g) === Compose . fmap (l f) . (l g)</pre></li></ul><p>The function <code><a href="Lens-Family-Unchecked.html#v:lens" title="Lens.Family.Unchecked">lens</a></code> can also be used to construct lenses.
 The resulting lenses will be well-defined so long as their preconditions are satisfied.</p></div><a href="#g:3" id="g:3"><h1>Traversals</h1></a><div class="doc"><p>If you have zero or more fields of the same type of a record, a traversal can be used to refer to all of them in order.
 Multiple references are made by replacing the <code><a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a></code> constraint of lenses with an <code><a href="../base-4.16.4.0/Control-Applicative.html#v:Applicative" title="Control.Applicative">Applicative</a></code> constraint.
 Consider the following example of a record with two <code><a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code> fields.</p><pre>data MyRecord = MyRecord { _myA :: Int, _myB :: Int, _myC :: Bool }

-- myInts is a traversal over both fields of MyRecord.
myInts :: Applicative f =&gt; LensLike' f MyRecord Int
myInts f (MyRecord a b c) = MyRecord &lt;$&gt; f a &lt;*&gt; f b &lt;*&gt; pure c</pre><p>If the record and the referenced fields are parametric, you can can build polymrphic traversals.
 Consider the following example of a record with two <code><a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> fields.</p><pre>data MyRecord a = MyRecord { _myA0 :: Maybe a, _myA1 :: Maybe a, myC :: Bool }

-- myMaybes is a traversal over both fields of MyRecord.
myMaybes :: Applicative f =&gt; LensLike f (MyRecord a) (MyRecord b) (Maybe a) (Maybe b)
myMaybes f (MyRecord a0 a1 c) = MyRecord &lt;$&gt; f a0 &lt;*&gt; f a1 &lt;*&gt; pure c</pre><p><em>Note</em>: It is possible to build traversals without even depending on <code>lens-family-core</code> by expanding away the type synonym.</p><pre>myMaybes :: Applicative f =&gt; (Maybe a -&gt; f (Maybe b)) -&gt; MyRecord a -&gt; f (MyRecord b)
myMaybes f (MyRecord a0 a1 c) = MyRecord &lt;$&gt; f a0 &lt;*&gt; f a1 &lt;*&gt; pure c</pre><p>Unfortunately, there are no helper functions for making traversals.
 In most cases, you must make them by hand.</p><p>Any value <code>t :: Applicative f =&gt; LensLike f s t a b</code> is well-defined when it satisfies the two van Laarhoven traversal laws:</p><ul><li><pre>t Identity === Identity</pre></li><li><pre>t (Compose . fmap f . g) === Compose . fmap (t f) . (t g)</pre></li></ul><p><code><a href="../base-4.16.4.0/Data-Traversable.html#v:traverse" title="Data.Traversable">traverse</a></code> is the canonical traversal for various containers.</p></div><a href="#g:4" id="g:4"><h1>Prisms</h1></a><div class="doc"><p>A prism focuses on a single variant of a type.
 They can be used to <code><a href="Lens-Family.html#v:matching" title="Lens.Family">matching</a></code> / <code><a href="Lens-Family.html#v:review" title="Lens.Family">review</a></code> the focused variant.
 Consider the following example.</p><pre>data MySum a = MyA a | MyB Int

-- myA is a prism for the MyA variant of MySum
myA :: (Applicative f, Traversable g) =&gt; AdapterLike f g (MySum a) (MySum b) a b
myA f = either pure (fmap MyA . f) . traverse h
 where
  h (MyA a) = Right a
  h (MyB n) = Left (MyB n)</pre><p>This prism can be used with <code><a href="Lens-Family.html#v:matching" title="Lens.Family">matching</a></code> via <code><a href="Lens-Family.html#v:under" title="Lens.Family">under</a></code>:</p><pre> <code><a href="Lens-Family.html#v:matching" title="Lens.Family">matching</a></code> (<code><a href="Lens-Family.html#v:under" title="Lens.Family">under</a></code> myA) :: MySum a -&gt; Either (MySum b) a</pre><p>This prism can be used with <code><a href="Lens-Family.html#v:review" title="Lens.Family">review</a></code> via <code><a href="Lens-Family.html#v:over" title="Lens.Family">over</a></code>:</p><pre> <code><a href="Lens-Family.html#v:review" title="Lens.Family">review</a></code> (<code><a href="Lens-Family.html#v:over" title="Lens.Family">over</a></code> myA) :: a -&gt; MySum a</pre><p><em>Note</em>: It is possible to build prisms without even depending on <code>lens-family-core</code> by expanding away the type synonym.</p><pre>myA :: (Appicative f, Traversable g) =&gt; (g a -&gt; f b) -&gt; g (MySum a) -&gt; f (MySum b)</pre><p>You can build prism for more than just constructors of sum types.
 Any value <code>p :: (Applicative f, Traversable g) =&gt; AdapterLike f g s t a b</code> is well-defined when it satisfies the prism laws:</p><ul><li><pre>matching (under p) (review (over p) b) === Right b</pre></li><li><pre>(id ||| review (over p)) (matching (under p) s) === s</pre></li><li><pre>left (match (under p)) (matching (under p) s) === left Left (matching (under p) s)</pre></li></ul><p>The function <code><a href="Lens-Family-Unchecked.html#v:prism" title="Lens.Family.Unchecked">prism</a></code> can also be used to construct prisms.
 The resulting prisms will be well-defined so long as their preconditions are satisfied.</p></div><a href="#g:5" id="g:5"><h1>Grates</h1></a><div class="doc"><p>A grate focuses on the contents of a representable functor.
 In other words, a grate focuses on the codomain of a function type or something isomorphic to a function type.
 They are used to lift operations on this codomain to operations on the larger structure via zipping.
 Consider the following example of a stream of <code><a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code>s.</p><pre>data IntStream = IntStream { hd :: Int, tl :: IntStream }

-- myInts is a grate over the Ints of IntStream.
myInts :: Functor g =&gt; GrateLike' g IntStream Int
myInts f s = IntStream (f (hd &lt;$&gt; s)) (myInts f (tl &lt;$&gt; s))</pre><p>If the contents are parametric, you can can build polymorphic grates.
 Consider the following example of a generic stream.</p><pre>data Stream a = Stream { hd :: a, tl :: Stream a }

-- myStream is a grate over the contents of a Stream.
myStream :: Functor g =&gt; GrateLike g (Stream a) (Stream b) a b
myStream f s = Stream (f (hd &lt;$&gt; s)) (myStream f (tl &lt;$&gt; s))</pre><p><em>Note</em>: It is possible to build grates without even depending on <code>lens-family-core</code> by expanding away the type synonym.</p><pre>myStream :: Functor g =&gt; (g (Stream a) -&gt; Stream b) -&gt; g a -&gt; b</pre><p>Any value <code>t :: Functor g =&gt; GrateLike g s t a b</code> is a well-defined grate when it satisfies the two van Laarhoven traversal laws:</p><ul><li><pre>t runIdentity === runIdentity</pre></li><li><pre>t (f . fmap g . runCompose) === (t f) . fmap (t g) . runCompose</pre></li></ul><p>The function <code><a href="Lens-Family-Unchecked.html#v:grate" title="Lens.Family.Unchecked">grate</a></code> can also be used to construct grates from graters.
 The resulting grates will be well-defined so long as the preconditions are satisfied.</p></div><a href="#g:6" id="g:6"><h1>Grids</h1></a><div class="doc"><p>A grid is both a traversal and a grate.
 When you have a type that is isomorphic to a fixed and finite number of copies of another type, a grid can be used to zip or traverse them.
 Consider the following example of a record with exactly two <code><a href="../base-4.16.4.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code> fields.</p><pre>data MyRecord = MyRecord { _myA :: Int, _myB :: Int }

-- myInts is a grid over both fields of MyRecord.
myInts :: (Applicative f, Functor g) =&gt; AdapterLike' f g MyRecord Int
myInts f r = MyRecord &lt;$&gt; f (_myA &lt;$&gt; r) &lt;*&gt; f (_myB &lt;$&gt; r)</pre><p>If the record and the referenced fields are parametric, you can can build polymorphic grids.
 Consider the following example of a record with exactly two <code><a href="../base-4.16.4.0/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> fields.</p><pre>data MyRecord a = MyRecord { _myA0 :: Maybe a, _myA1 :: Maybe a }

-- myMaybes is a traversal over both fields of MyRecord.
myMaybes :: (Applicative f, Functor g) =&gt; AdapterLike f g (MyRecord a) (MyRecord b) (Maybe a) (Maybe b)
myMaybes f r = MyRecord &lt;$&gt; f (_myA0 &lt;$&gt; r) &lt;*&gt; f (_myA1 &lt;$&gt; r)</pre><p>A grid is converted into a grate by using the <code><a href="Lens-Family.html#v:over" title="Lens.Family">over</a></code> function, and it is converted to a traversal by using the <code><a href="Lens-Family.html#v:under" title="Lens.Family">under</a></code> function.</p><p><em>Note</em>: It is possible to build grids without even depending on <code>lens-family-core</code> by expanding away the type synonym.</p><pre>myMaybes :: (Applicative f, Functor g) =&gt; (g (Maybe a) -&gt; f (Maybe b)) -&gt; g (MyRecord a) -&gt; f (MyRecord b)</pre><p>Unfortunately, there are no helper functions for making grids.
 In most cases, you must make them by hand.</p></div><a href="#g:7" id="g:7"><h1>Documentation</h1></a><div class="top"><p class="src"><a id="v:adapter" class="def">adapter</a> <a href="src/Lens.Family.Unchecked.html#adapter" class="link">Source</a> <a href="#v:adapter" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f, <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (s -&gt; a)</td><td class="doc"><p>yin</p></td></tr><tr><td class="src">-&gt; (b -&gt; t)</td><td class="doc"><p>yang</p></td></tr><tr><td class="src">-&gt; <a href="Lens-Family-Unchecked.html#t:AdapterLike" title="Lens.Family.Unchecked">AdapterLike</a> f g s t a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><pre>adapter :: (s -&gt; a) -&gt; (b -&gt; t) -&gt; Adapter s t a b
</pre><p>Build an adapter from an isomorphism family.</p><p><em>Caution</em>: In order for the generated adapter family to be well-defined, you must ensure that the two isomorphism laws hold:</p><ul><li><pre>yin . yang === id</pre></li><li><pre>yang . yin === id</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:lens" class="def">lens</a> <a href="src/Lens.Family.Unchecked.html#lens" class="link">Source</a> <a href="#v:lens" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> f</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (s -&gt; a)</td><td class="doc"><p>getter</p></td></tr><tr><td class="src">-&gt; (s -&gt; b -&gt; t)</td><td class="doc"><p>setter</p></td></tr><tr><td class="src">-&gt; <a href="Lens-Family-Unchecked.html#t:LensLike" title="Lens.Family.Unchecked">LensLike</a> f s t a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><pre>lens :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b
</pre><p>Build a lens from a <code>getter</code> and <code>setter</code> family.</p><p><em>Caution</em>: In order for the generated lens family to be well-defined, you must ensure that the three lens laws hold:</p><ul><li><pre>getter (setter s a) === a</pre></li><li><pre>setter s (getter s) === s</pre></li><li><pre>setter (setter s a1) a2 === setter s a2</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:prism" class="def">prism</a> <a href="src/Lens.Family.Unchecked.html#prism" class="link">Source</a> <a href="#v:prism" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f, <a href="../base-4.16.4.0/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (s -&gt; <a href="../base-4.16.4.0/Data-Either.html#t:Either" title="Data.Either">Either</a> t a)</td><td class="doc"><p>matcher</p></td></tr><tr><td class="src">-&gt; (b -&gt; t)</td><td class="doc"><p>reviewer</p></td></tr><tr><td class="src">-&gt; <a href="Lens-Family-Unchecked.html#t:AdapterLike" title="Lens.Family.Unchecked">AdapterLike</a> f g s t a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><pre>prism :: (s -&gt; Either t a) -&gt; (b -&gt; t) -&gt; Prism s t a b
</pre><p>Build a prism from a <code>matcher</code> and <code>reviewer</code> family.</p><p><em>Caution</em>: In order for the generated prism family to be well-defined, you must ensure that the three prism laws hold:</p><ul><li><pre>matcher (reviewer b) === Right b</pre></li><li><pre>(id ||| reviewer) (matcher s) === s</pre></li><li><pre>left matcher (matcher s) === left Left (matcher s)</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:grate" class="def">grate</a> <a href="src/Lens.Family.Unchecked.html#grate" class="link">Source</a> <a href="#v:grate" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="../base-4.16.4.0/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> g</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (((s -&gt; a) -&gt; b) -&gt; t)</td><td class="doc"><p>grater</p></td></tr><tr><td class="src">-&gt; <a href="Lens-Family-Unchecked.html#t:GrateLike" title="Lens.Family.Unchecked">GrateLike</a> g s t a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><pre>grate :: (((s -&gt; a) -&gt; b) -&gt; t) -&gt; Grate s t a b
</pre><p>Build a grate from a <code>grater</code> family.</p><p><em>Caution</em>: In order for the generated grate family to be well-defined, you must ensure that the two grater laws hold:</p><ul><li><pre>grater ($ s) === s</pre></li><li><pre>grater (k -&gt; h (k . grater)) === grater (k -&gt; h ($ k))</pre></li></ul><p>Note: The grater laws are that of an algebra for the parameterised continuation monad, <code><a href="Lens-Family.html#v:PCont" title="Lens.Family">PCont</a></code>.</p></div></div><div class="top"><p class="src"><a id="v:setting" class="def">setting</a> <a href="src/Lens.Family.Unchecked.html#setting" class="link">Source</a> <a href="#v:setting" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> f</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ((a -&gt; b) -&gt; s -&gt; t)</td><td class="doc"><p>sec (semantic editor combinator)</p></td></tr><tr><td class="src">-&gt; <a href="Lens-Family-Unchecked.html#t:LensLike" title="Lens.Family.Unchecked">LensLike</a> f s t a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><a href="Lens-Family-Unchecked.html#v:setting" title="Lens.Family.Unchecked">setting</a></code> promotes a &quot;semantic editor combinator&quot; to a modify-only lens.
 To demote a lens to a semantic edit combinator, use the section <code>(l %~)</code> or <code>over l</code> from <a href="Lens-Family.html">Lens.Family</a>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>[(&quot;The&quot;,0),(&quot;quick&quot;,1),(&quot;brown&quot;,1),(&quot;fox&quot;,2)] &amp; setting map . fstL %~ length
</code></strong>[(3,0),(5,1),(5,1),(3,2)]
</pre><p><em>Caution</em>: In order for the generated family to be well-defined, you must ensure that the two functors laws hold:</p><ul><li><pre>sec id === id</pre></li><li><pre>sec f . sec g === sec (f . g)</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:resetting" class="def">resetting</a> <a href="src/Lens.Family.Unchecked.html#resetting" class="link">Source</a> <a href="#v:resetting" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> g</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ((a -&gt; b) -&gt; s -&gt; t)</td><td class="doc"><p>sec (semantic editor combinator)</p></td></tr><tr><td class="src">-&gt; <a href="Lens-Family-Unchecked.html#t:GrateLike" title="Lens.Family.Unchecked">GrateLike</a> g s t a b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p><code><a href="Lens-Family-Unchecked.html#v:resetting" title="Lens.Family.Unchecked">resetting</a></code> promotes a &quot;semantic editor combinator&quot; to a form of grate that can only lift unary functions.
 To demote a grate to a semantic edit combinator, use <code>under l</code> from <a href="Lens-Family.html">Lens.Family</a>.</p><p><em>Caution</em>: In order for the generated family to be well-defined, you must ensure that the two functors laws hold:</p><ul><li><pre>sec id === id</pre></li><li><pre>sec f . sec g === sec (f . g)</pre></li></ul></div></div><a href="#g:8" id="g:8"><h1>Types</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:AdapterLike" class="def">AdapterLike</a> f g s t a b = (g a -&gt; f b) -&gt; g s -&gt; f t <a href="src/Lens.Family.Unchecked.html#AdapterLike" class="link">Source</a> <a href="#t:AdapterLike" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:AdapterLike-39-" class="def">AdapterLike'</a> f g s a = (g a -&gt; f a) -&gt; g s -&gt; f s <a href="src/Lens.Family.Unchecked.html#AdapterLike%27" class="link">Source</a> <a href="#t:AdapterLike-39-" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LensLike" class="def">LensLike</a> f s t a b = (a -&gt; f b) -&gt; s -&gt; f t <a href="src/Lens.Family.Unchecked.html#LensLike" class="link">Source</a> <a href="#t:LensLike" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:LensLike-39-" class="def">LensLike'</a> f s a = (a -&gt; f a) -&gt; s -&gt; f s <a href="src/Lens.Family.Unchecked.html#LensLike%27" class="link">Source</a> <a href="#t:LensLike-39-" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:GrateLike" class="def">GrateLike</a> g s t a b = (g a -&gt; b) -&gt; g s -&gt; t <a href="src/Lens.Family.Unchecked.html#GrateLike" class="link">Source</a> <a href="#t:GrateLike" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:GrateLike-39-" class="def">GrateLike'</a> g s a = (g a -&gt; a) -&gt; g s -&gt; s <a href="src/Lens.Family.Unchecked.html#GrateLike%27" class="link">Source</a> <a href="#t:GrateLike-39-" class="selflink">#</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="../base-4.16.4.0/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> f, <a href="../base-4.16.4.0/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f) =&gt; <a id="t:Identical" class="def">Identical</a> f <a href="src/Lens.Family.Identical.html#Identical" class="link">Source</a> <a href="#t:Identical" class="selflink">#</a></p><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">extract</p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Identical">Instances</h4><details id="i:Identical" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Identical:Identical:1"></span> <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> <a href="Lens-Family.html#t:Identity" title="Lens.Family">Identity</a></span> <a href="src/Lens.Family.Identical.html#line-11" class="link">Source</a> <a href="#t:Identical" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Identical:Identical:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Lens-Family-Identical.html">Lens.Family.Identical</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extract">extract</a> :: <a href="Lens-Family.html#t:Identity" title="Lens.Family">Identity</a> a -&gt; a</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Identical:Identical:2"></span> <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> f =&gt; <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> (<a href="Lens-Family-Stock.html#t:Backwards" title="Lens.Family.Stock">Backwards</a> f)</span> <a href="src/Lens.Family.Identical.html#line-14" class="link">Source</a> <a href="#t:Identical" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Identical:Identical:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Lens-Family-Identical.html">Lens.Family.Identical</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extract">extract</a> :: <a href="Lens-Family-Stock.html#t:Backwards" title="Lens.Family.Stock">Backwards</a> f a -&gt; a</p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Identical:Identical:3"></span> (<a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> f, <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> g) =&gt; <a href="Lens-Family-Unchecked.html#t:Identical" title="Lens.Family.Unchecked">Identical</a> (<a href="../base-4.16.4.0/Data-Functor-Compose.html#t:Compose" title="Data.Functor.Compose">Compose</a> f g)</span> <a href="src/Lens.Family.Identical.html#line-17" class="link">Source</a> <a href="#t:Identical" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Identical:Identical:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Lens-Family-Identical.html">Lens.Family.Identical</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:extract">extract</a> :: <a href="../base-4.16.4.0/Data-Functor-Compose.html#t:Compose" title="Data.Functor.Compose">Compose</a> f g a -&gt; a</p></div></details></td></tr></table></details></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.26.0</p></div></body></html>