-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell 2022 Lens Families
--   
--   This package provides first class(†) functional references in Van
--   Laarhoven style supporting the following optics:
--   
--   <ul>
--   <li>Lenses (view, over)</li>
--   <li>Traversals (toListOf, matching, over)</li>
--   <li>Setters (over)</li>
--   <li>Grates (zipWithOf, under, review)</li>
--   <li>Resetters (under)</li>
--   <li>Adapters (view, review)</li>
--   <li>Grids (toListOf, over / under, review)</li>
--   <li>Prisms (matching, over / under, review)</li>
--   <li>Getters (view)</li>
--   <li>Folders (toListOf)</li>
--   <li>Reviewers (review)</li>
--   </ul>
--   
--   (†) For optimal first-class support use the <tt>lens-family</tt>
--   package with rank 2 / rank N polymorphism. <a>Lens.Family.Clone</a>
--   allows for first-class support of lenses and traversals for those who
--   cannot support rank 2 polymorphism.
@package lens-family-core
@version 2.1.2


-- | <i>Caution</i>: Improper use of this module can lead to unexpected
--   behaviour if the preconditions of the functions are not met.
module Lens.Family.Unchecked

-- | <pre>
--   adapter :: (s -&gt; a) -&gt; (b -&gt; t) -&gt; Adapter s t a b
--   </pre>
--   
--   Build an adapter from an isomorphism family.
--   
--   <i>Caution</i>: In order for the generated adapter family to be
--   well-defined, you must ensure that the two isomorphism laws hold:
--   
--   <ul>
--   <li><pre>yin . yang === id</pre></li>
--   <li><pre>yang . yin === id</pre></li>
--   </ul>
adapter :: (Functor f, Functor g) => (s -> a) -> (b -> t) -> AdapterLike f g s t a b

-- | <pre>
--   lens :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b
--   </pre>
--   
--   Build a lens from a <tt>getter</tt> and <tt>setter</tt> family.
--   
--   <i>Caution</i>: In order for the generated lens family to be
--   well-defined, you must ensure that the three lens laws hold:
--   
--   <ul>
--   <li><pre>getter (setter s a) === a</pre></li>
--   <li><pre>setter s (getter s) === s</pre></li>
--   <li><pre>setter (setter s a1) a2 === setter s a2</pre></li>
--   </ul>
lens :: Functor f => (s -> a) -> (s -> b -> t) -> LensLike f s t a b

-- | <pre>
--   prism :: (s -&gt; Either t a) -&gt; (b -&gt; t) -&gt; Prism s t a b
--   </pre>
--   
--   Build a prism from a <tt>matcher</tt> and <tt>reviewer</tt> family.
--   
--   <i>Caution</i>: In order for the generated prism family to be
--   well-defined, you must ensure that the three prism laws hold:
--   
--   <ul>
--   <li><pre>matcher (reviewer b) === Right b</pre></li>
--   <li><pre>(id ||| reviewer) (matcher s) === s</pre></li>
--   <li><pre>left matcher (matcher s) === left Left (matcher s)</pre></li>
--   </ul>
prism :: (Applicative f, Traversable g) => (s -> Either t a) -> (b -> t) -> AdapterLike f g s t a b

-- | <pre>
--   grate :: (((s -&gt; a) -&gt; b) -&gt; t) -&gt; Grate s t a b
--   </pre>
--   
--   Build a grate from a <tt>grater</tt> family.
--   
--   <i>Caution</i>: In order for the generated grate family to be
--   well-defined, you must ensure that the two grater laws hold:
--   
--   <ul>
--   <li><pre>grater ($ s) === s</pre></li>
--   <li><pre>grater (k -&gt; h (k . grater)) === grater (k -&gt; h ($
--   k))</pre></li>
--   </ul>
--   
--   Note: The grater laws are that of an algebra for the parameterised
--   continuation monad, <a>PCont</a>.
grate :: Functor g => (((s -> a) -> b) -> t) -> GrateLike g s t a b

-- | <a>setting</a> promotes a "semantic editor combinator" to a
--   modify-only lens. To demote a lens to a semantic edit combinator, use
--   the section <tt>(l %~)</tt> or <tt>over l</tt> from
--   <a>Lens.Family</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [("The",0),("quick",1),("brown",1),("fox",2)] &amp; setting map . fstL %~ length
--   [(3,0),(5,1),(5,1),(3,2)]
--   </pre>
--   
--   <i>Caution</i>: In order for the generated family to be well-defined,
--   you must ensure that the two functors laws hold:
--   
--   <ul>
--   <li><pre>sec id === id</pre></li>
--   <li><pre>sec f . sec g === sec (f . g)</pre></li>
--   </ul>
setting :: Identical f => ((a -> b) -> s -> t) -> LensLike f s t a b

-- | <a>resetting</a> promotes a "semantic editor combinator" to a form of
--   grate that can only lift unary functions. To demote a grate to a
--   semantic edit combinator, use <tt>under l</tt> from
--   <a>Lens.Family</a>.
--   
--   <i>Caution</i>: In order for the generated family to be well-defined,
--   you must ensure that the two functors laws hold:
--   
--   <ul>
--   <li><pre>sec id === id</pre></li>
--   <li><pre>sec f . sec g === sec (f . g)</pre></li>
--   </ul>
resetting :: Identical g => ((a -> b) -> s -> t) -> GrateLike g s t a b
type AdapterLike f g s t a b = (g a -> f b) -> (g s -> f t)
type AdapterLike' f g s a = (g a -> f a) -> (g s -> f s)
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike' f s a = (a -> f a) -> (s -> f s)
type GrateLike g s t a b = (g a -> b) -> (g s -> t)
type GrateLike' g s a = (g a -> a) -> (g s -> s)
class (Traversable f, Applicative f) => Identical f


-- | This is the main module for end-users of lens-families-core. If you
--   are not building your own optics such as lenses, traversals, grates,
--   etc., but just using optics made by others, this is the only module
--   you need.
module Lens.Family

-- | <pre>
--   to :: (s -&gt; a) -&gt; Getter s t a b
--   </pre>
--   
--   <a>to</a> promotes a projection function to a read-only lens called a
--   getter. To demote a lens to a projection function, use the section
--   <tt>(^.l)</tt> or <tt>view l</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (3 :+ 4, "example")^._1.to(abs)
--   5.0 :+ 0.0
--   </pre>
to :: Phantom f => (s -> a) -> LensLike f s t a b

-- | <pre>
--   view :: Getter s t a b -&gt; s -&gt; a
--   </pre>
--   
--   Demote a lens or getter to a projection function.
--   
--   <pre>
--   view :: Monoid a =&gt; Fold s t a b -&gt; s -&gt; a
--   </pre>
--   
--   Returns the monoidal summary of a traversal or a fold.
view :: FoldLike a s t a b -> s -> a

-- | <pre>
--   (^.) :: s -&gt; Getter s t a b -&gt; a
--   </pre>
--   
--   Access the value referenced by a getter or lens.
--   
--   <pre>
--   (^.) :: Monoid a =&gt; s -&gt; Fold s t a b -&gt; a
--   </pre>
--   
--   Access the monoidal summary referenced by a traversal or a fold.
(^.) :: s -> FoldLike a s t a b -> a
infixl 8 ^.

-- | <pre>
--   folding :: (s -&gt; [a]) -&gt; Fold s t a b
--   </pre>
--   
--   <a>folding</a> promotes a "toList" function to a read-only traversal
--   called a fold.
--   
--   To demote a traversal or fold to a "toList" function use the section
--   <tt>(^..l)</tt> or <tt>toListOf l</tt>.
folding :: (Foldable g, Phantom f, Applicative f) => (s -> g a) -> LensLike f s t a b

-- | <pre>
--   views :: Monoid r =&gt; Fold s t a b -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   Given a fold or traversal, return the <a>foldMap</a> of all the values
--   using the given function.
--   
--   <pre>
--   views :: Getter s t a b -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <a>views</a> is not particularly useful for getters or lenses, but
--   given a getter or lens, it returns the referenced value passed through
--   the given function.
--   
--   <pre>
--   views l f s = f (view l s)
--   </pre>
views :: FoldLike r s t a b -> (a -> r) -> s -> r

-- | <pre>
--   (^..) :: s -&gt; Fold s t a b -&gt; [a]
--   </pre>
--   
--   Returns a list of all of the referenced values in order.
(^..) :: s -> FoldLike [a] s t a b -> [a]
infixl 8 ^..

-- | <pre>
--   (^?) :: s -&gt; Fold s t a b -&gt; Maybe a
--   </pre>
--   
--   Returns <a>Just</a> the first referenced value. Returns <a>Nothing</a>
--   if there are no referenced values.
(^?) :: s -> FoldLike (First a) s t a b -> Maybe a
infixl 8 ^?

-- | <pre>
--   toListOf :: Fold s t a b -&gt; s -&gt; [a]
--   </pre>
--   
--   Returns a list of all of the referenced values in order.
toListOf :: FoldLike [a] s t a b -> s -> [a]

-- | <pre>
--   allOf :: Fold s t a b -&gt; (a -&gt; Bool) -&gt; s -&gt; Bool
--   </pre>
--   
--   Returns true if all of the referenced values satisfy the given
--   predicate.
allOf :: FoldLike All s t a b -> (a -> Bool) -> s -> Bool

-- | <pre>
--   anyOf :: Fold s t a b -&gt; (a -&gt; Bool) -&gt; s -&gt; Bool
--   </pre>
--   
--   Returns true if any of the referenced values satisfy the given
--   predicate.
anyOf :: FoldLike Any s t a b -> (a -> Bool) -> s -> Bool

-- | <pre>
--   firstOf :: Fold s t a b -&gt; s -&gt; Maybe a
--   </pre>
--   
--   Returns <a>Just</a> the first referenced value. Returns <a>Nothing</a>
--   if there are no referenced values. See <a>^?</a> for an infix version
--   of <a>firstOf</a>
firstOf :: FoldLike (First a) s t a b -> s -> Maybe a

-- | <pre>
--   lastOf :: Fold s t a b -&gt; s -&gt; Maybe a
--   </pre>
--   
--   Returns <a>Just</a> the last referenced value. Returns <a>Nothing</a>
--   if there are no referenced values.
lastOf :: FoldLike (Last a) s t a b -> s -> Maybe a

-- | <pre>
--   sumOf :: Num a =&gt; Fold s t a b -&gt; s -&gt; a
--   </pre>
--   
--   Returns the sum of all the referenced values.
sumOf :: Num a => FoldLike (Sum a) s t a b -> s -> a

-- | <pre>
--   productOf :: Num a =&gt; Fold s t a b -&gt; s -&gt; a
--   </pre>
--   
--   Returns the product of all the referenced values.
productOf :: Num a => FoldLike (Product a) s t a b -> s -> a

-- | <pre>
--   lengthOf :: Num r =&gt; Fold s t a b -&gt; s -&gt; r
--   </pre>
--   
--   Counts the number of references in a traversal or fold for the input.
lengthOf :: Num r => FoldLike (Sum r) s t a b -> s -> r

-- | <pre>
--   nullOf :: Fold s t a b -&gt; s -&gt; Bool
--   </pre>
--   
--   Returns true if the number of references in the input is zero.
nullOf :: FoldLike All s t a b -> s -> Bool

-- | <pre>
--   matching :: Traversal s t a b -&gt; s -&gt; Either t a
--   </pre>
--   
--   Returns <a>Right</a> of the first referenced value. Returns
--   <a>Left</a> the original value when there are no referenced values. In
--   case there are no referenced values, the result might have a fresh
--   type parameter, thereby proving the original value had no referenced
--   values.
matching :: LensLike (Either a) s t a b -> s -> Either t a

-- | <pre>
--   over :: Setter s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
--   
--   Demote a setter to a semantic editor combinator.
--   
--   <pre>
--   over :: Prism s t a b -&gt; Reviwer s t a b
--   over :: Grid s t a b -&gt; Grate s t a b
--   over :: Adapter s t a b -&gt; Grate s t a b
--   </pre>
--   
--   Covert an <a>AdapterLike</a> optic into a <a>GrateLike</a> optic.
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | Modify all referenced fields.
(%~) :: ASetter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Set all referenced fields to the given value.
set :: ASetter s t a b -> b -> s -> t

-- | Set all referenced fields to the given value.
(.~) :: ASetter s t a b -> b -> s -> t
infixr 4 .~

-- | <pre>
--   review :: Grate s t a b -&gt; b -&gt; t
--   review :: Reviewer s t a b -&gt; b -&gt; t
--   </pre>
review :: GrateLike (Constant ()) s t a b -> b -> t

-- | <pre>
--   zipWithOf :: Grate s t a b -&gt; (a -&gt; a -&gt; b) -&gt; s -&gt; s -&gt; t
--   </pre>
--   
--   Returns a binary instance of a grate.
--   
--   <pre>
--   zipWithOf l f x y = degrating l (k -&gt; f (k x) (k y))
--   </pre>
zipWithOf :: GrateLike (Prod Identity Identity) s t a b -> (a -> a -> b) -> s -> s -> t

-- | <pre>
--   degrating :: Grate s t a b -&gt; ((s -&gt; a) -&gt; b) -&gt; t
--   </pre>
--   
--   Demote a grate to its normal, higher-order function, form.
--   
--   <pre>
--   degrating . grate = id
--   grate . degrating = id
--   </pre>
degrating :: AGrate s t a b -> ((s -> a) -> b) -> t

-- | <pre>
--   under :: Resetter s t a b -&gt; (a -&gt; b) -&gt; s -&gt; t
--   </pre>
--   
--   Demote a resetter to a semantic editor combinator.
--   
--   <pre>
--   under :: Prism s t a b -&gt; Traversal s t a b
--   under :: Grid s t a b -&gt; Traversal s t a b
--   under :: Adapter s t a b -&gt; Lens s t a b
--   </pre>
--   
--   Covert an <a>AdapterLike</a> optic into a <a>LensLike</a> optic.
--   
--   Note: this function is unrelated to the lens package's <tt>under</tt>
--   function.
under :: AResetter s t a b -> (a -> b) -> s -> t

-- | <pre>
--   reset :: Resetter s t a b -&gt; b -&gt; s -&gt; t
--   </pre>
--   
--   Set all referenced fields to the given value.
reset :: AResetter s t a b -> b -> s -> t

-- | A flipped version of <tt>($)</tt>.
(&) :: s -> (s -> t) -> t
infixl 1 &
(+~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 +~
(*~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 *~
(-~) :: Num a => ASetter s t a a -> a -> s -> t
infixr 4 -~
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
infixr 4 //~
(&&~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 &&~
(||~) :: ASetter s t Bool Bool -> Bool -> s -> t
infixr 4 ||~

-- | Monoidally append a value to all referenced fields.
(<>~) :: Monoid a => ASetter s t a a -> a -> s -> t
infixr 4 <>~
type AdapterLike f g s t a b = (g a -> f b) -> (g s -> f t)
type AdapterLike' f g s a = (g a -> f a) -> (g s -> f s)
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike' f s a = (a -> f a) -> (s -> f s)
type FoldLike r s t a b = LensLike (Constant r) s t a b
type FoldLike' r s a = LensLike' (Constant r) s a
type GrateLike g s t a b = (g a -> b) -> (g s -> t)
type GrateLike' g s a = (g a -> a) -> (g s -> s)
type AGrate s t a b = GrateLike (PCont b a) s t a b
type AGrate' s a = GrateLike' (PCont a a) s a
type ASetter s t a b = LensLike Identity s t a b
type ASetter' s a = LensLike' Identity s a
type AResetter s t a b = GrateLike Identity s t a b
type AResetter' s a = GrateLike' Identity s a
data PCont i j a
data First a
data Last a
class Functor f => Phantom f

-- | Constant functor.
data Constant a (b :: k)

-- | Identity functor and monad. (a non-strict monad)
data Identity a
type Prod = Product

-- | Boolean monoid under conjunction (<a>&amp;&amp;</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
--   False
--   </pre>
data All

-- | Boolean monoid under disjunction (<a>||</a>).
--   
--   <pre>
--   &gt;&gt;&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
--   True
--   </pre>
data Any

-- | Monoid under addition.
--   
--   <pre>
--   &gt;&gt;&gt; getSum (Sum 1 &lt;&gt; Sum 2 &lt;&gt; mempty)
--   3
--   </pre>
data Sum a

-- | Monoid under multiplication.
--   
--   <pre>
--   &gt;&gt;&gt; getProduct (Product 3 &lt;&gt; Product 4 &lt;&gt; mempty)
--   12
--   </pre>
data Product a
instance GHC.Base.Monoid (Lens.Family.Last a)
instance GHC.Base.Semigroup (Lens.Family.Last a)
instance GHC.Base.Monoid (Lens.Family.First a)
instance GHC.Base.Semigroup (Lens.Family.First a)
instance GHC.Base.Functor (Lens.Family.PCont i j)


-- | This module contains lenses, prisms, grids, grates and traversals for
--   common structures in Haskell. It also contains the combinators for
--   various kinds of optics.
--   
--   A Function name with <tt>'</tt> is a grate variant of a grid, and a
--   function name with <tt>_</tt> is a traversal variants of a grid or
--   prism. For example, <a>both'</a> is the grate variant of <a>both</a>
--   while <a>both_</a> is the traversal variant.
module Lens.Family.Stock

-- | <pre>
--   _1 :: Lens (a, r) (b, r) a b
--   </pre>
--   
--   Lens on the first element of a pair.
_1 :: Functor f => LensLike f (a, r) (b, r) a b

-- | <pre>
--   _2 :: Lens (r, a) (r, b) a b
--   </pre>
--   
--   Lens on the second element of a pair.
_2 :: Functor f => LensLike f (r, a) (r, b) a b

-- | <pre>
--   chosen :: Lens (Either a a) (Either b b) a b
--   </pre>
--   
--   Lens on the Left or Right element of an (<a>Either</a> a a).
chosen :: Functor f => LensLike f (Either a a) (Either b b) a b

-- | <pre>
--   ix :: Eq k =&gt; k -&gt; Lens' (k -&gt; v) v
--   </pre>
--   
--   Lens on a given point of a function.
ix :: (Eq k, Functor f) => k -> LensLike' f (k -> v) v

-- | <pre>
--   at :: Ord k =&gt; k -&gt; Lens' (Map.Map k v) (Maybe v)
--   </pre>
--   
--   Lens on a given point of a <a>Map</a>.
at :: (Ord k, Functor f) => k -> LensLike' f (Map k v) (Maybe v)

-- | <pre>
--   intAt :: Int -&gt; Lens (IntMap.IntMap v) (Maybe v)
--   </pre>
--   
--   Lens on a given point of a <a>IntMap</a>.
intAt :: Functor f => Int -> LensLike' f (IntMap v) (Maybe v)

-- | <pre>
--   at :: Ord k =&gt; k -&gt; Lens' (Map.Map k v) (Maybe v)
--   </pre>
--   
--   Lens providing strict access to a given point of a <a>Map</a>.
at' :: (Ord k, Functor f) => k -> LensLike' f (Map k v) (Maybe v)

-- | <pre>
--   intAt :: Int -&gt; Lens (IntMap.IntMap v) (Maybe v)
--   </pre>
--   
--   Lens providing strict access to a given point of a <a>IntMap</a>.
intAt' :: Functor f => Int -> LensLike' f (IntMap v) (Maybe v)

-- | <pre>
--   contains :: Ord =&gt; k -&gt; Lens' (Set.Set k) Bool
--   </pre>
--   
--   Lens on a given point of a <a>Set</a>.
contains :: (Ord k, Functor f) => k -> LensLike' f (Set k) Bool

-- | <pre>
--   intContains :: Int -&gt; Lens' IntSet.IntSet Bool
--   </pre>
--   
--   Lens on a given point of a <a>IntSet</a>.
intContains :: Functor f => Int -> LensLike' f IntSet Bool

-- | <pre>
--   left :: Prism (Either a r) (Either b r) a b
--   </pre>
--   
--   A prism on the <a>Left</a> element of an <a>Either</a>.
left :: (Applicative f, Traversable g) => AdapterLike f g (Either a r) (Either b r) a b

-- | <pre>
--   right :: Prism (Either r a) (Either r b) a b
--   </pre>
--   
--   A prism on the <a>Right</a> element of an <a>Either</a>.
right :: (Applicative f, Traversable g) => AdapterLike f g (Either r a) (Either r b) a b

-- | <pre>
--   just :: Prism (Maybe a) (Maybe b) a b
--   </pre>
--   
--   A prism on the <a>Just</a> element of a <a>Maybe</a>.
just :: (Applicative f, Traversable g) => AdapterLike f g (Maybe a) (Maybe b) a b

-- | <pre>
--   nothing :: Prism' (Maybe a) ()
--   </pre>
--   
--   A prism on the <a>Nothing</a> element of a <a>Maybe</a>.
nothing :: (Applicative f, Traversable g) => AdapterLike' f g (Maybe a) ()

-- | <pre>
--   both :: Grid (a,a) (b,b) a b
--   </pre>
--   
--   A grid on both elements of a pair <tt>(a,a)</tt>.
both :: (Applicative f, Functor g) => AdapterLike f g (a, a) (b, b) a b

-- | <pre>
--   bend :: FiniteBits b =&gt; Grid' b Bool
--   </pre>
--   
--   A grid from the most significant bit to the least significant bit of a
--   <a>FiniteBits</a> type.
--   
--   Big endian order.
bend :: (FiniteBits b, Applicative f, Functor g) => AdapterLike' f g b Bool

-- | <pre>
--   lend :: FiniteBits b =&gt; Grid' b Bool
--   </pre>
--   
--   A grid from the least significant bit to the most significant bit of a
--   <a>FiniteBits</a> type.
--   
--   Little endian order.
lend :: (FiniteBits b, Applicative f, Functor g) => AdapterLike' f g b Bool

-- | <pre>
--   cod :: Grate (r -&gt; a) (r -&gt; b) a b
--   </pre>
--   
--   A grate accessing the codomain of a function.
cod :: Functor g => GrateLike g (r -> a) (r -> b) a b

-- | <pre>
--   both' :: Grate (a,a) (b,b) a b
--   </pre>
--   
--   A grate on both elements of a pair <tt>(a,a)</tt>.
--   
--   <pre>
--   both' = over both
--   </pre>
both' :: Functor g => GrateLike g (a, a) (b, b) a b

-- | <pre>
--   bend' :: FiniteBits b =&gt; Grate' b Bool
--   </pre>
--   
--   A grate from the most significant bit to the least significant bit of
--   a <a>FiniteBits</a> type.
--   
--   Big endian order.
--   
--   <pre>
--   bend' = over bend
--   </pre>
bend' :: (FiniteBits b, Functor g) => GrateLike' g b Bool

-- | <pre>
--   lend' :: FiniteBits b =&gt; Grate' b Bool
--   </pre>
--   
--   A grate from the least significant bit to the most significant bit of
--   a <a>FiniteBits</a> type.
--   
--   Little endian order.
--   
--   <pre>
--   lend' = over lend
--   </pre>
lend' :: (FiniteBits b, Functor g) => GrateLike' g b Bool

-- | <pre>
--   both_ :: Traversal (a,a) (b,b) a b
--   </pre>
--   
--   Traversals on both elements of a pair <tt>(a,a)</tt>.
--   
--   <pre>
--   both_ = under both
--   </pre>
both_ :: Applicative f => LensLike f (a, a) (b, b) a b

-- | <pre>
--   bend_ :: FiniteBits b =&gt; Traversal' b Bool
--   </pre>
--   
--   A traversal from the most significant bit to the least significant bit
--   of a <a>FiniteBits</a> type.
--   
--   Big endian order.
--   
--   <pre>
--   bend_ = under bend
--   </pre>
bend_ :: (FiniteBits b, Applicative f) => LensLike' f b Bool

-- | <pre>
--   lend_ :: FiniteBits b =&gt; Traversal' b Bool
--   </pre>
--   
--   A traversal from the least significant bit to the most significant bit
--   of a <a>FiniteBits</a> type.
--   
--   Little endian order.
--   
--   <pre>
--   lend_ = under lend
--   </pre>
lend_ :: (FiniteBits b, Applicative f) => LensLike' f b Bool

-- | <pre>
--   left_ :: Traversal (Either a r) (Either b r) a b
--   </pre>
--   
--   Traversal on the <a>Left</a> element of an <a>Either</a>.
--   
--   <pre>
--   left_ = under left
--   </pre>
left_ :: Applicative f => LensLike f (Either a r) (Either b r) a b

-- | <pre>
--   right_ :: Traversal (Either r a) (Either r b) a b
--   </pre>
--   
--   Traversal on the <a>Right</a> element of an <a>Either</a>.
--   
--   <pre>
--   right_ = under right
--   </pre>
right_ :: Applicative f => LensLike f (Either r a) (Either r b) a b

-- | <pre>
--   just_ :: Traversal (Maybe a) (Maybe b) a b
--   </pre>
--   
--   Traversal on the <a>Just</a> element of a <a>Maybe</a>.
just_ :: Applicative f => LensLike f (Maybe a) (Maybe b) a b

-- | <pre>
--   nothing_ :: Traversal' (Maybe a) ()
--   </pre>
--   
--   Traversal on the <a>Nothing</a> element of a <a>Maybe</a>.
nothing_ :: Applicative f => LensLike' f (Maybe a) ()

-- | <pre>
--   ignored :: Traversal s s a b
--   </pre>
--   
--   The empty traversal on any type.
ignored :: Applicative f => null -> s -> f s

-- | <pre>
--   mapped :: Functor h =&gt; Setter (h a) (h b) a b
--   </pre>
--   
--   An SEC referencing the parameter of a functor.
mapped :: (Identical f, Functor h) => LensLike f (h a) (h b) a b

-- | <pre>
--   alongside :: Lens s0 t0 a0 b0 -&gt; Lens s1 t1 a1 b1 -&gt; Lens (s0, s1) (t0, t1) (a0, a1) (b0, b1)
--   </pre>
--   
--   <pre>
--   alongside :: Getter s0 t0 a0 b0 -&gt; Getter s1 t1 a1 b1 -&gt; Getter (s0, s1) (t0, t1) (a0, a1) (b0, b1)
--   </pre>
--   
--   Given two lens/getter families, make a new lens/getter on their
--   product.
alongside :: Functor f => LensLike (AlongsideLeft f b1) s0 t0 a0 b0 -> LensLike (AlongsideRight f t0) s1 t1 a1 b1 -> LensLike f (s0, s1) (t0, t1) (a0, a1) (b0, b1)

-- | <pre>
--   backwards :: Traversal s t a b -&gt; Traversal s t a b
--   backwards :: Fold s t a b -&gt; Fold s t a b
--   </pre>
--   
--   Given a traversal or fold, reverse the order that elements are
--   traversed.
--   
--   <pre>
--   backwards :: Lens s t a b -&gt; Lens s t a b
--   backwards :: Getter s t a b -&gt; Getter s t a b
--   backwards :: Setter s t a b -&gt; Setter s t a b
--   </pre>
--   
--   No effect on lenses, getters or setters.
backwards :: LensLike (Backwards f) s t a b -> LensLike f s t a b

-- | <pre>
--   beside :: Grid s1 t1 a b -&gt; Grid s2 t2 a b -&gt; Grid (s1, s2) (t1, t2) a b
--   </pre>
--   
--   Given two grids referencing a type <tt>c</tt>, create a grid on the
--   pair referencing <tt>c</tt>.
beside :: (Applicative f, Functor g) => AdapterLike f g s0 t0 a b -> AdapterLike f g s1 t1 a b -> AdapterLike f g (s0, s1) (t0, t1) a b

-- | <pre>
--   beside' :: Grate s0 t0 a b -&gt; Grate s1 t1 a b -&gt; Grate (s0, s1) (t0, t1) a b
--   </pre>
--   
--   <pre>
--   beside' :: Resetter s0 t0 a b -&gt; Resetter s1 t1 a b -&gt; Resetter (s0, s1) (t0, t1) a b
--   </pre>
--   
--   Given two grates/resetters referencing a type <tt>c</tt>, create a
--   grate/resetter on the pair referencing <tt>c</tt>.
beside' :: Functor g => GrateLike g s0 t0 a b -> GrateLike g s1 t1 a b -> GrateLike g (s0, s1) (t0, t1) a b

-- | <pre>
--   beside_ :: Traversal s0 t0 a b -&gt; Traversal s1 t1 a b -&gt; Traversal (s0, s1) (t0, t1) a b
--   </pre>
--   
--   <pre>
--   beside_ :: Fold s0 t0 a b -&gt; Fold s1 t1 a b -&gt; Fold (s0, s1) (t0, t1) a b
--   </pre>
--   
--   <pre>
--   beside_ :: Setter s0 t0 a b -&gt; Setter s1 t1 a b -&gt; Setter (s0, s1) (t0, t1) a b
--   </pre>
--   
--   Given two traversals/folds/setters referencing a type <tt>c</tt>,
--   create a traversal/fold/setter on the pair referencing <tt>c</tt>.
beside_ :: Applicative f => LensLike f s0 t0 a b -> LensLike f s1 t1 a b -> LensLike f (s0, s1) (t0, t1) a b

-- | <pre>
--   choosing :: Lens s0 t0 a b -&gt; Lens s1 t1 a b -&gt; Lens (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Traversal s0 t0 a b -&gt; Traversal s1 t1 a b -&gt; Traversal (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Getter s0 t0 a b -&gt; Getter s1 t1 a b -&gt; Getter (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Fold s0 t0 a b -&gt; Fold s1 t1 a b -&gt; Fold (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Setter s0 t0 a b -&gt; Setter s1 t1 a b -&gt; Setter (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   Given two lens/traversal/getter/fold/setter families with the same
--   substructure, make a new lens/traversal/getter/fold/setter on
--   <a>Either</a>.
choosing :: Functor f => LensLike f s0 t0 a b -> LensLike f s1 t1 a b -> LensLike f (Either s0 s1) (Either t0 t1) a b

-- | <pre>
--   from :: Adapter b a t s -&gt; Adapter s t a b
--   </pre>
--   
--   Reverses the direction of an adapter.
--   
--   <pre>
--   from :: Getter b a t s -&gt; Reviewer s t a b
--   from :: Reviewer b a t s -&gt; Getter s t a b
--   </pre>
--   
--   Changes a Getter into a Reviewer and vice versa.
from :: (Functor f, Functor g) => AdapterLike (FromF (g s -> f t) (f b) g) (FromG (f b) f) b a t s -> AdapterLike f g s t a b
data AlongsideLeft f b a
data AlongsideRight f a b
data FromF i j g x
data FromG e f x
type AdapterLike f g s t a b = (g a -> f b) -> (g s -> f t)
type AdapterLike' f g s a = (g a -> f a) -> (g s -> f s)
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike' f s a = (a -> f a) -> (s -> f s)
type GrateLike g s t a b = (g a -> b) -> (g s -> t)
type GrateLike' g s a = (g a -> a) -> (g s -> s)
class (Traversable f, Applicative f) => Identical f

-- | The same functor, but with an <a>Applicative</a> instance that
--   performs actions in the reverse order.
data Backwards (f :: k -> Type) (a :: k)

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | <i>Deprecated: Renamed as <a>left</a>.</i>
lft :: (Applicative f, Traversable g) => AdapterLike f g (Either a r) (Either b r) a b

-- | <i>Deprecated: Renamed as <a>right</a>.</i>
rgt :: (Applicative f, Traversable g) => AdapterLike f g (Either r a) (Either r b) a b

-- | <i>Deprecated: Renamed as <a>just</a>.</i>
some :: (Applicative f, Traversable g) => AdapterLike f g (Maybe a) (Maybe b) a b

-- | <i>Deprecated: Renamed as <a>nothing</a>.</i>
none :: (Applicative f, Traversable g) => AdapterLike' f g (Maybe a) ()

-- | <i>Deprecated: Renamed as <a>left_</a>.</i>
lft_ :: Applicative f => LensLike f (Either a r) (Either b r) a b

-- | <i>Deprecated: Renamed as <a>right_</a>.</i>
rgt_ :: Applicative f => LensLike f (Either r a) (Either r b) a b

-- | <i>Deprecated: Renamed as <a>just_</a>.</i>
some_ :: Applicative f => LensLike f (Maybe a) (Maybe b) a b

-- | <i>Deprecated: Renamed as <a>nothing_</a>.</i>
none_ :: Applicative f => LensLike' f (Maybe a) ()
instance GHC.Base.Functor f => GHC.Base.Functor (Lens.Family.Stock.FromG e f)
instance Lens.Family.Phantom.Phantom g => Lens.Family.Phantom.Phantom (Lens.Family.Stock.FromG e g)
instance GHC.Base.Functor g => GHC.Base.Functor (Lens.Family.Stock.FromF i j g)
instance Lens.Family.Phantom.Phantom g => Lens.Family.Phantom.Phantom (Lens.Family.Stock.FromF i j g)
instance GHC.Base.Functor f => GHC.Base.Functor (Lens.Family.Stock.AlongsideRight f a)
instance Lens.Family.Phantom.Phantom f => Lens.Family.Phantom.Phantom (Lens.Family.Stock.AlongsideRight f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Lens.Family.Stock.AlongsideLeft f a)
instance Lens.Family.Phantom.Phantom f => Lens.Family.Phantom.Phantom (Lens.Family.Stock.AlongsideLeft f a)


-- | Lenses allow you to use fields of the state of a state monad as if
--   they were variables in an imperative language. <a>use</a> is used to
--   retrieve the value of a variable, and <a>.=</a> and <a>%=</a> allow
--   you to set and modify a variable. C-style compound assignments are
--   also provided.
module Lens.Family.State.Strict

-- | <pre>
--   zoom :: Monad m =&gt; Lens' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Lift a stateful operation on a field to a stateful operation on the
--   whole state. This is a good way to call a "subroutine" that only needs
--   access to part of the state.
--   
--   <pre>
--   zoom :: (Monad m, Monoid c) =&gt; Traversal' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Run the "subroutine" on each element of the traversal in turn and
--   <a>mconcat</a> all the results together.
--   
--   <pre>
--   zoom :: Monad m =&gt; Traversal' s a -&gt; StateT a m () -&gt; StateT s m ()
--   </pre>
--   
--   Run the "subroutine" on each element the traversal in turn.
zoom :: Monad m => LensLike' (Zooming m c) s a -> StateT a m c -> StateT s m c

-- | <pre>
--   use :: Monad m =&gt; Getter s t a b -&gt; StateT s m a
--   </pre>
--   
--   Retrieve a field of the state
--   
--   <pre>
--   use :: (Monad m, Monoid a) =&gt; Fold s t a b -&gt; StateT s m a
--   </pre>
--   
--   Retrieve a monoidal summary of all the referenced fields from the
--   state
use :: Monad m => FoldLike a s t a b -> StateT s m a

-- | <pre>
--   uses :: (Monad m, Monoid r) =&gt; Fold s t a b -&gt; (a -&gt; r) -&gt; StateT s m r
--   </pre>
--   
--   Retrieve all the referenced fields from the state and foldMap the
--   results together with <tt>f :: a -&gt; r</tt>.
--   
--   <pre>
--   uses :: Monad m =&gt; Getter s t a b -&gt; (a -&gt; r) -&gt; StateT s m r
--   </pre>
--   
--   Retrieve a field of the state and pass it through the function <tt>f
--   :: a -&gt; r</tt>.
--   
--   <pre>
--   uses l f = f &lt;$&gt; use l
--   </pre>
uses :: Monad m => FoldLike r s t a b -> (a -> r) -> StateT s m r

-- | Modify a field of the state.
(%=) :: Monad m => ASetter s s a b -> (a -> b) -> StateT s m ()
infix 4 %=

-- | Set a field of the state.
assign :: Monad m => ASetter s s a b -> b -> StateT s m ()

-- | Set a field of the state.
(.=) :: Monad m => ASetter s s a b -> b -> StateT s m ()
infix 4 .=

-- | <pre>
--   (%%=) :: Monad m =&gt; Lens s s a b -&gt; (a -&gt; (c, b)) -&gt; StateT s m c
--   </pre>
--   
--   Modify a field of the state while returning another value.
--   
--   <pre>
--   (%%=) :: (Monad m, Monoid c) =&gt; Traversal s s a b -&gt; (a -&gt; (c, b)) -&gt; StateT s m c
--   </pre>
--   
--   Modify each field of the state and return the <a>mconcat</a> of the
--   other values.
(%%=) :: Monad m => LensLike (Writer c) s s a b -> (a -> (c, b)) -> StateT s m c
infix 4 %%=

-- | Set a field of the state using the result of executing a stateful
--   command.
(<~) :: Monad m => ASetter s s a b -> StateT s m b -> StateT s m ()
infixr 2 <~
(+=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 +=
(-=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 -=
(*=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 *=
(//=) :: (Monad m, Fractional a) => ASetter' s a -> a -> StateT s m ()
infixr 4 //=
(&&=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 &&=
(||=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 ||=

-- | Monoidally append a value to all referenced fields of the state.
(<>=) :: (Monad m, Monoid a) => ASetter' s a -> a -> StateT s m ()
infixr 4 <>=

-- | Strictly modify a field of the state.
(%!=) :: Monad m => ASetter s s a b -> (a -> b) -> StateT s m ()
infix 4 %!=
(+!=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 +!=
(-!=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 -!=
(*!=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 *!=
(//!=) :: (Monad m, Fractional a) => ASetter' s a -> a -> StateT s m ()
infixr 4 //!=
(&&!=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 &&!=
(||!=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 ||!=
(<>!=) :: (Monad m, Monoid a) => ASetter' s a -> a -> StateT s m ()
infixr 4 <>!=
data Zooming m c a
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike' f s a = (a -> f a) -> (s -> f s)
type FoldLike r s t a b = LensLike (Constant r) s t a b

-- | Constant functor.
data Constant a (b :: k)
type ASetter s t a b = LensLike Identity s t a b
type ASetter' s a = LensLike' Identity s a

-- | Identity functor and monad. (a non-strict monad)
data Identity a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: Type -> Type) a

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity


-- | Lenses allow you to use fields of the state of a state monad as if
--   they were variables in an imperative language. <a>use</a> is used to
--   retrieve the value of a variable, and <a>.=</a> and <a>%=</a> allow
--   you to set and modify a variable. C-style compound assignments are
--   also provided.
module Lens.Family.State.Lazy

-- | <pre>
--   zoom :: Monad m =&gt; Lens' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Lift a stateful operation on a field to a stateful operation on the
--   whole state. This is a good way to call a "subroutine" that only needs
--   access to part of the state.
--   
--   <pre>
--   zoom :: (Monad m, Monoid c) =&gt; Traversal' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Run the "subroutine" on each element of the traversal in turn and
--   <a>mconcat</a> all the results together.
--   
--   <pre>
--   zoom :: Monad m =&gt; Traversal' s a -&gt; StateT a m () -&gt; StateT s m ()
--   </pre>
--   
--   Run the "subroutine" on each element the traversal in turn.
zoom :: Monad m => LensLike' (Zooming m c) s a -> StateT a m c -> StateT s m c

-- | <pre>
--   use :: Monad m =&gt; Getter s t a b -&gt; StateT s m a
--   </pre>
--   
--   Retrieve a field of the state
--   
--   <pre>
--   use :: (Monad m, Monoid a) =&gt; Fold s t a b -&gt; StateT s m a
--   </pre>
--   
--   Retrieve a monoidal summary of all the referenced fields from the
--   state
use :: Monad m => FoldLike a s t a b -> StateT s m a

-- | <pre>
--   uses :: (Monad m, Monoid r) =&gt; Fold s t a b -&gt; (a -&gt; r) -&gt; StateT s m r
--   </pre>
--   
--   Retrieve all the referenced fields from the state and foldMap the
--   results together with <tt>f :: a -&gt; r</tt>.
--   
--   <pre>
--   uses :: Monad m =&gt; Getter s t a b -&gt; (a -&gt; r) -&gt; StateT s m r
--   </pre>
--   
--   Retrieve a field of the state and pass it through the function <tt>f
--   :: a -&gt; r</tt>.
--   
--   <pre>
--   uses l f = f &lt;$&gt; use l
--   </pre>
uses :: Monad m => FoldLike r s t a b -> (a -> r) -> StateT s m r

-- | Modify a field of the state.
(%=) :: Monad m => ASetter s s a b -> (a -> b) -> StateT s m ()
infix 4 %=

-- | Set a field of the state.
assign :: Monad m => ASetter s s a b -> b -> StateT s m ()

-- | Set a field of the state.
(.=) :: Monad m => ASetter s s a b -> b -> StateT s m ()
infix 4 .=

-- | <pre>
--   (%%=) :: Monad m =&gt; Lens s s a b -&gt; (a -&gt; (c, b)) -&gt; StateT s m c
--   </pre>
--   
--   Modify a field of the state while returning another value.
--   
--   <pre>
--   (%%=) :: (Monad m, Monoid c) =&gt; Traversal s s a b -&gt; (a -&gt; (c, b)) -&gt; StateT s m c
--   </pre>
--   
--   Modify each field of the state and return the <a>mconcat</a> of the
--   other values.
(%%=) :: Monad m => LensLike (Writer c) s s a b -> (a -> (c, b)) -> StateT s m c
infix 4 %%=

-- | Set a field of the state using the result of executing a stateful
--   command.
(<~) :: Monad m => ASetter s s a b -> StateT s m b -> StateT s m ()
infixr 2 <~
(+=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 +=
(-=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 -=
(*=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 *=
(//=) :: (Monad m, Fractional a) => ASetter' s a -> a -> StateT s m ()
infixr 4 //=
(&&=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 &&=
(||=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 ||=

-- | Monoidally append a value to all referenced fields of the state.
(<>=) :: (Monad m, Monoid a) => ASetter' s a -> a -> StateT s m ()
infixr 4 <>=

-- | Strictly modify a field of the state.
(%!=) :: Monad m => ASetter s s a b -> (a -> b) -> StateT s m ()
infix 4 %!=
(+!=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 +!=
(-!=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 -!=
(*!=) :: (Monad m, Num a) => ASetter' s a -> a -> StateT s m ()
infixr 4 *!=
(//!=) :: (Monad m, Fractional a) => ASetter' s a -> a -> StateT s m ()
infixr 4 //!=
(&&!=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 &&!=
(||!=) :: Monad m => ASetter' s Bool -> Bool -> StateT s m ()
infixr 4 ||!=
(<>!=) :: (Monad m, Monoid a) => ASetter' s a -> a -> StateT s m ()
infixr 4 <>!=
data Zooming m c a
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike' f s a = (a -> f a) -> (s -> f s)
type FoldLike r s t a b = LensLike (Constant r) s t a b

-- | Constant functor.
data Constant a (b :: k)
type ASetter s t a b = LensLike Identity s t a b
type ASetter' s a = LensLike' Identity s a

-- | Identity functor and monad. (a non-strict monad)
data Identity a

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: Type -> Type) a

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

module Lens.Family.State


-- | This module is provided for "Haskell 2022" compatibility. If you are
--   able to use <tt>Rank2Types</tt>, I advise you to instead use the rank
--   2 aliases
--   
--   <ul>
--   <li><tt>Adapter</tt>, <tt>Adapter'</tt></li>
--   <li><tt>Prism</tt>, <tt>Prism'</tt></li>
--   <li><tt>Lens</tt>, <tt>Lens'</tt></li>
--   <li><tt>Traversal</tt>, <tt>Traversal'</tt></li>
--   <li><tt>Setter</tt>, <tt>Setter'</tt></li>
--   <li><tt>Grate</tt>, <tt>Grate'</tt></li>
--   <li><tt>Resetter</tt>, <tt>Resetter'</tt></li>
--   <li><tt>Grid</tt>, <tt>Grid'</tt></li>
--   <li><tt>Fold</tt>, <tt>Fold'</tt></li>
--   <li><tt>Getter</tt>, <tt>Getter'</tt></li>
--   <li><tt>Reviewer</tt>, <tt>Reviewer'</tt></li>
--   </ul>
--   
--   from the <tt>lens-family</tt> package instead.
--   
--   <a>cloneLens</a> allows one to circumvent the need for rank 2 types by
--   allowing one to take a universal monomorphic lens instance and
--   rederive a polymorphic instance. When you require a lens family
--   parameter you use the type <tt><a>ALens</a> s t a b</tt> (or
--   <tt><a>ALens'</a> s a</tt>). Then, inside a <tt>where</tt> clause, you
--   use <a>cloneLens</a> to create a <tt>Lens</tt> type.
--   
--   For example.
--   
--   <pre>
--   example :: ALens s t a b -&gt; Example
--   example l = ... x^.cl ... cl .~ y ...
--    where
--     cl x = cloneLens l x
--   </pre>
--   
--   <i>Note</i>: It is important to eta-expand the definition of
--   <tt>cl</tt> to avoid the dreaded monomorphism restriction.
--   
--   <a>cloneAdapter</a>, <a>cloneGrate</a>, <a>cloneTraversal</a>,
--   <a>cloneSetter</a>, <a>cloneResetter</a>, <a>cloneGetter</a>, and
--   <a>cloneFold</a> provides similar functionality for adapters, grates,
--   traversals, setters, resetters, getters, and folds respectively.
--   Unfortunately, it is not yet known how to clone prisms and grids.
--   
--   <i>Note</i>: Cloning is only need if you use a functional reference
--   multiple times with different instances.
module Lens.Family.Clone

-- | Converts a universal adapter instance back into a polymorphic adapter.
cloneAdapter :: (Functor f, Functor g) => AnAdapter s t a b -> AdapterLike f g s t a b

-- | Converts a universal lens instance back into a polymorphic lens.
cloneLens :: Functor f => ALens s t a b -> LensLike f s t a b

-- | Converts a universal grate instance back into a polymorphic grater.
cloneGrate :: Functor g => AGrate s t a b -> GrateLike g s t a b

-- | Converts a universal traversal instance back into a polymorphic
--   traversal.
cloneTraversal :: Applicative f => ATraversal s t a b -> LensLike f s t a b

-- | Converts a universal setter instance back into a polymorphic setter.
cloneSetter :: Identical f => ASetter s t a b -> LensLike f s t a b

-- | Converts a universal resetter instance back into a polymorphic
--   resetter.
cloneResetter :: Identical f => AResetter s t a b -> GrateLike f s t a b

-- | Converts a universal getter instance back into a polymorphic getter.
cloneGetter :: Phantom f => AGetter s t a b -> LensLike f s t a b

-- | Converts a universal fold instance back into a polymorphic fold.
cloneFold :: (Phantom f, Applicative f) => AFold s t a b -> LensLike f s t a b

-- | AnAdapter s t a b is a universal Adapter s t a b instance
type AnAdapter s t a b = AdapterLike (PStore (s -> a) b) ((->) s) s t a b

-- | AnAdapter' s a is a universal Adapter' s a instance
type AnAdapter' s a = AdapterLike' (PStore (s -> a) a) ((->) s) s a

-- | ALens s t a b is a universal Lens s t a b instance
type ALens s t a b = LensLike (PStore a b) s t a b

-- | ALens' s a is a universal Lens' s a instance
type ALens' s a = LensLike' (PStore a a) s a

-- | ATraversal s t a b is a universal Traversal s t a b instance
type ATraversal s t a b = LensLike (PKleeneStore a b) s t a b

-- | ATraversal' a b is a universal Traversal' a b instance
type ATraversal' s a = LensLike' (PKleeneStore a a) s a

-- | AGetter s t a b is a universal Getter s t a b instance
type AGetter s t a b = FoldLike a s t a b

-- | AGetter' s a is a universal Getter' s a instance
type AGetter' s a = FoldLike' a s a

-- | AFold s t a b is a universal Fold s t a b instance
type AFold s t a b = FoldLike [a] s t a b

-- | AFold' s a is a universal Fold' s a instance
type AFold' s a = FoldLike' [a] s a
data PStore i j a
data PKleeneStore i j a
type LensLike f s t a b = (a -> f b) -> (s -> f t)
type LensLike' f s a = (a -> f a) -> (s -> f s)
type GrateLike g s t a b = (g a -> b) -> (g s -> t)
type GrateLike' g s a = (g a -> a) -> (g s -> s)
type FoldLike r s t a b = LensLike (Constant r) s t a b
type FoldLike' r s a = LensLike' (Constant r) s a
type AGrate s t a b = GrateLike (PCont b a) s t a b
type ASetter s t a b = LensLike Identity s t a b
type AResetter s t a b = GrateLike Identity s t a b
class Functor f => Phantom f
class (Traversable f, Applicative f) => Identical f
instance GHC.Base.Functor (Lens.Family.Clone.PKleeneStore i j)
instance GHC.Base.Applicative (Lens.Family.Clone.PKleeneStore i j)
instance GHC.Base.Functor (Lens.Family.Clone.PStore i j)
