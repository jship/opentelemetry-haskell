-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | JSON logging using monad-logger interface
--   
--   <tt>monad-logger-aeson</tt> provides structured JSON logging using
--   <tt>monad-logger</tt>'s interface.
--   
--   Specifically, it is intended to be a (largely) drop-in replacement for
--   <tt>monad-logger</tt>'s <a>Control.Monad.Logger.CallStack</a> module.
@package monad-logger-aeson
@version 0.4.0.3

module Control.Monad.Logger.Aeson.Internal

-- | A <a>Message</a> captures a textual component and a metadata
--   component. The metadata component is a list of <a>SeriesElem</a> to
--   support tacking on arbitrary structured data to a log message.
--   
--   With the <tt>OverloadedStrings</tt> extension enabled, <a>Message</a>
--   values can be constructed without metadata fairly conveniently, just
--   as if we were using <a>Text</a> directly:
--   
--   <pre>
--   logDebug "Some log message without metadata"
--   </pre>
--   
--   Metadata may be included in a <a>Message</a> via the <a>:#</a>
--   constructor:
--   
--   <pre>
--   <a>logDebug</a> $ "Some log message with metadata" <a>:#</a>
--     [ "bloorp" <a>.=</a> (42 :: <a>Int</a>)
--     , "bonk" <a>.=</a> ("abc" :: <a>Text</a>)
--     ]
--   </pre>
--   
--   The mnemonic for the <a>:#</a> constructor is that the <tt>#</tt>
--   symbol is sometimes referred to as a hash, a JSON object can be
--   thought of as a hash map, and so with <tt>:#</tt> (and enough
--   squinting), we are <tt>cons</tt>-ing a textual message onto a JSON
--   object. Yes, this mnemonic isn't well-typed, but hopefully it still
--   helps!
data Message
(:#) :: Text -> [SeriesElem] -> Message
infixr 5 :#

-- | A single key-value pair, where the value is encoded JSON. This is a
--   more restricted version of <a>Series</a>: a <a>SeriesElem</a> is
--   intended to encapsulate exactly one key-value pair, whereas a
--   <a>Series</a> encapsulates zero or more key-value pairs.
--   <a>SeriesElem</a> values can be created via <a>(.=)</a> from
--   <tt>aeson</tt>.
--   
--   While a <a>SeriesElem</a> most often will map to a single pair, note
--   that a <a>Semigroup</a> instance is available for performance's sake.
--   The <a>Semigroup</a> instance is useful when multiple pairs are
--   grouped together and then shared across multiple logging calls. In
--   that case, the cost of combining the pairs in the group must only be
--   paid once.
newtype SeriesElem
UnsafeSeriesElem :: Series -> SeriesElem
[unSeriesElem] :: SeriesElem -> Series

-- | This type is the Haskell representation of each JSON log message
--   produced by this library.
--   
--   While we never interact with this type directly when logging messages
--   with <tt>monad-logger-aeson</tt>, we may wish to use this type if we
--   are parsing/processing log files generated by this library.
data LoggedMessage
LoggedMessage :: UTCTime -> LogLevel -> Maybe Loc -> Maybe LogSource -> KeyMap Value -> Text -> KeyMap Value -> LoggedMessage
[loggedMessageTimestamp] :: LoggedMessage -> UTCTime
[loggedMessageLevel] :: LoggedMessage -> LogLevel
[loggedMessageLoc] :: LoggedMessage -> Maybe Loc
[loggedMessageLogSource] :: LoggedMessage -> Maybe LogSource
[loggedMessageThreadContext] :: LoggedMessage -> KeyMap Value
[loggedMessageText] :: LoggedMessage -> Text
[loggedMessageMeta] :: LoggedMessage -> KeyMap Value

-- | Thread-safe, global <a>Store</a> that captures the thread context of
--   messages.
--   
--   Note that there is a bit of somewhat unavoidable name-overloading
--   here: this binding is called <a>threadContextStore</a> because it
--   stores the thread context (i.e. <tt>ThreadContext</tt>/<tt>MDC</tt>
--   from Java land) for messages. It also just so happens that the
--   <a>Store</a> type comes from the <tt>context</tt> package, which is a
--   package providing thread-indexed storage of arbitrary context values.
--   Please don't hate the player!
threadContextStore :: Store (KeyMap Value)
logCS :: MonadLogger m => CallStack -> LogSource -> LogLevel -> Message -> m ()

-- | <a>OutputOptions</a> is for use with <a>defaultOutputWith</a> and
--   enables us to configure the JSON output produced by this library.
--   
--   We can get a hold of a value of this type via
--   <a>defaultOutputOptions</a>.
data OutputOptions
OutputOptions :: (LogLevel -> ByteString -> IO ()) -> Bool -> [Pair] -> OutputOptions
[outputAction] :: OutputOptions -> LogLevel -> ByteString -> IO ()

-- | Controls whether or not the thread ID is included in each log
--   message's thread context.
--   
--   Default: <a>False</a>
[outputIncludeThreadId] :: OutputOptions -> Bool

-- | Allows for setting a "base" thread context, i.e. a set of <a>Pair</a>
--   that will always be present in log messages.
--   
--   If we subsequently use <a>withThreadContext</a> to register some
--   thread context for our messages, if any of the keys in those
--   <a>Pair</a> values overlap with the "base" thread context, then the
--   overlapped <a>Pair</a> values in the "base" thread context will be
--   overridden for the duration of the action provided to
--   <a>withThreadContext</a>.
--   
--   Default: <a>mempty</a>
[outputBaseThreadContext] :: OutputOptions -> [Pair]
defaultLogStrBS :: UTCTime -> KeyMap Value -> Loc -> LogSource -> LogLevel -> LogStr -> ByteString
defaultLogStrLBS :: UTCTime -> KeyMap Value -> Loc -> LogSource -> LogLevel -> LogStr -> ByteString
messageEncoding :: Message -> Encoding
messageSeries :: Message -> Series
data LogItem
LogItem :: UTCTime -> Loc -> LogSource -> LogLevel -> KeyMap Value -> Encoding -> LogItem
[logItemTimestamp] :: LogItem -> UTCTime
[logItemLoc] :: LogItem -> Loc
[logItemLogSource] :: LogItem -> LogSource
[logItemLevel] :: LogItem -> LogLevel
[logItemThreadContext] :: LogItem -> KeyMap Value
[logItemMessageEncoding] :: LogItem -> Encoding
logItemEncoding :: LogItem -> Encoding
pairsEncoding :: [Pair] -> Encoding
pairsSeries :: [Pair] -> Series
levelEncoding :: LogLevel -> Encoding
locEncoding :: Loc -> Encoding

-- | Not exported from 'monad-logger', so copied here.
mkLoggerLoc :: SrcLoc -> Loc

-- | Not exported from 'monad-logger', so copied here.
locFromCS :: CallStack -> Loc

-- | Not exported from 'monad-logger', so copied here.
isDefaultLoc :: Loc -> Bool
data Key

-- | A map from JSON key type <a>Key</a> to <tt>v</tt>.
data KeyMap v
emptyKeyMap :: KeyMap v
keyMapFromList :: [(Key, v)] -> KeyMap v
keyMapToList :: KeyMap v -> [(Key, v)]
keyMapInsert :: Key -> v -> KeyMap v -> KeyMap v
keyMapUnion :: KeyMap v -> KeyMap v -> KeyMap v
instance GHC.Show.Show Control.Monad.Logger.Aeson.Internal.LoggedMessage
instance GHC.Classes.Ord Control.Monad.Logger.Aeson.Internal.LoggedMessage
instance GHC.Generics.Generic Control.Monad.Logger.Aeson.Internal.LoggedMessage
instance GHC.Classes.Eq Control.Monad.Logger.Aeson.Internal.LoggedMessage
instance Data.Aeson.Types.ToJSON.KeyValue Control.Monad.Logger.Aeson.Internal.SeriesElem
instance GHC.Base.Semigroup Control.Monad.Logger.Aeson.Internal.SeriesElem
instance Data.Aeson.Types.ToJSON.ToJSON Control.Monad.Logger.Aeson.Internal.LoggedMessage
instance Data.String.IsString Control.Monad.Logger.Aeson.Internal.Message
instance System.Log.FastLogger.LogStr.ToLogStr Control.Monad.Logger.Aeson.Internal.Message
instance Data.Aeson.Types.FromJSON.FromJSON Control.Monad.Logger.Aeson.Internal.LoggedMessage

module Control.Monad.Logger.Aeson

-- | A <a>Message</a> captures a textual component and a metadata
--   component. The metadata component is a list of <a>SeriesElem</a> to
--   support tacking on arbitrary structured data to a log message.
--   
--   With the <tt>OverloadedStrings</tt> extension enabled, <a>Message</a>
--   values can be constructed without metadata fairly conveniently, just
--   as if we were using <a>Text</a> directly:
--   
--   <pre>
--   logDebug "Some log message without metadata"
--   </pre>
--   
--   Metadata may be included in a <a>Message</a> via the <a>:#</a>
--   constructor:
--   
--   <pre>
--   <a>logDebug</a> $ "Some log message with metadata" <a>:#</a>
--     [ "bloorp" <a>.=</a> (42 :: <a>Int</a>)
--     , "bonk" <a>.=</a> ("abc" :: <a>Text</a>)
--     ]
--   </pre>
--   
--   The mnemonic for the <a>:#</a> constructor is that the <tt>#</tt>
--   symbol is sometimes referred to as a hash, a JSON object can be
--   thought of as a hash map, and so with <tt>:#</tt> (and enough
--   squinting), we are <tt>cons</tt>-ing a textual message onto a JSON
--   object. Yes, this mnemonic isn't well-typed, but hopefully it still
--   helps!
data Message
(:#) :: Text -> [SeriesElem] -> Message
infixr 5 :#

-- | A single key-value pair, where the value is encoded JSON. This is a
--   more restricted version of <a>Series</a>: a <a>SeriesElem</a> is
--   intended to encapsulate exactly one key-value pair, whereas a
--   <a>Series</a> encapsulates zero or more key-value pairs.
--   <a>SeriesElem</a> values can be created via <a>(.=)</a> from
--   <tt>aeson</tt>.
--   
--   While a <a>SeriesElem</a> most often will map to a single pair, note
--   that a <a>Semigroup</a> instance is available for performance's sake.
--   The <a>Semigroup</a> instance is useful when multiple pairs are
--   grouped together and then shared across multiple logging calls. In
--   that case, the cost of combining the pairs in the group must only be
--   paid once.
data SeriesElem

-- | This type is the Haskell representation of each JSON log message
--   produced by this library.
--   
--   While we never interact with this type directly when logging messages
--   with <tt>monad-logger-aeson</tt>, we may wish to use this type if we
--   are parsing/processing log files generated by this library.
data LoggedMessage
LoggedMessage :: UTCTime -> LogLevel -> Maybe Loc -> Maybe LogSource -> KeyMap Value -> Text -> KeyMap Value -> LoggedMessage
[loggedMessageTimestamp] :: LoggedMessage -> UTCTime
[loggedMessageLevel] :: LoggedMessage -> LogLevel
[loggedMessageLoc] :: LoggedMessage -> Maybe Loc
[loggedMessageLogSource] :: LoggedMessage -> Maybe LogSource
[loggedMessageThreadContext] :: LoggedMessage -> KeyMap Value
[loggedMessageText] :: LoggedMessage -> Text
[loggedMessageMeta] :: LoggedMessage -> KeyMap Value

-- | Logs a <a>Message</a> with the location provided by an implicit
--   <a>CallStack</a>.
logDebug :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebug</a>
logInfo :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebug</a>
logWarn :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebug</a>
logError :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebug</a>
logOther :: (HasCallStack, MonadLogger m) => LogLevel -> Message -> m ()

-- | Logs a <a>Message</a> with location given by <a>CallStack</a>.
logDebugCS :: MonadLogger m => CallStack -> Message -> m ()

-- | See <a>logDebugCS</a>
logInfoCS :: MonadLogger m => CallStack -> Message -> m ()

-- | See <a>logDebugCS</a>
logWarnCS :: MonadLogger m => CallStack -> Message -> m ()

-- | See <a>logDebugCS</a>
logErrorCS :: MonadLogger m => CallStack -> Message -> m ()

-- | See <a>logDebugCS</a>
logOtherCS :: MonadLogger m => CallStack -> LogLevel -> Message -> m ()

-- | See <a>logDebugCS</a>
logDebugNS :: (HasCallStack, MonadLogger m) => LogSource -> Message -> m ()

-- | See <a>logDebugNS</a>
logInfoNS :: (HasCallStack, MonadLogger m) => LogSource -> Message -> m ()

-- | See <a>logDebugNS</a>
logWarnNS :: (HasCallStack, MonadLogger m) => LogSource -> Message -> m ()

-- | See <a>logDebugNS</a>
logErrorNS :: (HasCallStack, MonadLogger m) => LogSource -> Message -> m ()

-- | See <a>logDebugNS</a>
logOtherNS :: (HasCallStack, MonadLogger m) => LogSource -> LogLevel -> Message -> m ()

-- | See <a>logDebug</a>.
--   
--   This is an alias for <a>logDebug</a> and is provided mainly for
--   symmetry with <tt>monad-logger</tt>.
logDebugN :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebugN</a>
logInfoN :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebugN</a>
logWarnN :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebugN</a>
logErrorN :: (HasCallStack, MonadLogger m) => Message -> m ()

-- | See <a>logDebugN</a>
logOtherN :: (HasCallStack, MonadLogger m) => LogLevel -> Message -> m ()

-- | This function lets us register structured, contextual info for the
--   duration of the provided action. All messages logged within the
--   provided action will automatically include this contextual info. This
--   function is thread-safe, as the contextual info is scoped to the
--   calling thread only.
--   
--   This function is additive: if we nest calls to it, each nested call
--   will add to the existing thread context. In the case of overlapping
--   keys, the nested call's <a>Pair</a> value(s) will win. Whenever the
--   inner action completes, the thread context is rolled back to its value
--   set in the enclosing action.
--   
--   If we wish to include the existing thread context from one thread in
--   another thread, we must register the thread context explicitly on that
--   other thread. <a>myThreadContext</a> can be leveraged in this case.
--   
--   Registering thread context for messages can be useful in many
--   scenarios. One particularly apt scenario is in <tt>wai</tt>
--   middlewares. We can generate an ID for each incoming request then
--   include it in the thread context. Now all messages subsequently logged
--   from our endpoint handler will automatically include that request ID:
--   
--   <pre>
--   import Control.Monad.Logger.Aeson ((.=), withThreadContext)
--   import Network.Wai (Middleware)
--   import qualified Data.UUID.V4 as UUID
--   
--   addRequestId :: Middleware
--   addRequestId app = \request sendResponse -&gt; do
--     uuid &lt;- UUID.nextRandom
--     withThreadContext ["requestId" .= uuid] do
--       app request sendResponse
--   </pre>
--   
--   If we're coming from a Java background, it may be helpful for us to
--   draw parallels between this function and <tt>log4j2</tt>'s
--   <tt>ThreadContext</tt> (or perhaps <tt>log4j</tt>'s <tt>MDC</tt>).
--   They all enable the same thing: setting some thread-local info that
--   will be automatically pulled into each logged message.
withThreadContext :: (MonadIO m, MonadMask m) => [Pair] -> m a -> m a

-- | This function lets us retrieve the calling thread's thread context.
--   For more detail, we can consult the docs for <a>withThreadContext</a>.
--   
--   Note that even though the type signature lists <a>MonadThrow</a> as a
--   required constraint, the library guarantees that
--   <a>myThreadContext</a> will never throw.
myThreadContext :: (MonadIO m, MonadThrow m) => m (KeyMap Value)

-- | Run a block using a <a>MonadLogger</a> instance which appends to the
--   specified file.
--   
--   Note that this differs from the <tt>monad-logger</tt> version in its
--   constraints. We use the <tt>exceptions</tt> package's <a>MonadMask</a>
--   here for bracketing, rather than <tt>monad-control</tt>.
runFileLoggingT :: (MonadIO m, MonadMask m) => FilePath -> LoggingT m a -> m a

-- | Run a block using a <a>MonadLogger</a> instance which prints to a
--   <a>Handle</a> determined by the log message's <a>LogLevel</a>.
--   
--   A common use case for this function is to log warn/error messages to
--   <a>stderr</a> and debug/info messages to <a>stdout</a> in CLIs/tools
--   (see <a>defaultHandleFromLevel</a>).
runHandleLoggingT :: (LogLevel -> Handle) -> LoggingT m a -> m a

-- | Run a block using a <a>MonadLogger</a> instance which prints to
--   <a>stdout</a>.
runStdoutLoggingT :: LoggingT m a -> m a

-- | Run a block using a <a>MonadLogger</a> instance which prints to
--   <a>stderr</a>.
runStderrLoggingT :: LoggingT m a -> m a

-- | Run a block using a <a>MonadLogger</a> instance which appends to the
--   specified <a>LoggerSet</a>.
runFastLoggingT :: LoggerSet -> LoggingT m a -> m a

-- | A default implementation of the action that backs the
--   <a>monadLoggerLog</a> function. It accepts a file handle as the first
--   argument and will log incoming <a>LogStr</a> values wrapped in the
--   JSON structure prescribed by this library.
--   
--   This is used in the definition of <a>runStdoutLoggingT</a> and
--   <a>runStderrLoggingT</a>:
--   
--   <pre>
--   <a>runStdoutLoggingT</a> :: <a>LoggingT</a> m a -&gt; m a
--   <a>runStdoutLoggingT</a> = <a>flip</a> <a>runLoggingT</a> (<a>defaultOutput</a> <a>stdout</a>)
--   </pre>
--   
--   We can instead use <a>defaultOutputWith</a> if we need more control of
--   the output.
defaultOutput :: Handle -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | An implementation of the action that backs the <a>monadLoggerLog</a>
--   function, where the <a>Handle</a> destination for each log message is
--   determined by the log message's <a>LogLevel</a>. This function will
--   log incoming <a>LogStr</a> values wrapped in the JSON structure
--   prescribed by this library.
--   
--   This is used in the definition of <a>runHandleLoggingT</a>:
--   
--   <pre>
--   <a>runHandleLoggingT</a> :: (<a>LogLevel</a> -&gt; <a>Handle</a>) -&gt; <a>LoggingT</a> m a -&gt; m a
--   <a>runHandleLoggingT</a> = <a>flip</a> <a>runLoggingT</a> . <a>handleOutput</a>
--   </pre>
handleOutput :: (LogLevel -> Handle) -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | An implementation of the action that backs the <a>monadLoggerLog</a>
--   function, where log messages are written to a provided
--   <a>LoggerSet</a>. This function will log incoming <a>LogStr</a> values
--   wrapped in the JSON structure prescribed by this library.
--   
--   This is used in the definition of <a>runFastLoggingT</a>:
--   
--   <pre>
--   <a>runFastLoggingT</a> :: <a>LoggerSet</a> -&gt; <a>LoggingT</a> m a -&gt; m a
--   <a>runFastLoggingT</a> loggerSet = <a>flip</a> <a>runLoggingT</a> (<a>fastLoggerOutput</a> loggerSet)
--   </pre>
fastLoggerOutput :: LoggerSet -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | This function is a lower-level helper for implementing the action that
--   backs the <a>monadLoggerLog</a> function.
--   
--   We should generally prefer <a>defaultOutput</a> over this function,
--   but this function is available if we do need more control over our
--   output.
defaultOutputWith :: OutputOptions -> Loc -> LogSource -> LogLevel -> LogStr -> IO ()

-- | Given an output action for log messages, this function will produce
--   the default recommended <a>OutputOptions</a>.
--   
--   Specific options can be overriden via record update syntax using
--   <a>outputIncludeThreadId</a>, <a>outputBaseThreadContext</a>, and
--   friends.
defaultOutputOptions :: (LogLevel -> ByteString -> IO ()) -> OutputOptions

-- | <a>OutputOptions</a> is for use with <a>defaultOutputWith</a> and
--   enables us to configure the JSON output produced by this library.
--   
--   We can get a hold of a value of this type via
--   <a>defaultOutputOptions</a>.
data OutputOptions

-- | Controls whether or not the thread ID is included in each log
--   message's thread context.
--   
--   Default: <a>False</a>
outputIncludeThreadId :: OutputOptions -> Bool

-- | Allows for setting a "base" thread context, i.e. a set of <a>Pair</a>
--   that will always be present in log messages.
--   
--   If we subsequently use <a>withThreadContext</a> to register some
--   thread context for our messages, if any of the keys in those
--   <a>Pair</a> values overlap with the "base" thread context, then the
--   overlapped <a>Pair</a> values in the "base" thread context will be
--   overridden for the duration of the action provided to
--   <a>withThreadContext</a>.
--   
--   Default: <a>mempty</a>
outputBaseThreadContext :: OutputOptions -> [Pair]

defaultLogStr :: UTCTime -> KeyMap Value -> Loc -> LogSource -> LogLevel -> LogStr -> LogStr

-- | This function maps the possible <a>LogLevel</a> values to
--   <a>Handle</a> values. Specifically, <a>LevelDebug</a> and
--   <a>LevelInfo</a> map to <a>stdout</a>, while <a>LevelWarn</a> and
--   <a>LevelError</a> map to <a>stderr</a>. The function is most useful
--   for CLIs/tools (see <a>runHandleLoggingT</a>).
--   
--   The input function discriminating <a>Text</a> is used to determine the
--   <a>Handle</a> mapping for <a>LevelOther</a>. For example, if we wish
--   for all <a>LevelOther</a> messages to be logged to <a>stderr</a>, we
--   can supply <tt>(const stderr)</tt> as the value for this input
--   function.
defaultHandleFromLevel :: (Text -> Handle) -> LogLevel -> Handle
(.=) :: (KeyValue kv, ToJSON v) => Key -> v -> kv
infixr 8 .=

-- | Converting <a>LogStr</a> to <a>ByteString</a>.
fromLogStr :: LogStr -> ByteString

-- | Log message builder. Use (<a>&lt;&gt;</a>) to append two LogStr in
--   O(1).
data LogStr

-- | Types that can be converted to a <a>LogStr</a>. Instances for types
--   from the <tt>text</tt> library use a UTF-8 encoding. Instances for
--   numerical types use a decimal encoding.
class ToLogStr msg
toLogStr :: ToLogStr msg => msg -> LogStr

-- | dummy location, used with <a>logWithoutLoc</a>
defaultLoc :: Loc

-- | Map the unwrapped computation using the given function.
mapNoLoggingT :: (m a -> n b) -> NoLoggingT m a -> NoLoggingT n b

-- | Map the unwrapped computation using the given function.
mapLoggingT :: (m a -> n b) -> LoggingT m a -> LoggingT n b

-- | Only log messages passing the given predicate function.
--   
--   This can be a convenient way, for example, to ignore debug level
--   messages.
filterLogger :: forall (m :: Type -> Type) a. (LogSource -> LogLevel -> Bool) -> LoggingT m a -> LoggingT m a

-- | Within the <a>LoggingT</a> monad, capture all log messages to a
--   bounded channel of the indicated size, and only actually log them if
--   there is an exception.
withChannelLogger :: forall (m :: Type -> Type) a. (MonadBaseControl IO m, MonadIO m) => Int -> LoggingT m a -> LoggingT m a

-- | Read logging tuples from an unbounded channel and log them into a
--   <a>MonadLoggerIO</a> monad, forever.
--   
--   For use in a dedicated thread with a channel fed by
--   <a>runChanLoggingT</a>.
unChanLoggingT :: (MonadLogger m, MonadIO m) => Chan LogLine -> m void

-- | Run a block using a <tt>MonadLogger</tt> instance which writes tuples
--   to an unbounded channel.
--   
--   The tuples can be extracted (ie. in another thread) with
--   <a>unChanLoggingT</a> or a custom extraction funtion, and written to a
--   destination.
runChanLoggingT :: MonadIO m => Chan LogLine -> LoggingT m a -> m a

-- | Run a block using a <tt>MonadLogger</tt> instance. Return logs in a
--   list | @since 0.3.28
execWriterLoggingT :: Functor m => WriterLoggingT m a -> m [LogLine]

-- | Run a block using a <tt>MonadLogger</tt> instance. Return a value and
--   logs in a list | @since 0.3.28
runWriterLoggingT :: Functor m => WriterLoggingT m a -> m (a, [LogLine])

-- | Generates a function that takes a <a>LogSource</a>, a level name and a
--   <a>Text</a> and logs a <a>LevelOther</a> message. Usage:
--   
--   <pre>
--   $logOtherS "SomeSource" "My new level" "This is a log message"
--   </pre>
logOtherS :: Q Exp

-- | See <a>logDebugS</a>
logErrorS :: Q Exp

-- | See <a>logDebugS</a>
logWarnS :: Q Exp

-- | See <a>logDebugS</a>
logInfoS :: Q Exp

-- | Generates a function that takes a <a>LogSource</a> and <a>Text</a> and
--   logs a <a>LevelDebug</a> message. Usage:
--   
--   <pre>
--   $logDebugS "SomeSource" "This is a debug log message"
--   </pre>
logDebugS :: Q Exp

-- | Lift a location into an Exp.
liftLoc :: Loc -> Q Exp

-- | Generates a function that takes a 'Show a =&gt; a' and logs a
--   <a>LevelOther</a> message. Usage:
--   
--   <pre>
--   $(logOtherSH "My new level") "This is a log message"
--   </pre>
logOtherSH :: Text -> Q Exp

-- | See <a>logDebugSH</a>
logErrorSH :: Q Exp

-- | See <a>logDebugSH</a>
logWarnSH :: Q Exp

-- | See <a>logDebugSH</a>
logInfoSH :: Q Exp

-- | Generates a function that takes a 'Show a =&gt; a' and logs a
--   <a>LevelDebug</a> message. Usage:
--   
--   <pre>
--   $(logDebugSH) (Just "This is a debug log message")
--   </pre>
logDebugSH :: Q Exp
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel
type LogSource = Text

-- | A <tt>Monad</tt> which has the ability to log messages in some manner.
class Monad m => MonadLogger (m :: Type -> Type)
monadLoggerLog :: (MonadLogger m, ToLogStr msg) => Loc -> LogSource -> LogLevel -> msg -> m ()

-- | An extension of <tt>MonadLogger</tt> for the common case where the
--   logging action is a simple <tt>IO</tt> action. The advantage of using
--   this typeclass is that the logging function itself can be extracted as
--   a first-class value, which can make it easier to manipulate monad
--   transformer stacks, as an example.
class (MonadLogger m, MonadIO m) => MonadLoggerIO (m :: Type -> Type)

-- | Request the logging function itself.
askLoggerIO :: MonadLoggerIO m => m (Loc -> LogSource -> LogLevel -> LogStr -> IO ())

-- | Monad transformer that disables logging.
newtype NoLoggingT (m :: Type -> Type) a
NoLoggingT :: m a -> NoLoggingT (m :: Type -> Type) a
[runNoLoggingT] :: NoLoggingT (m :: Type -> Type) a -> m a

type LogLine = (Loc, LogSource, LogLevel, LogStr)

newtype WriterLoggingT (m :: Type -> Type) a
WriterLoggingT :: m (a, DList LogLine) -> WriterLoggingT (m :: Type -> Type) a
[unWriterLoggingT] :: WriterLoggingT (m :: Type -> Type) a -> m (a, DList LogLine)

-- | Monad transformer that adds a new logging function.
newtype LoggingT (m :: Type -> Type) a
LoggingT :: ((Loc -> LogSource -> LogLevel -> LogStr -> IO ()) -> m a) -> LoggingT (m :: Type -> Type) a
[runLoggingT] :: LoggingT (m :: Type -> Type) a -> (Loc -> LogSource -> LogLevel -> LogStr -> IO ()) -> m a
data Loc
Loc :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
