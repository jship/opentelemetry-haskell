<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">{-
(c) The University of Glasgow 2011

-}</span><span>
</span><span id="line-5"></span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span class="hs-comment">-- | The deriving code for the Functor, Foldable, and Traversable classes</span><span>
</span><span id="line-13"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">GHC.Tc.Deriv.Functor</span><span>
</span><span id="line-14"></span><span>   </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier">FFoldType</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span>   </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#functorLikeTraverse"><span class="hs-identifier">functorLikeTraverse</span></a></span><span>
</span><span id="line-16"></span><span>   </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#deepSubtypesContaining"><span class="hs-identifier">deepSubtypesContaining</span></a></span><span>
</span><span id="line-17"></span><span>   </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier">foldDataConArgs</span></a></span><span>
</span><span id="line-18"></span><span>
</span><span id="line-19"></span><span>   </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Functor_binds"><span class="hs-identifier">gen_Functor_binds</span></a></span><span>
</span><span id="line-20"></span><span>   </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Foldable_binds"><span class="hs-identifier">gen_Foldable_binds</span></a></span><span>
</span><span id="line-21"></span><span>   </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Traversable_binds"><span class="hs-identifier">gen_Traversable_binds</span></a></span><span>
</span><span id="line-22"></span><span>   </span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span class="hs-keyword">where</span><span class="hs-cpp">

#include &quot;HsVersions.h&quot;
</span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span>
</span><span id="line-30"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html"><span class="hs-identifier">GHC.Core.DataCon</span></a></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html"><span class="hs-identifier">GHC.Data.FastString</span></a></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.html"><span class="hs-identifier">GHC.Hs</span></a></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Panic.html"><span class="hs-identifier">GHC.Utils.Panic</span></a></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Builtin.Names.html"><span class="hs-identifier">GHC.Builtin.Names</span></a></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html"><span class="hs-identifier">GHC.Types.Name.Reader</span></a></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html"><span class="hs-identifier">GHC.Utils.Monad.State</span></a></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Generate.html"><span class="hs-identifier">GHC.Tc.Deriv.Generate</span></a></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Utils.TcType.html"><span class="hs-identifier">GHC.Tc.Utils.TcType</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html"><span class="hs-identifier">GHC.Core.TyCon</span></a></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html"><span class="hs-identifier">GHC.Core.TyCo.Rep</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Misc.html"><span class="hs-identifier">GHC.Utils.Misc</span></a></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.html"><span class="hs-identifier">GHC.Types.Var</span></a></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.Set.html"><span class="hs-identifier">GHC.Types.Var.Set</span></a></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Id.Make.html"><span class="hs-identifier">GHC.Types.Id.Make</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Id.Make.html#coerceId"><span class="hs-identifier">coerceId</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Builtin.Types.html"><span class="hs-identifier">GHC.Builtin.Types</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Builtin.Types.html#true_RDR"><span class="hs-identifier">true_RDR</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Builtin.Types.html#false_RDR"><span class="hs-identifier">false_RDR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Maybe.html#"><span class="hs-identifier">Data.Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Maybe.html#catMaybes"><span class="hs-identifier">catMaybes</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Maybe.html#isJust"><span class="hs-identifier">isJust</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                        Functor instances

 see http://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html

*                                                                      *
************************************************************************

For the data type:

  data T a = T1 Int a | T2 (T a)

We generate the instance:

  instance Functor T where
      fmap f (T1 b1 a) = T1 b1 (f a)
      fmap f (T2 ta)   = T2 (fmap f ta)

Notice that we don't simply apply 'fmap' to the constructor arguments.
Rather
  - Do nothing to an argument whose type doesn't mention 'a'
  - Apply 'f' to an argument of type 'a'
  - Apply 'fmap f' to other arguments
That's why we have to recurse deeply into the constructor argument types,
rather than just one level, as we typically do.

What about types with more than one type parameter?  In general, we only
derive Functor for the last position:

  data S a b = S1 [b] | S2 (a, T a b)
  instance Functor (S a) where
    fmap f (S1 bs)    = S1 (fmap f bs)
    fmap f (S2 (p,q)) = S2 (a, fmap f q)

However, we have special cases for
         - tuples
         - functions

More formally, we write the derivation of fmap code over type variable
'a for type 'b as ($fmap 'a 'b x).  In this general notation the derived
instance for T is:

  instance Functor T where
      fmap f (T1 x1 x2) = T1 ($(fmap 'a 'b1) x1) ($(fmap 'a 'a) x2)
      fmap f (T2 x1)    = T2 ($(fmap 'a '(T a)) x1)

  $(fmap 'a 'b x)          = x     -- when b does not contain a
  $(fmap 'a 'a x)          = f x
  $(fmap 'a '(b1,b2) x)    = case x of (x1,x2) -&gt; ($(fmap 'a 'b1 x1), $(fmap 'a 'b2 x2))
  $(fmap 'a '(T b1 a) x)   = fmap f x -- when a only occurs directly as the last argument of T
  $(fmap 'a '(T b1 b2) x)  = fmap (\y. $(fmap 'a 'b2 y)) x -- when a only occurs in the last parameter, b2
  $(fmap 'a '(tb -&gt; tc) x) = \(y:tb[b/a]) -&gt; $(fmap 'a' 'tc' (x $(cofmap 'a 'tb y)))

For functions, the type parameter 'a can occur in a contravariant position,
which means we need to derive a function like:

  cofmap :: (a -&gt; b) -&gt; (f b -&gt; f a)

This is pretty much the same as $fmap, only without the $(cofmap 'a 'a x) and
$(cofmap 'a '(T b1 a) x) cases:

  $(cofmap 'a 'b x)          = x     -- when b does not contain a
  $(cofmap 'a 'a x)          = error &quot;type variable in contravariant position&quot;
  $(cofmap 'a '(b1,b2) x)    = case x of (x1,x2) -&gt; ($(cofmap 'a 'b1) x1, $(cofmap 'a 'b2) x2)
  $(cofmap 'a '(T b1 a) x)   = error &quot;type variable in contravariant position&quot; -- when a only occurs directly as the last argument of T
  $(cofmap 'a '(T b1 b2) x)  = fmap (\y. $(cofmap 'a 'b2 y)) x -- when a only occurs in the last parameter, b2
  $(cofmap 'a '(tb -&gt; tc) x) = \(y:tb[b/a]) -&gt; $(cofmap 'a' 'tc' (x $(fmap 'a 'tb y)))

Note that the code produced by $(fmap _ _ _) is always a higher order function,
with type `(a -&gt; b) -&gt; (g a -&gt; g b)` for some g.

Note that there are two distinct cases in $fmap (and $cofmap) that match on an
application of some type constructor T (where T is not a tuple type
constructor):

  $(fmap 'a '(T b1 a) x)  = fmap f x -- when a only occurs directly as the last argument of T
  $(fmap 'a '(T b1 b2) x) = fmap (\y. $(fmap 'a 'b2 y)) x -- when a only occurs in the last parameter, b2

While the latter case technically subsumes the former case, it is important to
give special treatment to the former case to avoid unnecessary eta expansion.
See Note [Avoid unnecessary eta expansion in derived fmap implementations].

We also generate code for (&lt;$) in addition to fmap&#8212;see Note [Deriving &lt;$] for
an explanation of why this is important. Just like $fmap/$cofmap above, there
is a similar algorithm for generating `p &lt;$ x` (for some constant `p`):

  $(replace 'a 'b x)          = x      -- when b does not contain a
  $(replace 'a 'a x)          = p
  $(replace 'a '(b1,b2) x)    = case x of (x1,x2) -&gt; ($(replace 'a 'b1 x1), $(replace 'a 'b2 x2))
  $(replace 'a '(T b1 a) x)   = p &lt;$ x -- when a only occurs directly as the last argument of T
  $(replace 'a '(T b1 b2) x)  = fmap (\y. $(replace 'a 'b2 y)) x -- when a only occurs in the last parameter, b2
  $(replace 'a '(tb -&gt; tc) x) = \(y:tb[b/a]) -&gt; $(replace 'a' 'tc' (x $(coreplace 'a 'tb y)))

  $(coreplace 'a 'b x)          = x      -- when b does not contain a
  $(coreplace 'a 'a x)          = error &quot;type variable in contravariant position&quot;
  $(coreplace 'a '(b1,b2) x)    = case x of (x1,x2) -&gt; ($(coreplace 'a 'b1 x1), $(coreplace 'a 'b2 x2))
  $(coreplace 'a '(T b1 a) x)   = error &quot;type variable in contravariant position&quot; -- when a only occurs directly as the last argument of T
  $(coreplace 'a '(T b1 b2) x)  = fmap (\y. $(coreplace 'a 'b2 y)) x -- when a only occurs in the last parameter, b2
  $(coreplace 'a '(tb -&gt; tc) x) = \(y:tb[b/a]) -&gt; $(coreplace 'a' 'tc' (x $(replace 'a 'tb y)))
-}</span><span>
</span><span id="line-153"></span><span>
</span><span id="line-154"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Functor_binds"><span class="hs-identifier hs-type">gen_Functor_binds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-type">LHsBinds</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Generate.html#BagDerivStuff"><span class="hs-identifier hs-type">BagDerivStuff</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- When the argument is phantom, we can use  fmap _ = coerce</span><span>
</span><span id="line-156"></span><span class="hs-comment">-- See Note [Phantom types with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-157"></span><span id="gen_Functor_binds"><span class="annot"><span class="annottext">gen_Functor_binds :: SrcSpan
-&gt; TyCon -&gt; [Type] -&gt; (LHsBinds (GhcPass 'Parsed), BagDerivStuff)
</span><a href="GHC.Tc.Deriv.Functor.html#gen_Functor_binds"><span class="hs-identifier hs-var hs-var">gen_Functor_binds</span></a></span></span><span> </span><span id="local-6989586621681418496"><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418496"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681418495"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418495"><span class="hs-identifier hs-var">tycon</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Role
</span><a href="GHC.Core.Coercion.Axiom.html#Phantom"><span class="hs-identifier hs-var">Phantom</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-List.html#last"><span class="hs-identifier hs-var">last</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; [Role]
</span><a href="GHC.Core.TyCon.html#tyConRoles"><span class="hs-identifier hs-var">tyConRoles</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418495"><span class="hs-identifier hs-var">tycon</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-159"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unitBag"><span class="hs-identifier hs-var">unitBag</span></a></span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418490"><span class="hs-identifier hs-var">fmap_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-161"></span><span>    </span><span id="local-6989586621681418488"><span class="annot"><span class="annottext">fmap_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418488"><span class="hs-identifier hs-var hs-var">fmap_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418496"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#fmap_RDR"><span class="hs-identifier hs-var">fmap_RDR</span></a></span><span>
</span><span id="line-162"></span><span>    </span><span id="local-6989586621681418490"><span class="annot"><span class="annottext">fmap_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418490"><span class="hs-identifier hs-var hs-var">fmap_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBind"><span class="hs-identifier hs-var">mkRdrFunBind</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418488"><span class="hs-identifier hs-var">fmap_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   (Anno
      (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed)))))
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418483"><span class="hs-identifier hs-var">fmap_eqns</span></a></span><span>
</span><span id="line-163"></span><span>    </span><span id="local-6989586621681418483"><span class="annot"><span class="annottext">fmap_eqns :: [GenLocated
   (Anno
      (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed)))))
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418483"><span class="hs-identifier hs-var hs-var">fmap_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (p :: Pass) (body :: * -&gt; *).
(Anno (Match (GhcPass p) (LocatedA (body (GhcPass p))))
 ~ SrcSpanAnnA,
 Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan) =&gt;
HsMatchContext (NoGhcTc (GhcPass p))
-&gt; [LPat (GhcPass p)]
-&gt; LocatedA (body (GhcPass p))
-&gt; LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
</span><a href="GHC.Hs.Utils.html#mkSimpleMatch"><span class="hs-identifier hs-var">mkSimpleMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418481"><span class="hs-identifier hs-var">fmap_match_ctxt</span></a></span><span>
</span><span id="line-164"></span><span>                               </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlWildPat"><span class="hs-identifier hs-var">nlWildPat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-165"></span><span>                               </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#coerce_Expr"><span class="hs-identifier hs-var">coerce_Expr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-166"></span><span>    </span><span id="local-6989586621681418481"><span class="annot"><span class="annottext">fmap_match_ctxt :: HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418481"><span class="hs-identifier hs-var hs-var">fmap_match_ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. LIdP p -&gt; HsMatchContext p
</span><a href="GHC.Hs.Utils.html#mkPrefixFunRhs"><span class="hs-identifier hs-var">mkPrefixFunRhs</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418488"><span class="hs-identifier hs-var">fmap_name</span></a></span><span>
</span><span id="line-167"></span><span>
</span><span id="line-168"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Functor_binds"><span class="hs-identifier hs-var">gen_Functor_binds</span></a></span><span> </span><span id="local-6989586621681418477"><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418477"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681418476"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418476"><span class="hs-identifier hs-var">tycon</span></a></span></span><span> </span><span id="local-6989586621681418475"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418475"><span class="hs-identifier hs-var">tycon_args</span></a></span></span><span>
</span><span id="line-169"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#listToBag"><span class="hs-identifier hs-var">listToBag</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418473"><span class="hs-identifier hs-var">fmap_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418472"><span class="hs-identifier hs-var">replace_bind</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-170"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-171"></span><span>    </span><span id="local-6989586621681418471"><span class="annot"><span class="annottext">data_cons :: [DataCon]
</span><a href="#local-6989586621681418471"><span class="hs-identifier hs-var hs-var">data_cons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; [DataCon]
</span><a href="GHC.Tc.Deriv.Generate.html#getPossibleDataCons"><span class="hs-identifier hs-var">getPossibleDataCons</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418476"><span class="hs-identifier hs-var">tycon</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418475"><span class="hs-identifier hs-var">tycon_args</span></a></span><span>
</span><span id="line-172"></span><span>    </span><span id="local-6989586621681418469"><span class="annot"><span class="annottext">fmap_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418469"><span class="hs-identifier hs-var hs-var">fmap_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418477"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#fmap_RDR"><span class="hs-identifier hs-var">fmap_RDR</span></a></span><span>
</span><span id="line-173"></span><span>
</span><span id="line-174"></span><span>    </span><span class="hs-comment">-- See Note [EmptyDataDecls with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-175"></span><span>    </span><span id="local-6989586621681418473"><span class="annot"><span class="annottext">fmap_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418473"><span class="hs-identifier hs-var hs-var">fmap_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; (LHsExpr (GhcPass 'Parsed) -&gt; LHsExpr (GhcPass 'Parsed))
-&gt; GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBindEC"><span class="hs-identifier hs-var">mkRdrFunBindEC</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#id"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418469"><span class="hs-identifier hs-var">fmap_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418466"><span class="hs-identifier hs-var">fmap_eqns</span></a></span><span>
</span><span id="line-176"></span><span>    </span><span id="local-6989586621681418465"><span class="annot"><span class="annottext">fmap_match_ctxt :: HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418465"><span class="hs-identifier hs-var hs-var">fmap_match_ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. LIdP p -&gt; HsMatchContext p
</span><a href="GHC.Hs.Utils.html#mkPrefixFunRhs"><span class="hs-identifier hs-var">mkPrefixFunRhs</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418469"><span class="hs-identifier hs-var">fmap_name</span></a></span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span>    </span><span id="local-6989586621681418464"><span class="annot"><span class="annottext">fmap_eqn :: DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418464"><span class="hs-identifier hs-var hs-var">fmap_eqn</span></a></span></span><span> </span><span id="local-6989586621681418463"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418463"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; a
</span><a href="GHC.Utils.Monad.State.html#evalState"><span class="hs-identifier hs-var">evalState</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-179"></span><span>                     </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; m (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418459"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418465"><span class="hs-identifier hs-var">fmap_match_ctxt</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Pat"><span class="hs-identifier hs-var">f_Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418463"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))
 -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418457"><span class="hs-identifier hs-var">parts</span></a></span><span>
</span><span id="line-180"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-181"></span><span>        </span><span id="local-6989586621681418457"><span class="annot"><span class="annottext">parts :: [LocatedA (HsExpr (GhcPass 'Parsed))
 -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418457"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var">foldDataConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType
  (LHsExpr (GhcPass 'Parsed)
   -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418456"><span class="hs-identifier hs-var">ft_fmap</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418463"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span>    </span><span id="local-6989586621681418466"><span class="annot"><span class="annottext">fmap_eqns :: [GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418466"><span class="hs-identifier hs-var hs-var">fmap_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418464"><span class="hs-identifier hs-var">fmap_eqn</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418471"><span class="hs-identifier hs-var">data_cons</span></a></span><span>
</span><span id="line-184"></span><span>
</span><span id="line-185"></span><span>    </span><span class="annot"><a href="#local-6989586621681418456"><span class="hs-identifier hs-type">ft_fmap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-186"></span><span>    </span><span id="local-6989586621681418456"><span class="annot"><span class="annottext">ft_fmap :: FFoldType
  (LHsExpr (GhcPass 'Parsed)
   -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418456"><span class="hs-identifier hs-var hs-var">ft_fmap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418453"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418453"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418453"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-187"></span><span>                   </span><span class="hs-comment">-- fmap f x = x</span><span>
</span><span id="line-188"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418451"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418451"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-var">f_Expr</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418451"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-189"></span><span>                   </span><span class="hs-comment">-- fmap f x = f x</span><span>
</span><span id="line-190"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: (LocatedA (HsExpr (GhcPass 'Parsed))
 -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; (LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418447"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418447"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621681418446"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418446"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621681418445"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418445"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418443"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418443"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-191"></span><span>                     </span><span id="local-6989586621681418442"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418442"><span class="hs-identifier hs-var">gg</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418447"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418443"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-192"></span><span>                     </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418446"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418445"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418442"><span class="hs-identifier hs-var">gg</span></a></span><span>
</span><span id="line-193"></span><span>                   </span><span class="hs-comment">-- fmap f x = \b -&gt; h (x (g b))</span><span>
</span><span id="line-194"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon
-&gt; [LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))]
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var">mkSimpleTupleCase</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; m (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418459"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-195"></span><span>                   </span><span class="hs-comment">-- fmap f x = case x of (a1,a2,..) -&gt; (g1 a1,g2 a2,..)</span><span>
</span><span id="line-196"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type
-&gt; Type
-&gt; (LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418437"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418437"><span class="hs-identifier hs-var">arg_ty</span></a></span></span><span> </span><span id="local-6989586621681418436"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418436"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621681418435"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418435"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-197"></span><span>                     </span><span class="hs-comment">-- If the argument type is a bare occurrence of the</span><span>
</span><span id="line-198"></span><span>                     </span><span class="hs-comment">-- data type's last type variable, then we can generate</span><span>
</span><span id="line-199"></span><span>                     </span><span class="hs-comment">-- more efficient code.</span><span>
</span><span id="line-200"></span><span>                     </span><span class="hs-comment">-- See Note [Avoid unnecessary eta expansion in derived fmap implementations]</span><span>
</span><span id="line-201"></span><span>                     </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="GHC.Tc.Utils.TcType.html#tcIsTyVarTy"><span class="hs-identifier hs-var">tcIsTyVarTy</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418437"><span class="hs-identifier hs-var">arg_ty</span></a></span><span>
</span><span id="line-202"></span><span>                       </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#fmap_RDR"><span class="hs-identifier hs-var">fmap_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-var">f_Expr</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418435"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-203"></span><span>                       </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621681418432"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418432"><span class="hs-identifier hs-var">gg</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418436"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-204"></span><span>                               </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#fmap_RDR"><span class="hs-identifier hs-var">fmap_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418432"><span class="hs-identifier hs-var">gg</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418435"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-205"></span><span>                   </span><span class="hs-comment">-- fmap f x = fmap g x</span><span>
</span><span id="line-206"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id
-&gt; (LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Id
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418430"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418430"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621681418429"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418429"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418430"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418429"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-207"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in ft_fmap&quot;</span></span><span>
</span><span id="line-208"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in ft_fmap&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-209"></span><span>
</span><span id="line-210"></span><span>    </span><span class="hs-comment">-- See Note [Deriving &lt;$]</span><span>
</span><span id="line-211"></span><span>    </span><span id="local-6989586621681418425"><span class="annot"><span class="annottext">replace_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418425"><span class="hs-identifier hs-var hs-var">replace_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418477"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#replace_RDR"><span class="hs-identifier hs-var">replace_RDR</span></a></span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span>    </span><span class="hs-comment">-- See Note [EmptyDataDecls with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-214"></span><span>    </span><span id="local-6989586621681418472"><span class="annot"><span class="annottext">replace_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418472"><span class="hs-identifier hs-var hs-var">replace_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; (LHsExpr (GhcPass 'Parsed) -&gt; LHsExpr (GhcPass 'Parsed))
-&gt; GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBindEC"><span class="hs-identifier hs-var">mkRdrFunBindEC</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#id"><span class="hs-identifier hs-var">id</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418425"><span class="hs-identifier hs-var">replace_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418423"><span class="hs-identifier hs-var">replace_eqns</span></a></span><span>
</span><span id="line-215"></span><span>    </span><span id="local-6989586621681418422"><span class="annot"><span class="annottext">replace_match_ctxt :: HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418422"><span class="hs-identifier hs-var hs-var">replace_match_ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. LIdP p -&gt; HsMatchContext p
</span><a href="GHC.Hs.Utils.html#mkPrefixFunRhs"><span class="hs-identifier hs-var">mkPrefixFunRhs</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418425"><span class="hs-identifier hs-var">replace_name</span></a></span><span>
</span><span id="line-216"></span><span>
</span><span id="line-217"></span><span>    </span><span id="local-6989586621681418421"><span class="annot"><span class="annottext">replace_eqn :: DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418421"><span class="hs-identifier hs-var hs-var">replace_eqn</span></a></span></span><span> </span><span id="local-6989586621681418420"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418420"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; a
</span><a href="GHC.Utils.Monad.State.html#evalState"><span class="hs-identifier hs-var">evalState</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-218"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; m (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418459"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418422"><span class="hs-identifier hs-var">replace_match_ctxt</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Pat"><span class="hs-identifier hs-var">z_Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418420"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))
 -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418418"><span class="hs-identifier hs-var">parts</span></a></span><span>
</span><span id="line-219"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-220"></span><span>        </span><span id="local-6989586621681418418"><span class="annot"><span class="annottext">parts :: [LocatedA (HsExpr (GhcPass 'Parsed))
 -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418418"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var">foldDataConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType
  (LHsExpr (GhcPass 'Parsed)
   -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418417"><span class="hs-identifier hs-var">ft_replace</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418420"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span>    </span><span id="local-6989586621681418423"><span class="annot"><span class="annottext">replace_eqns :: [GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418423"><span class="hs-identifier hs-var hs-var">replace_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418421"><span class="hs-identifier hs-var">replace_eqn</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418471"><span class="hs-identifier hs-var">data_cons</span></a></span><span>
</span><span id="line-223"></span><span>
</span><span id="line-224"></span><span>    </span><span class="annot"><a href="#local-6989586621681418417"><span class="hs-identifier hs-type">ft_replace</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-225"></span><span>    </span><span id="local-6989586621681418417"><span class="annot"><span class="annottext">ft_replace :: FFoldType
  (LHsExpr (GhcPass 'Parsed)
   -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418417"><span class="hs-identifier hs-var hs-var">ft_replace</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418416"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418416"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418416"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-226"></span><span>                   </span><span class="hs-comment">-- p &lt;$ x = x</span><span>
</span><span id="line-227"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Expr"><span class="hs-identifier hs-var">z_Expr</span></a></span><span>
</span><span id="line-228"></span><span>                   </span><span class="hs-comment">-- p &lt;$ _ = p</span><span>
</span><span id="line-229"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: (LocatedA (HsExpr (GhcPass 'Parsed))
 -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; (LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418414"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418414"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621681418413"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418413"><span class="hs-identifier hs-var">h</span></a></span></span><span> </span><span id="local-6989586621681418412"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418412"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418411"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418411"><span class="hs-identifier hs-var">b</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-230"></span><span>                     </span><span id="local-6989586621681418410"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418410"><span class="hs-identifier hs-var">gg</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418414"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418411"><span class="hs-identifier hs-var">b</span></a></span><span>
</span><span id="line-231"></span><span>                     </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418413"><span class="hs-identifier hs-var">h</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418412"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418410"><span class="hs-identifier hs-var">gg</span></a></span><span>
</span><span id="line-232"></span><span>                   </span><span class="hs-comment">-- p &lt;$ x = \b -&gt; h (x (g b))</span><span>
</span><span id="line-233"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon
-&gt; [LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))]
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var">mkSimpleTupleCase</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; m (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418459"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-234"></span><span>                   </span><span class="hs-comment">-- p &lt;$ x = case x of (a1,a2,..) -&gt; (g1 a1,g2 a2,..)</span><span>
</span><span id="line-235"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type
-&gt; Type
-&gt; (LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418409"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418409"><span class="hs-identifier hs-var">arg_ty</span></a></span></span><span> </span><span id="local-6989586621681418408"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418408"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621681418407"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418407"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-236"></span><span>                       </span><span class="hs-comment">-- If the argument type is a bare occurrence of the</span><span>
</span><span id="line-237"></span><span>                       </span><span class="hs-comment">-- data type's last type variable, then we can generate</span><span>
</span><span id="line-238"></span><span>                       </span><span class="hs-comment">-- more efficient code.</span><span>
</span><span id="line-239"></span><span>                       </span><span class="hs-comment">-- See [Deriving &lt;$]</span><span>
</span><span id="line-240"></span><span>                       </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Bool
</span><a href="GHC.Tc.Utils.TcType.html#tcIsTyVarTy"><span class="hs-identifier hs-var">tcIsTyVarTy</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418409"><span class="hs-identifier hs-var">arg_ty</span></a></span><span>
</span><span id="line-241"></span><span>                         </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#replace_RDR"><span class="hs-identifier hs-var">replace_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Expr"><span class="hs-identifier hs-var">z_Expr</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418407"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-242"></span><span>                         </span><span class="hs-keyword">else</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621681418406"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418406"><span class="hs-identifier hs-var">gg</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418408"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-243"></span><span>                                 </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#fmap_RDR"><span class="hs-identifier hs-var">fmap_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418406"><span class="hs-identifier hs-var">gg</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418407"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-244"></span><span>                   </span><span class="hs-comment">-- p &lt;$ x = fmap (p &lt;$) x</span><span>
</span><span id="line-245"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id
-&gt; (LocatedA (HsExpr (GhcPass 'Parsed))
    -&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Id
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418405"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418405"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span id="local-6989586621681418404"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418404"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418405"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418404"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-246"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in ft_replace&quot;</span></span><span>
</span><span id="line-247"></span><span>                 </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: LocatedA (HsExpr (GhcPass 'Parsed))
-&gt; State [RdrName] (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in ft_replace&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-248"></span><span>
</span><span id="line-249"></span><span>    </span><span class="hs-comment">-- Con a1 a2 ... -&gt; Con (f1 a1) (f2 a2) ...</span><span>
</span><span id="line-250"></span><span>    </span><span id="local-6989586621681418833"><span class="annot"><a href="#local-6989586621681418459"><span class="hs-identifier hs-type">match_for_con</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418833"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-251"></span><span>                  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-252"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-253"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418833"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-254"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418833"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-255"></span><span>    </span><span id="local-6989586621681418459"><span class="annot"><span class="annottext">match_for_con :: forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; m (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418459"><span class="hs-identifier hs-var hs-var">match_for_con</span></a></span></span><span> </span><span id="local-6989586621681418392"><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418392"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (RdrName -&gt; [a] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; a]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch"><span class="hs-identifier hs-var">mkSimpleConMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418392"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-256"></span><span>        </span><span class="hs-glyph">\</span><span id="local-6989586621681418390"><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418390"><span class="hs-identifier hs-var">con_name</span></a></span></span><span> </span><span id="local-6989586621681418389"><span class="annot"><span class="annottext">[m (LHsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418389"><span class="hs-identifier hs-var">xsM</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621681418388"><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418388"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">[m (LHsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418389"><span class="hs-identifier hs-var">xsM</span></a></span><span>
</span><span id="line-257"></span><span>                            </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418390"><span class="hs-identifier hs-var">con_name</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418388"><span class="hs-identifier hs-var">xs</span></a></span><span>  </span><span class="hs-comment">-- Con x1 x2 ..</span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span class="hs-comment">{-
Note [Avoid unnecessary eta expansion in derived fmap implementations]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
For the sake of simplicity, the algorithm that derived implementations of
fmap used to have a single case that dealt with applications of some type
constructor T (where T is not a tuple type constructor):

  $(fmap 'a '(T b1 b2) x) = fmap (\y. $(fmap 'a 'b2 y)) x -- when a only occurs in the last parameter, b2

This generated less than optimal code in certain situations, however. Consider
this example:

  data List a = Nil | Cons a (List a) deriving Functor

This would generate the following Functor instance:

  instance Functor List where
    fmap f Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap (\y -&gt; f y) xs)

The code `fmap (\y -&gt; f y) xs` is peculiar, since it eta expands an application
of `f`. What's worse, this eta expansion actually degrades performance! To see
why, we can trace an invocation of fmap on a small List:

  fmap id     $ Cons 0 $ Cons 0 $ Cons 0 $ Cons 0 Nil

  Cons (id 0) $ fmap (\y -&gt; id y)
              $ Cons 0 $ Cons 0 $ Cons 0 Nil

  Cons (id 0) $ Cons ((\y -&gt; id y) 0)
              $ fmap (\y' -&gt; (\y -&gt; id y) y')
              $ Cons 0 $ Cons 0 Nil

  Cons (id 0) $ Cons ((\y -&gt; id y) 0)
              $ Cons ((\y' -&gt; (\y -&gt; id y) y') 0)
              $ fmap (\y'' -&gt; (\y' -&gt; (\y -&gt; id y) y') y'')
              $ Cons 0 Nil

  Cons (id 0) $ Cons ((\y -&gt; id y) 0)
              $ Cons ((\y' -&gt; (\y -&gt; id y) y') 0)
              $ Cons ((\y'' -&gt; (\y' -&gt; (\y -&gt; id y) y') y'') 0)
              $ fmap (\y''' -&gt; (\y'' -&gt; (\y' -&gt; (\y -&gt; id y) y') y'') y''')
              $ Nil

  Cons (id 0) $ Cons ((\y -&gt; id y) 0)
              $ Cons ((\y' -&gt; (\y -&gt; id y) y') 0)
              $ Cons ((\y'' -&gt; (\y' -&gt; (\y -&gt; id y) y') y'') 0)
              $ Nil

Notice how the number of lambdas&#8212;and hence, the number of closures&#8212;one
needs to evaluate grows very quickly. In general, a List with N cons cells will
require (1 + 2 + ... (N-1)) beta reductions, which takes O(N^2) time! This is
what caused the performance issues observed in #7436.

But hold on a second: shouldn't GHC's optimizer be able to eta reduce
`\y -&gt; f y` to `f` and avoid these beta reductions? Unfortunately, this is not
the case. In general, eta reduction can change the semantics of a program. For
instance, (\x -&gt; &#8869;) `seq` () converges, but &#8869; `seq` () diverges. It just so
happens that the fmap implementation above would have the same semantics
regardless of whether or not `\y -&gt; f y` or `f` is used, but GHC's optimizer is
not yet smart enough to realize this (see #17881).

To avoid this quadratic blowup, we add a special case to $fmap that applies
`fmap f` directly:

  $(fmap 'a '(T b1 a) x)  = fmap f x -- when a only occurs directly as the last argument of T
  $(fmap 'a '(T b1 b2) x) = fmap (\y. $(fmap 'a 'b2 y)) x -- when a only occurs in the last parameter, b2

With this modified algorithm, the derived Functor List instance becomes:

  instance Functor List where
    fmap f Nil = Nil
    fmap f (Cons x xs) = Cons (f x) (fmap f xs)

No lambdas in sight, just the way we like it.

This special case does not prevent all sources quadratic closure buildup,
however. In this example:

  data PolyList a = PLNil | PLCons a (PolyList (PolyList a))
    deriving Functor

We would derive the following code:

  instance Functor PolyList where
    fmap f PLNil = PLNil
    fmap f (PLCons x xs) = PLCons (f x) (fmap (\y -&gt; fmap f y) xs)

The use of `fmap (\y -&gt; fmap f y) xs` builds up closures in much the same way
as `fmap (\y -&gt; f y) xs`. The difference here is that even if we eta reduced
to `fmap (fmap f) xs`, GHC would /still/ build up a closure, since we are
recursively invoking fmap with a different argument (fmap f). Since we end up
paying the price of building a closure either way, we do not extend the special
case in $fmap any further, since it wouldn't buy us anything.

The ft_ty_app field of FFoldType distinguishes between these two $fmap cases by
inspecting the argument type. If the argument type is a bare type variable,
then we can conclude the type variable /must/ be the same as the data type's
last type parameter. We know that this must be the case since there is an
invariant that the argument type in ft_ty_app will always contain the last
type parameter somewhere (see Note [FFoldType and functorLikeTraverse]), so
if the argument type is a bare variable, then that must be exactly the last
type parameter.

Note that the ft_ty_app case of ft_replace (which derives implementations of
(&lt;$)) also inspects the argument type to generate more efficient code.
See Note [Deriving &lt;$].

Note [Deriving &lt;$]
~~~~~~~~~~~~~~~~~~

We derive the definition of &lt;$. Allowing this to take the default definition
can lead to memory leaks: mapping over a structure with a constant function can
fill the result structure with trivial thunks that retain the values from the
original structure. The simplifier seems to handle this all right for simple
types, but not for recursive ones. Consider

data Tree a = Bin !(Tree a) a !(Tree a) | Tip deriving Functor

-- fmap _ Tip = Tip
-- fmap f (Bin l v r) = Bin (fmap f l) (f v) (fmap f r)

Using the default definition of &lt;$, we get (&lt;$) x = fmap (\_ -&gt; x) and that
simplifies no further. Why is that? `fmap` is defined recursively, so GHC
cannot inline it. The static argument transformation would turn the definition
into a non-recursive one

-- fmap f = go where
--   go Tip = Tip
--   go (Bin l v r) = Bin (go l) (f v) (go r)

which GHC could inline, producing an efficient definion of `&lt;$`. But there are
several problems. First, GHC does not perform the static argument transformation
by default, even with -O2. Second, even when it does perform the static argument
transformation, it does so only when there are at least two static arguments,
which is not the case for fmap. Finally, when the type in question is
non-regular, such as

data Nesty a = Z a | S (Nesty a) (Nest (a, a))

the function argument is no longer (entirely) static, so the static argument
transformation will do nothing for us.

Applying the default definition of `&lt;$` will produce a tree full of thunks that
look like ((\_ -&gt; x) x0), which represents unnecessary thunk allocation and
also retention of the previous value, potentially leaking memory. Instead, we
derive &lt;$ separately. Two aspects are different from fmap: the case of the
sought type variable (ft_var) and the case of a type application (ft_ty_app).
The interesting one is ft_ty_app. We have to distinguish two cases: the
&quot;immediate&quot; case where the type argument *is* the sought type variable, and
the &quot;nested&quot; case where the type argument *contains* the sought type variable.

The immediate case:

Suppose we have

data Imm a = Imm (F ... a)

Then we want to define

x &lt;$ Imm q = Imm (x &lt;$ q)

The nested case:

Suppose we have

data Nes a = Nes (F ... (G a))

Then we want to define

x &lt;$ Nes q = Nes (fmap (x &lt;$) q)

We inspect the argument type in ft_ty_app
(see Note [FFoldType and functorLikeTraverse]) to distinguish between these
two cases. If the argument type is a bare type variable, then we know that it
must be the same variable as the data type's last type parameter.
This is very similar to a trick that derived fmap implementations
use in their own ft_ty_app case.
See Note [Avoid unnecessary eta expansion in derived fmap implementations],
which explains why checking if the argument type is a bare variable is
the right thing to do.

We could, but do not, give tuples special treatment to improve efficiency
in some cases. Suppose we have

data Nest a = Z a | S (Nest (a,a))

The optimal definition would be

x &lt;$ Z _ = Z x
x &lt;$ S t = S ((x, x) &lt;$ t)

which produces a result with maximal internal sharing. The reason we do not
attempt to treat this case specially is that we have no way to give
user-provided tuple-like types similar treatment. If the user changed the
definition to

data Pair a = Pair a a
data Nest a = Z a | S (Nest (Pair a))

they would experience a surprising degradation in performance. -}</span><span>
</span><span id="line-460"></span><span>
</span><span id="line-461"></span><span>
</span><span id="line-462"></span><span class="hs-comment">{-
Utility functions related to Functor deriving.

Since several things use the same pattern of traversal, this is abstracted into functorLikeTraverse.
This function works like a fold: it makes a value of type 'a' in a bottom up way.
-}</span><span>
</span><span id="line-468"></span><span>
</span><span id="line-469"></span><span class="hs-comment">-- Generic traversal for Functor deriving</span><span>
</span><span id="line-470"></span><span class="hs-comment">-- See Note [FFoldType and functorLikeTraverse]</span><span>
</span><span id="line-471"></span><span class="hs-keyword">data</span><span> </span><span id="FFoldType"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-var">FFoldType</span></a></span></span><span> </span><span id="local-6989586621681418811"><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span></span><span>      </span><span class="hs-comment">-- Describes how to fold over a Type in a functor like way</span><span>
</span><span id="line-472"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="FT"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-var">FT</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="ft_triv"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var hs-var">ft_triv</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-473"></span><span>          </span><span class="hs-comment">-- ^ Does not contain variable</span><span>
</span><span id="line-474"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_var"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var hs-var">ft_var</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-475"></span><span>          </span><span class="hs-comment">-- ^ The variable itself</span><span>
</span><span id="line-476"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_co_var"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var hs-var">ft_co_var</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-477"></span><span>          </span><span class="hs-comment">-- ^ The variable itself, contravariantly</span><span>
</span><span id="line-478"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_fun"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; a -&gt; a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var hs-var">ft_fun</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-479"></span><span>          </span><span class="hs-comment">-- ^ Function type</span><span>
</span><span id="line-480"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_tup"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; TyCon -&gt; [a] -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var hs-var">ft_tup</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-481"></span><span>          </span><span class="hs-comment">-- ^ Tuple type. The @[a]@ is the result of folding over the</span><span>
</span><span id="line-482"></span><span>          </span><span class="hs-comment">--   arguments of the tuple.</span><span>
</span><span id="line-483"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_ty_app"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; Type -&gt; Type -&gt; a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var hs-var">ft_ty_app</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-484"></span><span>          </span><span class="hs-comment">-- ^ Type app, variable only in last argument. The two 'Type's are</span><span>
</span><span id="line-485"></span><span>          </span><span class="hs-comment">--   the function and argument parts of @fun_ty arg_ty@,</span><span>
</span><span id="line-486"></span><span>          </span><span class="hs-comment">--   respectively.</span><span>
</span><span id="line-487"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_bad_app"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var hs-var">ft_bad_app</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-488"></span><span>          </span><span class="hs-comment">-- ^ Type app, variable other than in last argument</span><span>
</span><span id="line-489"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="ft_forall"><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; Id -&gt; a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var hs-var">ft_forall</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Var.html#TcTyVar"><span class="hs-identifier hs-type">TcTyVar</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418811"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-490"></span><span>          </span><span class="hs-comment">-- ^ Forall type</span><span>
</span><span id="line-491"></span><span>     </span><span class="hs-special">}</span><span>
</span><span id="line-492"></span><span>
</span><span id="line-493"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#functorLikeTraverse"><span class="hs-identifier hs-type">functorLikeTraverse</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681418802"><span class="annot"><a href="#local-6989586621681418802"><span class="hs-identifier hs-type">a</span></a></span></span><span class="hs-operator">.</span><span>
</span><span id="line-494"></span><span>                       </span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span>         </span><span class="hs-comment">-- ^ Variable to look for</span><span>
</span><span id="line-495"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418802"><span class="hs-identifier hs-type">a</span></a></span><span>   </span><span class="hs-comment">-- ^ How to fold</span><span>
</span><span id="line-496"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>          </span><span class="hs-comment">-- ^ Type to process</span><span>
</span><span id="line-497"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418802"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-498"></span><span id="functorLikeTraverse"><span class="annot"><span class="annottext">functorLikeTraverse :: forall a. Id -&gt; FFoldType a -&gt; Type -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#functorLikeTraverse"><span class="hs-identifier hs-var hs-var">functorLikeTraverse</span></a></span></span><span> </span><span id="local-6989586621681418379"><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418379"><span class="hs-identifier hs-var">var</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418378"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418378"><span class="hs-identifier hs-var">caseTrivial</span></a></span></span><span class="hs-special">,</span><span>     </span><span class="annot"><span class="annottext">ft_var :: forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418377"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418377"><span class="hs-identifier hs-var">caseVar</span></a></span></span><span>
</span><span id="line-499"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418376"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418376"><span class="hs-identifier hs-var">caseCoVar</span></a></span></span><span class="hs-special">,</span><span>     </span><span class="annot"><span class="annottext">ft_fun :: forall a. FFoldType a -&gt; a -&gt; a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418375"><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621681418375"><span class="hs-identifier hs-var">caseFun</span></a></span></span><span>
</span><span id="line-500"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: forall a. FFoldType a -&gt; TyCon -&gt; [a] -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418374"><span class="annot"><span class="annottext">TyCon -&gt; [a] -&gt; a
</span><a href="#local-6989586621681418374"><span class="hs-identifier hs-var">caseTuple</span></a></span></span><span class="hs-special">,</span><span>        </span><span class="annot"><span class="annottext">ft_ty_app :: forall a. FFoldType a -&gt; Type -&gt; Type -&gt; a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418373"><span class="annot"><span class="annottext">Type -&gt; Type -&gt; a -&gt; a
</span><a href="#local-6989586621681418373"><span class="hs-identifier hs-var">caseTyApp</span></a></span></span><span>
</span><span id="line-501"></span><span>                            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418372"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418372"><span class="hs-identifier hs-var">caseWrongArg</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: forall a. FFoldType a -&gt; Id -&gt; a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418371"><span class="annot"><span class="annottext">Id -&gt; a -&gt; a
</span><a href="#local-6989586621681418371"><span class="hs-identifier hs-var">caseForAll</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-502"></span><span>                    </span><span id="local-6989586621681418370"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418370"><span class="hs-identifier hs-var">ty</span></a></span></span><span>
</span><span id="line-503"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a, b) -&gt; a
</span><a href="../../base-4.16.4.0/src/Data-Tuple.html#fst"><span class="hs-identifier hs-var">fst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418370"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-504"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-505"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>        </span><span class="hs-comment">-- Covariant or contravariant context</span><span>
</span><span id="line-506"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-507"></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621681418802"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- (result of type a, does type contain var)</span><span>
</span><span id="line-508"></span><span>
</span><span id="line-509"></span><span>    </span><span id="local-6989586621681418369"><span class="annot"><span class="annottext">go :: Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621681418368"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418368"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span id="local-6989586621681418367"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418367"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621681418366"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418366"><span class="hs-identifier hs-var">ty'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
</span><a href="GHC.Core.Type.html#tcView"><span class="hs-identifier hs-var">tcView</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418367"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418368"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418366"><span class="hs-identifier hs-var">ty'</span></a></span><span>
</span><span id="line-510"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621681418364"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418364"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#TyVarTy"><span class="hs-identifier hs-type">TyVarTy</span></a></span><span>    </span><span id="local-6989586621681418362"><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418362"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418362"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418379"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418364"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418376"><span class="hs-identifier hs-var">caseCoVar</span></a></span><span> </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418377"><span class="hs-identifier hs-var">caseVar</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-511"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621681418361"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418361"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#FunTy"><span class="hs-identifier hs-type">FunTy</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_arg :: Type -&gt; Type
</span><a href="GHC.Core.TyCo.Rep.html#ft_arg"><span class="hs-identifier hs-var">ft_arg</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418358"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418358"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_res :: Type -&gt; Type
</span><a href="GHC.Core.TyCo.Rep.html#ft_res"><span class="hs-identifier hs-var">ft_res</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418356"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418356"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_af :: Type -&gt; AnonArgFlag
</span><a href="GHC.Core.TyCo.Rep.html#ft_af"><span class="hs-identifier hs-var">ft_af</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681418354"><span class="annot"><span class="annottext">AnonArgFlag
</span><a href="#local-6989586621681418354"><span class="hs-identifier hs-var">af</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-512"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">AnonArgFlag
</span><a href="GHC.Types.Var.html#InvisArg"><span class="hs-identifier hs-var">InvisArg</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">AnonArgFlag
</span><a href="#local-6989586621681418354"><span class="hs-identifier hs-var">af</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418361"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418356"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-513"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418352"><span class="hs-identifier hs-var">xc</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418350"><span class="hs-identifier hs-var">yc</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; a
</span><a href="#local-6989586621681418375"><span class="hs-identifier hs-var">caseFun</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418349"><span class="hs-identifier hs-var">xr</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418348"><span class="hs-identifier hs-var">yr</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span>       </span><span class="hs-keyword">where</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681418349"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418349"><span class="hs-identifier hs-var">xr</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681418352"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418352"><span class="hs-identifier hs-var">xc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418361"><span class="hs-identifier hs-var">co</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418358"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-515"></span><span>             </span><span class="hs-special">(</span><span id="local-6989586621681418348"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418348"><span class="hs-identifier hs-var">yr</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681418350"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418350"><span class="hs-identifier hs-var">yc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418361"><span class="hs-identifier hs-var">co</span></a></span><span>       </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418356"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-516"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621681418346"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418346"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#AppTy"><span class="hs-identifier hs-type">AppTy</span></a></span><span>    </span><span id="local-6989586621681418344"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418344"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681418343"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418343"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418342"><span class="hs-identifier hs-var">xc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418372"><span class="hs-identifier hs-var">caseWrongArg</span></a></span><span class="hs-special">,</span><span>   </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-517"></span><span>                         </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418341"><span class="hs-identifier hs-var">yc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; a -&gt; a
</span><a href="#local-6989586621681418373"><span class="hs-identifier hs-var">caseTyApp</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418344"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418343"><span class="hs-identifier hs-var">y</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418340"><span class="hs-identifier hs-var">yr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-518"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681418342"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418342"><span class="hs-identifier hs-var">xc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418346"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418344"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-519"></span><span>              </span><span class="hs-special">(</span><span id="local-6989586621681418340"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418340"><span class="hs-identifier hs-var">yr</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681418341"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418341"><span class="hs-identifier hs-var">yc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418346"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418343"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-520"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621681418339"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418339"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span id="local-6989586621681418338"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621681418338"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#TyConApp"><span class="hs-identifier hs-type">TyConApp</span></a></span><span> </span><span id="local-6989586621681418336"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418336"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621681418335"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418335"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-521"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#or"><span class="hs-identifier hs-var">or</span></a></span><span> </span><span class="annot"><span class="annottext">[Bool]
</span><a href="#local-6989586621681418333"><span class="hs-identifier hs-var">xcs</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418378"><span class="hs-identifier hs-var">caseTrivial</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Variable does not occur</span><span>
</span><span id="line-522"></span><span>       </span><span class="hs-comment">-- At this point we know that xrs, xcs is not empty,</span><span>
</span><span id="line-523"></span><span>       </span><span class="hs-comment">-- and at least one xr is True</span><span>
</span><span id="line-524"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; Bool
</span><a href="GHC.Core.TyCon.html#isTupleTyCon"><span class="hs-identifier hs-var">isTupleTyCon</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418336"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; [a] -&gt; a
</span><a href="#local-6989586621681418374"><span class="hs-identifier hs-var">caseTuple</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418336"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681418331"><span class="hs-identifier hs-var">xrs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-525"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *). Foldable t =&gt; t Bool -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#or"><span class="hs-identifier hs-var">or</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-List.html#init"><span class="hs-identifier hs-var">init</span></a></span><span> </span><span class="annot"><span class="annottext">[Bool]
</span><a href="#local-6989586621681418333"><span class="hs-identifier hs-var">xcs</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418372"><span class="hs-identifier hs-var">caseWrongArg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- T (..var..)    ty</span><span>
</span><span id="line-526"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681418329"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418329"><span class="hs-identifier hs-var">fun_ty</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681418328"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418328"><span class="hs-identifier hs-var">arg_ty</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe (Type, Type)
</span><a href="GHC.Core.Type.html#splitAppTy_maybe"><span class="hs-identifier hs-var">splitAppTy_maybe</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418338"><span class="hs-identifier hs-var">ty</span></a></span><span>    </span><span class="hs-comment">-- T (..no var..) ty</span><span>
</span><span id="line-527"></span><span>                          </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; a -&gt; a
</span><a href="#local-6989586621681418373"><span class="hs-identifier hs-var">caseTyApp</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418329"><span class="hs-identifier hs-var">fun_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418328"><span class="hs-identifier hs-var">arg_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-List.html#last"><span class="hs-identifier hs-var">last</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681418331"><span class="hs-identifier hs-var">xrs</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-528"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418372"><span class="hs-identifier hs-var">caseWrongArg</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- Non-decomposable (eg type function)</span><span>
</span><span id="line-529"></span><span>       </span><span class="hs-keyword">where</span><span>
</span><span id="line-530"></span><span>         </span><span class="hs-comment">-- When folding over an unboxed tuple, we must explicitly drop the</span><span>
</span><span id="line-531"></span><span>         </span><span class="hs-comment">-- runtime rep arguments, or else GHC will generate twice as many</span><span>
</span><span id="line-532"></span><span>         </span><span class="hs-comment">-- variables in a unboxed tuple pattern match and expression as it</span><span>
</span><span id="line-533"></span><span>         </span><span class="hs-comment">-- actually needs. See #12399</span><span>
</span><span id="line-534"></span><span>         </span><span class="hs-special">(</span><span id="local-6989586621681418331"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681418331"><span class="hs-identifier hs-var">xrs</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681418333"><span class="annot"><span class="annottext">[Bool]
</span><a href="#local-6989586621681418333"><span class="hs-identifier hs-var">xcs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. [(a, b)] -&gt; ([a], [b])
</span><a href="../../base-4.16.4.0/src/GHC-List.html#unzip"><span class="hs-identifier hs-var">unzip</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418339"><span class="hs-identifier hs-var">co</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Type] -&gt; [Type]
</span><a href="GHC.Core.Type.html#dropRuntimeRepArgs"><span class="hs-identifier hs-var">dropRuntimeRepArgs</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418335"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-535"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621681418324"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418324"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#ForAllTy"><span class="hs-identifier hs-type">ForAllTy</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Var.html#Bndr"><span class="hs-identifier hs-type">Bndr</span></a></span><span> </span><span id="local-6989586621681418321"><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418321"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621681418320"><span class="annot"><span class="annottext">ArgFlag
</span><a href="#local-6989586621681418320"><span class="hs-identifier hs-var">vis</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621681418319"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418319"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-536"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">ArgFlag -&gt; Bool
</span><a href="GHC.Types.Var.html#isVisibleArgFlag"><span class="hs-identifier hs-var">isVisibleArgFlag</span></a></span><span> </span><span class="annot"><span class="annottext">ArgFlag
</span><a href="#local-6989586621681418320"><span class="hs-identifier hs-var">vis</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unexpected visible binder&quot;</span></span><span>
</span><span id="line-537"></span><span>       </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418321"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418379"><span class="hs-identifier hs-var">var</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418315"><span class="hs-identifier hs-var">xc</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Id -&gt; a -&gt; a
</span><a href="#local-6989586621681418371"><span class="hs-identifier hs-var">caseForAll</span></a></span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418321"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418314"><span class="hs-identifier hs-var">xr</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span class="hs-special">)</span><span>
</span><span id="line-538"></span><span>       </span><span class="hs-keyword">where</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681418314"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418314"><span class="hs-identifier hs-var">xr</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681418315"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418315"><span class="hs-identifier hs-var">xc</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Type -&gt; (a, Bool)
</span><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681418324"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418319"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-539"></span><span>
</span><span id="line-540"></span><span>    </span><span class="annot"><a href="#local-6989586621681418369"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418378"><span class="hs-identifier hs-var">caseTrivial</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-special">)</span><span>
</span><span id="line-541"></span><span>
</span><span id="line-542"></span><span class="hs-comment">-- Return all syntactic subterms of ty that contain var somewhere</span><span>
</span><span id="line-543"></span><span class="hs-comment">-- These are the things that should appear in instance constraints</span><span>
</span><span id="line-544"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#deepSubtypesContaining"><span class="hs-identifier hs-type">deepSubtypesContaining</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Utils.TcType.html#TcType"><span class="hs-identifier hs-type">TcType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-545"></span><span id="deepSubtypesContaining"><span class="annot"><span class="annottext">deepSubtypesContaining :: Id -&gt; Type -&gt; [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#deepSubtypesContaining"><span class="hs-identifier hs-var hs-var">deepSubtypesContaining</span></a></span></span><span> </span><span id="local-6989586621681418312"><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418312"><span class="hs-identifier hs-var">tv</span></a></span></span><span>
</span><span id="line-546"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Id -&gt; FFoldType a -&gt; Type -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#functorLikeTraverse"><span class="hs-identifier hs-var">functorLikeTraverse</span></a></span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418312"><span class="hs-identifier hs-var">tv</span></a></span><span>
</span><span id="line-547"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-548"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-549"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: [Type] -&gt; [Type] -&gt; [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%2B%2B"><span class="hs-operator hs-var">(++)</span></a></span><span>
</span><span id="line-550"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon -&gt; [[Type]] -&gt; [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">TyCon
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418311"><span class="annot"><span class="annottext">[[Type]]
</span><a href="#local-6989586621681418311"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#concat"><span class="hs-identifier hs-var">concat</span></a></span><span> </span><span class="annot"><span class="annottext">[[Type]]
</span><a href="#local-6989586621681418311"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-551"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type -&gt; Type -&gt; [Type] -&gt; [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418309"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418309"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418308"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418308"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681418309"><span class="hs-identifier hs-var">t</span></a></span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418308"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-552"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in deepSubtypesContaining&quot;</span></span><span>
</span><span id="line-553"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in deepSubtypesContaining&quot;</span></span><span>
</span><span id="line-554"></span><span>            </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id -&gt; [Type] -&gt; [Type]
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418307"><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418307"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span id="local-6989586621681418306"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418306"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#filterOut"><span class="hs-identifier hs-var">filterOut</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418307"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Id -&gt; VarSet -&gt; Bool
</span><a href="GHC.Types.Var.Set.html#elemVarSet"><span class="hs-operator hs-var">`elemVarSet`</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; VarSet
</span><a href="GHC.Core.TyCo.FVs.html#tyCoVarsOfType"><span class="hs-identifier hs-var">tyCoVarsOfType</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418306"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span>
</span><span id="line-557"></span><span id="local-6989586621681418832"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-type">foldDataConArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418832"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681418832"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-558"></span><span class="hs-comment">-- Fold over the arguments of the datacon</span><span>
</span><span id="line-559"></span><span id="foldDataConArgs"><span class="annot"><span class="annottext">foldDataConArgs :: forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var hs-var">foldDataConArgs</span></a></span></span><span> </span><span id="local-6989586621681418301"><span class="annot"><span class="annottext">FFoldType a
</span><a href="#local-6989586621681418301"><span class="hs-identifier hs-var">ft</span></a></span></span><span> </span><span id="local-6989586621681418300"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418300"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-560"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; a
</span><a href="#local-6989586621681418299"><span class="hs-identifier hs-var">foldArg</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Scaled a -&gt; a
</span><a href="GHC.Core.TyCo.Rep.html#scaledThing"><span class="hs-identifier hs-var">scaledThing</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [Scaled Type]
</span><a href="GHC.Core.DataCon.html#dataConOrigArgTys"><span class="hs-identifier hs-var">dataConOrigArgTys</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418300"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-561"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-562"></span><span>    </span><span id="local-6989586621681418299"><span class="annot"><span class="annottext">foldArg :: Type -&gt; a
</span><a href="#local-6989586621681418299"><span class="hs-identifier hs-var hs-var">foldArg</span></a></span></span><span>
</span><span id="line-563"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Id
</span><a href="GHC.Core.Type.html#getTyVar_maybe"><span class="hs-identifier hs-var">getTyVar_maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-List.html#last"><span class="hs-identifier hs-var">last</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; [Type]
</span><a href="GHC.Core.Type.html#tyConAppArgs"><span class="hs-identifier hs-var">tyConAppArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; Type
</span><a href="GHC.Core.DataCon.html#dataConOrigResTy"><span class="hs-identifier hs-var">dataConOrigResTy</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418300"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-564"></span><span>             </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621681418293"><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418293"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Id -&gt; FFoldType a -&gt; Type -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#functorLikeTraverse"><span class="hs-identifier hs-var">functorLikeTraverse</span></a></span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="#local-6989586621681418293"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType a
</span><a href="#local-6989586621681418301"><span class="hs-identifier hs-var">ft</span></a></span><span>
</span><span id="line-565"></span><span>             </span><span class="annot"><span class="annottext">Maybe Id
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#const"><span class="hs-identifier hs-var">const</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; a
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType a
</span><a href="#local-6989586621681418301"><span class="hs-identifier hs-var">ft</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-566"></span><span>    </span><span class="hs-comment">-- If we are deriving Foldable for a GADT, there is a chance that the last</span><span>
</span><span id="line-567"></span><span>    </span><span class="hs-comment">-- type variable in the data type isn't actually a type variable at all.</span><span>
</span><span id="line-568"></span><span>    </span><span class="hs-comment">-- (for example, this can happen if the last type variable is refined to</span><span>
</span><span id="line-569"></span><span>    </span><span class="hs-comment">-- be a concrete type such as Int). If the last type variable is refined</span><span>
</span><span id="line-570"></span><span>    </span><span class="hs-comment">-- to be a specific type, then getTyVar_maybe will return Nothing.</span><span>
</span><span id="line-571"></span><span>    </span><span class="hs-comment">-- See Note [DeriveFoldable with ExistentialQuantification]</span><span>
</span><span id="line-572"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-573"></span><span>    </span><span class="hs-comment">-- The kind checks have ensured the last type parameter is of kind *.</span><span>
</span><span id="line-574"></span><span>
</span><span id="line-575"></span><span class="hs-comment">-- Make a HsLam using a fresh variable from a State monad</span><span>
</span><span id="line-576"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-type">mkSimpleLam</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-577"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-578"></span><span class="hs-comment">-- (mkSimpleLam fn) returns (\x. fn(x))</span><span>
</span><span id="line-579"></span><span id="mkSimpleLam"><span class="annot"><span class="annottext">mkSimpleLam :: (LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var hs-var">mkSimpleLam</span></a></span></span><span> </span><span id="local-6989586621681418291"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418291"><span class="hs-identifier hs-var">lam</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-580"></span><span>    </span><span class="annot"><span class="annottext">forall s. State s s
</span><a href="GHC.Utils.Monad.State.html#get"><span class="hs-identifier hs-var">get</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%3E%3E%3D"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-581"></span><span>      </span><span id="local-6989586621681418289"><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418289"><span class="hs-identifier hs-var">n</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621681418288"><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418288"><span class="hs-identifier hs-var">names</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-582"></span><span>        </span><span class="annot"><span class="annottext">forall s. s -&gt; State s ()
</span><a href="GHC.Utils.Monad.State.html#put"><span class="hs-identifier hs-var">put</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418288"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-583"></span><span>        </span><span id="local-6989586621681418286"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418286"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418291"><span class="hs-identifier hs-var">lam</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418289"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-584"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass).
(IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ NoExtField) =&gt;
[LPat (GhcPass p)] -&gt; LHsExpr (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#mkHsLam"><span class="hs-identifier hs-var">mkHsLam</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlVarPat"><span class="hs-identifier hs-var">nlVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418289"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418286"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-585"></span><span>      </span><span class="annot"><span class="annottext">[RdrName]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mkSimpleLam&quot;</span></span><span>
</span><span id="line-586"></span><span>
</span><span id="line-587"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam2"><span class="hs-identifier hs-type">mkSimpleLam2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-588"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-589"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-590"></span><span id="mkSimpleLam2"><span class="annot"><span class="annottext">mkSimpleLam2 :: (LHsExpr (GhcPass 'Parsed)
 -&gt; LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam2"><span class="hs-identifier hs-var hs-var">mkSimpleLam2</span></a></span></span><span> </span><span id="local-6989586621681418281"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418281"><span class="hs-identifier hs-var">lam</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-591"></span><span>    </span><span class="annot"><span class="annottext">forall s. State s s
</span><a href="GHC.Utils.Monad.State.html#get"><span class="hs-identifier hs-var">get</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%3E%3E%3D"><span class="hs-operator hs-var">&gt;&gt;=</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-592"></span><span>      </span><span id="local-6989586621681418280"><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418280"><span class="hs-identifier hs-var">n1</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621681418279"><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418279"><span class="hs-identifier hs-var">n2</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621681418278"><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418278"><span class="hs-identifier hs-var">names</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-593"></span><span>        </span><span class="annot"><span class="annottext">forall s. s -&gt; State s ()
</span><a href="GHC.Utils.Monad.State.html#put"><span class="hs-identifier hs-var">put</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418278"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-594"></span><span>        </span><span id="local-6989586621681418277"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418277"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418281"><span class="hs-identifier hs-var">lam</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418280"><span class="hs-identifier hs-var">n1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418279"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-595"></span><span>        </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass).
(IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ NoExtField) =&gt;
[LPat (GhcPass p)] -&gt; LHsExpr (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#mkHsLam"><span class="hs-identifier hs-var">mkHsLam</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlVarPat"><span class="hs-identifier hs-var">nlVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418280"><span class="hs-identifier hs-var">n1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlVarPat"><span class="hs-identifier hs-var">nlVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418279"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418277"><span class="hs-identifier hs-var">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-596"></span><span>      </span><span class="annot"><span class="annottext">[RdrName]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;mkSimpleLam2&quot;</span></span><span>
</span><span id="line-597"></span><span>
</span><span id="line-598"></span><span class="hs-comment">-- &quot;Con a1 a2 a3 -&gt; fold [x1 a1, x2 a2, x3 a3]&quot;</span><span>
</span><span id="line-599"></span><span class="hs-comment">--</span><span>
</span><span id="line-600"></span><span class="hs-comment">-- @mkSimpleConMatch fold extra_pats con insides@ produces a match clause in</span><span>
</span><span id="line-601"></span><span class="hs-comment">-- which the LHS pattern-matches on @extra_pats@, followed by a match on the</span><span>
</span><span id="line-602"></span><span class="hs-comment">-- constructor @con@ and its arguments. The RHS folds (with @fold@) over @con@</span><span>
</span><span id="line-603"></span><span class="hs-comment">-- and its arguments, applying an expression (from @insides@) to each of the</span><span>
</span><span id="line-604"></span><span class="hs-comment">-- respective arguments of @con@.</span><span>
</span><span id="line-605"></span><span id="local-6989586621681418815"><span id="local-6989586621681418816"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch"><span class="hs-identifier hs-type">mkSimpleConMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418816"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-606"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681418815"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418816"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-607"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-608"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-609"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418815"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-610"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418816"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span></span><span>
</span><span id="line-611"></span><span id="mkSimpleConMatch"><span class="annot"><span class="annottext">mkSimpleConMatch :: forall (m :: * -&gt; *) a.
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (RdrName -&gt; [a] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [LHsExpr (GhcPass 'Parsed) -&gt; a]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch"><span class="hs-identifier hs-var hs-var">mkSimpleConMatch</span></a></span></span><span> </span><span id="local-6989586621681418266"><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418266"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621681418265"><span class="annot"><span class="annottext">RdrName -&gt; [a] -&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418265"><span class="hs-identifier hs-var">fold</span></a></span></span><span> </span><span id="local-6989586621681418264"><span class="annot"><span class="annottext">[LPat (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418264"><span class="hs-identifier hs-var">extra_pats</span></a></span></span><span> </span><span id="local-6989586621681418263"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418263"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621681418262"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed) -&gt; a]
</span><a href="#local-6989586621681418262"><span class="hs-identifier hs-var">insides</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-612"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418261"><span class="annot"><span class="annottext">con_name :: RdrName
</span><a href="#local-6989586621681418261"><span class="hs-identifier hs-var hs-var">con_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall thing. NamedThing thing =&gt; thing -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#getRdrName"><span class="hs-identifier hs-var">getRdrName</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418263"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-613"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418259"><span class="annot"><span class="annottext">vars_needed :: [RdrName]
</span><a href="#local-6989586621681418259"><span class="hs-identifier hs-var hs-var">vars_needed</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a. [b] -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#takeList"><span class="hs-identifier hs-var">takeList</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed) -&gt; a]
</span><a href="#local-6989586621681418262"><span class="hs-identifier hs-var">insides</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#as_RDRs"><span class="hs-identifier hs-var">as_RDRs</span></a></span><span>
</span><span id="line-614"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418256"><span class="annot"><span class="annottext">bare_pat :: LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418256"><span class="hs-identifier hs-var hs-var">bare_pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">RdrName -&gt; [RdrName] -&gt; LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlConVarPat"><span class="hs-identifier hs-var">nlConVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418261"><span class="hs-identifier hs-var">con_name</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418259"><span class="hs-identifier hs-var">vars_needed</span></a></span><span>
</span><span id="line-615"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418254"><span class="annot"><span class="annottext">pat :: LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418254"><span class="hs-identifier hs-var hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418259"><span class="hs-identifier hs-var">vars_needed</span></a></span><span>
</span><span id="line-616"></span><span>          </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418256"><span class="hs-identifier hs-var">bare_pat</span></a></span><span>
</span><span id="line-617"></span><span>          </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (name :: Pass). LPat (GhcPass name) -&gt; LPat (GhcPass name)
</span><a href="GHC.Hs.Utils.html#nlParPat"><span class="hs-identifier hs-var">nlParPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418256"><span class="hs-identifier hs-var">bare_pat</span></a></span><span>
</span><span id="line-618"></span><span>    </span><span id="local-6989586621681418251"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418251"><span class="hs-identifier hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">RdrName -&gt; [a] -&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418265"><span class="hs-identifier hs-var">fold</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418261"><span class="hs-identifier hs-var">con_name</span></a></span><span>
</span><span id="line-619"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><a href="../../base-4.16.4.0/src/GHC-List.html#zipWith"><span class="hs-identifier hs-var">zipWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681418249"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed)) -&gt; a
</span><a href="#local-6989586621681418249"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621681418248"><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418248"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed)) -&gt; a
</span><a href="#local-6989586621681418249"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418248"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed) -&gt; a]
</span><a href="#local-6989586621681418262"><span class="hs-identifier hs-var">insides</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418259"><span class="hs-identifier hs-var">vars_needed</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-620"></span><span>    </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
IsPass p =&gt;
HsMatchContext (NoGhcTc (GhcPass p))
-&gt; [LPat (GhcPass p)]
-&gt; LHsExpr (GhcPass p)
-&gt; HsLocalBinds (GhcPass p)
-&gt; LMatch (GhcPass p) (LHsExpr (GhcPass p))
</span><a href="GHC.Hs.Utils.html#mkMatch"><span class="hs-identifier hs-var">mkMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418266"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[LPat (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418264"><span class="hs-identifier hs-var">extra_pats</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418254"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418251"><span class="hs-identifier hs-var">rhs</span></a></span><span> </span><span class="annot"><span class="annottext">forall (a :: Pass) (b :: Pass).
HsLocalBindsLR (GhcPass a) (GhcPass b)
</span><a href="GHC.Hs.Binds.html#emptyLocalBinds"><span class="hs-identifier hs-var">emptyLocalBinds</span></a></span><span>
</span><span id="line-621"></span><span>
</span><span id="line-622"></span><span class="hs-comment">-- &quot;Con a1 a2 a3 -&gt; fmap (\b2 -&gt; Con a1 b2 a3) (traverse f a2)&quot;</span><span>
</span><span id="line-623"></span><span class="hs-comment">--</span><span>
</span><span id="line-624"></span><span class="hs-comment">-- @mkSimpleConMatch2 fold extra_pats con insides@ behaves very similarly to</span><span>
</span><span id="line-625"></span><span class="hs-comment">-- 'mkSimpleConMatch', with two key differences:</span><span>
</span><span id="line-626"></span><span class="hs-comment">--</span><span>
</span><span id="line-627"></span><span class="hs-comment">-- 1. @insides@ is a @[Maybe (LHsExpr RdrName)]@ instead of a</span><span>
</span><span id="line-628"></span><span class="hs-comment">--    @[LHsExpr RdrName]@. This is because it filters out the expressions</span><span>
</span><span id="line-629"></span><span class="hs-comment">--    corresponding to arguments whose types do not mention the last type</span><span>
</span><span id="line-630"></span><span class="hs-comment">--    variable in a derived 'Foldable' or 'Traversable' instance (i.e., the</span><span>
</span><span id="line-631"></span><span class="hs-comment">--    'Nothing' elements of @insides@).</span><span>
</span><span id="line-632"></span><span class="hs-comment">--</span><span>
</span><span id="line-633"></span><span class="hs-comment">-- 2. @fold@ takes an expression as its first argument instead of a</span><span>
</span><span id="line-634"></span><span class="hs-comment">--    constructor name. This is because it uses a specialized</span><span>
</span><span id="line-635"></span><span class="hs-comment">--    constructor function expression that only takes as many parameters as</span><span>
</span><span id="line-636"></span><span class="hs-comment">--    there are argument types that mention the last type variable.</span><span>
</span><span id="line-637"></span><span class="hs-comment">--</span><span>
</span><span id="line-638"></span><span class="hs-comment">-- See Note [Generated code for DeriveFoldable and DeriveTraversable]</span><span>
</span><span id="line-639"></span><span id="local-6989586621681418749"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch2"><span class="hs-identifier hs-type">mkSimpleConMatch2</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418749"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-640"></span><span>                  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-641"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-642"></span><span>                                      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418749"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-643"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-644"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-645"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-646"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418749"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-647"></span><span id="mkSimpleConMatch2"><span class="annot"><span class="annottext">mkSimpleConMatch2 :: forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (LHsExpr (GhcPass 'Parsed)
    -&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch2"><span class="hs-identifier hs-var hs-var">mkSimpleConMatch2</span></a></span></span><span> </span><span id="local-6989586621681418221"><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418221"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621681418220"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418220"><span class="hs-identifier hs-var">fold</span></a></span></span><span> </span><span id="local-6989586621681418219"><span class="annot"><span class="annottext">[LPat (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418219"><span class="hs-identifier hs-var">extra_pats</span></a></span></span><span> </span><span id="local-6989586621681418218"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418218"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621681418217"><span class="annot"><span class="annottext">[Maybe (LHsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418217"><span class="hs-identifier hs-var">insides</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-648"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418216"><span class="annot"><span class="annottext">con_name :: RdrName
</span><a href="#local-6989586621681418216"><span class="hs-identifier hs-var hs-var">con_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall thing. NamedThing thing =&gt; thing -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#getRdrName"><span class="hs-identifier hs-var">getRdrName</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418218"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-649"></span><span>        </span><span id="local-6989586621681418215"><span class="annot"><span class="annottext">vars_needed :: [RdrName]
</span><a href="#local-6989586621681418215"><span class="hs-identifier hs-var hs-var">vars_needed</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall b a. [b] -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#takeList"><span class="hs-identifier hs-var">takeList</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LHsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418217"><span class="hs-identifier hs-var">insides</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#as_RDRs"><span class="hs-identifier hs-var">as_RDRs</span></a></span><span>
</span><span id="line-650"></span><span>        </span><span id="local-6989586621681418214"><span class="annot"><span class="annottext">pat :: LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418214"><span class="hs-identifier hs-var hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">RdrName -&gt; [RdrName] -&gt; LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlConVarPat"><span class="hs-identifier hs-var">nlConVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418216"><span class="hs-identifier hs-var">con_name</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418215"><span class="hs-identifier hs-var">vars_needed</span></a></span><span>
</span><span id="line-651"></span><span>        </span><span class="hs-comment">-- Make sure to zip BEFORE invoking catMaybes. We want the variable</span><span>
</span><span id="line-652"></span><span>        </span><span class="hs-comment">-- indices in each expression to match up with the argument indices</span><span>
</span><span id="line-653"></span><span>        </span><span class="hs-comment">-- in con_expr (defined below).</span><span>
</span><span id="line-654"></span><span>        </span><span id="local-6989586621681418213"><span class="annot"><span class="annottext">exps :: [LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418213"><span class="hs-identifier hs-var hs-var">exps</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Maybe a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/Data-Maybe.html#catMaybes"><span class="hs-identifier hs-var">catMaybes</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><a href="../../base-4.16.4.0/src/GHC-List.html#zipWith"><span class="hs-identifier hs-var">zipWith</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681418212"><span class="annot"><span class="annottext">Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418212"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span id="local-6989586621681418211"><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418211"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-operator hs-var">`nlHsApp`</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418211"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/Data-Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418212"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-655"></span><span>                                   </span><span class="annot"><span class="annottext">[Maybe (LHsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418217"><span class="hs-identifier hs-var">insides</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418215"><span class="hs-identifier hs-var">vars_needed</span></a></span><span>
</span><span id="line-656"></span><span>        </span><span class="hs-comment">-- An element of argTysTyVarInfo is True if the constructor argument</span><span>
</span><span id="line-657"></span><span>        </span><span class="hs-comment">-- with the same index has a type which mentions the last type</span><span>
</span><span id="line-658"></span><span>        </span><span class="hs-comment">-- variable.</span><span>
</span><span id="line-659"></span><span>        </span><span id="local-6989586621681418209"><span class="annot"><span class="annottext">argTysTyVarInfo :: [Bool]
</span><a href="#local-6989586621681418209"><span class="hs-identifier hs-var hs-var">argTysTyVarInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Maybe.html#isJust"><span class="hs-identifier hs-var">isJust</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LHsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418217"><span class="hs-identifier hs-var">insides</span></a></span><span>
</span><span id="line-660"></span><span>        </span><span class="hs-special">(</span><span id="local-6989586621681418208"><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418208"><span class="hs-identifier hs-var">asWithTyVar</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681418207"><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418207"><span class="hs-identifier hs-var">asWithoutTyVar</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Bool] -&gt; [a] -&gt; ([a], [a])
</span><a href="GHC.Utils.Misc.html#partitionByList"><span class="hs-identifier hs-var">partitionByList</span></a></span><span> </span><span class="annot"><span class="annottext">[Bool]
</span><a href="#local-6989586621681418209"><span class="hs-identifier hs-var">argTysTyVarInfo</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="GHC.Tc.Deriv.Functor.html#as_Vars"><span class="hs-identifier hs-var">as_Vars</span></a></span><span>
</span><span id="line-661"></span><span>
</span><span id="line-662"></span><span>        </span><span id="local-6989586621681418204"><span class="annot"><span class="annottext">con_expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418204"><span class="hs-identifier hs-var hs-var">con_expr</span></a></span></span><span>
</span><span id="line-663"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418208"><span class="hs-identifier hs-var">asWithTyVar</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418216"><span class="hs-identifier hs-var">con_name</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418207"><span class="hs-identifier hs-var">asWithoutTyVar</span></a></span><span>
</span><span id="line-664"></span><span>          </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-665"></span><span>              </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418203"><span class="annot"><span class="annottext">bs :: [RdrName]
</span><a href="#local-6989586621681418203"><span class="hs-identifier hs-var hs-var">bs</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Bool] -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#filterByList"><span class="hs-identifier hs-var">filterByList</span></a></span><span>  </span><span class="annot"><span class="annottext">[Bool]
</span><a href="#local-6989586621681418209"><span class="hs-identifier hs-var">argTysTyVarInfo</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span>
</span><span id="line-666"></span><span>                  </span><span id="local-6989586621681418201"><span class="annot"><span class="annottext">vars :: [LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418201"><span class="hs-identifier hs-var hs-var">vars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Bool] -&gt; [a] -&gt; [a] -&gt; [a]
</span><a href="GHC.Utils.Misc.html#filterByLists"><span class="hs-identifier hs-var">filterByLists</span></a></span><span> </span><span class="annot"><span class="annottext">[Bool]
</span><a href="#local-6989586621681418209"><span class="hs-identifier hs-var">argTysTyVarInfo</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_Vars"><span class="hs-identifier hs-var">bs_Vars</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="GHC.Tc.Deriv.Functor.html#as_Vars"><span class="hs-identifier hs-var">as_Vars</span></a></span><span>
</span><span id="line-667"></span><span>              </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
(IsPass p, XMG (GhcPass p) (LHsExpr (GhcPass p)) ~ NoExtField) =&gt;
[LPat (GhcPass p)] -&gt; LHsExpr (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#mkHsLam"><span class="hs-identifier hs-var">mkHsLam</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlVarPat"><span class="hs-identifier hs-var">nlVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="#local-6989586621681418203"><span class="hs-identifier hs-var">bs</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="#local-6989586621681418216"><span class="hs-identifier hs-var">con_name</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418201"><span class="hs-identifier hs-var">vars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-668"></span><span>
</span><span id="line-669"></span><span>    </span><span id="local-6989586621681418198"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418198"><span class="hs-identifier hs-var">rhs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418220"><span class="hs-identifier hs-var">fold</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418204"><span class="hs-identifier hs-var">con_expr</span></a></span><span> </span><span class="annot"><span class="annottext">[LocatedA (HsExpr (GhcPass 'Parsed))]
</span><a href="#local-6989586621681418213"><span class="hs-identifier hs-var">exps</span></a></span><span>
</span><span id="line-670"></span><span>    </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
IsPass p =&gt;
HsMatchContext (NoGhcTc (GhcPass p))
-&gt; [LPat (GhcPass p)]
-&gt; LHsExpr (GhcPass p)
-&gt; HsLocalBinds (GhcPass p)
-&gt; LMatch (GhcPass p) (LHsExpr (GhcPass p))
</span><a href="GHC.Hs.Utils.html#mkMatch"><span class="hs-identifier hs-var">mkMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass 'Parsed)
</span><a href="#local-6989586621681418221"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[LPat (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418219"><span class="hs-identifier hs-var">extra_pats</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="#local-6989586621681418214"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418198"><span class="hs-identifier hs-var">rhs</span></a></span><span> </span><span class="annot"><span class="annottext">forall (a :: Pass) (b :: Pass).
HsLocalBindsLR (GhcPass a) (GhcPass b)
</span><a href="GHC.Hs.Binds.html#emptyLocalBinds"><span class="hs-identifier hs-var">emptyLocalBinds</span></a></span><span>
</span><span id="line-671"></span><span>
</span><span id="line-672"></span><span class="hs-comment">-- &quot;case x of (a1,a2,a3) -&gt; fold [x1 a1, x2 a2, x3 a3]&quot;</span><span>
</span><span id="line-673"></span><span id="local-6989586621681418824"><span id="local-6989586621681418825"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-type">mkSimpleTupleCase</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418825"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681418824"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-674"></span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418825"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-675"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621681418824"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418825"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-676"></span><span id="mkSimpleTupleCase"><span class="annot"><span class="annottext">mkSimpleTupleCase :: forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var hs-var">mkSimpleTupleCase</span></a></span></span><span> </span><span id="local-6989586621681418194"><span class="annot"><span class="annottext">[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [a]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418194"><span class="hs-identifier hs-var">match_for_con</span></a></span></span><span> </span><span id="local-6989586621681418193"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418193"><span class="hs-identifier hs-var">tc</span></a></span></span><span> </span><span id="local-6989586621681418192"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681418192"><span class="hs-identifier hs-var">insides</span></a></span></span><span> </span><span id="local-6989586621681418191"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418191"><span class="hs-identifier hs-var">x</span></a></span></span><span>
</span><span id="line-677"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621681418190"><span class="annot"><span class="annottext">data_con :: DataCon
</span><a href="#local-6989586621681418190"><span class="hs-identifier hs-var hs-var">data_con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; DataCon
</span><a href="GHC.Core.TyCon.html#tyConSingleDataCon"><span class="hs-identifier hs-var">tyConSingleDataCon</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418193"><span class="hs-identifier hs-var">tc</span></a></span><span>
</span><span id="line-678"></span><span>       </span><span class="hs-special">;</span><span> </span><span id="local-6989586621681418188"><span class="annot"><span class="annottext">GenLocated
  SrcSpanAnnA
  (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418188"><span class="hs-identifier hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [a]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418194"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418190"><span class="hs-identifier hs-var">data_con</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681418192"><span class="hs-identifier hs-var">insides</span></a></span><span>
</span><span id="line-679"></span><span>       </span><span class="hs-special">;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlHsCase"><span class="hs-identifier hs-var">nlHsCase</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418191"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">GenLocated
  SrcSpanAnnA
  (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418188"><span class="hs-identifier hs-var">match</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-680"></span><span>
</span><span id="line-681"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                        Foldable instances

 see http://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html

*                                                                      *
************************************************************************

Deriving Foldable instances works the same way as Functor instances,
only Foldable instances are not possible for function types at all.
Given (data T a = T a a (T a) deriving Foldable), we get:

  instance Foldable T where
      foldr f z (T x1 x2 x3) =
        $(foldr 'a 'a) x1 ( $(foldr 'a 'a) x2 ( $(foldr 'a '(T a)) x3 z ) )

-XDeriveFoldable is different from -XDeriveFunctor in that it filters out
arguments to the constructor that would produce useless code in a Foldable
instance. For example, the following datatype:

  data Foo a = Foo Int a Int deriving Foldable

would have the following generated Foldable instance:

  instance Foldable Foo where
    foldr f z (Foo x1 x2 x3) = $(foldr 'a 'a) x2

since neither of the two Int arguments are folded over.

The cases are:

  $(foldr 'a 'a)         =  f
  $(foldr 'a '(b1,b2))   =  \x z -&gt; case x of (x1,x2) -&gt; $(foldr 'a 'b1) x1 ( $(foldr 'a 'b2) x2 z )
  $(foldr 'a '(T b1 b2)) =  \x z -&gt; foldr $(foldr 'a 'b2) z x  -- when a only occurs in the last parameter, b2

Note that the arguments to the real foldr function are the wrong way around,
since (f :: a -&gt; b -&gt; b), while (foldr f :: b -&gt; t a -&gt; b).

One can envision a case for types that don't contain the last type variable:

  $(foldr 'a 'b)         =  \x z -&gt; z     -- when b does not contain a

But this case will never materialize, since the aforementioned filtering
removes all such types from consideration.
See Note [Generated code for DeriveFoldable and DeriveTraversable].

Foldable instances differ from Functor and Traversable instances in that
Foldable instances can be derived for data types in which the last type
variable is existentially quantified. In particular, if the last type variable
is refined to a more specific type in a GADT:

  data GADT a where
      G :: a ~ Int =&gt; a -&gt; G Int

then the deriving machinery does not attempt to check that the type a contains
Int, since it is not syntactically equal to a type variable. That is, the
derived Foldable instance for GADT is:

  instance Foldable GADT where
      foldr _ z (GADT _) = z

See Note [DeriveFoldable with ExistentialQuantification].

Note [Deriving null]
~~~~~~~~~~~~~~~~~~~~

In some cases, deriving the definition of 'null' can produce much better
results than the default definition. For example, with

  data SnocList a = Nil | Snoc (SnocList a) a

the default definition of 'null' would walk the entire spine of a
nonempty snoc-list before concluding that it is not null. But looking at
the Snoc constructor, we can immediately see that it contains an 'a', and
so 'null' can return False immediately if it matches on Snoc. When we
derive 'null', we keep track of things that cannot be null. The interesting
case is type application. Given

  data Wrap a = Wrap (Foo (Bar a))

we use

  null (Wrap fba) = all null fba

but if we see

  data Wrap a = Wrap (Foo a)

we can just use

  null (Wrap fa) = null fa

Indeed, we allow this to happen even for tuples:

  data Wrap a = Wrap (Foo (a, Int))

produces

  null (Wrap fa) = null fa

As explained in Note [Deriving &lt;$], giving tuples special performance treatment
could surprise users if they switch to other types, but Ryan Scott seems to
think it's okay to do it for now.
-}</span><span>
</span><span id="line-787"></span><span>
</span><span id="line-788"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Foldable_binds"><span class="hs-identifier hs-type">gen_Foldable_binds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-type">LHsBinds</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Generate.html#BagDerivStuff"><span class="hs-identifier hs-type">BagDerivStuff</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-789"></span><span class="hs-comment">-- When the parameter is phantom, we can use foldMap _ _ = mempty</span><span>
</span><span id="line-790"></span><span class="hs-comment">-- See Note [Phantom types with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-791"></span><span id="gen_Foldable_binds"><span class="annot"><span class="annottext">gen_Foldable_binds :: SrcSpan
-&gt; TyCon -&gt; [Type] -&gt; (LHsBinds (GhcPass 'Parsed), BagDerivStuff)
</span><a href="GHC.Tc.Deriv.Functor.html#gen_Foldable_binds"><span class="hs-identifier hs-var hs-var">gen_Foldable_binds</span></a></span></span><span> </span><span id="local-6989586621681418186"><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418186"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681418185"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418185"><span class="hs-identifier hs-var">tycon</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-792"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Role
</span><a href="GHC.Core.Coercion.Axiom.html#Phantom"><span class="hs-identifier hs-var">Phantom</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-List.html#last"><span class="hs-identifier hs-var">last</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; [Role]
</span><a href="GHC.Core.TyCon.html#tyConRoles"><span class="hs-identifier hs-var">tyConRoles</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418185"><span class="hs-identifier hs-var">tycon</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-793"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unitBag"><span class="hs-identifier hs-var">unitBag</span></a></span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418184"><span class="hs-identifier hs-var">foldMap_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-794"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-795"></span><span>    </span><span id="local-6989586621681418183"><span class="annot"><span class="annottext">foldMap_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418183"><span class="hs-identifier hs-var hs-var">foldMap_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418186"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#foldMap_RDR"><span class="hs-identifier hs-var">foldMap_RDR</span></a></span><span>
</span><span id="line-796"></span><span>    </span><span id="local-6989586621681418184"><span class="annot"><span class="annottext">foldMap_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418184"><span class="hs-identifier hs-var hs-var">foldMap_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBind"><span class="hs-identifier hs-var">mkRdrFunBind</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418183"><span class="hs-identifier hs-var">foldMap_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   (Anno
      (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed)))))
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418181"><span class="hs-identifier hs-var">foldMap_eqns</span></a></span><span>
</span><span id="line-797"></span><span>    </span><span id="local-6989586621681418181"><span class="annot"><span class="annottext">foldMap_eqns :: [GenLocated
   (Anno
      (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed)))))
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418181"><span class="hs-identifier hs-var hs-var">foldMap_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (p :: Pass) (body :: * -&gt; *).
(Anno (Match (GhcPass p) (LocatedA (body (GhcPass p))))
 ~ SrcSpanAnnA,
 Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan) =&gt;
HsMatchContext (NoGhcTc (GhcPass p))
-&gt; [LPat (GhcPass p)]
-&gt; LocatedA (body (GhcPass p))
-&gt; LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
</span><a href="GHC.Hs.Utils.html#mkSimpleMatch"><span class="hs-identifier hs-var">mkSimpleMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418180"><span class="hs-identifier hs-var">foldMap_match_ctxt</span></a></span><span>
</span><span id="line-798"></span><span>                                  </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlWildPat"><span class="hs-identifier hs-var">nlWildPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlWildPat"><span class="hs-identifier hs-var">nlWildPat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-799"></span><span>                                  </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#mempty_Expr"><span class="hs-identifier hs-var">mempty_Expr</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-800"></span><span>    </span><span id="local-6989586621681418180"><span class="annot"><span class="annottext">foldMap_match_ctxt :: HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418180"><span class="hs-identifier hs-var hs-var">foldMap_match_ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. LIdP p -&gt; HsMatchContext p
</span><a href="GHC.Hs.Utils.html#mkPrefixFunRhs"><span class="hs-identifier hs-var">mkPrefixFunRhs</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418183"><span class="hs-identifier hs-var">foldMap_name</span></a></span><span>
</span><span id="line-801"></span><span>
</span><span id="line-802"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Foldable_binds"><span class="hs-identifier hs-var">gen_Foldable_binds</span></a></span><span> </span><span id="local-6989586621681418178"><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418178"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681418177"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418177"><span class="hs-identifier hs-var">tycon</span></a></span></span><span> </span><span id="local-6989586621681418176"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418176"><span class="hs-identifier hs-var">tycon_args</span></a></span></span><span>
</span><span id="line-803"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418175"><span class="hs-identifier hs-var">data_cons</span></a></span><span>  </span><span class="hs-comment">-- There's no real point producing anything but</span><span>
</span><span id="line-804"></span><span>                    </span><span class="hs-comment">-- foldMap for a type with no constructors.</span><span>
</span><span id="line-805"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unitBag"><span class="hs-identifier hs-var">unitBag</span></a></span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418174"><span class="hs-identifier hs-var">foldMap_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-806"></span><span>
</span><span id="line-807"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>
</span><span id="line-808"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#listToBag"><span class="hs-identifier hs-var">listToBag</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418173"><span class="hs-identifier hs-var">foldr_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418174"><span class="hs-identifier hs-var">foldMap_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418172"><span class="hs-identifier hs-var">null_bind</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-809"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-810"></span><span>    </span><span id="local-6989586621681418175"><span class="annot"><span class="annottext">data_cons :: [DataCon]
</span><a href="#local-6989586621681418175"><span class="hs-identifier hs-var hs-var">data_cons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; [DataCon]
</span><a href="GHC.Tc.Deriv.Generate.html#getPossibleDataCons"><span class="hs-identifier hs-var">getPossibleDataCons</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418177"><span class="hs-identifier hs-var">tycon</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418176"><span class="hs-identifier hs-var">tycon_args</span></a></span><span>
</span><span id="line-811"></span><span>
</span><span id="line-812"></span><span>    </span><span id="local-6989586621681418173"><span class="annot"><span class="annottext">foldr_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418173"><span class="hs-identifier hs-var hs-var">foldr_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBind"><span class="hs-identifier hs-var">mkRdrFunBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418178"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#foldable_foldr_RDR"><span class="hs-identifier hs-var">foldable_foldr_RDR</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418170"><span class="hs-identifier hs-var">eqns</span></a></span><span>
</span><span id="line-813"></span><span>    </span><span id="local-6989586621681418170"><span class="annot"><span class="annottext">eqns :: [GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418170"><span class="hs-identifier hs-var hs-var">eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418169"><span class="hs-identifier hs-var">foldr_eqn</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418175"><span class="hs-identifier hs-var">data_cons</span></a></span><span>
</span><span id="line-814"></span><span>    </span><span id="local-6989586621681418169"><span class="annot"><span class="annottext">foldr_eqn :: DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418169"><span class="hs-identifier hs-var hs-var">foldr_eqn</span></a></span></span><span> </span><span id="local-6989586621681418164"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418164"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-815"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; a
</span><a href="GHC.Utils.Monad.State.html#evalState"><span class="hs-identifier hs-var">evalState</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
LHsExpr (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418163"><span class="hs-identifier hs-var">match_foldr</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Expr"><span class="hs-identifier hs-var">z_Expr</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Pat"><span class="hs-identifier hs-var">f_Pat</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Pat"><span class="hs-identifier hs-var">z_Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418164"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%3D%3C%3C"><span class="hs-operator hs-var">=&lt;&lt;</span></a></span><span> </span><span class="annot"><span class="annottext">State [RdrName] [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418161"><span class="hs-identifier hs-var">parts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span>
</span><span id="line-816"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-817"></span><span>        </span><span id="local-6989586621681418161"><span class="annot"><span class="annottext">parts :: State [RdrName] [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418161"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var">foldDataConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType (State [RdrName] (Maybe (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418160"><span class="hs-identifier hs-var">ft_foldr</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418164"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-818"></span><span>
</span><span id="line-819"></span><span>    </span><span id="local-6989586621681418159"><span class="annot"><span class="annottext">foldMap_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418159"><span class="hs-identifier hs-var hs-var">foldMap_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418178"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#foldMap_RDR"><span class="hs-identifier hs-var">foldMap_RDR</span></a></span><span>
</span><span id="line-820"></span><span>
</span><span id="line-821"></span><span>    </span><span class="hs-comment">-- See Note [EmptyDataDecls with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-822"></span><span>    </span><span id="local-6989586621681418174"><span class="annot"><span class="annottext">foldMap_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418174"><span class="hs-identifier hs-var hs-var">foldMap_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; (LHsExpr (GhcPass 'Parsed) -&gt; LHsExpr (GhcPass 'Parsed))
-&gt; GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBindEC"><span class="hs-identifier hs-var">mkRdrFunBindEC</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. a -&gt; b -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#const"><span class="hs-identifier hs-var">const</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#mempty_Expr"><span class="hs-identifier hs-var">mempty_Expr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-823"></span><span>                      </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418159"><span class="hs-identifier hs-var">foldMap_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418158"><span class="hs-identifier hs-var">foldMap_eqns</span></a></span><span>
</span><span id="line-824"></span><span>
</span><span id="line-825"></span><span>    </span><span id="local-6989586621681418158"><span class="annot"><span class="annottext">foldMap_eqns :: [GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418158"><span class="hs-identifier hs-var hs-var">foldMap_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418157"><span class="hs-identifier hs-var">foldMap_eqn</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418175"><span class="hs-identifier hs-var">data_cons</span></a></span><span>
</span><span id="line-826"></span><span>
</span><span id="line-827"></span><span>    </span><span id="local-6989586621681418157"><span class="annot"><span class="annottext">foldMap_eqn :: DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418157"><span class="hs-identifier hs-var hs-var">foldMap_eqn</span></a></span></span><span> </span><span id="local-6989586621681418152"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418152"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-828"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; a
</span><a href="GHC.Utils.Monad.State.html#evalState"><span class="hs-identifier hs-var">evalState</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418151"><span class="hs-identifier hs-var">match_foldMap</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Pat"><span class="hs-identifier hs-var">f_Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418152"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%3D%3C%3C"><span class="hs-operator hs-var">=&lt;&lt;</span></a></span><span> </span><span class="annot"><span class="annottext">State [RdrName] [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418150"><span class="hs-identifier hs-var">parts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span>
</span><span id="line-829"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-830"></span><span>        </span><span id="local-6989586621681418150"><span class="annot"><span class="annottext">parts :: State [RdrName] [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418150"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var">foldDataConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType (State [RdrName] (Maybe (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418149"><span class="hs-identifier hs-var">ft_foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418152"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-831"></span><span>
</span><span id="line-832"></span><span>    </span><span class="hs-comment">-- Given a list of NullM results, produce Nothing if any of</span><span>
</span><span id="line-833"></span><span>    </span><span class="hs-comment">-- them is NotNull, and otherwise produce a list of Maybes</span><span>
</span><span id="line-834"></span><span>    </span><span class="hs-comment">-- with Justs representing unknowns and Nothings representing</span><span>
</span><span id="line-835"></span><span>    </span><span class="hs-comment">-- things that are definitely null.</span><span>
</span><span id="line-836"></span><span>    </span><span id="local-6989586621681418732"><span class="annot"><a href="#local-6989586621681418148"><span class="hs-identifier hs-type">convert</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-type">NullM</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418732"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418732"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span></span><span>
</span><span id="line-837"></span><span>    </span><span id="local-6989586621681418148"><span class="annot"><span class="annottext">convert :: forall a. [NullM a] -&gt; Maybe [Maybe a]
</span><a href="#local-6989586621681418148"><span class="hs-identifier hs-var hs-var">convert</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#traverse"><span class="hs-identifier hs-var">traverse</span></a></span><span> </span><span class="annot"><span class="annottext">forall {a}. NullM a -&gt; Maybe (Maybe a)
</span><a href="#local-6989586621681418143"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-838"></span><span>      </span><span id="local-6989586621681418143"><span class="annot"><span class="annottext">go :: NullM a -&gt; Maybe (Maybe a)
</span><a href="#local-6989586621681418143"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="annot"><span class="annottext">NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#IsNull"><span class="hs-identifier hs-var">IsNull</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-839"></span><span>      </span><span class="annot"><a href="#local-6989586621681418143"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#NotNull"><span class="hs-identifier hs-var">NotNull</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-840"></span><span>      </span><span class="annot"><a href="#local-6989586621681418143"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-type">NullM</span></a></span><span> </span><span id="local-6989586621681418139"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418139"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681418139"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-841"></span><span>
</span><span id="line-842"></span><span>    </span><span id="local-6989586621681418138"><span class="annot"><span class="annottext">null_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418138"><span class="hs-identifier hs-var hs-var">null_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418178"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#null_RDR"><span class="hs-identifier hs-var">null_RDR</span></a></span><span>
</span><span id="line-843"></span><span>    </span><span id="local-6989586621681418136"><span class="annot"><span class="annottext">null_match_ctxt :: HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418136"><span class="hs-identifier hs-var hs-var">null_match_ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. LIdP p -&gt; HsMatchContext p
</span><a href="GHC.Hs.Utils.html#mkPrefixFunRhs"><span class="hs-identifier hs-var">mkPrefixFunRhs</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418138"><span class="hs-identifier hs-var">null_name</span></a></span><span>
</span><span id="line-844"></span><span>    </span><span id="local-6989586621681418172"><span class="annot"><span class="annottext">null_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418172"><span class="hs-identifier hs-var hs-var">null_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBind"><span class="hs-identifier hs-var">mkRdrFunBind</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418138"><span class="hs-identifier hs-var">null_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418135"><span class="hs-identifier hs-var">null_eqns</span></a></span><span>
</span><span id="line-845"></span><span>    </span><span id="local-6989586621681418135"><span class="annot"><span class="annottext">null_eqns :: [GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418135"><span class="hs-identifier hs-var hs-var">null_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418134"><span class="hs-identifier hs-var">null_eqn</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418175"><span class="hs-identifier hs-var">data_cons</span></a></span><span>
</span><span id="line-846"></span><span>    </span><span id="local-6989586621681418134"><span class="annot"><span class="annottext">null_eqn :: DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418134"><span class="hs-identifier hs-var hs-var">null_eqn</span></a></span></span><span> </span><span id="local-6989586621681418133"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418133"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-847"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; a
</span><a href="GHC.Utils.Monad.State.html#evalState"><span class="hs-identifier hs-var">evalState</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-848"></span><span>          </span><span id="local-6989586621681418132"><span class="annot"><span class="annottext">[NullM (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418132"><span class="hs-identifier hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var">foldDataConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType (State [RdrName] (NullM (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418131"><span class="hs-identifier hs-var">ft_null</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418133"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-849"></span><span>          </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall a. [NullM a] -&gt; Maybe [Maybe a]
</span><a href="#local-6989586621681418148"><span class="hs-identifier hs-var">convert</span></a></span><span> </span><span class="annot"><span class="annottext">[NullM (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418132"><span class="hs-identifier hs-var">parts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-850"></span><span>            </span><span class="annot"><span class="annottext">Maybe [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-851"></span><span>              </span><span class="annot"><span class="annottext">forall (p :: Pass).
IsPass p =&gt;
HsMatchContext (NoGhcTc (GhcPass p))
-&gt; [LPat (GhcPass p)]
-&gt; LHsExpr (GhcPass p)
-&gt; HsLocalBinds (GhcPass p)
-&gt; LMatch (GhcPass p) (LHsExpr (GhcPass p))
</span><a href="GHC.Hs.Utils.html#mkMatch"><span class="hs-identifier hs-var">mkMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418136"><span class="hs-identifier hs-var">null_match_ctxt</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (name :: Pass). LPat (GhcPass name) -&gt; LPat (GhcPass name)
</span><a href="GHC.Hs.Utils.html#nlParPat"><span class="hs-identifier hs-var">nlParPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlWildConPat"><span class="hs-identifier hs-var">nlWildConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418133"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-852"></span><span>                </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#false_Expr"><span class="hs-identifier hs-var">false_Expr</span></a></span><span> </span><span class="annot"><span class="annottext">forall (a :: Pass) (b :: Pass).
HsLocalBindsLR (GhcPass a) (GhcPass b)
</span><a href="GHC.Hs.Binds.html#emptyLocalBinds"><span class="hs-identifier hs-var">emptyLocalBinds</span></a></span><span>
</span><span id="line-853"></span><span>            </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621681418128"><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418128"><span class="hs-identifier hs-var">cp</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418127"><span class="hs-identifier hs-var">match_null</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418133"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418128"><span class="hs-identifier hs-var">cp</span></a></span><span>
</span><span id="line-854"></span><span>
</span><span id="line-855"></span><span>    </span><span class="hs-comment">-- Yields 'Just' an expression if we're folding over a type that mentions</span><span>
</span><span id="line-856"></span><span>    </span><span class="hs-comment">-- the last type parameter of the datatype. Otherwise, yields 'Nothing'.</span><span>
</span><span id="line-857"></span><span>    </span><span class="hs-comment">-- See Note [FFoldType and functorLikeTraverse]</span><span>
</span><span id="line-858"></span><span>    </span><span class="annot"><a href="#local-6989586621681418160"><span class="hs-identifier hs-type">ft_foldr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-859"></span><span>    </span><span id="local-6989586621681418160"><span class="annot"><span class="annottext">ft_foldr :: FFoldType (State [RdrName] (Maybe (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418160"><span class="hs-identifier hs-var hs-var">ft_foldr</span></a></span></span><span>
</span><span id="line-860"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-861"></span><span>             </span><span class="hs-comment">-- foldr f = \x z -&gt; z</span><span>
</span><span id="line-862"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-var">f_Expr</span></a></span><span>
</span><span id="line-863"></span><span>             </span><span class="hs-comment">-- foldr f = f</span><span>
</span><span id="line-864"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon
-&gt; [State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418126"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418126"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621681418125"><span class="annot"><span class="annottext">[State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418125"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-865"></span><span>               </span><span id="local-6989586621681418124"><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418124"><span class="hs-identifier hs-var">gg</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">[State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418125"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-866"></span><span>               </span><span id="local-6989586621681418123"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418123"><span class="hs-identifier hs-var">lam</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam2"><span class="hs-identifier hs-var">mkSimpleLam2</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418122"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418122"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681418121"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418121"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-867"></span><span>                 </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var">mkSimpleTupleCase</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
LHsExpr (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418163"><span class="hs-identifier hs-var">match_foldr</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418121"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418126"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418124"><span class="hs-identifier hs-var">gg</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418122"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-868"></span><span>               </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418123"><span class="hs-identifier hs-var">lam</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-869"></span><span>             </span><span class="hs-comment">-- foldr f = (\x z -&gt; case x of ...)</span><span>
</span><span id="line-870"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type
-&gt; Type
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418120"><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418120"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-871"></span><span>               </span><span id="local-6989586621681418119"><span class="annot"><span class="annottext">Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418119"><span class="hs-identifier hs-var">gg</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418120"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-872"></span><span>               </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#mapM"><span class="hs-identifier hs-var">mapM</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681418117"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418117"><span class="hs-identifier hs-var">gg'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam2"><span class="hs-identifier hs-var">mkSimpleLam2</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418116"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418116"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681418115"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418115"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-873"></span><span>                 </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#foldable_foldr_RDR"><span class="hs-identifier hs-var">foldable_foldr_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418117"><span class="hs-identifier hs-var">gg'</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418115"><span class="hs-identifier hs-var">z</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418116"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418119"><span class="hs-identifier hs-var">gg</span></a></span><span>
</span><span id="line-874"></span><span>             </span><span class="hs-comment">-- foldr f = (\x z -&gt; foldr g z x)</span><span>
</span><span id="line-875"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Id
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418114"><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418114"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418114"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-876"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in ft_foldr&quot;</span></span><span>
</span><span id="line-877"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;function in ft_foldr&quot;</span></span><span>
</span><span id="line-878"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in ft_foldr&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-879"></span><span>
</span><span id="line-880"></span><span>    </span><span id="local-6989586621681418737"><span class="annot"><a href="#local-6989586621681418163"><span class="hs-identifier hs-type">match_foldr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418737"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-881"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-882"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-883"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-884"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-885"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418737"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-886"></span><span>    </span><span id="local-6989586621681418163"><span class="annot"><span class="annottext">match_foldr :: forall (m :: * -&gt; *).
Monad m =&gt;
LHsExpr (GhcPass 'Parsed)
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418163"><span class="hs-identifier hs-var hs-var">match_foldr</span></a></span></span><span> </span><span id="local-6989586621681418108"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418108"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (LHsExpr (GhcPass 'Parsed)
    -&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch2"><span class="hs-identifier hs-var">mkSimpleConMatch2</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#LambdaExpr"><span class="hs-identifier hs-var">LambdaExpr</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418106"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418106"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418105"><span class="hs-identifier hs-var">mkFoldr</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418106"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-887"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-888"></span><span>        </span><span class="hs-comment">-- g1 v1 (g2 v2 (.. z))</span><span>
</span><span id="line-889"></span><span>        </span><span class="annot"><a href="#local-6989586621681418105"><span class="hs-identifier hs-type">mkFoldr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-890"></span><span>        </span><span id="local-6989586621681418105"><span class="annot"><span class="annottext">mkFoldr :: [LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418105"><span class="hs-identifier hs-var hs-var">mkFoldr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#foldr"><span class="hs-identifier hs-var">foldr</span></a></span><span> </span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418108"><span class="hs-identifier hs-var">z</span></a></span><span>
</span><span id="line-891"></span><span>
</span><span id="line-892"></span><span>    </span><span class="hs-comment">-- See Note [FFoldType and functorLikeTraverse]</span><span>
</span><span id="line-893"></span><span>    </span><span class="annot"><a href="#local-6989586621681418149"><span class="hs-identifier hs-type">ft_foldMap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-894"></span><span>    </span><span id="local-6989586621681418149"><span class="annot"><span class="annottext">ft_foldMap :: FFoldType (State [RdrName] (Maybe (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418149"><span class="hs-identifier hs-var hs-var">ft_foldMap</span></a></span></span><span>
</span><span id="line-895"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-896"></span><span>             </span><span class="hs-comment">-- foldMap f = \x -&gt; mempty</span><span>
</span><span id="line-897"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-var">f_Expr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-898"></span><span>             </span><span class="hs-comment">-- foldMap f = f</span><span>
</span><span id="line-899"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon
-&gt; [State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418103"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418103"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621681418102"><span class="annot"><span class="annottext">[State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418102"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-900"></span><span>               </span><span id="local-6989586621681418101"><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418101"><span class="hs-identifier hs-var">gg</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">[State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418102"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-901"></span><span>               </span><span id="local-6989586621681418100"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418100"><span class="hs-identifier hs-var">lam</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var">mkSimpleTupleCase</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418151"><span class="hs-identifier hs-var">match_foldMap</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418103"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418101"><span class="hs-identifier hs-var">gg</span></a></span><span>
</span><span id="line-902"></span><span>               </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418100"><span class="hs-identifier hs-var">lam</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-903"></span><span>             </span><span class="hs-comment">-- foldMap f = \x -&gt; case x of (..,)</span><span>
</span><span id="line-904"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type
-&gt; Type
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418099"><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418099"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#foldMap_Expr"><span class="hs-identifier hs-var">foldMap_Expr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/Data-Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418099"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-905"></span><span>             </span><span class="hs-comment">-- foldMap f = foldMap g</span><span>
</span><span id="line-906"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Id
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418097"><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418097"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418097"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-907"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in ft_foldMap&quot;</span></span><span>
</span><span id="line-908"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;function in ft_foldMap&quot;</span></span><span>
</span><span id="line-909"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in ft_foldMap&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-910"></span><span>
</span><span id="line-911"></span><span>    </span><span id="local-6989586621681418733"><span class="annot"><a href="#local-6989586621681418151"><span class="hs-identifier hs-type">match_foldMap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418733"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-912"></span><span>                  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-913"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-914"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-915"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418733"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-916"></span><span>    </span><span id="local-6989586621681418151"><span class="annot"><span class="annottext">match_foldMap :: forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418151"><span class="hs-identifier hs-var hs-var">match_foldMap</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (LHsExpr (GhcPass 'Parsed)
    -&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch2"><span class="hs-identifier hs-var">mkSimpleConMatch2</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418089"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418089"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418088"><span class="hs-identifier hs-var">mkFoldMap</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418089"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-917"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-918"></span><span>        </span><span class="hs-comment">-- mappend v1 (mappend v2 ..)</span><span>
</span><span id="line-919"></span><span>        </span><span class="annot"><a href="#local-6989586621681418088"><span class="hs-identifier hs-type">mkFoldMap</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-920"></span><span>        </span><span id="local-6989586621681418088"><span class="annot"><span class="annottext">mkFoldMap :: [LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418088"><span class="hs-identifier hs-var hs-var">mkFoldMap</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#mempty_Expr"><span class="hs-identifier hs-var">mempty_Expr</span></a></span><span>
</span><span id="line-921"></span><span>        </span><span class="annot"><a href="#local-6989586621681418088"><span class="hs-identifier hs-var">mkFoldMap</span></a></span><span> </span><span id="local-6989586621681418087"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418087"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#foldr1"><span class="hs-identifier hs-var">foldr1</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681418085"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418085"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681418084"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418084"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#mappend_RDR"><span class="hs-identifier hs-var">mappend_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418085"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418084"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418087"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-922"></span><span>
</span><span id="line-923"></span><span>    </span><span class="hs-comment">-- See Note [FFoldType and functorLikeTraverse]</span><span>
</span><span id="line-924"></span><span>    </span><span class="hs-comment">-- Yields NullM an expression if we're folding over an expression</span><span>
</span><span id="line-925"></span><span>    </span><span class="hs-comment">-- that may or may not be null. Yields IsNull if it's certainly</span><span>
</span><span id="line-926"></span><span>    </span><span class="hs-comment">-- null, and yields NotNull if it's certainly not null.</span><span>
</span><span id="line-927"></span><span>    </span><span class="hs-comment">-- See Note [Deriving null]</span><span>
</span><span id="line-928"></span><span>    </span><span class="annot"><a href="#local-6989586621681418131"><span class="hs-identifier hs-type">ft_null</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-type">NullM</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-929"></span><span>    </span><span id="local-6989586621681418131"><span class="annot"><span class="annottext">ft_null :: FFoldType (State [RdrName] (NullM (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418131"><span class="hs-identifier hs-var hs-var">ft_null</span></a></span></span><span>
</span><span id="line-930"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#IsNull"><span class="hs-identifier hs-var">IsNull</span></a></span><span>
</span><span id="line-931"></span><span>             </span><span class="hs-comment">-- null = \_ -&gt; True</span><span>
</span><span id="line-932"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#NotNull"><span class="hs-identifier hs-var">NotNull</span></a></span><span>
</span><span id="line-933"></span><span>             </span><span class="hs-comment">-- null = \_ -&gt; False</span><span>
</span><span id="line-934"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon
-&gt; [State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))]
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418082"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418082"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621681418081"><span class="annot"><span class="annottext">[State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418081"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-935"></span><span>               </span><span id="local-6989586621681418080"><span class="annot"><span class="annottext">[NullM (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418080"><span class="hs-identifier hs-var">gg</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">[State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418081"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-936"></span><span>               </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall a. [NullM a] -&gt; Maybe [Maybe a]
</span><a href="#local-6989586621681418148"><span class="hs-identifier hs-var">convert</span></a></span><span> </span><span class="annot"><span class="annottext">[NullM (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418080"><span class="hs-identifier hs-var">gg</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-937"></span><span>                 </span><span class="annot"><span class="annottext">Maybe [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#pure"><span class="hs-identifier hs-var">pure</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#NotNull"><span class="hs-identifier hs-var">NotNull</span></a></span><span>
</span><span id="line-938"></span><span>                 </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span id="local-6989586621681418079"><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418079"><span class="hs-identifier hs-var">ggg</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-939"></span><span>                   </span><span class="annot"><span class="annottext">forall a. a -&gt; NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-var">NullM</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/Data-Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var">mkSimpleTupleCase</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418127"><span class="hs-identifier hs-var">match_null</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418082"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418079"><span class="hs-identifier hs-var">ggg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-940"></span><span>             </span><span class="hs-comment">-- null = \x -&gt; case x of (..,)</span><span>
</span><span id="line-941"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type
-&gt; Type
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418078"><span class="annot"><span class="annottext">State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418078"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#flip"><span class="hs-identifier hs-var">flip</span></a></span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418078"><span class="hs-identifier hs-var">g</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418077"><span class="annot"><span class="annottext">NullM (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418077"><span class="hs-identifier hs-var">nestedResult</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-942"></span><span>                              </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">NullM (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418077"><span class="hs-identifier hs-var">nestedResult</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-943"></span><span>                                </span><span class="hs-comment">-- If e definitely contains the parameter,</span><span>
</span><span id="line-944"></span><span>                                </span><span class="hs-comment">-- then we can test if (G e) contains it by</span><span>
</span><span id="line-945"></span><span>                                </span><span class="hs-comment">-- simply checking if (G e) is null</span><span>
</span><span id="line-946"></span><span>                                </span><span class="annot"><span class="annottext">NullM (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#NotNull"><span class="hs-identifier hs-var">NotNull</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-var">NullM</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#null_Expr"><span class="hs-identifier hs-var">null_Expr</span></a></span><span>
</span><span id="line-947"></span><span>                                </span><span class="hs-comment">-- This case is unreachable--it will actually be</span><span>
</span><span id="line-948"></span><span>                                </span><span class="hs-comment">-- caught by ft_triv</span><span>
</span><span id="line-949"></span><span>                                </span><span class="annot"><span class="annottext">NullM (LocatedA (HsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#IsNull"><span class="hs-identifier hs-var">IsNull</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#IsNull"><span class="hs-identifier hs-var">IsNull</span></a></span><span>
</span><span id="line-950"></span><span>                                </span><span class="hs-comment">-- The general case uses (all null),</span><span>
</span><span id="line-951"></span><span>                                </span><span class="hs-comment">-- (all (all null)), etc.</span><span>
</span><span id="line-952"></span><span>                                </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-type">NullM</span></a></span><span> </span><span id="local-6989586621681418075"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418075"><span class="hs-identifier hs-var">nestedTest</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; NullM a
</span><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-var">NullM</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-953"></span><span>                                                    </span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#all_Expr"><span class="hs-identifier hs-var">all_Expr</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418075"><span class="hs-identifier hs-var">nestedTest</span></a></span><span>
</span><span id="line-954"></span><span>             </span><span class="hs-comment">-- null fa = null fa, or null fa = all null fa, or null fa = True</span><span>
</span><span id="line-955"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Id
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418073"><span class="annot"><span class="annottext">State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418073"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418073"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-956"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in ft_null&quot;</span></span><span>
</span><span id="line-957"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;function in ft_null&quot;</span></span><span>
</span><span id="line-958"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: State [RdrName] (NullM (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in ft_null&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-959"></span><span>
</span><span id="line-960"></span><span>    </span><span id="local-6989586621681418072"><span class="annot"><a href="#local-6989586621681418127"><span class="hs-identifier hs-type">match_null</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418072"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-961"></span><span>               </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-962"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-963"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-964"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418072"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-965"></span><span>    </span><span id="local-6989586621681418127"><span class="annot"><span class="annottext">match_null :: forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418127"><span class="hs-identifier hs-var hs-var">match_null</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (LHsExpr (GhcPass 'Parsed)
    -&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch2"><span class="hs-identifier hs-var">mkSimpleConMatch2</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418064"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418064"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418063"><span class="hs-identifier hs-var">mkNull</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418064"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-966"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-967"></span><span>        </span><span class="hs-comment">-- v1 &amp;&amp; v2 &amp;&amp; ..</span><span>
</span><span id="line-968"></span><span>        </span><span class="annot"><a href="#local-6989586621681418063"><span class="hs-identifier hs-type">mkNull</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-969"></span><span>        </span><span id="local-6989586621681418063"><span class="annot"><span class="annottext">mkNull :: [LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418063"><span class="hs-identifier hs-var hs-var">mkNull</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#true_Expr"><span class="hs-identifier hs-var">true_Expr</span></a></span><span>
</span><span id="line-970"></span><span>        </span><span class="annot"><a href="#local-6989586621681418063"><span class="hs-identifier hs-var">mkNull</span></a></span><span> </span><span id="local-6989586621681418061"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418061"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; a -&gt; a) -&gt; t a -&gt; a
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#foldr1"><span class="hs-identifier hs-var">foldr1</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681418060"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418060"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681418059"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418059"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#and_RDR"><span class="hs-identifier hs-var">and_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418060"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418059"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418061"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-971"></span><span>
</span><span id="line-972"></span><span class="hs-keyword">data</span><span> </span><span id="NullM"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-var">NullM</span></a></span></span><span> </span><span id="local-6989586621681418715"><span class="annot"><a href="#local-6989586621681418715"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-973"></span><span>    </span><span id="IsNull"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#IsNull"><span class="hs-identifier hs-var">IsNull</span></a></span></span><span>   </span><span class="hs-comment">-- Definitely null</span><span>
</span><span id="line-974"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NotNull"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NotNull"><span class="hs-identifier hs-var">NotNull</span></a></span></span><span>  </span><span class="hs-comment">-- Definitely not null</span><span>
</span><span id="line-975"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NullM"><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#NullM"><span class="hs-identifier hs-var">NullM</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621681418715"><span class="hs-identifier hs-type">a</span></a></span><span>  </span><span class="hs-comment">-- Unknown</span><span>
</span><span id="line-976"></span><span>
</span><span id="line-977"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                        Traversable instances

 see http://www.mail-archive.com/haskell-prime@haskell.org/msg02116.html
*                                                                      *
************************************************************************

Again, Traversable is much like Functor and Foldable.

The cases are:

  $(traverse 'a 'a)          =  f
  $(traverse 'a '(b1,b2))    =  \x -&gt; case x of (x1,x2) -&gt;
     liftA2 (,) ($(traverse 'a 'b1) x1) ($(traverse 'a 'b2) x2)
  $(traverse 'a '(T b1 b2))  =  traverse $(traverse 'a 'b2)  -- when a only occurs in the last parameter, b2

Like -XDeriveFoldable, -XDeriveTraversable filters out arguments whose types
do not mention the last type parameter. Therefore, the following datatype:

  data Foo a = Foo Int a Int

would have the following derived Traversable instance:

  instance Traversable Foo where
    traverse f (Foo x1 x2 x3) =
      fmap (\b2 -&gt; Foo x1 b2 x3) ( $(traverse 'a 'a) x2 )

since the two Int arguments do not produce any effects in a traversal.

One can envision a case for types that do not mention the last type parameter:

  $(traverse 'a 'b)          =  pure     -- when b does not contain a

But this case will never materialize, since the aforementioned filtering
removes all such types from consideration.
See Note [Generated code for DeriveFoldable and DeriveTraversable].
-}</span><span>
</span><span id="line-1016"></span><span>
</span><span id="line-1017"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Traversable_binds"><span class="hs-identifier hs-type">gen_Traversable_binds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html#TyCon"><span class="hs-identifier hs-type">TyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-type">LHsBinds</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Generate.html#BagDerivStuff"><span class="hs-identifier hs-type">BagDerivStuff</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1018"></span><span class="hs-comment">-- When the argument is phantom, we can use traverse = pure . coerce</span><span>
</span><span id="line-1019"></span><span class="hs-comment">-- See Note [Phantom types with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-1020"></span><span id="gen_Traversable_binds"><span class="annot"><span class="annottext">gen_Traversable_binds :: SrcSpan
-&gt; TyCon -&gt; [Type] -&gt; (LHsBinds (GhcPass 'Parsed), BagDerivStuff)
</span><a href="GHC.Tc.Deriv.Functor.html#gen_Traversable_binds"><span class="hs-identifier hs-var hs-var">gen_Traversable_binds</span></a></span></span><span> </span><span id="local-6989586621681418057"><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418057"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681418056"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418056"><span class="hs-identifier hs-var">tycon</span></a></span></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-1021"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Role
</span><a href="GHC.Core.Coercion.Axiom.html#Phantom"><span class="hs-identifier hs-var">Phantom</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; a
</span><a href="../../base-4.16.4.0/src/GHC-List.html#last"><span class="hs-identifier hs-var">last</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; [Role]
</span><a href="GHC.Core.TyCon.html#tyConRoles"><span class="hs-identifier hs-var">tyConRoles</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418056"><span class="hs-identifier hs-var">tycon</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1022"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unitBag"><span class="hs-identifier hs-var">unitBag</span></a></span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418055"><span class="hs-identifier hs-var">traverse_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1023"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1024"></span><span>    </span><span id="local-6989586621681418054"><span class="annot"><span class="annottext">traverse_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418054"><span class="hs-identifier hs-var hs-var">traverse_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418057"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#traverse_RDR"><span class="hs-identifier hs-var">traverse_RDR</span></a></span><span>
</span><span id="line-1025"></span><span>    </span><span id="local-6989586621681418055"><span class="annot"><span class="annottext">traverse_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418055"><span class="hs-identifier hs-var hs-var">traverse_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBind"><span class="hs-identifier hs-var">mkRdrFunBind</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418054"><span class="hs-identifier hs-var">traverse_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   (Anno
      (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed)))))
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418052"><span class="hs-identifier hs-var">traverse_eqns</span></a></span><span>
</span><span id="line-1026"></span><span>    </span><span id="local-6989586621681418052"><span class="annot"><span class="annottext">traverse_eqns :: [GenLocated
   (Anno
      (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed)))))
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418052"><span class="hs-identifier hs-var hs-var">traverse_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1027"></span><span>        </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (p :: Pass) (body :: * -&gt; *).
(Anno (Match (GhcPass p) (LocatedA (body (GhcPass p))))
 ~ SrcSpanAnnA,
 Anno (GRHS (GhcPass p) (LocatedA (body (GhcPass p)))) ~ SrcSpan) =&gt;
HsMatchContext (NoGhcTc (GhcPass p))
-&gt; [LPat (GhcPass p)]
-&gt; LocatedA (body (GhcPass p))
-&gt; LMatch (GhcPass p) (LocatedA (body (GhcPass p)))
</span><a href="GHC.Hs.Utils.html#mkSimpleMatch"><span class="hs-identifier hs-var">mkSimpleMatch</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418051"><span class="hs-identifier hs-var">traverse_match_ctxt</span></a></span><span>
</span><span id="line-1028"></span><span>                       </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Hs.Utils.html#nlWildPat"><span class="hs-identifier hs-var">nlWildPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Pat"><span class="hs-identifier hs-var">z_Pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1029"></span><span>                       </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#pure_RDR"><span class="hs-identifier hs-var">pure_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#coerce_Expr"><span class="hs-identifier hs-var">coerce_Expr</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Expr"><span class="hs-identifier hs-var">z_Expr</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1030"></span><span>    </span><span id="local-6989586621681418051"><span class="annot"><span class="annottext">traverse_match_ctxt :: HsMatchContext (GhcPass (NoGhcTcPass 'Parsed))
</span><a href="#local-6989586621681418051"><span class="hs-identifier hs-var hs-var">traverse_match_ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. LIdP p -&gt; HsMatchContext p
</span><a href="GHC.Hs.Utils.html#mkPrefixFunRhs"><span class="hs-identifier hs-var">mkPrefixFunRhs</span></a></span><span> </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418054"><span class="hs-identifier hs-var">traverse_name</span></a></span><span>
</span><span id="line-1031"></span><span>
</span><span id="line-1032"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#gen_Traversable_binds"><span class="hs-identifier hs-var">gen_Traversable_binds</span></a></span><span> </span><span id="local-6989586621681418049"><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418049"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681418048"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418048"><span class="hs-identifier hs-var">tycon</span></a></span></span><span> </span><span id="local-6989586621681418047"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418047"><span class="hs-identifier hs-var">tycon_args</span></a></span></span><span>
</span><span id="line-1033"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unitBag"><span class="hs-identifier hs-var">unitBag</span></a></span><span> </span><span class="annot"><span class="annottext">LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418046"><span class="hs-identifier hs-var">traverse_bind</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1034"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1035"></span><span>    </span><span id="local-6989586621681418045"><span class="annot"><span class="annottext">data_cons :: [DataCon]
</span><a href="#local-6989586621681418045"><span class="hs-identifier hs-var hs-var">data_cons</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyCon -&gt; [Type] -&gt; [DataCon]
</span><a href="GHC.Tc.Deriv.Generate.html#getPossibleDataCons"><span class="hs-identifier hs-var">getPossibleDataCons</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418048"><span class="hs-identifier hs-var">tycon</span></a></span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681418047"><span class="hs-identifier hs-var">tycon_args</span></a></span><span>
</span><span id="line-1036"></span><span>
</span><span id="line-1037"></span><span>    </span><span id="local-6989586621681418044"><span class="annot"><span class="annottext">traverse_name :: GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418044"><span class="hs-identifier hs-var hs-var">traverse_name</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall ann. SrcSpan -&gt; SrcAnn ann
</span><a href="GHC.Parser.Annotation.html#noAnnSrcSpan"><span class="hs-identifier hs-var">noAnnSrcSpan</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpan
</span><a href="#local-6989586621681418049"><span class="hs-identifier hs-var">loc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#traverse_RDR"><span class="hs-identifier hs-var">traverse_RDR</span></a></span><span>
</span><span id="line-1038"></span><span>
</span><span id="line-1039"></span><span>    </span><span class="hs-comment">-- See Note [EmptyDataDecls with Functor, Foldable, and Traversable]</span><span>
</span><span id="line-1040"></span><span>    </span><span id="local-6989586621681418046"><span class="annot"><span class="annottext">traverse_bind :: LHsBind (GhcPass 'Parsed)
</span><a href="#local-6989586621681418046"><span class="hs-identifier hs-var hs-var">traverse_bind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int
-&gt; (LHsExpr (GhcPass 'Parsed) -&gt; LHsExpr (GhcPass 'Parsed))
-&gt; GenLocated SrcSpanAnnN RdrName
-&gt; [LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))]
-&gt; LHsBind (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Generate.html#mkRdrFunBindEC"><span class="hs-identifier hs-var">mkRdrFunBindEC</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">2</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#pure_Expr"><span class="hs-identifier hs-var">pure_Expr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1041"></span><span>                                   </span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnN RdrName
</span><a href="#local-6989586621681418044"><span class="hs-identifier hs-var">traverse_name</span></a></span><span> </span><span class="annot"><span class="annottext">[GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418042"><span class="hs-identifier hs-var">traverse_eqns</span></a></span><span>
</span><span id="line-1042"></span><span>    </span><span id="local-6989586621681418042"><span class="annot"><span class="annottext">traverse_eqns :: [GenLocated
   SrcSpanAnnA
   (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418042"><span class="hs-identifier hs-var hs-var">traverse_eqns</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418041"><span class="hs-identifier hs-var">traverse_eqn</span></a></span><span> </span><span class="annot"><span class="annottext">[DataCon]
</span><a href="#local-6989586621681418045"><span class="hs-identifier hs-var">data_cons</span></a></span><span>
</span><span id="line-1043"></span><span>    </span><span id="local-6989586621681418041"><span class="annot"><span class="annottext">traverse_eqn :: DataCon
-&gt; GenLocated
     SrcSpanAnnA
     (Match (GhcPass 'Parsed) (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418041"><span class="hs-identifier hs-var hs-var">traverse_eqn</span></a></span></span><span> </span><span id="local-6989586621681418036"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418036"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-1044"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall s a. State s a -&gt; s -&gt; a
</span><a href="GHC.Utils.Monad.State.html#evalState"><span class="hs-identifier hs-var">evalState</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418035"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Pat"><span class="hs-identifier hs-var">f_Pat</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418036"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%3D%3C%3C"><span class="hs-operator hs-var">=&lt;&lt;</span></a></span><span> </span><span class="annot"><span class="annottext">State [RdrName] [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418034"><span class="hs-identifier hs-var">parts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span>
</span><span id="line-1045"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-1046"></span><span>        </span><span id="local-6989586621681418034"><span class="annot"><span class="annottext">parts :: State [RdrName] [Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418034"><span class="hs-identifier hs-var hs-var">parts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. FFoldType a -&gt; DataCon -&gt; [a]
</span><a href="GHC.Tc.Deriv.Functor.html#foldDataConArgs"><span class="hs-identifier hs-var">foldDataConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">FFoldType (State [RdrName] (Maybe (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418033"><span class="hs-identifier hs-var">ft_trav</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681418036"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-1047"></span><span>
</span><span id="line-1048"></span><span>    </span><span class="hs-comment">-- Yields 'Just' an expression if we're folding over a type that mentions</span><span>
</span><span id="line-1049"></span><span>    </span><span class="hs-comment">-- the last type parameter of the datatype. Otherwise, yields 'Nothing'.</span><span>
</span><span id="line-1050"></span><span>    </span><span class="hs-comment">-- See Note [FFoldType and functorLikeTraverse]</span><span>
</span><span id="line-1051"></span><span>    </span><span class="annot"><a href="#local-6989586621681418033"><span class="hs-identifier hs-type">ft_trav</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FFoldType"><span class="hs-identifier hs-type">FFoldType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Monad.State.html#State"><span class="hs-identifier hs-type">State</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1052"></span><span>    </span><span id="local-6989586621681418033"><span class="annot"><span class="annottext">ft_trav :: FFoldType (State [RdrName] (Maybe (LHsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418033"><span class="hs-identifier hs-var hs-var">ft_trav</span></a></span></span><span>
</span><span id="line-1053"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#FT"><span class="hs-identifier hs-type">FT</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">ft_triv :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_triv"><span class="hs-identifier hs-var">ft_triv</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-1054"></span><span>             </span><span class="hs-comment">-- traverse f = pure x</span><span>
</span><span id="line-1055"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_var :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_var"><span class="hs-identifier hs-var">ft_var</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-var">f_Expr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1056"></span><span>             </span><span class="hs-comment">-- traverse f = f x</span><span>
</span><span id="line-1057"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_tup :: TyCon
-&gt; [State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_tup"><span class="hs-identifier hs-var">ft_tup</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681418032"><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418032"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621681418031"><span class="annot"><span class="annottext">[State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418031"><span class="hs-identifier hs-var">gs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1058"></span><span>               </span><span id="local-6989586621681418030"><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418030"><span class="hs-identifier hs-var">gg</span></a></span></span><span>  </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><a href="../../base-4.16.4.0/src/Data-Traversable.html#sequence"><span class="hs-identifier hs-var">sequence</span></a></span><span> </span><span class="annot"><span class="annottext">[State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))]
</span><a href="#local-6989586621681418031"><span class="hs-identifier hs-var">gs</span></a></span><span>
</span><span id="line-1059"></span><span>               </span><span id="local-6989586621681418029"><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418029"><span class="hs-identifier hs-var">lam</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(LHsExpr (GhcPass 'Parsed)
 -&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed)))
-&gt; State [RdrName] (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleLam"><span class="hs-identifier hs-var">mkSimpleLam</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a.
Monad m =&gt;
([LPat (GhcPass 'Parsed)]
 -&gt; DataCon
 -&gt; [a]
 -&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed))))
-&gt; TyCon
-&gt; [a]
-&gt; LHsExpr (GhcPass 'Parsed)
-&gt; m (LHsExpr (GhcPass 'Parsed))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleTupleCase"><span class="hs-identifier hs-var">mkSimpleTupleCase</span></a></span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418035"><span class="hs-identifier hs-var">match_for_con</span></a></span><span> </span><span class="annot"><span class="annottext">TyCon
</span><a href="#local-6989586621681418032"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Maybe (LocatedA (HsExpr (GhcPass 'Parsed)))]
</span><a href="#local-6989586621681418030"><span class="hs-identifier hs-var">gg</span></a></span><span>
</span><span id="line-1060"></span><span>               </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="annot"><span class="annottext">LocatedA (HsExpr (GhcPass 'Parsed))
</span><a href="#local-6989586621681418029"><span class="hs-identifier hs-var">lam</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1061"></span><span>             </span><span class="hs-comment">-- traverse f = \x -&gt; case x of (a1,a2,..) -&gt;</span><span>
</span><span id="line-1062"></span><span>             </span><span class="hs-comment">--                           liftA2 (,,) (g1 a1) (g2 a2) &lt;*&gt; ..</span><span>
</span><span id="line-1063"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_ty_app :: Type
-&gt; Type
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_ty_app"><span class="hs-identifier hs-var">ft_ty_app</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418028"><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418028"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (id :: Pass).
IsPass id =&gt;
LHsExpr (GhcPass id)
-&gt; LHsExpr (GhcPass id) -&gt; LHsExpr (GhcPass id)
</span><a href="GHC.Hs.Utils.html#nlHsApp"><span class="hs-identifier hs-var">nlHsApp</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#traverse_Expr"><span class="hs-identifier hs-var">traverse_Expr</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/Data-Functor.html#%3C%24%3E"><span class="hs-operator hs-var">&lt;$&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418028"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-1064"></span><span>             </span><span class="hs-comment">-- traverse f = traverse g</span><span>
</span><span id="line-1065"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_forall :: Id
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_forall"><span class="hs-identifier hs-var">ft_forall</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-glyph">\</span><span class="annot"><span class="annottext">Id
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681418026"><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418026"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="#local-6989586621681418026"><span class="hs-identifier hs-var">g</span></a></span><span>
</span><span id="line-1066"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_co_var :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_co_var"><span class="hs-identifier hs-var">ft_co_var</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;contravariant in ft_trav&quot;</span></span><span>
</span><span id="line-1067"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_fun :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
-&gt; State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_fun"><span class="hs-identifier hs-var">ft_fun</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;function in ft_trav&quot;</span></span><span>
</span><span id="line-1068"></span><span>           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">ft_bad_app :: State [RdrName] (Maybe (LocatedA (HsExpr (GhcPass 'Parsed))))
</span><a href="GHC.Tc.Deriv.Functor.html#ft_bad_app"><span class="hs-identifier hs-var">ft_bad_app</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;in other argument in ft_trav&quot;</span></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-1069"></span><span>
</span><span id="line-1070"></span><span>    </span><span class="hs-comment">-- Con a1 a2 ... -&gt; liftA2 (\b1 b2 ... -&gt; Con b1 b2 ...) (g1 a1)</span><span>
</span><span id="line-1071"></span><span>    </span><span class="hs-comment">--                    (g2 a2) &lt;*&gt; ...</span><span>
</span><span id="line-1072"></span><span>    </span><span id="local-6989586621681418025"><span class="annot"><a href="#local-6989586621681418035"><span class="hs-identifier hs-type">match_for_con</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#Monad"><span class="hs-identifier hs-type">Monad</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681418025"><span class="hs-identifier hs-type">m</span></a></span><span>
</span><span id="line-1073"></span><span>                  </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1074"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span>
</span><span id="line-1075"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1076"></span><span>                  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681418025"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-1077"></span><span>    </span><span id="local-6989586621681418035"><span class="annot"><span class="annottext">match_for_con :: forall (m :: * -&gt; *).
Monad m =&gt;
[LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="#local-6989586621681418035"><span class="hs-identifier hs-var hs-var">match_for_con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *).
Monad m =&gt;
HsMatchContext (GhcPass 'Parsed)
-&gt; (LHsExpr (GhcPass 'Parsed)
    -&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; m (LHsExpr (GhcPass 'Parsed)))
-&gt; [LPat (GhcPass 'Parsed)]
-&gt; DataCon
-&gt; [Maybe (LHsExpr (GhcPass 'Parsed))]
-&gt; m (LMatch (GhcPass 'Parsed) (LHsExpr (GhcPass 'Parsed)))
</span><a href="GHC.Tc.Deriv.Functor.html#mkSimpleConMatch2"><span class="hs-identifier hs-var">mkSimpleConMatch2</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span>
</span><span id="line-1078"></span><span>                                             </span><span class="hs-glyph">\</span><span id="local-6989586621681418006"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418006"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621681418005"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418005"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#return"><span class="hs-identifier hs-var">return</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
-&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418004"><span class="hs-identifier hs-var">mkApCon</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418006"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681418005"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1079"></span><span>      </span><span class="hs-keyword">where</span><span>
</span><span id="line-1080"></span><span>        </span><span class="hs-comment">-- liftA2 (\b1 b2 ... -&gt; Con b1 b2 ...) x1 x2 &lt;*&gt; ..</span><span>
</span><span id="line-1081"></span><span>        </span><span class="annot"><a href="#local-6989586621681418004"><span class="hs-identifier hs-type">mkApCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-1082"></span><span>        </span><span id="local-6989586621681418004"><span class="annot"><span class="annottext">mkApCon :: LHsExpr (GhcPass 'Parsed)
-&gt; [LHsExpr (GhcPass 'Parsed)] -&gt; LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418004"><span class="hs-identifier hs-var hs-var">mkApCon</span></a></span></span><span> </span><span id="local-6989586621681418003"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418003"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#pure_RDR"><span class="hs-identifier hs-var">pure_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418003"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1083"></span><span>        </span><span class="annot"><a href="#local-6989586621681418004"><span class="hs-identifier hs-var">mkApCon</span></a></span><span> </span><span id="local-6989586621681418002"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418002"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-special">[</span><span id="local-6989586621681418001"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418001"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#fmap_RDR"><span class="hs-identifier hs-var">fmap_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418002"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418001"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1084"></span><span>        </span><span class="annot"><a href="#local-6989586621681418004"><span class="hs-identifier hs-var">mkApCon</span></a></span><span> </span><span id="local-6989586621681418000"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418000"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621681417999"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681417999"><span class="hs-identifier hs-var">x1</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621681417998"><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681417998"><span class="hs-identifier hs-var">x2</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621681417997"><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681417997"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1085"></span><span>            </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#foldl%27"><span class="hs-identifier hs-var">foldl'</span></a></span><span> </span><span class="annot"><span class="annottext">forall {p :: Pass}.
(Anno (IdGhcP p) ~ SrcSpanAnnN, IdGhcP p ~ RdrName, IsPass p) =&gt;
GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
</span><a href="#local-6989586621681417995"><span class="hs-identifier hs-var">appAp</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#liftA2_RDR"><span class="hs-identifier hs-var">liftA2_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681418000"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681417999"><span class="hs-identifier hs-var">x1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">LHsExpr (GhcPass 'Parsed)
</span><a href="#local-6989586621681417998"><span class="hs-identifier hs-var">x2</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LHsExpr (GhcPass 'Parsed)]
</span><a href="#local-6989586621681417997"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1086"></span><span>          </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681417995"><span class="annot"><span class="annottext">appAp :: GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
-&gt; GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
-&gt; LHsExpr (GhcPass p)
</span><a href="#local-6989586621681417995"><span class="hs-identifier hs-var hs-var">appAp</span></a></span></span><span> </span><span id="local-6989586621681417976"><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
</span><a href="#local-6989586621681417976"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621681417975"><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
</span><a href="#local-6989586621681417975"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; [LHsExpr (GhcPass p)] -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsApps"><span class="hs-identifier hs-var">nlHsApps</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#ap_RDR"><span class="hs-identifier hs-var">ap_RDR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
</span><a href="#local-6989586621681417976"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">GenLocated SrcSpanAnnA (HsExpr (GhcPass p))
</span><a href="#local-6989586621681417975"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1087"></span><span>
</span><span id="line-1088"></span><span class="hs-comment">-----------------------------------------------------------------------</span><span>
</span><span id="line-1089"></span><span>
</span><span id="line-1090"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-type">f_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#z_Expr"><span class="hs-identifier hs-type">z_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#mempty_Expr"><span class="hs-identifier hs-type">mempty_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#foldMap_Expr"><span class="hs-identifier hs-type">foldMap_Expr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1091"></span><span>    </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#traverse_Expr"><span class="hs-identifier hs-type">traverse_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#coerce_Expr"><span class="hs-identifier hs-type">coerce_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#pure_Expr"><span class="hs-identifier hs-type">pure_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#true_Expr"><span class="hs-identifier hs-type">true_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#false_Expr"><span class="hs-identifier hs-type">false_Expr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1092"></span><span>    </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#all_Expr"><span class="hs-identifier hs-type">all_Expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#null_Expr"><span class="hs-identifier hs-type">null_Expr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-1093"></span><span id="f_Expr"><span class="annot"><span class="annottext">f_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Expr"><span class="hs-identifier hs-var hs-var">f_Expr</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Tc.Deriv.Functor.html#f_RDR"><span class="hs-identifier hs-var">f_RDR</span></a></span><span>
</span><span id="line-1094"></span><span id="z_Expr"><span class="annot"><span class="annottext">z_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Expr"><span class="hs-identifier hs-var hs-var">z_Expr</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Tc.Deriv.Functor.html#z_RDR"><span class="hs-identifier hs-var">z_RDR</span></a></span><span>
</span><span id="line-1095"></span><span id="mempty_Expr"><span class="annot"><span class="annottext">mempty_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#mempty_Expr"><span class="hs-identifier hs-var hs-var">mempty_Expr</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#mempty_RDR"><span class="hs-identifier hs-var">mempty_RDR</span></a></span><span>
</span><span id="line-1096"></span><span id="foldMap_Expr"><span class="annot"><span class="annottext">foldMap_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#foldMap_Expr"><span class="hs-identifier hs-var hs-var">foldMap_Expr</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#foldMap_RDR"><span class="hs-identifier hs-var">foldMap_RDR</span></a></span><span>
</span><span id="line-1097"></span><span id="traverse_Expr"><span class="annot"><span class="annottext">traverse_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#traverse_Expr"><span class="hs-identifier hs-var hs-var">traverse_Expr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#traverse_RDR"><span class="hs-identifier hs-var">traverse_RDR</span></a></span><span>
</span><span id="line-1098"></span><span id="coerce_Expr"><span class="annot"><span class="annottext">coerce_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#coerce_Expr"><span class="hs-identifier hs-var hs-var">coerce_Expr</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall thing. NamedThing thing =&gt; thing -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#getRdrName"><span class="hs-identifier hs-var">getRdrName</span></a></span><span> </span><span class="annot"><span class="annottext">Id
</span><a href="GHC.Types.Id.Make.html#coerceId"><span class="hs-identifier hs-var">coerceId</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1099"></span><span id="pure_Expr"><span class="annot"><span class="annottext">pure_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#pure_Expr"><span class="hs-identifier hs-var hs-var">pure_Expr</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#pure_RDR"><span class="hs-identifier hs-var">pure_RDR</span></a></span><span>
</span><span id="line-1100"></span><span id="true_Expr"><span class="annot"><span class="annottext">true_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#true_Expr"><span class="hs-identifier hs-var hs-var">true_Expr</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Types.html#true_RDR"><span class="hs-identifier hs-var">true_RDR</span></a></span><span>
</span><span id="line-1101"></span><span id="false_Expr"><span class="annot"><span class="annottext">false_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#false_Expr"><span class="hs-identifier hs-var hs-var">false_Expr</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Types.html#false_RDR"><span class="hs-identifier hs-var">false_RDR</span></a></span><span>
</span><span id="line-1102"></span><span id="all_Expr"><span class="annot"><span class="annottext">all_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#all_Expr"><span class="hs-identifier hs-var hs-var">all_Expr</span></a></span></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#all_RDR"><span class="hs-identifier hs-var">all_RDR</span></a></span><span>
</span><span id="line-1103"></span><span id="null_Expr"><span class="annot"><span class="annottext">null_Expr :: LHsExpr (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#null_Expr"><span class="hs-identifier hs-var hs-var">null_Expr</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Builtin.Names.html#null_RDR"><span class="hs-identifier hs-var">null_RDR</span></a></span><span>
</span><span id="line-1104"></span><span>
</span><span id="line-1105"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#f_RDR"><span class="hs-identifier hs-type">f_RDR</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#z_RDR"><span class="hs-identifier hs-type">z_RDR</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span>
</span><span id="line-1106"></span><span id="f_RDR"><span class="annot"><span class="annottext">f_RDR :: RdrName
</span><a href="GHC.Tc.Deriv.Functor.html#f_RDR"><span class="hs-identifier hs-var hs-var">f_RDR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FastString -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#mkVarUnqual"><span class="hs-identifier hs-var">mkVarUnqual</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; FastString
</span><a href="GHC.Data.FastString.html#fsLit"><span class="hs-identifier hs-var">fsLit</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;f&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1107"></span><span id="z_RDR"><span class="annot"><span class="annottext">z_RDR :: RdrName
</span><a href="GHC.Tc.Deriv.Functor.html#z_RDR"><span class="hs-identifier hs-var hs-var">z_RDR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FastString -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#mkVarUnqual"><span class="hs-identifier hs-var">mkVarUnqual</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; FastString
</span><a href="GHC.Data.FastString.html#fsLit"><span class="hs-identifier hs-var">fsLit</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;z&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1108"></span><span>
</span><span id="line-1109"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#as_RDRs"><span class="hs-identifier hs-type">as_RDRs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-type">bs_RDRs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1110"></span><span id="as_RDRs"><span class="annot"><span class="annottext">as_RDRs :: [RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#as_RDRs"><span class="hs-identifier hs-var hs-var">as_RDRs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">FastString -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#mkVarUnqual"><span class="hs-identifier hs-var">mkVarUnqual</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; FastString
</span><a href="GHC.Data.FastString.html#mkFastString"><span class="hs-identifier hs-var">mkFastString</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;a&quot;</span></span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><a href="../../base-4.16.4.0/src/GHC-Show.html#show"><span class="hs-identifier hs-var">show</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681417965"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621681417965"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681417965"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-glyph">::</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">..</span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1111"></span><span id="bs_RDRs"><span class="annot"><span class="annottext">bs_RDRs :: [RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var hs-var">bs_RDRs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">FastString -&gt; RdrName
</span><a href="GHC.Types.Name.Reader.html#mkVarUnqual"><span class="hs-identifier hs-var">mkVarUnqual</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; FastString
</span><a href="GHC.Data.FastString.html#mkFastString"><span class="hs-identifier hs-var">mkFastString</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;b&quot;</span></span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><a href="../../base-4.16.4.0/src/GHC-Show.html#show"><span class="hs-identifier hs-var">show</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681417964"><span class="hs-identifier hs-var">i</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621681417964"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681417964"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-glyph">::</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">..</span><span> </span><span class="hs-special">]</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1112"></span><span>
</span><span id="line-1113"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#as_Vars"><span class="hs-identifier hs-type">as_Vars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#bs_Vars"><span class="hs-identifier hs-type">bs_Vars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1114"></span><span id="as_Vars"><span class="annot"><span class="annottext">as_Vars :: [LHsExpr (GhcPass 'Parsed)]
</span><a href="GHC.Tc.Deriv.Functor.html#as_Vars"><span class="hs-identifier hs-var hs-var">as_Vars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#as_RDRs"><span class="hs-identifier hs-var">as_RDRs</span></a></span><span>
</span><span id="line-1115"></span><span id="bs_Vars"><span class="annot"><span class="annottext">bs_Vars :: [LHsExpr (GhcPass 'Parsed)]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_Vars"><span class="hs-identifier hs-var hs-var">bs_Vars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LHsExpr (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlHsVar"><span class="hs-identifier hs-var">nlHsVar</span></a></span><span> </span><span class="annot"><span class="annottext">[RdrName]
</span><a href="GHC.Tc.Deriv.Functor.html#bs_RDRs"><span class="hs-identifier hs-var">bs_RDRs</span></a></span><span>
</span><span id="line-1116"></span><span>
</span><span id="line-1117"></span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#f_Pat"><span class="hs-identifier hs-type">f_Pat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Tc.Deriv.Functor.html#z_Pat"><span class="hs-identifier hs-type">z_Pat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span>
</span><span id="line-1118"></span><span id="f_Pat"><span class="annot"><span class="annottext">f_Pat :: LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#f_Pat"><span class="hs-identifier hs-var hs-var">f_Pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlVarPat"><span class="hs-identifier hs-var">nlVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Tc.Deriv.Functor.html#f_RDR"><span class="hs-identifier hs-var">f_RDR</span></a></span><span>
</span><span id="line-1119"></span><span id="z_Pat"><span class="annot"><span class="annottext">z_Pat :: LPat (GhcPass 'Parsed)
</span><a href="GHC.Tc.Deriv.Functor.html#z_Pat"><span class="hs-identifier hs-var hs-var">z_Pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass) a.
IsSrcSpanAnn p a =&gt;
IdP (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Utils.html#nlVarPat"><span class="hs-identifier hs-var">nlVarPat</span></a></span><span> </span><span class="annot"><span class="annottext">RdrName
</span><a href="GHC.Tc.Deriv.Functor.html#z_RDR"><span class="hs-identifier hs-var">z_RDR</span></a></span><span>
</span><span id="line-1120"></span><span>
</span><span id="line-1121"></span><span class="hs-comment">{-
Note [DeriveFoldable with ExistentialQuantification]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Functor and Traversable instances can only be derived for data types whose
last type parameter is truly universally polymorphic. For example:

  data T a b where
    T1 ::                 b   -&gt; T a b   -- YES, b is unconstrained
    T2 :: Ord b   =&gt;      b   -&gt; T a b   -- NO, b is constrained by (Ord b)
    T3 :: b ~ Int =&gt;      b   -&gt; T a b   -- NO, b is constrained by (b ~ Int)
    T4 ::                 Int -&gt; T a Int -- NO, this is just like T3
    T5 :: Ord a   =&gt; a -&gt; b   -&gt; T a b   -- YES, b is unconstrained, even
                                         -- though a is existential
    T6 ::                 Int -&gt; T Int b -- YES, b is unconstrained

For Foldable instances, however, we can completely lift the constraint that
the last type parameter be truly universally polymorphic. This means that T
(as defined above) can have a derived Foldable instance:

  instance Foldable (T a) where
    foldr f z (T1 b)   = f b z
    foldr f z (T2 b)   = f b z
    foldr f z (T3 b)   = f b z
    foldr f z (T4 b)   = z
    foldr f z (T5 a b) = f b z
    foldr f z (T6 a)   = z

    foldMap f (T1 b)   = f b
    foldMap f (T2 b)   = f b
    foldMap f (T3 b)   = f b
    foldMap f (T4 b)   = mempty
    foldMap f (T5 a b) = f b
    foldMap f (T6 a)   = mempty

In a Foldable instance, it is safe to fold over an occurrence of the last type
parameter that is not truly universally polymorphic. However, there is a bit
of subtlety in determining what is actually an occurrence of a type parameter.
T3 and T4, as defined above, provide one example:

  data T a b where
    ...
    T3 :: b ~ Int =&gt; b   -&gt; T a b
    T4 ::            Int -&gt; T a Int
    ...

  instance Foldable (T a) where
    ...
    foldr f z (T3 b) = f b z
    foldr f z (T4 b) = z
    ...
    foldMap f (T3 b) = f b
    foldMap f (T4 b) = mempty
    ...

Notice that the argument of T3 is folded over, whereas the argument of T4 is
not. This is because we only fold over constructor arguments that
syntactically mention the universally quantified type parameter of that
particular data constructor. See foldDataConArgs for how this is implemented.

As another example, consider the following data type. The argument of each
constructor has the same type as the last type parameter:

  data E a where
    E1 :: (a ~ Int) =&gt; a   -&gt; E a
    E2 ::              Int -&gt; E Int
    E3 :: (a ~ Int) =&gt; a   -&gt; E Int
    E4 :: (a ~ Int) =&gt; Int -&gt; E a

Only E1's argument is an occurrence of a universally quantified type variable
that is syntactically equivalent to the last type parameter, so only E1's
argument will be folded over in a derived Foldable instance.

See #10447 for the original discussion on this feature. Also see
https://gitlab.haskell.org/ghc/ghc/wikis/commentary/compiler/derive-functor
for a more in-depth explanation.

Note [FFoldType and functorLikeTraverse]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Deriving Functor, Foldable, and Traversable all require generating expressions
which perform an operation on each argument of a data constructor depending
on the argument's type. In particular, a generated operation can be different
depending on whether the type mentions the last type variable of the datatype
(e.g., if you have data T a = MkT a Int, then a generated foldr expression would
fold over the first argument of MkT, but not the second).

This pattern is abstracted with the FFoldType datatype, which provides hooks
for the user to specify how a constructor argument should be folded when it
has a type with a particular &quot;shape&quot;. The shapes are as follows (assume that
a is the last type variable in a given datatype):

* ft_triv:    The type does not mention the last type variable at all.
              Examples: Int, b

* ft_var:     The type is syntactically equal to the last type variable.
              Moreover, the type appears in a covariant position (see
              the Deriving Functor instances section of the user's guide
              for an in-depth explanation of covariance vs. contravariance).
              Example: a (covariantly)

* ft_co_var:  The type is syntactically equal to the last type variable.
              Moreover, the type appears in a contravariant position.
              Example: a (contravariantly)

* ft_fun:     A function type which mentions the last type variable in
              the argument position, result position or both.
              Examples: a -&gt; Int, Int -&gt; a, Maybe a -&gt; [a]

* ft_tup:     A tuple type which mentions the last type variable in at least
              one of its fields. The TyCon argument of ft_tup represents the
              particular tuple's type constructor.
              Examples: (a, Int), (Maybe a, [a], Either a Int), (# Int, a #)

* ft_ty_app:  A type is being applied to the last type parameter, where the
              applied type does not mention the last type parameter (if it
              did, it would fall under ft_bad_app) and the argument type
              mentions the last type parameter (if it did not, it would fall
              under ft_triv). The first two Type arguments to
              ft_ty_app represent the applied type and argument type,
              respectively.

              Currently, only DeriveFunctor makes use of the argument type.
              It inspects the argument type so that it can generate more
              efficient implementations of fmap
              (see Note [Avoid unnecessary eta expansion in derived fmap implementations])
              and (&lt;$) (see Note [Deriving &lt;$]) in certain cases.

              Note that functions, tuples, and foralls are distinct cases
              and take precedence over ft_ty_app. (For example, (Int -&gt; a) would
              fall under (ft_fun Int a), not (ft_ty_app ((-&gt;) Int) a).
              Examples: Maybe a, Either b a

* ft_bad_app: A type application uses the last type parameter in a position
              other than the last argument. This case is singled out because
              Functor, Foldable, and Traversable instances cannot be derived
              for datatypes containing arguments with such types.
              Examples: Either a Int, Const a b

* ft_forall:  A forall'd type mentions the last type parameter on its right-
              hand side (and is not quantified on the left-hand side). This
              case is present mostly for plumbing purposes.
              Example: forall b. Either b a

If FFoldType describes a strategy for folding subcomponents of a Type, then
functorLikeTraverse is the function that applies that strategy to the entirety
of a Type, returning the final folded-up result.

foldDataConArgs applies functorLikeTraverse to every argument type of a
constructor, returning a list of the fold results. This makes foldDataConArgs
a natural way to generate the subexpressions in a generated fmap, foldr,
foldMap, or traverse definition (the subexpressions must then be combined in
a method-specific fashion to form the final generated expression).

Deriving Generic1 also does validity checking by looking for the last type
variable in certain positions of a constructor's argument types, so it also
uses foldDataConArgs. See Note [degenerate use of FFoldType] in GHC.Tc.Deriv.Generics.

Note [Generated code for DeriveFoldable and DeriveTraversable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
We adapt the algorithms for -XDeriveFoldable and -XDeriveTraversable based on
that of -XDeriveFunctor. However, there an important difference between deriving
the former two typeclasses and the latter one, which is best illustrated by the
following scenario:

  data WithInt a = WithInt a Int# deriving (Functor, Foldable, Traversable)

The generated code for the Functor instance is straightforward:

  instance Functor WithInt where
    fmap f (WithInt a i) = WithInt (f a) i

But if we use too similar of a strategy for deriving the Foldable and
Traversable instances, we end up with this code:

  instance Foldable WithInt where
    foldMap f (WithInt a i) = f a &lt;&gt; mempty

  instance Traversable WithInt where
    traverse f (WithInt a i) = fmap WithInt (f a) &lt;*&gt; pure i

This is unsatisfying for two reasons:

1. The Traversable instance doesn't typecheck! Int# is of kind #, but pure
   expects an argument whose type is of kind *. This effectively prevents
   Traversable from being derived for any datatype with an unlifted argument
   type (#11174).

2. The generated code contains superfluous expressions. By the Monoid laws,
   we can reduce (f a &lt;&gt; mempty) to (f a), and by the Applicative laws, we can
   reduce (fmap WithInt (f a) &lt;*&gt; pure i) to (fmap (\b -&gt; WithInt b i) (f a)).

We can fix both of these issues by incorporating a slight twist to the usual
algorithm that we use for -XDeriveFunctor. The differences can be summarized
as follows:

1. In the generated expression, we only fold over arguments whose types
   mention the last type parameter. Any other argument types will simply
   produce useless 'mempty's or 'pure's, so they can be safely ignored.

2. In the case of -XDeriveTraversable, instead of applying ConName,
   we apply (\b_i ... b_k -&gt; ConName a_1 ... a_n), where

   * ConName has n arguments
   * {b_i, ..., b_k} is a subset of {a_1, ..., a_n} whose indices correspond
     to the arguments whose types mention the last type parameter. As a
     consequence, taking the difference of {a_1, ..., a_n} and
     {b_i, ..., b_k} yields the all the argument values of ConName whose types
     do not mention the last type parameter. Note that [i, ..., k] is a
     strictly increasing&#8212;but not necessarily consecutive&#8212;integer sequence.

     For example, the datatype

       data Foo a = Foo Int a Int a

     would generate the following Traversable instance:

       instance Traversable Foo where
         traverse f (Foo a1 a2 a3 a4) =
           fmap (\b2 b4 -&gt; Foo a1 b2 a3 b4) (f a2) &lt;*&gt; f a4

Technically, this approach would also work for -XDeriveFunctor as well, but we
decide not to do so because:

1. There's not much benefit to generating, e.g., ((\b -&gt; WithInt b i) (f a))
   instead of (WithInt (f a) i).

2. There would be certain datatypes for which the above strategy would
   generate Functor code that would fail to typecheck. For example:

     data Bar f a = Bar (forall f. Functor f =&gt; f a) deriving Functor

   With the conventional algorithm, it would generate something like:

     fmap f (Bar a) = Bar (fmap f a)

   which typechecks. But with the strategy mentioned above, it would generate:

     fmap f (Bar a) = (\b -&gt; Bar b) (fmap f a)

   which does not typecheck, since GHC cannot unify the rank-2 type variables
   in the types of b and (fmap f a).

Note [Phantom types with Functor, Foldable, and Traversable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Given a type F :: * -&gt; * whose type argument has a phantom role, we can always
produce lawful Functor and Traversable instances using

    fmap _ = coerce
    traverse _ = pure . coerce

Indeed, these are equivalent to any *strictly lawful* instances one could
write, except that this definition of 'traverse' may be lazier.  That is, if
instances obey the laws under true equality (rather than up to some equivalence
relation), then they will be essentially equivalent to these. These definitions
are incredibly cheap, so we want to use them even if it means ignoring some
non-strictly-lawful instance in an embedded type.

Foldable has far fewer laws to work with, which leaves us unwelcome
freedom in implementing it. At a minimum, we would like to ensure that
a derived foldMap is always at least as good as foldMapDefault with a
derived traverse. To accomplish that, we must define

   foldMap _ _ = mempty

in these cases.

This may have different strictness properties from a standard derivation.
Consider

   data NotAList a = Nil | Cons (NotAList a) deriving Foldable

The usual deriving mechanism would produce

   foldMap _ Nil = mempty
   foldMap f (Cons x) = foldMap f x

which is strict in the entire spine of the NotAList.

Final point: why do we even care about such types? Users will rarely if ever
map, fold, or traverse over such things themselves, but other derived
instances may:

   data Hasn'tAList a = NotHere a (NotAList a) deriving Foldable

Note [EmptyDataDecls with Functor, Foldable, and Traversable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are some slightly tricky decisions to make about how to handle
Functor, Foldable, and Traversable instances for types with no constructors.
For fmap, the two basic options are

   fmap _ _ = error &quot;Sorry, no constructors&quot;

or

   fmap _ z = case z of

In most cases, the latter is more helpful: if the thunk passed to fmap
throws an exception, we're generally going to be much more interested in
that exception than in the fact that there aren't any constructors.

In order to match the semantics for phantoms (see note above), we need to
be a bit careful about 'traverse'. The obvious definition would be

   traverse _ z = case z of

but this is stricter than the one for phantoms. We instead use

   traverse _ z = pure $ case z of

For foldMap, the obvious choices are

   foldMap _ _ = mempty

or

   foldMap _ z = case z of

We choose the first one to be consistent with what foldMapDefault does for
a derived Traversable instance.
-}</span><span>
</span><span id="line-1442"></span></pre></body></html>