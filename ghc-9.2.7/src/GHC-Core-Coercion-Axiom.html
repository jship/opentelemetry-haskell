<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Coercion/Axiom.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP                 #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE DataKinds           #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE DeriveDataTypeable  #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE GADTs               #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE KindSignatures      #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE RoleAnnotations     #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-comment'>-- (c) The University of Glasgow 2012</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-comment'>-- | Module for coercion axioms, used to represent type family instances</span>
<a name="line-12"></a><span class='hs-comment'>-- and newtypes</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Coercion.Axiom</span> <span class='hs-layout'>(</span>
<a name="line-15"></a>       <span class='hs-conid'>BranchFlag</span><span class='hs-layout'>,</span> <span class='hs-conid'>Branched</span><span class='hs-layout'>,</span> <span class='hs-conid'>Unbranched</span><span class='hs-layout'>,</span> <span class='hs-conid'>BranchIndex</span><span class='hs-layout'>,</span> <span class='hs-conid'>Branches</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-16"></a>       <span class='hs-varid'>manyBranches</span><span class='hs-layout'>,</span> <span class='hs-varid'>unbranched</span><span class='hs-layout'>,</span>
<a name="line-17"></a>       <span class='hs-varid'>fromBranches</span><span class='hs-layout'>,</span> <span class='hs-varid'>numBranches</span><span class='hs-layout'>,</span>
<a name="line-18"></a>       <span class='hs-varid'>mapAccumBranches</span><span class='hs-layout'>,</span>
<a name="line-19"></a>
<a name="line-20"></a>       <span class='hs-conid'>CoAxiom</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoAxBranch</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-21"></a>
<a name="line-22"></a>       <span class='hs-varid'>toBranchedAxiom</span><span class='hs-layout'>,</span> <span class='hs-varid'>toUnbranchedAxiom</span><span class='hs-layout'>,</span>
<a name="line-23"></a>       <span class='hs-varid'>coAxiomName</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxiomArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxiomBranches</span><span class='hs-layout'>,</span>
<a name="line-24"></a>       <span class='hs-varid'>coAxiomTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>isImplicitCoAxiom</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxiomNumPats</span><span class='hs-layout'>,</span>
<a name="line-25"></a>       <span class='hs-varid'>coAxiomNthBranch</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxiomSingleBranch_maybe</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxiomRole</span><span class='hs-layout'>,</span>
<a name="line-26"></a>       <span class='hs-varid'>coAxiomSingleBranch</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxBranchTyVars</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxBranchCoVars</span><span class='hs-layout'>,</span>
<a name="line-27"></a>       <span class='hs-varid'>coAxBranchRoles</span><span class='hs-layout'>,</span>
<a name="line-28"></a>       <span class='hs-varid'>coAxBranchLHS</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxBranchRHS</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxBranchSpan</span><span class='hs-layout'>,</span> <span class='hs-varid'>coAxBranchIncomps</span><span class='hs-layout'>,</span>
<a name="line-29"></a>       <span class='hs-varid'>placeHolderIncomps</span><span class='hs-layout'>,</span>
<a name="line-30"></a>
<a name="line-31"></a>       <span class='hs-conid'>Role</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsFromRole</span><span class='hs-layout'>,</span>
<a name="line-32"></a>
<a name="line-33"></a>       <span class='hs-conid'>CoAxiomRule</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>TypeEqn</span><span class='hs-layout'>,</span>
<a name="line-34"></a>       <span class='hs-conid'>BuiltInSynFamily</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>trivialBuiltInFamily</span>
<a name="line-35"></a>       <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Core.TyCo.Ppr</span> <span class='hs-layout'>(</span> <span class='hs-varid'>pprType</span> <span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Core.TyCon</span>    <span class='hs-layout'>(</span> <span class='hs-conid'>TyCon</span> <span class='hs-layout'>)</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Binary</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Pair</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Typeable</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Typeable</span> <span class='hs-layout'>)</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Data</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Data</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Array</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-layout'>)</span>
<a name="line-57"></a>
<a name="line-58"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-59"></a>
<a name="line-60"></a><span class='hs-comment'>{-
<a name="line-61"></a>Note [Coercion axiom branches]
<a name="line-62"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-63"></a>In order to allow closed type families, an axiom needs to contain an
<a name="line-64"></a>ordered list of alternatives, called branches. The kind of the coercion built
<a name="line-65"></a>from an axiom is determined by which index is used when building the coercion
<a name="line-66"></a>from the axiom.
<a name="line-67"></a>
<a name="line-68"></a>For example, consider the axiom derived from the following declaration:
<a name="line-69"></a>
<a name="line-70"></a>type family F a where
<a name="line-71"></a>  F [Int] = Bool
<a name="line-72"></a>  F [a]   = Double
<a name="line-73"></a>  F (a b) = Char
<a name="line-74"></a>
<a name="line-75"></a>This will give rise to this axiom:
<a name="line-76"></a>
<a name="line-77"></a>axF :: {                                         F [Int] ~ Bool
<a name="line-78"></a>       ; forall (a :: *).                        F [a]   ~ Double
<a name="line-79"></a>       ; forall (k :: *) (a :: k -&gt; *) (b :: k). F (a b) ~ Char
<a name="line-80"></a>       }
<a name="line-81"></a>
<a name="line-82"></a>The axiom is used with the AxiomInstCo constructor of Coercion. If we wish
<a name="line-83"></a>to have a coercion showing that F (Maybe Int) ~ Char, it will look like
<a name="line-84"></a>
<a name="line-85"></a>axF[2] &lt;*&gt; &lt;Maybe&gt; &lt;Int&gt; :: F (Maybe Int) ~ Char
<a name="line-86"></a>-- or, written using concrete-ish syntax --
<a name="line-87"></a>AxiomInstCo axF 2 [Refl *, Refl Maybe, Refl Int]
<a name="line-88"></a>
<a name="line-89"></a>Note that the index is 0-based.
<a name="line-90"></a>
<a name="line-91"></a>For type-checking, it is also necessary to check that no previous pattern
<a name="line-92"></a>can unify with the supplied arguments. After all, it is possible that some
<a name="line-93"></a>of the type arguments are lambda-bound type variables whose instantiation may
<a name="line-94"></a>cause an earlier match among the branches. We wish to prohibit this behavior,
<a name="line-95"></a>so the type checker rules out the choice of a branch where a previous branch
<a name="line-96"></a>can unify. See also [Apartness] in GHC.Core.FamInstEnv.
<a name="line-97"></a>
<a name="line-98"></a>For example, the following is malformed, where 'a' is a lambda-bound type
<a name="line-99"></a>variable:
<a name="line-100"></a>
<a name="line-101"></a>axF[2] &lt;*&gt; &lt;a&gt; &lt;Bool&gt; :: F (a Bool) ~ Char
<a name="line-102"></a>
<a name="line-103"></a>Why? Because a might be instantiated with [], meaning that branch 1 should
<a name="line-104"></a>apply, not branch 2. This is a vital consistency check; without it, we could
<a name="line-105"></a>derive Int ~ Bool, and that is a Bad Thing.
<a name="line-106"></a>
<a name="line-107"></a>Note [Branched axioms]
<a name="line-108"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-109"></a>Although a CoAxiom has the capacity to store many branches, in certain cases,
<a name="line-110"></a>we want only one. These cases are in data/newtype family instances, newtype
<a name="line-111"></a>coercions, and type family instances.
<a name="line-112"></a>Furthermore, these unbranched axioms are used in a
<a name="line-113"></a>variety of places throughout GHC, and it would difficult to generalize all of
<a name="line-114"></a>that code to deal with branched axioms, especially when the code can be sure
<a name="line-115"></a>of the fact that an axiom is indeed a singleton. At the same time, it seems
<a name="line-116"></a>dangerous to assume singlehood in various places through GHC.
<a name="line-117"></a>
<a name="line-118"></a>The solution to this is to label a CoAxiom with a phantom type variable
<a name="line-119"></a>declaring whether it is known to be a singleton or not. The branches
<a name="line-120"></a>are stored using a special datatype, declared below, that ensures that the
<a name="line-121"></a>type variable is accurate.
<a name="line-122"></a>
<a name="line-123"></a>************************************************************************
<a name="line-124"></a>*                                                                      *
<a name="line-125"></a>                    Branches
<a name="line-126"></a>*                                                                      *
<a name="line-127"></a>************************************************************************
<a name="line-128"></a>-}</span>
<a name="line-129"></a>
<a name="line-130"></a><a name="BranchIndex"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>BranchIndex</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Int</span>  <span class='hs-comment'>-- The index of the branch in the list of branches</span>
<a name="line-131"></a>                        <span class='hs-comment'>-- Counting from zero</span>
<a name="line-132"></a>
<a name="line-133"></a><a name="BranchFlag"></a><span class='hs-comment'>-- promoted data type</span>
<a name="line-134"></a><a name="BranchFlag"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>BranchFlag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Branched</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Unbranched</span>
<a name="line-135"></a><a name="Branched"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Branched</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>Branched</span>
<a name="line-136"></a><a name="Unbranched"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Unbranched</span> <span class='hs-keyglyph'>=</span> <span class='hs-chr'>'</span><span class='hs-conid'>Unbranched</span>
<a name="line-137"></a><span class='hs-comment'>-- By using type synonyms for the promoted constructors, we avoid needing</span>
<a name="line-138"></a><span class='hs-comment'>-- DataKinds and the promotion quote in client modules. This also means that</span>
<a name="line-139"></a><span class='hs-comment'>-- we don't need to export the term-level constructors, which should never be used.</span>
<a name="line-140"></a>
<a name="line-141"></a><a name="Branches"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>Branches</span> <span class='hs-layout'>(</span><span class='hs-varid'>br</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BranchFlag</span><span class='hs-layout'>)</span>
<a name="line-142"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkBranches</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unMkBranches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Array</span> <span class='hs-conid'>BranchIndex</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-layout'>}</span>
<a name="line-143"></a><span class='hs-keyword'>type</span> <span class='hs-varid'>role</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>nominal</span>
<a name="line-144"></a>
<a name="line-145"></a><a name="manyBranches"></a><span class='hs-definition'>manyBranches</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-conid'>Branched</span>
<a name="line-146"></a><span class='hs-definition'>manyBranches</span> <span class='hs-varid'>brs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>bnds</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>bnds</span> <span class='hs-layout'>)</span>
<a name="line-147"></a>                   <span class='hs-conid'>MkBranches</span> <span class='hs-layout'>(</span><span class='hs-varid'>listArray</span> <span class='hs-varid'>bnds</span> <span class='hs-varid'>brs</span><span class='hs-layout'>)</span>
<a name="line-148"></a>  <span class='hs-keyword'>where</span>
<a name="line-149"></a>    <span class='hs-varid'>bnds</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-varid'>length</span> <span class='hs-varid'>brs</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-150"></a>
<a name="line-151"></a><a name="unbranched"></a><span class='hs-definition'>unbranched</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-conid'>Unbranched</span>
<a name="line-152"></a><span class='hs-definition'>unbranched</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkBranches</span> <span class='hs-layout'>(</span><span class='hs-varid'>listArray</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>br</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-153"></a>
<a name="line-154"></a><a name="toBranched"></a><span class='hs-definition'>toBranched</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-conid'>Branched</span>
<a name="line-155"></a><span class='hs-definition'>toBranched</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkBranches</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unMkBranches</span>
<a name="line-156"></a>
<a name="line-157"></a><a name="toUnbranched"></a><span class='hs-definition'>toUnbranched</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-conid'>Unbranched</span>
<a name="line-158"></a><span class='hs-definition'>toUnbranched</span> <span class='hs-layout'>(</span><span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>bounds</span> <span class='hs-varid'>arr</span> <span class='hs-varop'>==</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span><span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-159"></a>                                <span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span>
<a name="line-160"></a>
<a name="line-161"></a><a name="fromBranches"></a><span class='hs-definition'>fromBranches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span>
<a name="line-162"></a><span class='hs-definition'>fromBranches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>elems</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unMkBranches</span>
<a name="line-163"></a>
<a name="line-164"></a><a name="branchesNth"></a><span class='hs-definition'>branchesNth</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BranchIndex</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-165"></a><span class='hs-definition'>branchesNth</span> <span class='hs-layout'>(</span><span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arr</span> <span class='hs-varop'>!</span> <span class='hs-varid'>n</span>
<a name="line-166"></a>
<a name="line-167"></a><a name="numBranches"></a><span class='hs-definition'>numBranches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-168"></a><span class='hs-definition'>numBranches</span> <span class='hs-layout'>(</span><span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-layout'>(</span><span class='hs-varid'>bounds</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
<a name="line-169"></a>
<a name="line-170"></a><a name="mapAccumBranches"></a><span class='hs-comment'>-- | The @[CoAxBranch]@ passed into the mapping function is a list of</span>
<a name="line-171"></a><span class='hs-comment'>-- all previous branches, reversed</span>
<a name="line-172"></a><span class='hs-definition'>mapAccumBranches</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span><span class='hs-layout'>)</span>
<a name="line-173"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span>
<a name="line-174"></a><span class='hs-definition'>mapAccumBranches</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span>
<a name="line-175"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkBranches</span> <span class='hs-layout'>(</span><span class='hs-varid'>listArray</span> <span class='hs-layout'>(</span><span class='hs-varid'>bounds</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-varid'>elems</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-176"></a>  <span class='hs-keyword'>where</span>
<a name="line-177"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoAxBranch</span><span class='hs-layout'>)</span>
<a name="line-178"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>cur_branch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>prev_branches</span>
<a name="line-179"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>f</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span> <span class='hs-layout'>)</span>
<a name="line-180"></a>
<a name="line-181"></a>
<a name="line-182"></a><span class='hs-comment'>{-
<a name="line-183"></a>************************************************************************
<a name="line-184"></a>*                                                                      *
<a name="line-185"></a>                    Coercion axioms
<a name="line-186"></a>*                                                                      *
<a name="line-187"></a>************************************************************************
<a name="line-188"></a>
<a name="line-189"></a>Note [Storing compatibility]
<a name="line-190"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-191"></a>During axiom application, we need to be aware of which branches are compatible
<a name="line-192"></a>with which others. The full explanation is in Note [Compatibility] in
<a name="line-193"></a>GHc.Core.FamInstEnv. (The code is placed there to avoid a dependency from
<a name="line-194"></a>GHC.Core.Coercion.Axiom on the unification algorithm.) Although we could
<a name="line-195"></a>theoretically compute compatibility on the fly, this is silly, so we store it
<a name="line-196"></a>in a CoAxiom.
<a name="line-197"></a>
<a name="line-198"></a>Specifically, each branch refers to all other branches with which it is
<a name="line-199"></a>incompatible. This list might well be empty, and it will always be for the
<a name="line-200"></a>first branch of any axiom.
<a name="line-201"></a>
<a name="line-202"></a>CoAxBranches that do not (yet) belong to a CoAxiom should have a panic thunk
<a name="line-203"></a>stored in cab_incomps. The incompatibilities are properly a property of the
<a name="line-204"></a>axiom as a whole, and they are computed only when the final axiom is built.
<a name="line-205"></a>
<a name="line-206"></a>During serialization, the list is converted into a list of the indices
<a name="line-207"></a>of the branches.
<a name="line-208"></a>
<a name="line-209"></a>Note [CoAxioms are homogeneous]
<a name="line-210"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-211"></a>All axioms must be *homogeneous*, meaning that the kind of the LHS must
<a name="line-212"></a>match the kind of the RHS. In practice, this means:
<a name="line-213"></a>
<a name="line-214"></a>  Given a CoAxiom { co_ax_tc = ax_tc },
<a name="line-215"></a>  for every branch CoAxBranch { cab_lhs = lhs, cab_rhs = rhs }:
<a name="line-216"></a>    typeKind (mkTyConApp ax_tc lhs) `eqType` typeKind rhs
<a name="line-217"></a>
<a name="line-218"></a>This is checked in FamInstEnv.mkCoAxBranch.
<a name="line-219"></a>-}</span>
<a name="line-220"></a>
<a name="line-221"></a><span class='hs-comment'>-- | A 'CoAxiom' is a \"coercion constructor\", i.e. a named equality axiom.</span>
<a name="line-222"></a>
<a name="line-223"></a><a name="CoAxiom"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-224"></a><a name="CoAxiom"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-225"></a><a name="CoAxiom"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span>
<a name="line-226"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoAxiom</span>                   <span class='hs-comment'>-- Type equality axiom.</span>
<a name="line-227"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>co_ax_unique</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unique</span>        <span class='hs-comment'>-- Unique identifier</span>
<a name="line-228"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>co_ax_name</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>          <span class='hs-comment'>-- Name for pretty-printing</span>
<a name="line-229"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>co_ax_role</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Role</span>          <span class='hs-comment'>-- Role of the axiom's equality</span>
<a name="line-230"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>co_ax_tc</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>         <span class='hs-comment'>-- The head of the LHS patterns</span>
<a name="line-231"></a>                                      <span class='hs-comment'>-- e.g.  the newtype or family tycon</span>
<a name="line-232"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>co_ax_branches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span>   <span class='hs-comment'>-- The branches that form this axiom</span>
<a name="line-233"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>co_ax_implicit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>          <span class='hs-comment'>-- True &lt;=&gt; the axiom is "implicit"</span>
<a name="line-234"></a>                                      <span class='hs-comment'>-- See Note [Implicit axioms]</span>
<a name="line-235"></a>         <span class='hs-comment'>-- INVARIANT: co_ax_implicit == True implies length co_ax_branches == 1.</span>
<a name="line-236"></a>    <span class='hs-layout'>}</span>
<a name="line-237"></a>
<a name="line-238"></a><a name="CoAxBranch"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-239"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-240"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>cab_loc</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SrcSpan</span>       <span class='hs-comment'>-- Location of the defining equation</span>
<a name="line-241"></a>                                    <span class='hs-comment'>-- See Note [CoAxiom locations]</span>
<a name="line-242"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_tvs</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Bound type variables; not necessarily fresh</span>
<a name="line-243"></a>                                    <span class='hs-comment'>-- See Note [CoAxBranch type variables]</span>
<a name="line-244"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_eta_tvs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Eta-reduced tyvars</span>
<a name="line-245"></a>                                    <span class='hs-comment'>-- cab_tvs and cab_lhs may be eta-reduced; see</span>
<a name="line-246"></a>                                    <span class='hs-comment'>-- Note [Eta reduction for data families]</span>
<a name="line-247"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_cvs</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Bound coercion variables</span>
<a name="line-248"></a>                                    <span class='hs-comment'>-- Always empty, for now.</span>
<a name="line-249"></a>                                    <span class='hs-comment'>-- See Note [Constraints in patterns]</span>
<a name="line-250"></a>                                    <span class='hs-comment'>-- in GHC.Tc.TyCl</span>
<a name="line-251"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_roles</span>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- See Note [CoAxBranch roles]</span>
<a name="line-252"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_lhs</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- Type patterns to match against</span>
<a name="line-253"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_rhs</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span>          <span class='hs-comment'>-- Right-hand side of the equality</span>
<a name="line-254"></a>                                    <span class='hs-comment'>-- See Note [CoAxioms are homogeneous]</span>
<a name="line-255"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>cab_incomps</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- The previous incompatible branches</span>
<a name="line-256"></a>                                    <span class='hs-comment'>-- See Note [Storing compatibility]</span>
<a name="line-257"></a>    <span class='hs-layout'>}</span>
<a name="line-258"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data.Data</span>
<a name="line-259"></a>
<a name="line-260"></a><a name="toBranchedAxiom"></a><span class='hs-definition'>toBranchedAxiom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-conid'>Branched</span>
<a name="line-261"></a><span class='hs-definition'>toBranchedAxiom</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>unique</span> <span class='hs-varid'>name</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>branches</span> <span class='hs-varid'>implicit</span><span class='hs-layout'>)</span>
<a name="line-262"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>unique</span> <span class='hs-varid'>name</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>toBranched</span> <span class='hs-varid'>branches</span><span class='hs-layout'>)</span> <span class='hs-varid'>implicit</span>
<a name="line-263"></a>
<a name="line-264"></a><a name="toUnbranchedAxiom"></a><span class='hs-definition'>toUnbranchedAxiom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-conid'>Unbranched</span>
<a name="line-265"></a><span class='hs-definition'>toUnbranchedAxiom</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>unique</span> <span class='hs-varid'>name</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>branches</span> <span class='hs-varid'>implicit</span><span class='hs-layout'>)</span>
<a name="line-266"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>unique</span> <span class='hs-varid'>name</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>toUnbranched</span> <span class='hs-varid'>branches</span><span class='hs-layout'>)</span> <span class='hs-varid'>implicit</span>
<a name="line-267"></a>
<a name="line-268"></a><a name="coAxiomNumPats"></a><span class='hs-definition'>coAxiomNumPats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-269"></a><span class='hs-definition'>coAxiomNumPats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varop'>.</span> <span class='hs-varid'>coAxBranchLHS</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varid'>flip</span> <span class='hs-varid'>coAxiomNthBranch</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<a name="line-270"></a>
<a name="line-271"></a><a name="coAxiomNthBranch"></a><span class='hs-definition'>coAxiomNthBranch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BranchIndex</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-272"></a><span class='hs-definition'>coAxiomNthBranch</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co_ax_branches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>index</span>
<a name="line-273"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>branchesNth</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>index</span>
<a name="line-274"></a>
<a name="line-275"></a><a name="coAxiomArity"></a><span class='hs-definition'>coAxiomArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>BranchIndex</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span>
<a name="line-276"></a><span class='hs-definition'>coAxiomArity</span> <span class='hs-varid'>ax</span> <span class='hs-varid'>index</span>
<a name="line-277"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>+</span> <span class='hs-varid'>length</span> <span class='hs-varid'>cvs</span>
<a name="line-278"></a>  <span class='hs-keyword'>where</span>
<a name="line-279"></a>    <span class='hs-conid'>CoAxBranch</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cab_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cab_cvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cvs</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coAxiomNthBranch</span> <span class='hs-varid'>ax</span> <span class='hs-varid'>index</span>
<a name="line-280"></a>
<a name="line-281"></a><a name="coAxiomName"></a><span class='hs-definition'>coAxiomName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span>
<a name="line-282"></a><span class='hs-definition'>coAxiomName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_name</span>
<a name="line-283"></a>
<a name="line-284"></a><a name="coAxiomRole"></a><span class='hs-definition'>coAxiomRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span>
<a name="line-285"></a><span class='hs-definition'>coAxiomRole</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_role</span>
<a name="line-286"></a>
<a name="line-287"></a><a name="coAxiomBranches"></a><span class='hs-definition'>coAxiomBranches</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Branches</span> <span class='hs-varid'>br</span>
<a name="line-288"></a><span class='hs-definition'>coAxiomBranches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_branches</span>
<a name="line-289"></a>
<a name="line-290"></a><a name="coAxiomSingleBranch_maybe"></a><span class='hs-definition'>coAxiomSingleBranch_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-291"></a><span class='hs-definition'>coAxiomSingleBranch_maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co_ax_branches</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-292"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>snd</span> <span class='hs-layout'>(</span><span class='hs-varid'>bounds</span> <span class='hs-varid'>arr</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span>
<a name="line-293"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>arr</span> <span class='hs-varop'>!</span> <span class='hs-num'>0</span>
<a name="line-294"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-295"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-296"></a>
<a name="line-297"></a><a name="coAxiomSingleBranch"></a><span class='hs-definition'>coAxiomSingleBranch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-conid'>Unbranched</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-298"></a><span class='hs-definition'>coAxiomSingleBranch</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co_ax_branches</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MkBranches</span> <span class='hs-varid'>arr</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-299"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arr</span> <span class='hs-varop'>!</span> <span class='hs-num'>0</span>
<a name="line-300"></a>
<a name="line-301"></a><a name="coAxiomTyCon"></a><span class='hs-definition'>coAxiomTyCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span>
<a name="line-302"></a><span class='hs-definition'>coAxiomTyCon</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_tc</span>
<a name="line-303"></a>
<a name="line-304"></a><a name="coAxBranchTyVars"></a><span class='hs-definition'>coAxBranchTyVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-305"></a><span class='hs-definition'>coAxBranchTyVars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_tvs</span>
<a name="line-306"></a>
<a name="line-307"></a><a name="coAxBranchCoVars"></a><span class='hs-definition'>coAxBranchCoVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoVar</span><span class='hs-keyglyph'>]</span>
<a name="line-308"></a><span class='hs-definition'>coAxBranchCoVars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_cvs</span>
<a name="line-309"></a>
<a name="line-310"></a><a name="coAxBranchLHS"></a><span class='hs-definition'>coAxBranchLHS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-311"></a><span class='hs-definition'>coAxBranchLHS</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_lhs</span>
<a name="line-312"></a>
<a name="line-313"></a><a name="coAxBranchRHS"></a><span class='hs-definition'>coAxBranchRHS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-314"></a><span class='hs-definition'>coAxBranchRHS</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_rhs</span>
<a name="line-315"></a>
<a name="line-316"></a><a name="coAxBranchRoles"></a><span class='hs-definition'>coAxBranchRoles</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-317"></a><span class='hs-definition'>coAxBranchRoles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_roles</span>
<a name="line-318"></a>
<a name="line-319"></a><a name="coAxBranchSpan"></a><span class='hs-definition'>coAxBranchSpan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SrcSpan</span>
<a name="line-320"></a><span class='hs-definition'>coAxBranchSpan</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_loc</span>
<a name="line-321"></a>
<a name="line-322"></a><a name="isImplicitCoAxiom"></a><span class='hs-definition'>isImplicitCoAxiom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-323"></a><span class='hs-definition'>isImplicitCoAxiom</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_implicit</span>
<a name="line-324"></a>
<a name="line-325"></a><a name="coAxBranchIncomps"></a><span class='hs-definition'>coAxBranchIncomps</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span>
<a name="line-326"></a><span class='hs-definition'>coAxBranchIncomps</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cab_incomps</span>
<a name="line-327"></a>
<a name="line-328"></a><a name="placeHolderIncomps"></a><span class='hs-comment'>-- See Note [Compatibility checking] in GHC.Core.FamInstEnv</span>
<a name="line-329"></a><span class='hs-definition'>placeHolderIncomps</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span>
<a name="line-330"></a><span class='hs-definition'>placeHolderIncomps</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"placeHolderIncomps"</span>
<a name="line-331"></a>
<a name="line-332"></a><span class='hs-comment'>{-
<a name="line-333"></a>Note [CoAxBranch type variables]
<a name="line-334"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-335"></a>In the case of a CoAxBranch of an associated type-family instance,
<a name="line-336"></a>we use the *same* type variables (where possible) as the
<a name="line-337"></a>enclosing class or instance.  Consider
<a name="line-338"></a>
<a name="line-339"></a>  instance C Int [z] where
<a name="line-340"></a>     type F Int [z] = ...   -- Second param must be [z]
<a name="line-341"></a>
<a name="line-342"></a>In the CoAxBranch in the instance decl (F Int [z]) we use the
<a name="line-343"></a>same 'z', so that it's easy to check that that type is the same
<a name="line-344"></a>as that in the instance header.
<a name="line-345"></a>
<a name="line-346"></a>So, unlike FamInsts, there is no expectation that the cab_tvs
<a name="line-347"></a>are fresh wrt each other, or any other CoAxBranch.
<a name="line-348"></a>
<a name="line-349"></a>Note [CoAxBranch roles]
<a name="line-350"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-351"></a>Consider this code:
<a name="line-352"></a>
<a name="line-353"></a>  newtype Age = MkAge Int
<a name="line-354"></a>  newtype Wrap a = MkWrap a
<a name="line-355"></a>
<a name="line-356"></a>  convert :: Wrap Age -&gt; Int
<a name="line-357"></a>  convert (MkWrap (MkAge i)) = i
<a name="line-358"></a>
<a name="line-359"></a>We want this to compile to:
<a name="line-360"></a>
<a name="line-361"></a>  NTCo:Wrap :: forall a. Wrap a ~R a
<a name="line-362"></a>  NTCo:Age  :: Age ~R Int
<a name="line-363"></a>  convert = \x -&gt; x |&gt; (NTCo:Wrap[0] NTCo:Age[0])
<a name="line-364"></a>
<a name="line-365"></a>But, note that NTCo:Age is at role R. Thus, we need to be able to pass
<a name="line-366"></a>coercions at role R into axioms. However, we don't *always* want to be able to
<a name="line-367"></a>do this, as it would be disastrous with type families. The solution is to
<a name="line-368"></a>annotate the arguments to the axiom with roles, much like we annotate tycon
<a name="line-369"></a>tyvars. Where do these roles get set? Newtype axioms inherit their roles from
<a name="line-370"></a>the newtype tycon; family axioms are all at role N.
<a name="line-371"></a>
<a name="line-372"></a>Note [CoAxiom locations]
<a name="line-373"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-374"></a>The source location of a CoAxiom is stored in two places in the
<a name="line-375"></a>datatype tree.
<a name="line-376"></a>  * The first is in the location info buried in the Name of the
<a name="line-377"></a>    CoAxiom. This span includes all of the branches of a branched
<a name="line-378"></a>    CoAxiom.
<a name="line-379"></a>  * The second is in the cab_loc fields of the CoAxBranches.
<a name="line-380"></a>
<a name="line-381"></a>In the case of a single branch, we can extract the source location of
<a name="line-382"></a>the branch from the name of the CoAxiom. In other cases, we need an
<a name="line-383"></a>explicit SrcSpan to correctly store the location of the equation
<a name="line-384"></a>giving rise to the FamInstBranch.
<a name="line-385"></a>
<a name="line-386"></a>Note [Implicit axioms]
<a name="line-387"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-388"></a>See also Note [Implicit TyThings] in GHC.Types.TyThing
<a name="line-389"></a>* A CoAxiom arising from data/type family instances is not "implicit".
<a name="line-390"></a>  That is, it has its own IfaceAxiom declaration in an interface file
<a name="line-391"></a>
<a name="line-392"></a>* The CoAxiom arising from a newtype declaration *is* "implicit".
<a name="line-393"></a>  That is, it does not have its own IfaceAxiom declaration in an
<a name="line-394"></a>  interface file; instead the CoAxiom is generated by type-checking
<a name="line-395"></a>  the newtype declaration
<a name="line-396"></a>
<a name="line-397"></a>Note [Eta reduction for data families]
<a name="line-398"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-399"></a>Consider this
<a name="line-400"></a>   data family T a b :: *
<a name="line-401"></a>   newtype instance T Int a = MkT (IO a) deriving( Monad )
<a name="line-402"></a>We'd like this to work.
<a name="line-403"></a>
<a name="line-404"></a>From the 'newtype instance' you might think we'd get:
<a name="line-405"></a>   newtype TInt a = MkT (IO a)
<a name="line-406"></a>   axiom ax1 a :: T Int a ~ TInt a   -- The newtype-instance part
<a name="line-407"></a>   axiom ax2 a :: TInt a ~ IO a      -- The newtype part
<a name="line-408"></a>
<a name="line-409"></a>But now what can we do?  We have this problem
<a name="line-410"></a>   Given:   d  :: Monad IO
<a name="line-411"></a>   Wanted:  d' :: Monad (T Int) = d |&gt; ????
<a name="line-412"></a>What coercion can we use for the ???
<a name="line-413"></a>
<a name="line-414"></a>Solution: eta-reduce both axioms, thus:
<a name="line-415"></a>   axiom ax1 :: T Int ~ TInt
<a name="line-416"></a>   axiom ax2 :: TInt ~ IO
<a name="line-417"></a>Now
<a name="line-418"></a>   d' = d |&gt; Monad (sym (ax2 ; ax1))
<a name="line-419"></a>
<a name="line-420"></a>----- Bottom line ------
<a name="line-421"></a>
<a name="line-422"></a>For a CoAxBranch for a data family instance with representation
<a name="line-423"></a>TyCon rep_tc:
<a name="line-424"></a>
<a name="line-425"></a>  - cab_tvs (of its CoAxiom) may be shorter
<a name="line-426"></a>    than tyConTyVars of rep_tc.
<a name="line-427"></a>
<a name="line-428"></a>  - cab_lhs may be shorter than tyConArity of the family tycon
<a name="line-429"></a>       i.e. LHS is unsaturated
<a name="line-430"></a>
<a name="line-431"></a>  - cab_rhs will be (rep_tc cab_tvs)
<a name="line-432"></a>       i.e. RHS is un-saturated
<a name="line-433"></a>
<a name="line-434"></a>  - This eta reduction happens for data instances as well
<a name="line-435"></a>    as newtype instances. Here we want to eta-reduce the data family axiom.
<a name="line-436"></a>
<a name="line-437"></a>  - This eta-reduction is done in GHC.Tc.TyCl.Instance.tcDataFamInstDecl.
<a name="line-438"></a>
<a name="line-439"></a>But for a /type/ family
<a name="line-440"></a>  - cab_lhs has the exact arity of the family tycon
<a name="line-441"></a>
<a name="line-442"></a>There are certain situations (e.g., pretty-printing) where it is necessary to
<a name="line-443"></a>deal with eta-expanded data family instances. For these situations, the
<a name="line-444"></a>cab_eta_tvs field records the stuff that has been eta-reduced away.
<a name="line-445"></a>So if we have
<a name="line-446"></a>    axiom forall a b. F [a-&gt;b] = D b a
<a name="line-447"></a>and cab_eta_tvs is [p,q], then the original user-written definition
<a name="line-448"></a>looked like
<a name="line-449"></a>    axiom forall a b p q. F [a-&gt;b] p q = D b a p q
<a name="line-450"></a>(See #9692, #14179, and #15845 for examples of what can go wrong if
<a name="line-451"></a>we don't eta-expand when showing things to the user.)
<a name="line-452"></a>
<a name="line-453"></a>See also:
<a name="line-454"></a>
<a name="line-455"></a>* Note [Newtype eta] in GHC.Core.TyCon.  This is notionally separate
<a name="line-456"></a>  and deals with the axiom connecting a newtype with its representation
<a name="line-457"></a>  type; but it too is eta-reduced.
<a name="line-458"></a>* Note [Implementing eta reduction for data families] in "GHC.Tc.TyCl.Instance". This
<a name="line-459"></a>  describes the implementation details of this eta reduction happen.
<a name="line-460"></a>-}</span>
<a name="line-461"></a>
<a name="line-462"></a><a name="instance%20Eq%20(CoAxiom%20br)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-463"></a>    <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getUnique</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>getUnique</span> <span class='hs-varid'>b</span>
<a name="line-464"></a>    <span class='hs-varid'>a</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getUnique</span> <span class='hs-varid'>a</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>getUnique</span> <span class='hs-varid'>b</span>
<a name="line-465"></a>
<a name="line-466"></a><a name="instance%20Uniquable%20(CoAxiom%20br)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Uniquable</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-467"></a>    <span class='hs-varid'>getUnique</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_unique</span>
<a name="line-468"></a>
<a name="line-469"></a><a name="instance%20Outputable%20(CoAxiom%20br)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-470"></a>    <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>getName</span>
<a name="line-471"></a>
<a name="line-472"></a><a name="instance%20NamedThing%20(CoAxiom%20br)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>NamedThing</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-473"></a>    <span class='hs-varid'>getName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>co_ax_name</span>
<a name="line-474"></a>
<a name="line-475"></a><a name="instance%20Data.Data%20(CoAxiom%20br)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Typeable</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Data.Data</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-varid'>br</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-476"></a>    <span class='hs-comment'>-- don't traverse?</span>
<a name="line-477"></a>    <span class='hs-varid'>toConstr</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>abstractConstr</span> <span class='hs-str'>"CoAxiom"</span>
<a name="line-478"></a>    <span class='hs-varid'>gunfold</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"gunfold"</span>
<a name="line-479"></a>    <span class='hs-varid'>dataTypeOf</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNoRepType</span> <span class='hs-str'>"CoAxiom"</span>
<a name="line-480"></a>
<a name="line-481"></a><a name="instance%20Outputable%20CoAxBranch"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyword'>where</span>
<a name="line-482"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxBranch</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cab_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span>
<a name="line-483"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>cab_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs</span>
<a name="line-484"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>cab_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-485"></a>    <span class='hs-varid'>text</span> <span class='hs-str'>"CoAxBranch"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>colon</span>
<a name="line-486"></a>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>brackets</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>punctuate</span> <span class='hs-varid'>comma</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>lhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-487"></a>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"=&gt;"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprType</span> <span class='hs-varid'>rhs</span>
<a name="line-488"></a>
<a name="line-489"></a><span class='hs-comment'>{-
<a name="line-490"></a>************************************************************************
<a name="line-491"></a>*                                                                      *
<a name="line-492"></a>                    Roles
<a name="line-493"></a>*                                                                      *
<a name="line-494"></a>************************************************************************
<a name="line-495"></a>
<a name="line-496"></a>Roles are defined here to avoid circular dependencies.
<a name="line-497"></a>-}</span>
<a name="line-498"></a>
<a name="line-499"></a><a name="Role"></a><span class='hs-comment'>-- See Note [Roles] in GHC.Core.Coercion</span>
<a name="line-500"></a><a name="Role"></a><span class='hs-comment'>-- defined here to avoid cyclic dependency with GHC.Core.Coercion</span>
<a name="line-501"></a><a name="Role"></a><span class='hs-comment'>--</span>
<a name="line-502"></a><a name="Role"></a><span class='hs-comment'>-- Order of constructors matters: the Ord instance coincides with the *super*typing</span>
<a name="line-503"></a><a name="Role"></a><span class='hs-comment'>-- relation on roles.</span>
<a name="line-504"></a><a name="Role"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nominal</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Representational</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Phantom</span>
<a name="line-505"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Ord</span><span class='hs-layout'>,</span> <span class='hs-conid'>Data.Data</span><span class='hs-layout'>)</span>
<a name="line-506"></a>
<a name="line-507"></a><a name="fsFromRole"></a><span class='hs-comment'>-- These names are slurped into the parser code. Changing these strings</span>
<a name="line-508"></a><span class='hs-comment'>-- will change the **surface syntax** that GHC accepts! If you want to</span>
<a name="line-509"></a><span class='hs-comment'>-- change only the pretty-printing, do some replumbing. See</span>
<a name="line-510"></a><span class='hs-comment'>-- mkRoleAnnotDecl in GHC.Parser.PostProcess</span>
<a name="line-511"></a><span class='hs-definition'>fsFromRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FastString</span>
<a name="line-512"></a><span class='hs-definition'>fsFromRole</span> <span class='hs-conid'>Nominal</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsLit</span> <span class='hs-str'>"nominal"</span>
<a name="line-513"></a><span class='hs-definition'>fsFromRole</span> <span class='hs-conid'>Representational</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsLit</span> <span class='hs-str'>"representational"</span>
<a name="line-514"></a><span class='hs-definition'>fsFromRole</span> <span class='hs-conid'>Phantom</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsLit</span> <span class='hs-str'>"phantom"</span>
<a name="line-515"></a>
<a name="line-516"></a><a name="instance%20Outputable%20Role"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Role</span> <span class='hs-keyword'>where</span>
<a name="line-517"></a>  <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ftext</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fsFromRole</span>
<a name="line-518"></a>
<a name="line-519"></a><a name="instance%20Binary%20Role"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Binary</span> <span class='hs-conid'>Role</span> <span class='hs-keyword'>where</span>
<a name="line-520"></a>  <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-conid'>Nominal</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>1</span>
<a name="line-521"></a>  <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-conid'>Representational</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>2</span>
<a name="line-522"></a>  <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-conid'>Phantom</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>3</span>
<a name="line-523"></a>
<a name="line-524"></a>  <span class='hs-varid'>get</span> <span class='hs-varid'>bh</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>tag</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getByte</span> <span class='hs-varid'>bh</span>
<a name="line-525"></a>              <span class='hs-keyword'>case</span> <span class='hs-varid'>tag</span> <span class='hs-keyword'>of</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nominal</span>
<a name="line-526"></a>                          <span class='hs-num'>2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Representational</span>
<a name="line-527"></a>                          <span class='hs-num'>3</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Phantom</span>
<a name="line-528"></a>                          <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panic</span> <span class='hs-layout'>(</span><span class='hs-str'>"get Role "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-varid'>tag</span><span class='hs-layout'>)</span>
<a name="line-529"></a>
<a name="line-530"></a><span class='hs-comment'>{-
<a name="line-531"></a>************************************************************************
<a name="line-532"></a>*                                                                      *
<a name="line-533"></a>                    CoAxiomRule
<a name="line-534"></a>              Rules for building Evidence
<a name="line-535"></a>*                                                                      *
<a name="line-536"></a>************************************************************************
<a name="line-537"></a>
<a name="line-538"></a>Conditional axioms.  The general idea is that a `CoAxiomRule` looks like this:
<a name="line-539"></a>
<a name="line-540"></a>    forall as. (r1 ~ r2, s1 ~ s2) =&gt; t1 ~ t2
<a name="line-541"></a>
<a name="line-542"></a>My intention is to reuse these for both (~) and (~#).
<a name="line-543"></a>The short-term plan is to use this datatype to represent the type-nat axioms.
<a name="line-544"></a>In the longer run, it may be good to unify this and `CoAxiom`,
<a name="line-545"></a>as `CoAxiom` is the special case when there are no assumptions.
<a name="line-546"></a>-}</span>
<a name="line-547"></a>
<a name="line-548"></a><a name="TypeEqn"></a><span class='hs-comment'>-- | A more explicit representation for `t1 ~ t2`.</span>
<a name="line-549"></a><a name="TypeEqn"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TypeEqn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Pair</span> <span class='hs-conid'>Type</span>
<a name="line-550"></a>
<a name="line-551"></a><a name="CoAxiomRule"></a><span class='hs-comment'>-- | For now, we work only with nominal equality.</span>
<a name="line-552"></a><a name="CoAxiomRule"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoAxiomRule</span>
<a name="line-553"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>coaxrName</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FastString</span>
<a name="line-554"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>coaxrAsmpRoles</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- roles of parameter equations</span>
<a name="line-555"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>coaxrRole</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Role</span>      <span class='hs-comment'>-- role of resulting equation</span>
<a name="line-556"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>coaxrProves</span>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeEqn</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>TypeEqn</span>
<a name="line-557"></a>        <span class='hs-comment'>-- ^ coaxrProves returns @Nothing@ when it doesn't like</span>
<a name="line-558"></a>        <span class='hs-comment'>-- the supplied arguments.  When this happens in a coercion</span>
<a name="line-559"></a>        <span class='hs-comment'>-- that means that the coercion is ill-formed, and Core Lint</span>
<a name="line-560"></a>        <span class='hs-comment'>-- checks for that.</span>
<a name="line-561"></a>  <span class='hs-layout'>}</span>
<a name="line-562"></a>
<a name="line-563"></a><a name="instance%20Data.Data%20CoAxiomRule"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Data.Data</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyword'>where</span>
<a name="line-564"></a>  <span class='hs-comment'>-- don't traverse?</span>
<a name="line-565"></a>  <span class='hs-varid'>toConstr</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>abstractConstr</span> <span class='hs-str'>"CoAxiomRule"</span>
<a name="line-566"></a>  <span class='hs-varid'>gunfold</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"gunfold"</span>
<a name="line-567"></a>  <span class='hs-varid'>dataTypeOf</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNoRepType</span> <span class='hs-str'>"CoAxiomRule"</span>
<a name="line-568"></a>
<a name="line-569"></a><a name="instance%20Uniquable%20CoAxiomRule"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Uniquable</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyword'>where</span>
<a name="line-570"></a>  <span class='hs-varid'>getUnique</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getUnique</span> <span class='hs-varop'>.</span> <span class='hs-varid'>coaxrName</span>
<a name="line-571"></a>
<a name="line-572"></a><a name="instance%20Eq%20CoAxiomRule"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyword'>where</span>
<a name="line-573"></a>  <span class='hs-varid'>x</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coaxrName</span> <span class='hs-varid'>x</span> <span class='hs-varop'>==</span> <span class='hs-varid'>coaxrName</span> <span class='hs-varid'>y</span>
<a name="line-574"></a>
<a name="line-575"></a><a name="instance%20Ord%20CoAxiomRule"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyword'>where</span>
<a name="line-576"></a>  <span class='hs-comment'>-- we compare lexically to avoid non-deterministic output when sets of rules</span>
<a name="line-577"></a>  <span class='hs-comment'>-- are printed</span>
<a name="line-578"></a>  <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lexicalCompareFS</span> <span class='hs-layout'>(</span><span class='hs-varid'>coaxrName</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>coaxrName</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-579"></a>
<a name="line-580"></a><a name="instance%20Outputable%20CoAxiomRule"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyword'>where</span>
<a name="line-581"></a>  <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>coaxrName</span>
<a name="line-582"></a>
<a name="line-583"></a>
<a name="line-584"></a><a name="BuiltInSynFamily"></a><span class='hs-comment'>-- Type checking of built-in families</span>
<a name="line-585"></a><a name="BuiltInSynFamily"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>BuiltInSynFamily</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BuiltInSynFamily</span>
<a name="line-586"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>sfMatchFam</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiomRule</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>
<a name="line-587"></a>    <span class='hs-comment'>-- Does this reduce on the given arguments?</span>
<a name="line-588"></a>    <span class='hs-comment'>-- If it does, returns (CoAxiomRule, types to instantiate the rule at, rhs type)</span>
<a name="line-589"></a>    <span class='hs-comment'>-- That is: mkAxiomRuleCo coax (zipWith mkReflCo (coaxrAsmpRoles coax) ts)</span>
<a name="line-590"></a>    <span class='hs-comment'>--              :: F tys ~r rhs,</span>
<a name="line-591"></a>    <span class='hs-comment'>-- where the r in the output is coaxrRole of the rule. It is up to the</span>
<a name="line-592"></a>    <span class='hs-comment'>-- caller to ensure that this role is appropriate.</span>
<a name="line-593"></a>
<a name="line-594"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>sfInteractTop</span>   <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeEqn</span><span class='hs-keyglyph'>]</span>
<a name="line-595"></a>    <span class='hs-comment'>-- If given these type arguments and RHS, returns the equalities that</span>
<a name="line-596"></a>    <span class='hs-comment'>-- are guaranteed to hold.</span>
<a name="line-597"></a>
<a name="line-598"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>sfInteractInert</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-599"></a>                       <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeEqn</span><span class='hs-keyglyph'>]</span>
<a name="line-600"></a>    <span class='hs-comment'>-- If given one set of arguments and result, and another set of arguments</span>
<a name="line-601"></a>    <span class='hs-comment'>-- and result, returns the equalities that are guaranteed to hold.</span>
<a name="line-602"></a>  <span class='hs-layout'>}</span>
<a name="line-603"></a>
<a name="line-604"></a><a name="trivialBuiltInFamily"></a><span class='hs-comment'>-- Provides default implementations that do nothing.</span>
<a name="line-605"></a><span class='hs-definition'>trivialBuiltInFamily</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BuiltInSynFamily</span>
<a name="line-606"></a><span class='hs-definition'>trivialBuiltInFamily</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BuiltInSynFamily</span>
<a name="line-607"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>sfMatchFam</span>      <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-608"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>sfInteractTop</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-609"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>sfInteractInert</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-610"></a>  <span class='hs-layout'>}</span>
</pre></body>
</html>
