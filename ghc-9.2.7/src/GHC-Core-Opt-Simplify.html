<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/Simplify.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The AQUA Project, Glasgow University, 1993-1998
<a name="line-3"></a>
<a name="line-4"></a>\section[Simplify]{The main module of the simplifier}
<a name="line-5"></a>-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-8"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-record-updates -Wno-incomplete-uni-patterns #-}</span>
<a name="line-11"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.Simplify</span> <span class='hs-layout'>(</span> <span class='hs-varid'>simplTopBinds</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplRules</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Platform</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Config</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Simplify.Monad</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-varid'>substTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>substTyVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendTvSubst</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendCvSubst</span> <span class='hs-layout'>)</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Simplify.Env</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Simplify.Utils</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.OccurAnal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>occurAnalyseExpr</span> <span class='hs-layout'>)</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Literal</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>litIsLifted</span> <span class='hs-layout'>)</span> <span class='hs-comment'>--, mkLitInt ) -- temporalily commented out. See #8326</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SourceText</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Make</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>seqId</span> <span class='hs-layout'>)</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Make</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>FloatBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkImpossibleExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>castBottomExpr</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.Core.Make</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>           <span class='hs-layout'>(</span> <span class='hs-varid'>mkSystemVarName</span><span class='hs-layout'>,</span> <span class='hs-varid'>isExternalName</span><span class='hs-layout'>,</span> <span class='hs-varid'>getOccFS</span> <span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-varid'>substCo</span><span class='hs-layout'>,</span> <span class='hs-varid'>substCoVar</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion.Opt</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>optCoercion</span> <span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>      <span class='hs-layout'>(</span> <span class='hs-conid'>FamInstEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-38"></a>   <span class='hs-layout'>(</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>dataConWorkId</span><span class='hs-layout'>,</span> <span class='hs-varid'>dataConRepStrictness</span>
<a name="line-39"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>dataConRepArgTys</span><span class='hs-layout'>,</span> <span class='hs-varid'>isUnboxedTupleDataCon</span>
<a name="line-40"></a>   <span class='hs-layout'>,</span> <span class='hs-conid'>StrictnessMark</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Monad</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Tick</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types.Prim</span><span class='hs-layout'>(</span> <span class='hs-varid'>realWorldStatePrimTy</span> <span class='hs-layout'>)</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span><span class='hs-layout'>(</span> <span class='hs-varid'>runRWKey</span> <span class='hs-layout'>)</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span> <span class='hs-layout'>(</span> <span class='hs-conid'>StrictSig</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Demand</span><span class='hs-layout'>,</span> <span class='hs-varid'>dmdTypeDepth</span><span class='hs-layout'>,</span> <span class='hs-varid'>isStrUsedDmd</span>
<a name="line-46"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>mkClosedStrictSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>,</span> <span class='hs-varid'>seqDmd</span><span class='hs-layout'>,</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-layout'>)</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Cpr</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>mkCprSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>botCpr</span> <span class='hs-layout'>)</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Ppr</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>pprCoreExpr</span> <span class='hs-layout'>)</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span> <span class='hs-layout'>(</span> <span class='hs-varid'>hasKey</span> <span class='hs-layout'>)</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unfold</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unfold.Make</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Arity</span> <span class='hs-layout'>(</span> <span class='hs-conid'>ArityType</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-54"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>pushCoTyArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushCoValArg</span>
<a name="line-55"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>idArityType</span><span class='hs-layout'>,</span> <span class='hs-varid'>etaExpandAT</span> <span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.SimpleOpt</span> <span class='hs-layout'>(</span> <span class='hs-varid'>exprIsConApp_maybe</span><span class='hs-layout'>,</span> <span class='hs-varid'>joinPointBinding_maybe</span><span class='hs-layout'>,</span> <span class='hs-varid'>joinPointBindings_maybe</span> <span class='hs-layout'>)</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>mkRuleInfo</span> <span class='hs-layout'>)</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Rules</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>lookupRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>getRules</span><span class='hs-layout'>,</span> <span class='hs-varid'>initRuleOpts</span> <span class='hs-layout'>)</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Monad</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>mapAccumLM</span><span class='hs-layout'>,</span> <span class='hs-varid'>liftIO</span> <span class='hs-layout'>)</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Logger</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>isTyCoVar</span> <span class='hs-layout'>)</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>isNothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>orElse</span> <span class='hs-layout'>)</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module</span> <span class='hs-layout'>(</span> <span class='hs-varid'>moduleName</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprModuleName</span> <span class='hs-layout'>)</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.PrimOps</span> <span class='hs-layout'>(</span> <span class='hs-conid'>PrimOp</span> <span class='hs-layout'>(</span><span class='hs-conid'>SeqOp</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-73"></a>
<a name="line-74"></a>
<a name="line-75"></a><span class='hs-comment'>{-
<a name="line-76"></a>The guts of the simplifier is in this module, but the driver loop for
<a name="line-77"></a>the simplifier is in GHC.Core.Opt.Pipeline
<a name="line-78"></a>
<a name="line-79"></a>Note [The big picture]
<a name="line-80"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-81"></a>The general shape of the simplifier is this:
<a name="line-82"></a>
<a name="line-83"></a>  simplExpr :: SimplEnv -&gt; InExpr -&gt; SimplCont -&gt; SimplM (SimplFloats, OutExpr)
<a name="line-84"></a>  simplBind :: SimplEnv -&gt; InBind -&gt; SimplM (SimplFloats, SimplEnv)
<a name="line-85"></a>
<a name="line-86"></a> * SimplEnv contains
<a name="line-87"></a>     - Simplifier mode (which includes DynFlags for convenience)
<a name="line-88"></a>     - Ambient substitution
<a name="line-89"></a>     - InScopeSet
<a name="line-90"></a>
<a name="line-91"></a> * SimplFloats contains
<a name="line-92"></a>     - Let-floats (which includes ok-for-spec case-floats)
<a name="line-93"></a>     - Join floats
<a name="line-94"></a>     - InScopeSet (including all the floats)
<a name="line-95"></a>
<a name="line-96"></a> * Expressions
<a name="line-97"></a>      simplExpr :: SimplEnv -&gt; InExpr -&gt; SimplCont
<a name="line-98"></a>                -&gt; SimplM (SimplFloats, OutExpr)
<a name="line-99"></a>   The result of simplifying an /expression/ is (floats, expr)
<a name="line-100"></a>      - A bunch of floats (let bindings, join bindings)
<a name="line-101"></a>      - A simplified expression.
<a name="line-102"></a>   The overall result is effectively (let floats in expr)
<a name="line-103"></a>
<a name="line-104"></a> * Bindings
<a name="line-105"></a>      simplBind :: SimplEnv -&gt; InBind -&gt; SimplM (SimplFloats, SimplEnv)
<a name="line-106"></a>   The result of simplifying a binding is
<a name="line-107"></a>     - A bunch of floats, the last of which is the simplified binding
<a name="line-108"></a>       There may be auxiliary bindings too; see prepareRhs
<a name="line-109"></a>     - An environment suitable for simplifying the scope of the binding
<a name="line-110"></a>
<a name="line-111"></a>   The floats may also be empty, if the binding is inlined unconditionally;
<a name="line-112"></a>   in that case the returned SimplEnv will have an augmented substitution.
<a name="line-113"></a>
<a name="line-114"></a>   The returned floats and env both have an in-scope set, and they are
<a name="line-115"></a>   guaranteed to be the same.
<a name="line-116"></a>
<a name="line-117"></a>
<a name="line-118"></a>Note [Shadowing]
<a name="line-119"></a>~~~~~~~~~~~~~~~~
<a name="line-120"></a>The simplifier used to guarantee that the output had no shadowing, but
<a name="line-121"></a>it does not do so any more.   (Actually, it never did!)  The reason is
<a name="line-122"></a>documented with simplifyArgs.
<a name="line-123"></a>
<a name="line-124"></a>
<a name="line-125"></a>Eta expansion
<a name="line-126"></a>~~~~~~~~~~~~~~
<a name="line-127"></a>For eta expansion, we want to catch things like
<a name="line-128"></a>
<a name="line-129"></a>        case e of (a,b) -&gt; \x -&gt; case a of (p,q) -&gt; \y -&gt; r
<a name="line-130"></a>
<a name="line-131"></a>If the \x was on the RHS of a let, we'd eta expand to bring the two
<a name="line-132"></a>lambdas together.  And in general that's a good thing to do.  Perhaps
<a name="line-133"></a>we should eta expand wherever we find a (value) lambda?  Then the eta
<a name="line-134"></a>expansion at a let RHS can concentrate solely on the PAP case.
<a name="line-135"></a>
<a name="line-136"></a>Note [In-scope set as a substitution]
<a name="line-137"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-138"></a>As per Note [Lookups in in-scope set], an in-scope set can act as
<a name="line-139"></a>a substitution. Specifically, it acts as a substitution from variable to
<a name="line-140"></a>variables /with the same unique/.
<a name="line-141"></a>
<a name="line-142"></a>Why do we need this? Well, during the course of the simplifier, we may want to
<a name="line-143"></a>adjust inessential properties of a variable. For instance, when performing a
<a name="line-144"></a>beta-reduction, we change
<a name="line-145"></a>
<a name="line-146"></a>    (\x. e) u ==&gt; let x = u in e
<a name="line-147"></a>
<a name="line-148"></a>We typically want to add an unfolding to `x` so that it inlines to (the
<a name="line-149"></a>simplification of) `u`.
<a name="line-150"></a>
<a name="line-151"></a>We do that by adding the unfolding to the binder `x`, which is added to the
<a name="line-152"></a>in-scope set. When simplifying occurrences of `x` (every occurrence!), they are
<a name="line-153"></a>replaced by their “updated” version from the in-scope set, hence inherit the
<a name="line-154"></a>unfolding. This happens in `SimplEnv.substId`.
<a name="line-155"></a>
<a name="line-156"></a>Another example. Consider
<a name="line-157"></a>
<a name="line-158"></a>   case x of y { Node a b -&gt; ...y...
<a name="line-159"></a>               ; Leaf v   -&gt; ...y... }
<a name="line-160"></a>
<a name="line-161"></a>In the Node branch want y's unfolding to be (Node a b); in the Leaf branch we
<a name="line-162"></a>want y's unfolding to be (Leaf v). We achieve this by adding the appropriate
<a name="line-163"></a>unfolding to y, and re-adding it to the in-scope set. See the calls to
<a name="line-164"></a>`addBinderUnfolding` in `Simplify.addAltUnfoldings` and elsewhere.
<a name="line-165"></a>
<a name="line-166"></a>It's quite convenient. This way we don't need to manipulate the substitution all
<a name="line-167"></a>the time: every update to a binder is automatically reflected to its bound
<a name="line-168"></a>occurrences.
<a name="line-169"></a>
<a name="line-170"></a>Note [Bangs in the Simplifier]
<a name="line-171"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-172"></a>Both SimplFloats and SimplEnv do *not* generally benefit from making
<a name="line-173"></a>their fields strict. I don't know if this is because of good use of
<a name="line-174"></a>laziness or unintended side effects like closures capturing more variables
<a name="line-175"></a>after WW has run.
<a name="line-176"></a>
<a name="line-177"></a>But the end result is that we keep these lazy, but force them in some places
<a name="line-178"></a>where we know it's beneficial to the compiler.
<a name="line-179"></a>
<a name="line-180"></a>Similarly environments returned from functions aren't *always* beneficial to
<a name="line-181"></a>force. In some places they would never be demanded so forcing them early
<a name="line-182"></a>increases allocation. In other places they almost always get demanded so
<a name="line-183"></a>it's worthwhile to force them early.
<a name="line-184"></a>
<a name="line-185"></a>Would it be better to through every allocation of e.g. SimplEnv and decide
<a name="line-186"></a>wether or not to make this one strict? Absolutely! Would be a good use of
<a name="line-187"></a>someones time? Absolutely not! I made these strict that showed up during
<a name="line-188"></a>a profiled build or which I noticed while looking at core for one reason
<a name="line-189"></a>or another.
<a name="line-190"></a>
<a name="line-191"></a>The result sadly is that we end up with "random" bangs in the simplifier
<a name="line-192"></a>where we sometimes force e.g. the returned environment from a function and
<a name="line-193"></a>sometimes we don't for the same function. Depending on the context around
<a name="line-194"></a>the call. The treatment is also not very consistent. I only added bangs
<a name="line-195"></a>where I saw it making a difference either in the core or benchmarks. Some
<a name="line-196"></a>patterns where it would be beneficial aren't convered as a consequence as
<a name="line-197"></a>I neither have the time to go through all of the core and some cases are
<a name="line-198"></a>too small to show up in benchmarks.
<a name="line-199"></a>
<a name="line-200"></a>
<a name="line-201"></a>
<a name="line-202"></a>************************************************************************
<a name="line-203"></a>*                                                                      *
<a name="line-204"></a>\subsection{Bindings}
<a name="line-205"></a>*                                                                      *
<a name="line-206"></a>************************************************************************
<a name="line-207"></a>-}</span>
<a name="line-208"></a>
<a name="line-209"></a><a name="simplTopBinds"></a><span class='hs-definition'>simplTopBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InBind</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-210"></a><span class='hs-comment'>-- See Note [The big picture]</span>
<a name="line-211"></a><span class='hs-definition'>simplTopBinds</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>binds0</span>
<a name="line-212"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span>       <span class='hs-comment'>-- Put all the top-level binders into scope at the start</span>
<a name="line-213"></a>                <span class='hs-comment'>-- so that if a rewrite rule has unexpectedly brought</span>
<a name="line-214"></a>                <span class='hs-comment'>-- anything into scope, then we don't get a complaint about that.</span>
<a name="line-215"></a>                <span class='hs-comment'>-- It's rather as if the top-level binders were imported.</span>
<a name="line-216"></a>                <span class='hs-comment'>-- See note [Glomming] in "GHC.Core.Opt.OccurAnal".</span>
<a name="line-217"></a>        <span class='hs-comment'>-- See Note [Bangs in the Simplifier]</span>
<a name="line-218"></a>        <span class='hs-layout'>;</span> <span class='hs-varop'>!</span><span class='hs-varid'>env1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "simplTopBinds-simplRecBndrs" #-}</span> <span class='hs-varid'>simplRecBndrs</span> <span class='hs-varid'>env0</span> <span class='hs-layout'>(</span><span class='hs-varid'>bindersOfBinds</span> <span class='hs-varid'>binds0</span><span class='hs-layout'>)</span>
<a name="line-219"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "simplTopBinds-simpl_binds" #-}</span> <span class='hs-varid'>simpl_binds</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>binds0</span>
<a name="line-220"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>freeTick</span> <span class='hs-conid'>SimplifierDone</span>
<a name="line-221"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-222"></a>  <span class='hs-keyword'>where</span>
<a name="line-223"></a>        <span class='hs-comment'>-- We need to track the zapped top-level binders, because</span>
<a name="line-224"></a>        <span class='hs-comment'>-- they should have their fragile IdInfo zapped (notably occurrence info)</span>
<a name="line-225"></a>        <span class='hs-comment'>-- That's why we run down binds and bndrs' simultaneously.</span>
<a name="line-226"></a>        <span class='hs-comment'>--</span>
<a name="line-227"></a>    <span class='hs-varid'>simpl_binds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InBind</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-228"></a>    <span class='hs-varid'>simpl_binds</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-229"></a>    <span class='hs-varid'>simpl_binds</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind</span><span class='hs-conop'>:</span><span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>float</span><span class='hs-layout'>,</span>  <span class='hs-varid'>env1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_bind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bind</span>
<a name="line-230"></a>                                      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_binds</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>binds</span>
<a name="line-231"></a>                                      <span class='hs-comment'>-- See Note [Bangs in the Simplifier]</span>
<a name="line-232"></a>                                      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>floats1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats</span>
<a name="line-233"></a>                                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-234"></a>
<a name="line-235"></a>    <span class='hs-varid'>simpl_bind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>
<a name="line-236"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplRecBind</span> <span class='hs-varid'>env</span> <span class='hs-conid'>TopLevel</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>pairs</span>
<a name="line-237"></a>    <span class='hs-varid'>simpl_bind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-238"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addBndrRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupRecBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-239"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>simplRecOrTopPair</span> <span class='hs-varid'>env'</span> <span class='hs-conid'>TopLevel</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>b</span> <span class='hs-varid'>b'</span> <span class='hs-varid'>r</span> <span class='hs-layout'>}</span>
<a name="line-240"></a>
<a name="line-241"></a><span class='hs-comment'>{-
<a name="line-242"></a>************************************************************************
<a name="line-243"></a>*                                                                      *
<a name="line-244"></a>        Lazy bindings
<a name="line-245"></a>*                                                                      *
<a name="line-246"></a>************************************************************************
<a name="line-247"></a>
<a name="line-248"></a>simplRecBind is used for
<a name="line-249"></a>        * recursive bindings only
<a name="line-250"></a>-}</span>
<a name="line-251"></a>
<a name="line-252"></a><a name="simplRecBind"></a><span class='hs-definition'>simplRecBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span>
<a name="line-253"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>InId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-254"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-255"></a><span class='hs-definition'>simplRecBind</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>mb_cont</span> <span class='hs-varid'>pairs0</span>
<a name="line-256"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env_with_info</span><span class='hs-layout'>,</span> <span class='hs-varid'>triples</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAccumLM</span> <span class='hs-varid'>add_rules</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>pairs0</span>
<a name="line-257"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rec_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env_with_info</span> <span class='hs-varid'>triples</span>
<a name="line-258"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkRecFloats</span> <span class='hs-varid'>rec_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-259"></a>  <span class='hs-keyword'>where</span>
<a name="line-260"></a>    <span class='hs-varid'>add_rules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>InBndr</span><span class='hs-layout'>,</span><span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>InBndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-261"></a>        <span class='hs-comment'>-- Add the (substituted) rules to the binder</span>
<a name="line-262"></a>    <span class='hs-varid'>add_rules</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-263"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addBndrRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupRecBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>mb_cont</span>
<a name="line-264"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-265"></a>
<a name="line-266"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-267"></a>
<a name="line-268"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>old_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>
<a name="line-269"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>float</span><span class='hs-layout'>,</span> <span class='hs-varid'>env1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplRecOrTopPair</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-conid'>Recursive</span> <span class='hs-varid'>mb_cont</span>
<a name="line-270"></a>                                                  <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-271"></a>             <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>pairs</span>
<a name="line-272"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>float</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-273"></a>
<a name="line-274"></a><span class='hs-comment'>{-
<a name="line-275"></a>simplOrTopPair is used for
<a name="line-276"></a>        * recursive bindings (whether top level or not)
<a name="line-277"></a>        * top-level non-recursive bindings
<a name="line-278"></a>
<a name="line-279"></a>It assumes the binder has already been simplified, but not its IdInfo.
<a name="line-280"></a>-}</span>
<a name="line-281"></a>
<a name="line-282"></a><a name="simplRecOrTopPair"></a><span class='hs-definition'>simplRecOrTopPair</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-283"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span>
<a name="line-284"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>  <span class='hs-comment'>-- Binder and rhs</span>
<a name="line-285"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-286"></a>
<a name="line-287"></a><span class='hs-definition'>simplRecOrTopPair</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>mb_cont</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-288"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>preInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>env</span>
<a name="line-289"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplRecOrTopPair-pre-inline-uncond" #-}</span>
<a name="line-290"></a>    <span class='hs-varid'>trace_bind</span> <span class='hs-str'>"pre-inline-uncond"</span> <span class='hs-varop'>$</span>
<a name="line-291"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>PreInlineUnconditionally</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span>
<a name="line-292"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-293"></a>
<a name="line-294"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_cont</span>
<a name="line-295"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplRecOrTopPair-join" #-}</span>
<a name="line-296"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isNotTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>new_bndr</span> <span class='hs-layout'>)</span>
<a name="line-297"></a>    <span class='hs-varid'>trace_bind</span> <span class='hs-str'>"join"</span> <span class='hs-varop'>$</span>
<a name="line-298"></a>    <span class='hs-varid'>simplJoinBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>env</span>
<a name="line-299"></a>
<a name="line-300"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-301"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplRecOrTopPair-normal" #-}</span>
<a name="line-302"></a>    <span class='hs-varid'>trace_bind</span> <span class='hs-str'>"normal"</span> <span class='hs-varop'>$</span>
<a name="line-303"></a>    <span class='hs-varid'>simplLazyBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>env</span>
<a name="line-304"></a>
<a name="line-305"></a>  <span class='hs-keyword'>where</span>
<a name="line-306"></a>    <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env</span>
<a name="line-307"></a>    <span class='hs-varid'>logger</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seLogger</span> <span class='hs-varid'>env</span>
<a name="line-308"></a>
<a name="line-309"></a>    <span class='hs-comment'>-- trace_bind emits a trace for each top-level binding, which</span>
<a name="line-310"></a>    <span class='hs-comment'>-- helps to locate the tracing for inlining and rule firing</span>
<a name="line-311"></a>    <span class='hs-varid'>trace_bind</span> <span class='hs-varid'>what</span> <span class='hs-varid'>thing_inside</span>
<a name="line-312"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_verbose_core2core</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-313"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thing_inside</span>
<a name="line-314"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-315"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putTraceMsg</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-layout'>(</span><span class='hs-str'>"SimplBind "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>what</span><span class='hs-layout'>)</span>
<a name="line-316"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>thing_inside</span>
<a name="line-317"></a>
<a name="line-318"></a><a name="simplLazyBind"></a><span class='hs-comment'>--------------------------</span>
<a name="line-319"></a><span class='hs-definition'>simplLazyBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-320"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span>
<a name="line-321"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>          <span class='hs-comment'>-- Binder, both pre-and post simpl</span>
<a name="line-322"></a>                                        <span class='hs-comment'>-- Not a JoinId</span>
<a name="line-323"></a>                                        <span class='hs-comment'>-- The OutId has IdInfo, except arity, unfolding</span>
<a name="line-324"></a>                                        <span class='hs-comment'>-- Ids only, no TyVars</span>
<a name="line-325"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>     <span class='hs-comment'>-- The RHS and its environment</span>
<a name="line-326"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-327"></a><span class='hs-comment'>-- Precondition: not a JoinId</span>
<a name="line-328"></a><span class='hs-comment'>-- Precondition: rhs obeys the let/app invariant</span>
<a name="line-329"></a><span class='hs-comment'>-- NOT used for JoinIds</span>
<a name="line-330"></a><span class='hs-definition'>simplLazyBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr1</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rhs_se</span>
<a name="line-331"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>)</span>
<a name="line-332"></a>    <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>)</span>
<a name="line-333"></a>    <span class='hs-comment'>-- pprTrace "simplLazyBind" ((ppr bndr &lt;+&gt; ppr bndr1) $$ ppr rhs $$ ppr (seIdSubst rhs_se)) $</span>
<a name="line-334"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span>   <span class='hs-varop'>!</span><span class='hs-varid'>rhs_env</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span> <span class='hs-comment'>-- See Note [Bangs in the Simplifier]</span>
<a name="line-335"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>collectTyAndValBinders</span> <span class='hs-varid'>rhs</span> <span class='hs-keyword'>of</span>
<a name="line-336"></a>                                <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-337"></a>                                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>surely_not_lam</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-338"></a>                                <span class='hs-keyword'>_</span>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-339"></a>
<a name="line-340"></a>                <span class='hs-varid'>surely_not_lam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-341"></a>                <span class='hs-varid'>surely_not_lam</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-342"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>surely_not_lam</span> <span class='hs-varid'>e</span>
<a name="line-343"></a>                   <span class='hs-comment'>-- eta-reduction could float</span>
<a name="line-344"></a>                <span class='hs-varid'>surely_not_lam</span> <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-345"></a>                        <span class='hs-comment'>-- Do not do the "abstract tyvar" thing if there's</span>
<a name="line-346"></a>                        <span class='hs-comment'>-- a lambda inside, because it defeats eta-reduction</span>
<a name="line-347"></a>                        <span class='hs-comment'>--    f = /\a. \x. g a x</span>
<a name="line-348"></a>                        <span class='hs-comment'>-- should eta-reduce.</span>
<a name="line-349"></a>
<a name="line-350"></a>
<a name="line-351"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "simplBinders" #-}</span> <span class='hs-varid'>simplBinders</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>tvs</span>
<a name="line-352"></a>                <span class='hs-comment'>-- See Note [Floating and type abstraction] in GHC.Core.Opt.Simplify.Utils</span>
<a name="line-353"></a>
<a name="line-354"></a>        <span class='hs-comment'>-- Simplify the RHS</span>
<a name="line-355"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkRhsStop</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-varid'>body_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-356"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_floats0</span><span class='hs-layout'>,</span> <span class='hs-varid'>body0</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "simplExprF" #-}</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>body_env</span> <span class='hs-varid'>body</span> <span class='hs-varid'>rhs_cont</span>
<a name="line-357"></a>
<a name="line-358"></a>              <span class='hs-comment'>-- Never float join-floats out of a non-join let-binding (which this is)</span>
<a name="line-359"></a>              <span class='hs-comment'>-- So wrap the body in the join-floats right now</span>
<a name="line-360"></a>              <span class='hs-comment'>-- Hence: body_floats1 consists only of let-floats</span>
<a name="line-361"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapJoinFloatsX</span> <span class='hs-varid'>body_floats0</span> <span class='hs-varid'>body0</span>
<a name="line-362"></a>
<a name="line-363"></a>        <span class='hs-comment'>-- ANF-ise a constructor or PAP rhs</span>
<a name="line-364"></a>        <span class='hs-comment'>-- We get at most one float per argument here</span>
<a name="line-365"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>body_env1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body_env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>body_floats1</span>
<a name="line-366"></a>              <span class='hs-comment'>-- body_env1: add to in-scope set the binders from body_floats1</span>
<a name="line-367"></a>              <span class='hs-comment'>-- so that prepareBinding knows what is in scope in body1</span>
<a name="line-368"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>let_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr2</span><span class='hs-layout'>,</span> <span class='hs-varid'>body2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "prepareBinding" #-}</span>
<a name="line-369"></a>                                        <span class='hs-varid'>prepareBinding</span> <span class='hs-varid'>body_env1</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr1</span> <span class='hs-varid'>body1</span>
<a name="line-370"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>body_floats2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body_floats1</span> <span class='hs-varop'>`addLetFloats`</span> <span class='hs-varid'>let_floats</span>
<a name="line-371"></a>
<a name="line-372"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>body3</span><span class='hs-layout'>)</span>
<a name="line-373"></a>            <span class='hs-keyglyph'>&lt;-</span>  <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>doFloatFromRhs</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>is_rec</span> <span class='hs-conid'>False</span> <span class='hs-varid'>body_floats2</span> <span class='hs-varid'>body2</span><span class='hs-layout'>)</span>
<a name="line-374"></a>                <span class='hs-keyword'>then</span>                    <span class='hs-comment'>-- No floating, revert to body1</span>
<a name="line-375"></a>                     <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>body_floats2</span> <span class='hs-varid'>body1</span><span class='hs-layout'>)</span>
<a name="line-376"></a>
<a name="line-377"></a>                <span class='hs-keyword'>else</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span> <span class='hs-keyword'>then</span>   <span class='hs-comment'>-- Simple floating</span>
<a name="line-378"></a>                     <span class='hs-comment'>{-#SCC "simplLazyBind-simple-floating" #-}</span>
<a name="line-379"></a>                     <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-conid'>LetFloatFromLet</span>
<a name="line-380"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>body2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-381"></a>
<a name="line-382"></a>                <span class='hs-keyword'>else</span>                    <span class='hs-comment'>-- Do type-abstraction first</span>
<a name="line-383"></a>                     <span class='hs-comment'>{-#SCC "simplLazyBind-type-abstraction-first" #-}</span>
<a name="line-384"></a>                     <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-conid'>LetFloatFromLet</span>
<a name="line-385"></a>                        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>poly_binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>body3</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>abstractFloats</span> <span class='hs-layout'>(</span><span class='hs-varid'>seUnfoldingOpts</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>top_lvl</span>
<a name="line-386"></a>                                                                <span class='hs-varid'>tvs'</span> <span class='hs-varid'>body_floats2</span> <span class='hs-varid'>body2</span>
<a name="line-387"></a>                        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>floats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>extendFloats</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>poly_binds</span>
<a name="line-388"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>body3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-389"></a>
<a name="line-390"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>rhs_floats</span>
<a name="line-391"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkLam</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>tvs'</span> <span class='hs-varid'>body3</span> <span class='hs-varid'>rhs_cont</span>
<a name="line-392"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind_float</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>completeBind</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>top_lvl</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr2</span> <span class='hs-varid'>rhs'</span>
<a name="line-393"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_floats</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>bind_float</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-394"></a>
<a name="line-395"></a><a name="simplJoinBind"></a><span class='hs-comment'>--------------------------</span>
<a name="line-396"></a><span class='hs-definition'>simplJoinBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-397"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-398"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>          <span class='hs-comment'>-- Binder, both pre-and post simpl</span>
<a name="line-399"></a>                                        <span class='hs-comment'>-- The OutId has IdInfo, except arity,</span>
<a name="line-400"></a>                                        <span class='hs-comment'>--   unfolding</span>
<a name="line-401"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>     <span class='hs-comment'>-- The right hand side and its env</span>
<a name="line-402"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-403"></a><span class='hs-definition'>simplJoinBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rhs_se</span>
<a name="line-404"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span>
<a name="line-405"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplJoinRhs</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-406"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>completeBind</span> <span class='hs-varid'>env</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs'</span> <span class='hs-layout'>}</span>
<a name="line-407"></a>
<a name="line-408"></a><a name="simplNonRecX"></a><span class='hs-comment'>--------------------------</span>
<a name="line-409"></a><span class='hs-definition'>simplNonRecX</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-410"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>            <span class='hs-comment'>-- Old binder; not a JoinId</span>
<a name="line-411"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>         <span class='hs-comment'>-- Simplified RHS</span>
<a name="line-412"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-413"></a><span class='hs-comment'>-- A specialised variant of simplNonRec used when the RHS is already</span>
<a name="line-414"></a><span class='hs-comment'>-- simplified, notably in knownCon.  It uses case-binding where necessary.</span>
<a name="line-415"></a><span class='hs-comment'>--</span>
<a name="line-416"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-417"></a>
<a name="line-418"></a><span class='hs-definition'>simplNonRecX</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>new_rhs</span>
<a name="line-419"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>)</span>
<a name="line-420"></a>    <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndr</span>   <span class='hs-comment'>-- Not uncommon; e.g. case (a,b) of c { (p,q) -&gt; p }</span>
<a name="line-421"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>    <span class='hs-comment'>--  Here c is dead, and we avoid</span>
<a name="line-422"></a>                                         <span class='hs-comment'>--  creating the binding c = (a,b)</span>
<a name="line-423"></a>
<a name="line-424"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>new_rhs</span>
<a name="line-425"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendCvSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-426"></a>
<a name="line-427"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-428"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-429"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>completeNonRecX</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStrictId</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>new_rhs</span> <span class='hs-layout'>}</span>
<a name="line-430"></a>          <span class='hs-comment'>-- NotTopLevel: simplNonRecX is only used for NotTopLevel things</span>
<a name="line-431"></a>          <span class='hs-comment'>--</span>
<a name="line-432"></a>          <span class='hs-comment'>-- isStrictId: use bndr' because in a levity-polymorphic setting</span>
<a name="line-433"></a>          <span class='hs-comment'>-- the InId bndr might have a levity-polymorphic type, which</span>
<a name="line-434"></a>          <span class='hs-comment'>-- which isStrictId doesn't expect</span>
<a name="line-435"></a>          <span class='hs-comment'>-- c.f. Note [Dark corner with levity polymorphism]</span>
<a name="line-436"></a>
<a name="line-437"></a><a name="completeNonRecX"></a><span class='hs-comment'>--------------------------</span>
<a name="line-438"></a><span class='hs-definition'>completeNonRecX</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-439"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-440"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>                 <span class='hs-comment'>-- Old binder; not a JoinId</span>
<a name="line-441"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>                <span class='hs-comment'>-- New binder</span>
<a name="line-442"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>              <span class='hs-comment'>-- Simplified RHS</span>
<a name="line-443"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- The new binding is in the floats</span>
<a name="line-444"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-445"></a><span class='hs-comment'>--               See Note [Core let/app invariant] in GHC.Core</span>
<a name="line-446"></a>
<a name="line-447"></a><span class='hs-definition'>completeNonRecX</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>is_strict</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_rhs</span>
<a name="line-448"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-layout'>)</span>
<a name="line-449"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>prepd_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
<a name="line-450"></a>              <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prepareBinding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_rhs</span>
<a name="line-451"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>floats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addLetFloats`</span> <span class='hs-varid'>prepd_floats</span>
<a name="line-452"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span>
<a name="line-453"></a>                <span class='hs-keyword'>if</span> <span class='hs-varid'>doFloatFromRhs</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-varid'>is_strict</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>new_rhs</span>
<a name="line-454"></a>                <span class='hs-keyword'>then</span>    <span class='hs-comment'>-- Add the floats to the main env</span>
<a name="line-455"></a>                     <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-conid'>LetFloatFromLet</span>
<a name="line-456"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-457"></a>                <span class='hs-keyword'>else</span>    <span class='hs-comment'>-- Do not float; wrap the floats around the RHS</span>
<a name="line-458"></a>                     <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
<a name="line-459"></a>
<a name="line-460"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind_float</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>completeBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>rhs_floats</span><span class='hs-layout'>)</span>
<a name="line-461"></a>                                             <span class='hs-conid'>NotTopLevel</span> <span class='hs-conid'>Nothing</span>
<a name="line-462"></a>                                             <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>rhs2</span>
<a name="line-463"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_floats</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>bind_float</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-464"></a>
<a name="line-465"></a>
<a name="line-466"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-467"></a>*                                                                      *
<a name="line-468"></a>           prepareBinding, prepareRhs, makeTrivial
<a name="line-469"></a>*                                                                      *
<a name="line-470"></a>************************************************************************
<a name="line-471"></a>
<a name="line-472"></a>Note [Cast worker/wrappers]
<a name="line-473"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-474"></a>When we have a binding
<a name="line-475"></a>   x = e |&gt; co
<a name="line-476"></a>we want to do something very similar to worker/wrapper:
<a name="line-477"></a>   $wx = e
<a name="line-478"></a>   x = $wx |&gt; co
<a name="line-479"></a>
<a name="line-480"></a>So now x can be inlined freely.  There's a chance that e will be a
<a name="line-481"></a>constructor application or function, or something like that, so moving
<a name="line-482"></a>the coercion to the usage site may well cancel the coercions and lead
<a name="line-483"></a>to further optimisation.  Example:
<a name="line-484"></a>
<a name="line-485"></a>     data family T a :: *
<a name="line-486"></a>     data instance T Int = T Int
<a name="line-487"></a>
<a name="line-488"></a>     foo :: Int -&gt; Int -&gt; Int
<a name="line-489"></a>     foo m n = ...
<a name="line-490"></a>        where
<a name="line-491"></a>          t = T m
<a name="line-492"></a>          go 0 = 0
<a name="line-493"></a>          go n = case t of { T m -&gt; go (n-m) }
<a name="line-494"></a>                -- This case should optimise
<a name="line-495"></a>
<a name="line-496"></a>We call this making a cast worker/wrapper, and it's done by prepareBinding.
<a name="line-497"></a>
<a name="line-498"></a>We need to be careful with inline/noinline pragmas:
<a name="line-499"></a>  rec { {-# NOINLINE f #-}
<a name="line-500"></a>        f = (...g...) |&gt; co
<a name="line-501"></a>      ; g = ...f... }
<a name="line-502"></a>This is legitimate -- it tells GHC to use f as the loop breaker
<a name="line-503"></a>rather than g.  Now we do the cast thing, to get something like
<a name="line-504"></a>  rec { $wf = ...g...
<a name="line-505"></a>      ; f = $wf |&gt; co
<a name="line-506"></a>      ; g = ...f... }
<a name="line-507"></a>Where should the NOINLINE pragma go?  If we leave it on f we'll get
<a name="line-508"></a>  rec { $wf = ...g...
<a name="line-509"></a>      ; {-# NOINLINE f #-}
<a name="line-510"></a>        f = $wf |&gt; co
<a name="line-511"></a>      ; g = ...f... }
<a name="line-512"></a>and that is bad: the whole point is that we want to inline that
<a name="line-513"></a>cast!  We want to transfer the pagma to $wf:
<a name="line-514"></a>  rec { {-# NOINLINE $wf #-}
<a name="line-515"></a>        $wf = ...g...
<a name="line-516"></a>      ; f = $wf |&gt; co
<a name="line-517"></a>      ; g = ...f... }
<a name="line-518"></a>It's exactly like worker/wrapper for strictness analysis:
<a name="line-519"></a>  f is the wrapper and must inline like crazy
<a name="line-520"></a>  $wf is the worker and must carry f's original pragma
<a name="line-521"></a>See Note [Worker-wrapper for NOINLINE functions] in
<a name="line-522"></a>GHC.Core.Opt.WorkWrap.
<a name="line-523"></a>
<a name="line-524"></a>See #17673, #18093, #18078.
<a name="line-525"></a>
<a name="line-526"></a>Note [Preserve strictness in cast w/w]
<a name="line-527"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-528"></a>In the Note [Cast worker/wrappers] transformation, keep the strictness info.
<a name="line-529"></a>Eg
<a name="line-530"></a>        f = e `cast` co    -- f has strictness SSL
<a name="line-531"></a>When we transform to
<a name="line-532"></a>        f' = e             -- f' also has strictness SSL
<a name="line-533"></a>        f = f' `cast` co   -- f still has strictness SSL
<a name="line-534"></a>
<a name="line-535"></a>Its not wrong to drop it on the floor, but better to keep it.
<a name="line-536"></a>
<a name="line-537"></a>Note [Cast w/w: unlifted]
<a name="line-538"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-539"></a>BUT don't do cast worker/wrapper if 'e' has an unlifted type.
<a name="line-540"></a>This *can* happen:
<a name="line-541"></a>
<a name="line-542"></a>     foo :: Int = (error (# Int,Int #) "urk")
<a name="line-543"></a>                  `cast` CoUnsafe (# Int,Int #) Int
<a name="line-544"></a>
<a name="line-545"></a>If do the makeTrivial thing to the error call, we'll get
<a name="line-546"></a>    foo = case error (# Int,Int #) "urk" of v -&gt; v `cast` ...
<a name="line-547"></a>But 'v' isn't in scope!
<a name="line-548"></a>
<a name="line-549"></a>These strange casts can happen as a result of case-of-case
<a name="line-550"></a>        bar = case (case x of { T -&gt; (# 2,3 #); F -&gt; error "urk" }) of
<a name="line-551"></a>                (# p,q #) -&gt; p+q
<a name="line-552"></a>
<a name="line-553"></a>NOTE: Nowadays we don't use casts for these error functions;
<a name="line-554"></a>instead, we use (case erorr ... of {}). So I'm not sure
<a name="line-555"></a>this Note makes much sense any more.
<a name="line-556"></a>-}</span>
<a name="line-557"></a>
<a name="line-558"></a><a name="prepareBinding"></a><span class='hs-definition'>prepareBinding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-559"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-560"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutId</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-561"></a>
<a name="line-562"></a><span class='hs-definition'>prepareBinding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-563"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs1</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rhs</span>
<a name="line-564"></a>    <span class='hs-comment'>-- Try for cast worker/wrapper</span>
<a name="line-565"></a>    <span class='hs-comment'>-- See Note [Cast worker/wrappers]</span>
<a name="line-566"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-567"></a>        <span class='hs-comment'>-- Don't make a cast w/w if the thing is going to be inlined anyway</span>
<a name="line-568"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span>
<a name="line-569"></a>        <span class='hs-comment'>-- Nor if the RHS is trivial; then again it'll be inlined</span>
<a name="line-570"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionLKind</span> <span class='hs-varid'>co</span>
<a name="line-571"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span>
<a name="line-572"></a>        <span class='hs-comment'>-- Not if rhs has an unlifted type; see Note [Cast w/w: unlifted]</span>
<a name="line-573"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeTrivialBinding</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>top_lvl</span>
<a name="line-574"></a>                                   <span class='hs-layout'>(</span><span class='hs-varid'>getOccFS</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>worker_info</span> <span class='hs-varid'>rhs1</span> <span class='hs-varid'>ty1</span>
<a name="line-575"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>bndr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`setInlinePragma`</span> <span class='hs-varid'>mkCastWrapperInlinePrag</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlinePragma</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-576"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>new_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-577"></a>
<a name="line-578"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-579"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prepareRhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>top_lvl</span> <span class='hs-layout'>(</span><span class='hs-varid'>getOccFS</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-580"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-581"></a> <span class='hs-keyword'>where</span>
<a name="line-582"></a>   <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInfo</span> <span class='hs-varid'>bndr</span>
<a name="line-583"></a>   <span class='hs-varid'>worker_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanillaIdInfo</span> <span class='hs-varop'>`setStrictnessInfo`</span> <span class='hs-varid'>strictnessInfo</span> <span class='hs-varid'>info</span>
<a name="line-584"></a>                               <span class='hs-varop'>`setCprInfo`</span>        <span class='hs-varid'>cprInfo</span> <span class='hs-varid'>info</span>
<a name="line-585"></a>                               <span class='hs-varop'>`setDemandInfo`</span>     <span class='hs-varid'>demandInfo</span> <span class='hs-varid'>info</span>
<a name="line-586"></a>                               <span class='hs-varop'>`setInlinePragInfo`</span> <span class='hs-varid'>inlinePragInfo</span> <span class='hs-varid'>info</span>
<a name="line-587"></a>                               <span class='hs-varop'>`setArityInfo`</span>      <span class='hs-varid'>arityInfo</span> <span class='hs-varid'>info</span>
<a name="line-588"></a>          <span class='hs-comment'>-- We do /not/ want to transfer OccInfo, Rules, Unfolding</span>
<a name="line-589"></a>          <span class='hs-comment'>-- Note [Preserve strictness in cast w/w]</span>
<a name="line-590"></a>
<a name="line-591"></a><a name="mkCastWrapperInlinePrag"></a><span class='hs-definition'>mkCastWrapperInlinePrag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InlinePragma</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InlinePragma</span>
<a name="line-592"></a><span class='hs-comment'>-- See Note [Cast wrappers]</span>
<a name="line-593"></a><span class='hs-definition'>mkCastWrapperInlinePrag</span> <span class='hs-layout'>(</span><span class='hs-conid'>InlinePragma</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inl_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span><span class='hs-layout'>,</span> <span class='hs-varid'>inl_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule_info</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-594"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InlinePragma</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inl_src</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SourceText</span> <span class='hs-str'>"{-# INLINE"</span>
<a name="line-595"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>inl_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUserInlinePrag</span> <span class='hs-comment'>-- See Note [Wrapper NoUserInline]</span>
<a name="line-596"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>inl_sat</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>      <span class='hs-comment'>--     in GHC.Core.Opt.WorkWrap</span>
<a name="line-597"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>inl_act</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrap_act</span>     <span class='hs-comment'>-- See Note [Wrapper activation]</span>
<a name="line-598"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>inl_rule</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule_info</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>--     in GHC.Core.Opt.WorkWrap</span>
<a name="line-599"></a>                                <span class='hs-comment'>-- RuleMatchInfo is (and must be) unaffected</span>
<a name="line-600"></a>  <span class='hs-keyword'>where</span>
<a name="line-601"></a>    <span class='hs-comment'>-- See Note [Wrapper activation] in GHC.Core.Opt.WorkWrap</span>
<a name="line-602"></a>    <span class='hs-comment'>-- But simpler, because we don't need to disable during InitialPhase</span>
<a name="line-603"></a>    <span class='hs-varid'>wrap_act</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNeverActive</span> <span class='hs-varid'>act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>activateDuringFinal</span>
<a name="line-604"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span>
<a name="line-605"></a>
<a name="line-606"></a><span class='hs-comment'>{- Note [prepareRhs]
<a name="line-607"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-608"></a>prepareRhs takes a putative RHS, checks whether it's a PAP or
<a name="line-609"></a>constructor application and, if so, converts it to ANF, so that the
<a name="line-610"></a>resulting thing can be inlined more easily.  Thus
<a name="line-611"></a>        x = (f a, g b)
<a name="line-612"></a>becomes
<a name="line-613"></a>        t1 = f a
<a name="line-614"></a>        t2 = g b
<a name="line-615"></a>        x = (t1,t2)
<a name="line-616"></a>
<a name="line-617"></a>We also want to deal well cases like this
<a name="line-618"></a>        v = (f e1 `cast` co) e2
<a name="line-619"></a>Here we want to make e1,e2 trivial and get
<a name="line-620"></a>        x1 = e1; x2 = e2; v = (f x1 `cast` co) v2
<a name="line-621"></a>That's what the 'go' loop in prepareRhs does
<a name="line-622"></a>-}</span>
<a name="line-623"></a>
<a name="line-624"></a><a name="prepareRhs"></a><span class='hs-definition'>prepareRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-625"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FastString</span>    <span class='hs-comment'>-- Base for any new variables</span>
<a name="line-626"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-627"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-628"></a><span class='hs-comment'>-- Transforms a RHS into a better RHS by ANF'ing args</span>
<a name="line-629"></a><span class='hs-comment'>-- for expandable RHSs: constructors and PAPs</span>
<a name="line-630"></a><span class='hs-comment'>-- e.g        x = Just e</span>
<a name="line-631"></a><span class='hs-comment'>-- becomes    a = e               -- 'a' is fresh</span>
<a name="line-632"></a><span class='hs-comment'>--            x = Just a</span>
<a name="line-633"></a><span class='hs-comment'>-- See Note [prepareRhs]</span>
<a name="line-634"></a><span class='hs-definition'>prepareRhs</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>occ</span> <span class='hs-varid'>rhs0</span>
<a name="line-635"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-sel'>_is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>rhs0</span>
<a name="line-636"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-637"></a>  <span class='hs-keyword'>where</span>
<a name="line-638"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>LetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-639"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-640"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>rhs</span>
<a name="line-641"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>rhs'</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-642"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-643"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>fun</span>
<a name="line-644"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>App</span> <span class='hs-varid'>rhs'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-645"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-646"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_val_args</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>fun</span>
<a name="line-647"></a>             <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>is_exp</span> <span class='hs-keyword'>of</span>
<a name="line-648"></a>                <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyLetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-649"></a>                <span class='hs-conid'>True</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeTrivial</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>topDmd</span> <span class='hs-varid'>occ</span> <span class='hs-varid'>arg</span>
<a name="line-650"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats1</span> <span class='hs-varop'>`addLetFlts`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-conid'>App</span> <span class='hs-varid'>fun'</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-651"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-652"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyLetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-653"></a>        <span class='hs-keyword'>where</span>
<a name="line-654"></a>          <span class='hs-varid'>is_exp</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isExpandableApp</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>n_val_args</span>   <span class='hs-comment'>-- The fun a constructor or PAP</span>
<a name="line-655"></a>                        <span class='hs-comment'>-- See Note [CONLIKE pragma] in GHC.Types.Basic</span>
<a name="line-656"></a>                        <span class='hs-comment'>-- The definition of is_exp should match that in</span>
<a name="line-657"></a>                        <span class='hs-comment'>-- 'GHC.Core.Opt.OccurAnal.occAnalApp'</span>
<a name="line-658"></a>
<a name="line-659"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-660"></a>        <span class='hs-comment'>-- We want to be able to float bindings past this</span>
<a name="line-661"></a>        <span class='hs-comment'>-- tick. Non-scoping ticks don't care.</span>
<a name="line-662"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishScoped</span> <span class='hs-varid'>t</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NoScope</span>
<a name="line-663"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>rhs</span>
<a name="line-664"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-665"></a>
<a name="line-666"></a>        <span class='hs-comment'>-- On the other hand, for scoping ticks we need to be able to</span>
<a name="line-667"></a>        <span class='hs-comment'>-- copy them on the floats, which in turn is only allowed if</span>
<a name="line-668"></a>        <span class='hs-comment'>-- we can obtain non-counting ticks.</span>
<a name="line-669"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>tickishCanSplit</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-670"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>rhs</span>
<a name="line-671"></a>             <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tickIt</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTick</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNoCount</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-672"></a>                   <span class='hs-varid'>floats'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapLetFloats</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>tickIt</span>
<a name="line-673"></a>             <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_exp</span><span class='hs-layout'>,</span> <span class='hs-varid'>floats'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-674"></a>
<a name="line-675"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>other</span>
<a name="line-676"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyLetFloats</span><span class='hs-layout'>,</span> <span class='hs-varid'>other</span><span class='hs-layout'>)</span>
<a name="line-677"></a>
<a name="line-678"></a><a name="makeTrivialArg"></a><span class='hs-definition'>makeTrivialArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgSpec</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>ArgSpec</span><span class='hs-layout'>)</span>
<a name="line-679"></a><span class='hs-definition'>makeTrivialArg</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>arg</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>as_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-680"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeTrivial</span> <span class='hs-varid'>mode</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"arg"</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-681"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-682"></a><span class='hs-definition'>makeTrivialArg</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>arg</span>
<a name="line-683"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyLetFloats</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- CastBy, TyArg</span>
<a name="line-684"></a>
<a name="line-685"></a><a name="makeTrivial"></a><span class='hs-definition'>makeTrivial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span>
<a name="line-686"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FastString</span>  <span class='hs-comment'>-- ^ A "friendly name" to build the new binder from</span>
<a name="line-687"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>     <span class='hs-comment'>-- ^ This expression satisfies the let/app invariant</span>
<a name="line-688"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-689"></a><span class='hs-comment'>-- Binds the expression to a variable, if it's not trivial, returning the variable</span>
<a name="line-690"></a><span class='hs-comment'>-- For the Demand argument, see Note [Keeping demand info in StrictArg Plan A]</span>
<a name="line-691"></a><span class='hs-definition'>makeTrivial</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>occ_fs</span> <span class='hs-varid'>expr</span>
<a name="line-692"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>expr</span>                          <span class='hs-comment'>-- Already trivial</span>
<a name="line-693"></a>  <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>bindingOk</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>expr_ty</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- Cannot trivialise</span>
<a name="line-694"></a>                                                <span class='hs-comment'>--   See Note [Cannot trivialise]</span>
<a name="line-695"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyLetFloats</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-696"></a>
<a name="line-697"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>expr'</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>expr</span>
<a name="line-698"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>triv_expr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeTrivial</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>dmd</span> <span class='hs-varid'>occ_fs</span> <span class='hs-varid'>expr'</span>
<a name="line-699"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>triv_expr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-700"></a>
<a name="line-701"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-702"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeTrivialBinding</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>occ_fs</span>
<a name="line-703"></a>                                                <span class='hs-varid'>id_info</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>expr_ty</span>
<a name="line-704"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>new_id</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-705"></a>  <span class='hs-keyword'>where</span>
<a name="line-706"></a>    <span class='hs-varid'>id_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vanillaIdInfo</span> <span class='hs-varop'>`setDemandInfo`</span> <span class='hs-varid'>dmd</span>
<a name="line-707"></a>    <span class='hs-varid'>expr_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>expr</span>
<a name="line-708"></a>
<a name="line-709"></a><a name="makeTrivialBinding"></a><span class='hs-definition'>makeTrivialBinding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-710"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FastString</span>  <span class='hs-comment'>-- ^ a "friendly name" to build the new binder from</span>
<a name="line-711"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IdInfo</span>
<a name="line-712"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>     <span class='hs-comment'>-- ^ This expression satisfies the let/app invariant</span>
<a name="line-713"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>     <span class='hs-comment'>-- Type of the expression</span>
<a name="line-714"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>LetFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutId</span><span class='hs-layout'>)</span>
<a name="line-715"></a><span class='hs-definition'>makeTrivialBinding</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>occ_fs</span> <span class='hs-varid'>info</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>expr_ty</span>
<a name="line-716"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prepareRhs</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>occ_fs</span> <span class='hs-varid'>expr</span>
<a name="line-717"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-718"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSystemVarName</span> <span class='hs-varid'>uniq</span> <span class='hs-varid'>occ_fs</span>
<a name="line-719"></a>              <span class='hs-varid'>var</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLocalIdWithInfo</span> <span class='hs-varid'>name</span> <span class='hs-conid'>Many</span> <span class='hs-varid'>expr_ty</span> <span class='hs-varid'>info</span>
<a name="line-720"></a>
<a name="line-721"></a>        <span class='hs-comment'>-- Now something very like completeBind,</span>
<a name="line-722"></a>        <span class='hs-comment'>-- but without the postInlineUnconditionally part</span>
<a name="line-723"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>arity_type</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryEtaExpandRhs</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>var</span> <span class='hs-varid'>expr1</span>
<a name="line-724"></a>          <span class='hs-comment'>-- Technically we should extend the in-scope set in 'env' with</span>
<a name="line-725"></a>          <span class='hs-comment'>-- the 'floats' from prepareRHS; but they are all fresh, so there is</span>
<a name="line-726"></a>          <span class='hs-comment'>-- no danger of introducing name shadowig in eta expansion</span>
<a name="line-727"></a>
<a name="line-728"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkLetUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_uf_opts</span> <span class='hs-varid'>mode</span><span class='hs-layout'>)</span> <span class='hs-varid'>top_lvl</span> <span class='hs-conid'>InlineRhs</span> <span class='hs-varid'>var</span> <span class='hs-varid'>expr2</span>
<a name="line-729"></a>
<a name="line-730"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addLetBndrInfo</span> <span class='hs-varid'>var</span> <span class='hs-varid'>arity_type</span> <span class='hs-varid'>unf</span>
<a name="line-731"></a>              <span class='hs-varid'>bind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>final_id</span> <span class='hs-varid'>expr2</span>
<a name="line-732"></a>
<a name="line-733"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>floats</span> <span class='hs-varop'>`addLetFlts`</span> <span class='hs-varid'>unitLetFloat</span> <span class='hs-varid'>bind</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_id</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-734"></a>
<a name="line-735"></a><a name="bindingOk"></a><span class='hs-definition'>bindingOk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-736"></a><span class='hs-comment'>-- True iff we can have a binding of this expression at this level</span>
<a name="line-737"></a><span class='hs-comment'>-- Precondition: the type is the type of the expression</span>
<a name="line-738"></a><span class='hs-definition'>bindingOk</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>expr_ty</span>
<a name="line-739"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprIsTopLevelBindable</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>expr_ty</span>
<a name="line-740"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-741"></a>
<a name="line-742"></a><span class='hs-comment'>{- Note [Cannot trivialise]
<a name="line-743"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-744"></a>Consider:
<a name="line-745"></a>   f :: Int -&gt; Addr#
<a name="line-746"></a>
<a name="line-747"></a>   foo :: Bar
<a name="line-748"></a>   foo = Bar (f 3)
<a name="line-749"></a>
<a name="line-750"></a>Then we can't ANF-ise foo, even though we'd like to, because
<a name="line-751"></a>we can't make a top-level binding for the Addr# (f 3). And if
<a name="line-752"></a>so we don't want to turn it into
<a name="line-753"></a>   foo = let x = f 3 in Bar x
<a name="line-754"></a>because we'll just end up inlining x back, and that makes the
<a name="line-755"></a>simplifier loop.  Better not to ANF-ise it at all.
<a name="line-756"></a>
<a name="line-757"></a>Literal strings are an exception.
<a name="line-758"></a>
<a name="line-759"></a>   foo = Ptr "blob"#
<a name="line-760"></a>
<a name="line-761"></a>We want to turn this into:
<a name="line-762"></a>
<a name="line-763"></a>   foo1 = "blob"#
<a name="line-764"></a>   foo = Ptr foo1
<a name="line-765"></a>
<a name="line-766"></a>See Note [Core top-level string literals] in GHC.Core.
<a name="line-767"></a>
<a name="line-768"></a>************************************************************************
<a name="line-769"></a>*                                                                      *
<a name="line-770"></a>          Completing a lazy binding
<a name="line-771"></a>*                                                                      *
<a name="line-772"></a>************************************************************************
<a name="line-773"></a>
<a name="line-774"></a>completeBind
<a name="line-775"></a>  * deals only with Ids, not TyVars
<a name="line-776"></a>  * takes an already-simplified binder and RHS
<a name="line-777"></a>  * is used for both recursive and non-recursive bindings
<a name="line-778"></a>  * is used for both top-level and non-top-level bindings
<a name="line-779"></a>
<a name="line-780"></a>It does the following:
<a name="line-781"></a>  - tries discarding a dead binding
<a name="line-782"></a>  - tries PostInlineUnconditionally
<a name="line-783"></a>  - add unfolding [this is the only place we add an unfolding]
<a name="line-784"></a>  - add arity
<a name="line-785"></a>
<a name="line-786"></a>It does *not* attempt to do let-to-case.  Why?  Because it is used for
<a name="line-787"></a>  - top-level bindings (when let-to-case is impossible)
<a name="line-788"></a>  - many situations where the "rhs" is known to be a WHNF
<a name="line-789"></a>                (so let-to-case is inappropriate).
<a name="line-790"></a>
<a name="line-791"></a>Nor does it do the atomic-argument thing
<a name="line-792"></a>-}</span>
<a name="line-793"></a>
<a name="line-794"></a><a name="completeBind"></a><span class='hs-definition'>completeBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-795"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>            <span class='hs-comment'>-- Flag stuck into unfolding</span>
<a name="line-796"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span>           <span class='hs-comment'>-- Required only for join point</span>
<a name="line-797"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>                    <span class='hs-comment'>-- Old binder</span>
<a name="line-798"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>        <span class='hs-comment'>-- New binder and RHS</span>
<a name="line-799"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>
<a name="line-800"></a><span class='hs-comment'>-- completeBind may choose to do its work</span>
<a name="line-801"></a><span class='hs-comment'>--      * by extending the substitution (e.g. let x = y in ...)</span>
<a name="line-802"></a><span class='hs-comment'>--      * or by adding to the floats in the envt</span>
<a name="line-803"></a><span class='hs-comment'>--</span>
<a name="line-804"></a><span class='hs-comment'>-- Binder /can/ be a JoinId</span>
<a name="line-805"></a><span class='hs-comment'>-- Precondition: rhs obeys the let/app invariant</span>
<a name="line-806"></a><span class='hs-definition'>completeBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>mb_cont</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_rhs</span>
<a name="line-807"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>old_bndr</span>
<a name="line-808"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>new_rhs</span> <span class='hs-keyword'>of</span>
<a name="line-809"></a>     <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendCvSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-810"></a>     <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFloatBind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-811"></a>
<a name="line-812"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-813"></a> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>new_bndr</span> <span class='hs-layout'>)</span>
<a name="line-814"></a>   <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>old_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInfo</span> <span class='hs-varid'>old_bndr</span>
<a name="line-815"></a>            <span class='hs-varid'>old_unf</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingInfo</span> <span class='hs-varid'>old_info</span>
<a name="line-816"></a>            <span class='hs-varid'>occ_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occInfo</span> <span class='hs-varid'>old_info</span>
<a name="line-817"></a>
<a name="line-818"></a>         <span class='hs-comment'>-- Do eta-expansion on the RHS of the binding</span>
<a name="line-819"></a>         <span class='hs-comment'>-- See Note [Eta-expanding at let bindings] in GHC.Core.Opt.Simplify.Utils</span>
<a name="line-820"></a>      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryEtaExpandRhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_rhs</span>
<a name="line-821"></a>
<a name="line-822"></a>        <span class='hs-comment'>-- Simplify the unfolding</span>
<a name="line-823"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>new_unfolding</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLetUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>mb_cont</span> <span class='hs-varid'>old_bndr</span>
<a name="line-824"></a>                          <span class='hs-varid'>final_rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_arity</span> <span class='hs-varid'>old_unf</span>
<a name="line-825"></a>
<a name="line-826"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addLetBndrInfo</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_arity</span> <span class='hs-varid'>new_unfolding</span>
<a name="line-827"></a>        <span class='hs-comment'>-- See Note [In-scope set as a substitution]</span>
<a name="line-828"></a>
<a name="line-829"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>postInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>final_bndr</span> <span class='hs-varid'>occ_info</span> <span class='hs-varid'>final_rhs</span>
<a name="line-830"></a>
<a name="line-831"></a>        <span class='hs-keyword'>then</span> <span class='hs-comment'>-- Inline and discard the binding</span>
<a name="line-832"></a>             <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>PostInlineUnconditionally</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span>
<a name="line-833"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span>
<a name="line-834"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>extendIdSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varop'>$</span>
<a name="line-835"></a>                            <span class='hs-conid'>DoneEx</span> <span class='hs-varid'>final_rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-836"></a>                <span class='hs-comment'>-- Use the substitution to make quite, quite sure that the</span>
<a name="line-837"></a>                <span class='hs-comment'>-- substitution will happen, since we are going to discard the binding</span>
<a name="line-838"></a>
<a name="line-839"></a>        <span class='hs-keyword'>else</span> <span class='hs-comment'>-- Keep the binding</span>
<a name="line-840"></a>             <span class='hs-comment'>-- pprTrace "Binding" (ppr final_bndr &lt;+&gt; ppr new_unfolding) $</span>
<a name="line-841"></a>             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFloatBind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>final_bndr</span> <span class='hs-varid'>final_rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-842"></a>
<a name="line-843"></a><a name="addLetBndrInfo"></a><span class='hs-definition'>addLetBndrInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>
<a name="line-844"></a><span class='hs-definition'>addLetBndrInfo</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>new_arity_type</span> <span class='hs-varid'>new_unf</span>
<a name="line-845"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varop'>`setIdInfo`</span> <span class='hs-varid'>info5</span>
<a name="line-846"></a>  <span class='hs-keyword'>where</span>
<a name="line-847"></a>    <span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_arity_type</span>
<a name="line-848"></a>    <span class='hs-varid'>new_arity</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>oss</span>
<a name="line-849"></a>
<a name="line-850"></a>    <span class='hs-varid'>info1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInfo</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varop'>`setArityInfo`</span> <span class='hs-varid'>new_arity</span>
<a name="line-851"></a>
<a name="line-852"></a>    <span class='hs-comment'>-- Unfolding info: Note [Setting the new unfolding]</span>
<a name="line-853"></a>    <span class='hs-varid'>info2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info1</span> <span class='hs-varop'>`setUnfoldingInfo`</span> <span class='hs-varid'>new_unf</span>
<a name="line-854"></a>
<a name="line-855"></a>    <span class='hs-comment'>-- Demand info: Note [Setting the demand info]</span>
<a name="line-856"></a>    <span class='hs-comment'>-- We also have to nuke demand info if for some reason</span>
<a name="line-857"></a>    <span class='hs-comment'>-- eta-expansion *reduces* the arity of the binding to less</span>
<a name="line-858"></a>    <span class='hs-comment'>-- than that of the strictness sig. This can happen: see Note [Arity decrease].</span>
<a name="line-859"></a>    <span class='hs-varid'>info3</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEvaldUnfolding</span> <span class='hs-varid'>new_unf</span>
<a name="line-860"></a>            <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-keyword'>case</span> <span class='hs-varid'>strictnessInfo</span> <span class='hs-varid'>info2</span> <span class='hs-keyword'>of</span>
<a name="line-861"></a>                  <span class='hs-conid'>StrictSig</span> <span class='hs-varid'>dmd_ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>new_arity</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>dmdTypeDepth</span> <span class='hs-varid'>dmd_ty</span><span class='hs-layout'>)</span>
<a name="line-862"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapDemandInfo</span> <span class='hs-varid'>info2</span> <span class='hs-varop'>`orElse`</span> <span class='hs-varid'>info2</span>
<a name="line-863"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-864"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info2</span>
<a name="line-865"></a>
<a name="line-866"></a>    <span class='hs-comment'>-- Bottoming bindings: see Note [Bottoming bindings]</span>
<a name="line-867"></a>    <span class='hs-varid'>info4</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info3</span> <span class='hs-varop'>`setStrictnessInfo`</span> <span class='hs-varid'>bot_sig</span>
<a name="line-868"></a>                                     <span class='hs-varop'>`setCprInfo`</span>        <span class='hs-varid'>bot_cpr</span>
<a name="line-869"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info3</span>
<a name="line-870"></a>
<a name="line-871"></a>    <span class='hs-varid'>bot_sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>replicate</span> <span class='hs-varid'>new_arity</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>div</span>
<a name="line-872"></a>    <span class='hs-varid'>bot_cpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCprSig</span> <span class='hs-varid'>new_arity</span> <span class='hs-varid'>botCpr</span>
<a name="line-873"></a>
<a name="line-874"></a>     <span class='hs-comment'>-- Zap call arity info. We have used it by now (via</span>
<a name="line-875"></a>     <span class='hs-comment'>-- `tryEtaExpandRhs`), and the simplifier can invalidate this</span>
<a name="line-876"></a>     <span class='hs-comment'>-- information, leading to broken code later (e.g. #13479)</span>
<a name="line-877"></a>    <span class='hs-varid'>info5</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapCallArityInfo</span> <span class='hs-varid'>info4</span>
<a name="line-878"></a>
<a name="line-879"></a>
<a name="line-880"></a><span class='hs-comment'>{- Note [Arity decrease]
<a name="line-881"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-882"></a>Generally speaking the arity of a binding should not decrease.  But it *can*
<a name="line-883"></a>legitimately happen because of RULES.  Eg
<a name="line-884"></a>        f = g @Int
<a name="line-885"></a>where g has arity 2, will have arity 2.  But if there's a rewrite rule
<a name="line-886"></a>        g @Int --&gt; h
<a name="line-887"></a>where h has arity 1, then f's arity will decrease.  Here's a real-life example,
<a name="line-888"></a>which is in the output of Specialise:
<a name="line-889"></a>
<a name="line-890"></a>     Rec {
<a name="line-891"></a>        $dm {Arity 2} = \d.\x. op d
<a name="line-892"></a>        {-# RULES forall d. $dm Int d = $s$dm #-}
<a name="line-893"></a>
<a name="line-894"></a>        dInt = MkD .... opInt ...
<a name="line-895"></a>        opInt {Arity 1} = $dm dInt
<a name="line-896"></a>
<a name="line-897"></a>        $s$dm {Arity 0} = \x. op dInt }
<a name="line-898"></a>
<a name="line-899"></a>Here opInt has arity 1; but when we apply the rule its arity drops to 0.
<a name="line-900"></a>That's why Specialise goes to a little trouble to pin the right arity
<a name="line-901"></a>on specialised functions too.
<a name="line-902"></a>
<a name="line-903"></a>Note [Bottoming bindings]
<a name="line-904"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-905"></a>Suppose we have
<a name="line-906"></a>   let x = error "urk"
<a name="line-907"></a>   in ...(case x of &lt;alts&gt;)...
<a name="line-908"></a>or
<a name="line-909"></a>   let f = \x. error (x ++ "urk")
<a name="line-910"></a>   in ...(case f "foo" of &lt;alts&gt;)...
<a name="line-911"></a>
<a name="line-912"></a>Then we'd like to drop the dead &lt;alts&gt; immediately.  So it's good to
<a name="line-913"></a>propagate the info that x's RHS is bottom to x's IdInfo as rapidly as
<a name="line-914"></a>possible.
<a name="line-915"></a>
<a name="line-916"></a>We use tryEtaExpandRhs on every binding, and it turns out that the
<a name="line-917"></a>arity computation it performs (via GHC.Core.Opt.Arity.findRhsArity) already
<a name="line-918"></a>does a simple bottoming-expression analysis.  So all we need to do
<a name="line-919"></a>is propagate that info to the binder's IdInfo.
<a name="line-920"></a>
<a name="line-921"></a>This showed up in #12150; see comment:16.
<a name="line-922"></a>
<a name="line-923"></a>Note [Setting the demand info]
<a name="line-924"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-925"></a>If the unfolding is a value, the demand info may
<a name="line-926"></a>go pear-shaped, so we nuke it.  Example:
<a name="line-927"></a>     let x = (a,b) in
<a name="line-928"></a>     case x of (p,q) -&gt; h p q x
<a name="line-929"></a>Here x is certainly demanded. But after we've nuked
<a name="line-930"></a>the case, we'll get just
<a name="line-931"></a>     let x = (a,b) in h a b x
<a name="line-932"></a>and now x is not demanded (I'm assuming h is lazy)
<a name="line-933"></a>This really happens.  Similarly
<a name="line-934"></a>     let f = \x -&gt; e in ...f..f...
<a name="line-935"></a>After inlining f at some of its call sites the original binding may
<a name="line-936"></a>(for example) be no longer strictly demanded.
<a name="line-937"></a>The solution here is a bit ad hoc...
<a name="line-938"></a>
<a name="line-939"></a>
<a name="line-940"></a>************************************************************************
<a name="line-941"></a>*                                                                      *
<a name="line-942"></a>\subsection[Simplify-simplExpr]{The main function: simplExpr}
<a name="line-943"></a>*                                                                      *
<a name="line-944"></a>************************************************************************
<a name="line-945"></a>
<a name="line-946"></a>The reason for this OutExprStuff stuff is that we want to float *after*
<a name="line-947"></a>simplifying a RHS, not before.  If we do so naively we get quadratic
<a name="line-948"></a>behaviour as things float out.
<a name="line-949"></a>
<a name="line-950"></a>To see why it's important to do it after, consider this (real) example:
<a name="line-951"></a>
<a name="line-952"></a>        let t = f x
<a name="line-953"></a>        in fst t
<a name="line-954"></a>==&gt;
<a name="line-955"></a>        let t = let a = e1
<a name="line-956"></a>                    b = e2
<a name="line-957"></a>                in (a,b)
<a name="line-958"></a>        in fst t
<a name="line-959"></a>==&gt;
<a name="line-960"></a>        let a = e1
<a name="line-961"></a>            b = e2
<a name="line-962"></a>            t = (a,b)
<a name="line-963"></a>        in
<a name="line-964"></a>        a       -- Can't inline a this round, cos it appears twice
<a name="line-965"></a>==&gt;
<a name="line-966"></a>        e1
<a name="line-967"></a>
<a name="line-968"></a>Each of the ==&gt; steps is a round of simplification.  We'd save a
<a name="line-969"></a>whole round if we float first.  This can cascade.  Consider
<a name="line-970"></a>
<a name="line-971"></a>        let f = g d
<a name="line-972"></a>        in \x -&gt; ...f...
<a name="line-973"></a>==&gt;
<a name="line-974"></a>        let f = let d1 = ..d.. in \y -&gt; e
<a name="line-975"></a>        in \x -&gt; ...f...
<a name="line-976"></a>==&gt;
<a name="line-977"></a>        let d1 = ..d..
<a name="line-978"></a>        in \x -&gt; ...(\y -&gt;e)...
<a name="line-979"></a>
<a name="line-980"></a>Only in this second round can the \y be applied, and it
<a name="line-981"></a>might do the same again.
<a name="line-982"></a>-}</span>
<a name="line-983"></a>
<a name="line-984"></a><a name="simplExpr"></a><span class='hs-definition'>simplExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-985"></a><a name="!"></a><span class='hs-definition'>simplExpr</span> <span class='hs-varop'>!</span><span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [Bangs in the Simplifier]</span>
<a name="line-986"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>  <span class='hs-comment'>-- See Note [Avoiding space leaks in OutType]</span>
<a name="line-987"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-988"></a>
<a name="line-989"></a><span class='hs-definition'>simplExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span>
<a name="line-990"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkBoringStop</span> <span class='hs-varid'>expr_out_ty</span><span class='hs-layout'>)</span>
<a name="line-991"></a>  <span class='hs-keyword'>where</span>
<a name="line-992"></a>    <span class='hs-varid'>expr_out_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutType</span>
<a name="line-993"></a>    <span class='hs-varid'>expr_out_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-994"></a>    <span class='hs-comment'>-- NB: Since 'expr' is term-valued, not (Type ty), this call</span>
<a name="line-995"></a>    <span class='hs-comment'>--     to exprType will succeed.  exprType fails on (Type ty).</span>
<a name="line-996"></a>
<a name="line-997"></a><a name="simplExprC"></a><span class='hs-definition'>simplExprC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-998"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>     <span class='hs-comment'>-- A term-valued expression, never (Type ty)</span>
<a name="line-999"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1000"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1001"></a>        <span class='hs-comment'>-- Simplify an expression, given a continuation</span>
<a name="line-1002"></a><span class='hs-definition'>simplExprC</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1003"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "simplExprC" (ppr expr $$ ppr cont {- $$ ppr (seIdSubst env) -} $$ ppr (seLetFloats env) ) $</span>
<a name="line-1004"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1005"></a>        <span class='hs-layout'>;</span> <span class='hs-comment'>-- pprTrace "simplExprC ret" (ppr expr $$ ppr expr') $</span>
<a name="line-1006"></a>          <span class='hs-comment'>-- pprTrace "simplExprC ret3" (ppr (seInScope env')) $</span>
<a name="line-1007"></a>          <span class='hs-comment'>-- pprTrace "simplExprC ret4" (ppr (seLetFloats env')) $</span>
<a name="line-1008"></a>          <span class='hs-varid'>return</span> <span class='hs-varop'>$!</span> <span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>expr'</span> <span class='hs-layout'>}</span>
<a name="line-1009"></a>
<a name="line-1010"></a><a name="simplExprF"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-1011"></a><span class='hs-definition'>simplExprF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-1012"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>     <span class='hs-comment'>-- A term-valued expression, never (Type ty)</span>
<a name="line-1013"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1014"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1015"></a>
<a name="line-1016"></a><span class='hs-definition'>simplExprF</span> <span class='hs-varop'>!</span><span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-varop'>!</span><span class='hs-varid'>cont</span> <span class='hs-comment'>-- See Note [Bangs in the Simplifier]</span>
<a name="line-1017"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{- pprTrace "simplExprF" (vcat
<a name="line-1018"></a>      [ ppr e
<a name="line-1019"></a>      , text "cont =" &lt;+&gt; ppr cont
<a name="line-1020"></a>      , text "inscope =" &lt;+&gt; ppr (seInScope env)
<a name="line-1021"></a>      , text "tvsubst =" &lt;+&gt; ppr (seTvSubst env)
<a name="line-1022"></a>      , text "idsubst =" &lt;+&gt; ppr (seIdSubst env)
<a name="line-1023"></a>      , text "cvsubst =" &lt;+&gt; ppr (seCvSubst env)
<a name="line-1024"></a>      ]) $ -}</span>
<a name="line-1025"></a>    <span class='hs-varid'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-varid'>cont</span>
<a name="line-1026"></a>
<a name="line-1027"></a><a name="simplExprF1"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1028"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1029"></a>
<a name="line-1030"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1031"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"simplExprF: type"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span><span class='hs-str'>"cont: "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-1032"></a>    <span class='hs-comment'>-- simplExprF does only with term-valued expressions</span>
<a name="line-1033"></a>    <span class='hs-comment'>-- The (Type ty) case is handled separately by simplExpr</span>
<a name="line-1034"></a>    <span class='hs-comment'>-- and by the other callers of simplExprF</span>
<a name="line-1035"></a>
<a name="line-1036"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>        <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplIdF" #-}</span> <span class='hs-varid'>simplIdF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-varid'>cont</span>
<a name="line-1037"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>      <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "rebuild" #-}</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1038"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>  <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplTick" #-}</span> <span class='hs-varid'>simplTick</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1039"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplCast" #-}</span> <span class='hs-varid'>simplCast</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>
<a name="line-1040"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>  <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplCoercionF" #-}</span> <span class='hs-varid'>simplCoercionF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>
<a name="line-1041"></a>
<a name="line-1042"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1043"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplExprF1-App" #-}</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg</span> <span class='hs-keyword'>of</span>
<a name="line-1044"></a>      <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- The argument type will (almost) certainly be used</span>
<a name="line-1045"></a>                      <span class='hs-comment'>-- in the output program, so just force it now.</span>
<a name="line-1046"></a>                      <span class='hs-comment'>-- See Note [Avoiding space leaks in OutType]</span>
<a name="line-1047"></a>                      <span class='hs-varid'>arg'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1048"></a>
<a name="line-1049"></a>                      <span class='hs-comment'>-- But use substTy, not simplType, to avoid forcing</span>
<a name="line-1050"></a>                      <span class='hs-comment'>-- the hole type; it will likely not be needed.</span>
<a name="line-1051"></a>                      <span class='hs-comment'>-- See Note [The hole type in ApplyToTy]</span>
<a name="line-1052"></a>                    <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>hole'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-1053"></a>
<a name="line-1054"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>$</span>
<a name="line-1055"></a>                      <span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg'</span>
<a name="line-1056"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole'</span>
<a name="line-1057"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1058"></a>      <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1059"></a>          <span class='hs-comment'>-- Crucially, sc_hole_ty is a /lazy/ binding.  It will</span>
<a name="line-1060"></a>          <span class='hs-comment'>-- be forced only if we need to run contHoleType.</span>
<a name="line-1061"></a>          <span class='hs-comment'>-- When these are forced, we might get quadratic behavior;</span>
<a name="line-1062"></a>          <span class='hs-comment'>-- this quadratic blowup could be avoided by drilling down</span>
<a name="line-1063"></a>          <span class='hs-comment'>-- to the function and getting its multiplicities all at once</span>
<a name="line-1064"></a>          <span class='hs-comment'>-- (instead of one-at-a-time). But in practice, we have not</span>
<a name="line-1065"></a>          <span class='hs-comment'>-- observed the quadratic behavior, so this extra entanglement</span>
<a name="line-1066"></a>          <span class='hs-comment'>-- seems not worthwhile.</span>
<a name="line-1067"></a>        <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>$</span>
<a name="line-1068"></a>        <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1069"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-1070"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoDup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1071"></a>
<a name="line-1072"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1073"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplExprF1-Lam" #-}</span>
<a name="line-1074"></a>    <span class='hs-varid'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>zapped_bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1075"></a>        <span class='hs-comment'>-- The main issue here is under-saturated lambdas</span>
<a name="line-1076"></a>        <span class='hs-comment'>--   (\x1. \x2. e) arg1</span>
<a name="line-1077"></a>        <span class='hs-comment'>-- Here x1 might have "occurs-once" occ-info, because occ-info</span>
<a name="line-1078"></a>        <span class='hs-comment'>-- is computed assuming that a group of lambdas is applied</span>
<a name="line-1079"></a>        <span class='hs-comment'>-- all at once.  If there are too few args, we must zap the</span>
<a name="line-1080"></a>        <span class='hs-comment'>-- occ-info, UNLESS the remaining binders are one-shot</span>
<a name="line-1081"></a>  <span class='hs-keyword'>where</span>
<a name="line-1082"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1083"></a>    <span class='hs-varid'>zapped_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapLamBndrs</span> <span class='hs-varid'>n_args</span> <span class='hs-varid'>bndrs</span>
<a name="line-1084"></a>    <span class='hs-varid'>n_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>countArgs</span> <span class='hs-varid'>cont</span>
<a name="line-1085"></a>        <span class='hs-comment'>-- NB: countArgs counts all the args (incl type args)</span>
<a name="line-1086"></a>        <span class='hs-comment'>-- and likewise drop counts all binders (incl type lambdas)</span>
<a name="line-1087"></a>
<a name="line-1088"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1089"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplExprF1-Case" #-}</span>
<a name="line-1090"></a>    <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoDup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span>
<a name="line-1091"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span>
<a name="line-1092"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1093"></a>
<a name="line-1094"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1095"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>pairs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>joinPointBindings_maybe</span> <span class='hs-varid'>pairs</span>
<a name="line-1096"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplRecJoinPoin" #-}</span> <span class='hs-varid'>simplRecJoinPoint</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs'</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1097"></a>
<a name="line-1098"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1099"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplRecE" #-}</span> <span class='hs-varid'>simplRecE</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1100"></a>
<a name="line-1101"></a><span class='hs-definition'>simplExprF1</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1102"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rhs</span>    <span class='hs-comment'>-- First deal with type lets (let a = Type ty in e)</span>
<a name="line-1103"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplExprF1-NonRecLet-Type" #-}</span>
<a name="line-1104"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>)</span>
<a name="line-1105"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1106"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplExprF</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendTvSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1107"></a>
<a name="line-1108"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>joinPointBinding_maybe</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-1109"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplNonRecJoinPoint" #-}</span> <span class='hs-varid'>simplNonRecJoinPoint</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>rhs'</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1110"></a>
<a name="line-1111"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1112"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "simplNonRecE" #-}</span> <span class='hs-varid'>simplNonRecE</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1113"></a>
<a name="line-1114"></a><span class='hs-comment'>{- Note [Avoiding space leaks in OutType]
<a name="line-1115"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1116"></a>Since the simplifier is run for multiple iterations, we need to ensure
<a name="line-1117"></a>that any thunks in the output of one simplifier iteration are forced
<a name="line-1118"></a>by the evaluation of the next simplifier iteration. Otherwise we may
<a name="line-1119"></a>retain multiple copies of the Core program and leak a terrible amount
<a name="line-1120"></a>of memory (as in #13426).
<a name="line-1121"></a>
<a name="line-1122"></a>The simplifier is naturally strict in the entire "Expr part" of the
<a name="line-1123"></a>input Core program, because any expression may contain binders, which
<a name="line-1124"></a>we must find in order to extend the SimplEnv accordingly. But types
<a name="line-1125"></a>do not contain binders and so it is tempting to write things like
<a name="line-1126"></a>
<a name="line-1127"></a>    simplExpr env (Type ty) = return (Type (substTy env ty))   -- Bad!
<a name="line-1128"></a>
<a name="line-1129"></a>This is Bad because the result includes a thunk (substTy env ty) which
<a name="line-1130"></a>retains a reference to the whole simplifier environment; and the next
<a name="line-1131"></a>simplifier iteration will not force this thunk either, because the
<a name="line-1132"></a>line above is not strict in ty.
<a name="line-1133"></a>
<a name="line-1134"></a>So instead our strategy is for the simplifier to fully evaluate
<a name="line-1135"></a>OutTypes when it emits them into the output Core program, for example
<a name="line-1136"></a>
<a name="line-1137"></a>    simplExpr env (Type ty) = do { ty' &lt;- simplType env ty     -- Good
<a name="line-1138"></a>                                 ; return (Type ty') }
<a name="line-1139"></a>
<a name="line-1140"></a>where the only difference from above is that simplType calls seqType
<a name="line-1141"></a>on the result of substTy.
<a name="line-1142"></a>
<a name="line-1143"></a>However, SimplCont can also contain OutTypes and it's not necessarily
<a name="line-1144"></a>a good idea to force types on the way in to SimplCont, because they
<a name="line-1145"></a>may end up not being used and forcing them could be a lot of wasted
<a name="line-1146"></a>work. T5631 is a good example of this.
<a name="line-1147"></a>
<a name="line-1148"></a>- For ApplyToTy's sc_arg_ty, we force the type on the way in because
<a name="line-1149"></a>  the type will almost certainly appear as a type argument in the
<a name="line-1150"></a>  output program.
<a name="line-1151"></a>
<a name="line-1152"></a>- For the hole types in Stop and ApplyToTy, we force the type when we
<a name="line-1153"></a>  emit it into the output program, after obtaining it from
<a name="line-1154"></a>  contResultType. (The hole type in ApplyToTy is only directly used
<a name="line-1155"></a>  to form the result type in a new Stop continuation.)
<a name="line-1156"></a>-}</span>
<a name="line-1157"></a>
<a name="line-1158"></a><a name="simplJoinRhs"></a><span class='hs-comment'>---------------------------------</span>
<a name="line-1159"></a><span class='hs-comment'>-- Simplify a join point, adding the context.</span>
<a name="line-1160"></a><span class='hs-comment'>-- Context goes *inside* the lambdas. IOW, if the join point has arity n, we do:</span>
<a name="line-1161"></a><span class='hs-comment'>--   \x1 .. xn -&gt; e =&gt; \x1 .. xn -&gt; E[e]</span>
<a name="line-1162"></a><span class='hs-comment'>-- Note that we need the arity of the join point, since e may be a lambda</span>
<a name="line-1163"></a><span class='hs-comment'>-- (though this is unlikely). See Note [Join points and case-of-case].</span>
<a name="line-1164"></a><span class='hs-definition'>simplJoinRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1165"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1166"></a><span class='hs-definition'>simplJoinRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1167"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>bndr</span>
<a name="line-1168"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>join_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>join_body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectNBinders</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>expr</span>
<a name="line-1169"></a>              <span class='hs-varid'>mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>cont</span>
<a name="line-1170"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>join_bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLamBndrs</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaleVarBy</span> <span class='hs-varid'>mult</span><span class='hs-layout'>)</span> <span class='hs-varid'>join_bndrs</span><span class='hs-layout'>)</span>
<a name="line-1171"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>join_body'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>join_body</span> <span class='hs-varid'>cont</span>
<a name="line-1172"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>join_bndrs'</span> <span class='hs-varid'>join_body'</span> <span class='hs-layout'>}</span>
<a name="line-1173"></a>
<a name="line-1174"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1175"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"simplJoinRhs"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1176"></a>
<a name="line-1177"></a><a name="simplType"></a><span class='hs-comment'>---------------------------------</span>
<a name="line-1178"></a><span class='hs-definition'>simplType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutType</span>
<a name="line-1179"></a>        <span class='hs-comment'>-- Kept monadic just so we can do the seqType</span>
<a name="line-1180"></a>        <span class='hs-comment'>-- See Note [Avoiding space leaks in OutType]</span>
<a name="line-1181"></a><span class='hs-definition'>simplType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1182"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "simplType" (ppr ty $$ ppr (seTvSubst env)) $</span>
<a name="line-1183"></a>    <span class='hs-varid'>seqType</span> <span class='hs-varid'>new_ty</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>return</span> <span class='hs-varid'>new_ty</span>
<a name="line-1184"></a>  <span class='hs-keyword'>where</span>
<a name="line-1185"></a>    <span class='hs-varid'>new_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1186"></a>
<a name="line-1187"></a><a name="simplCoercionF"></a><span class='hs-comment'>---------------------------------</span>
<a name="line-1188"></a><span class='hs-definition'>simplCoercionF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1189"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1190"></a><span class='hs-definition'>simplCoercionF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>
<a name="line-1191"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplCoercion</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1192"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co'</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1193"></a>
<a name="line-1194"></a><a name="simplCoercion"></a><span class='hs-definition'>simplCoercion</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutCoercion</span>
<a name="line-1195"></a><span class='hs-definition'>simplCoercion</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1196"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getOptCoercionOpts</span>
<a name="line-1197"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>opt_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>optCoercion</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>(</span><span class='hs-varid'>getTCvSubst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-1198"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>seqCo</span> <span class='hs-varid'>opt_co</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>return</span> <span class='hs-varid'>opt_co</span> <span class='hs-layout'>}</span>
<a name="line-1199"></a>
<a name="line-1200"></a><span class='hs-comment'>-----------------------------------</span>
<a name="line-1201"></a><span class='hs-comment'>-- | Push a TickIt context outwards past applications and cases, as</span>
<a name="line-1202"></a><span class='hs-comment'>-- long as this is a non-scoping tick, to let case and application</span>
<a name="line-1203"></a><span class='hs-comment'>-- optimisations apply.</span>
<a name="line-1204"></a>
<a name="line-1205"></a><a name="simplTick"></a><span class='hs-definition'>simplTick</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreTickish</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1206"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1207"></a><span class='hs-definition'>simplTick</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1208"></a>  <span class='hs-comment'>-- A scoped tick turns into a continuation, so that we can spot</span>
<a name="line-1209"></a>  <span class='hs-comment'>-- (scc t (\x . e)) in simplLam and eliminate the scc.  If we didn't do</span>
<a name="line-1210"></a>  <span class='hs-comment'>-- it this way, then it would take two passes of the simplifier to</span>
<a name="line-1211"></a>  <span class='hs-comment'>-- reduce ((scc t (\x . e)) e').</span>
<a name="line-1212"></a>  <span class='hs-comment'>-- NB, don't do this with counting ticks, because if the expr is</span>
<a name="line-1213"></a>  <span class='hs-comment'>-- bottom, then rebuildCall will discard the continuation.</span>
<a name="line-1214"></a>
<a name="line-1215"></a><span class='hs-comment'>-- XXX: we cannot do this, because the simplifier assumes that</span>
<a name="line-1216"></a><span class='hs-comment'>-- the context can be pushed into a case with a single branch. e.g.</span>
<a name="line-1217"></a><span class='hs-comment'>--    scc&lt;f&gt;  case expensive of p -&gt; e</span>
<a name="line-1218"></a><span class='hs-comment'>-- becomes</span>
<a name="line-1219"></a><span class='hs-comment'>--    case expensive of p -&gt; scc&lt;f&gt; e</span>
<a name="line-1220"></a><span class='hs-comment'>--</span>
<a name="line-1221"></a><span class='hs-comment'>-- So I'm disabling this for now.  It just means we will do more</span>
<a name="line-1222"></a><span class='hs-comment'>-- simplifier iterations that necessary in some cases.</span>
<a name="line-1223"></a>
<a name="line-1224"></a><span class='hs-comment'>--  | tickishScoped tickish &amp;&amp; not (tickishCounts tickish)</span>
<a name="line-1225"></a><span class='hs-comment'>--  = simplExprF env expr (TickIt tickish cont)</span>
<a name="line-1226"></a>
<a name="line-1227"></a>  <span class='hs-comment'>-- For unscoped or soft-scoped ticks, we are allowed to float in new</span>
<a name="line-1228"></a>  <span class='hs-comment'>-- cost, so we simply push the continuation inside the tick.  This</span>
<a name="line-1229"></a>  <span class='hs-comment'>-- has the effect of moving the tick to the outside of a case or</span>
<a name="line-1230"></a>  <span class='hs-comment'>-- application context, allowing the normal case and application</span>
<a name="line-1231"></a>  <span class='hs-comment'>-- optimisations to fire.</span>
<a name="line-1232"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickish</span> <span class='hs-varop'>`tickishScopesLike`</span> <span class='hs-conid'>SoftScope</span>
<a name="line-1233"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1234"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span>
<a name="line-1235"></a>       <span class='hs-layout'>}</span>
<a name="line-1236"></a>
<a name="line-1237"></a>  <span class='hs-comment'>-- Push tick inside if the context looks like this will allow us to</span>
<a name="line-1238"></a>  <span class='hs-comment'>-- do a case-of-case - see Note [case-of-scc-of-case]</span>
<a name="line-1239"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Select</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>expr'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>push_tick_inside</span>
<a name="line-1240"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr'</span> <span class='hs-varid'>cont</span>
<a name="line-1241"></a>
<a name="line-1242"></a>  <span class='hs-comment'>-- We don't want to move the tick, but we might still want to allow</span>
<a name="line-1243"></a>  <span class='hs-comment'>-- floats to pass through with appropriate wrapping (or not, see</span>
<a name="line-1244"></a>  <span class='hs-comment'>-- wrap_floats below)</span>
<a name="line-1245"></a>  <span class='hs-comment'>--- | not (tickishCounts tickish) || tickishCanSplit tickish</span>
<a name="line-1246"></a>  <span class='hs-comment'>-- = wrap_floats</span>
<a name="line-1247"></a>
<a name="line-1248"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1249"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_floating_past_tick</span>
<a name="line-1250"></a>
<a name="line-1251"></a> <span class='hs-keyword'>where</span>
<a name="line-1252"></a>
<a name="line-1253"></a>  <span class='hs-comment'>-- Try to push tick inside a case, see Note [case-of-scc-of-case].</span>
<a name="line-1254"></a>  <span class='hs-varid'>push_tick_inside</span> <span class='hs-keyglyph'>=</span>
<a name="line-1255"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>expr0</span> <span class='hs-keyword'>of</span>
<a name="line-1256"></a>      <span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span>
<a name="line-1257"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickScrut</span> <span class='hs-varid'>scrut</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>tickAlt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1258"></a>      <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-1259"></a>   <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-varid'>ticks</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr0</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripTicksTop</span> <span class='hs-varid'>movable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1260"></a>         <span class='hs-varid'>movable</span> <span class='hs-varid'>t</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span>
<a name="line-1261"></a>                          <span class='hs-varid'>t</span> <span class='hs-varop'>`tickishScopesLike`</span> <span class='hs-conid'>NoScope</span> <span class='hs-varop'>||</span>
<a name="line-1262"></a>                          <span class='hs-varid'>tickishCanSplit</span> <span class='hs-varid'>t</span>
<a name="line-1263"></a>         <span class='hs-varid'>tickScrut</span> <span class='hs-varid'>e</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkTick</span> <span class='hs-varid'>e</span> <span class='hs-varid'>ticks</span>
<a name="line-1264"></a>         <span class='hs-comment'>-- Alternatives get annotated with all ticks that scope in some way,</span>
<a name="line-1265"></a>         <span class='hs-comment'>-- but we don't want to count entries.</span>
<a name="line-1266"></a>         <span class='hs-varid'>tickAlt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>c</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>c</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-varid'>mkTick</span> <span class='hs-varid'>e</span> <span class='hs-varid'>ts_scope</span><span class='hs-layout'>)</span>
<a name="line-1267"></a>         <span class='hs-varid'>ts_scope</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkNoCount</span> <span class='hs-varop'>$</span>
<a name="line-1268"></a>                            <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-varop'>`tickishScopesLike`</span> <span class='hs-conid'>NoScope</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>ticks</span>
<a name="line-1269"></a>
<a name="line-1270"></a>  <span class='hs-varid'>no_floating_past_tick</span> <span class='hs-keyglyph'>=</span>
<a name="line-1271"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>inc</span><span class='hs-layout'>,</span><span class='hs-varid'>outc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitCont</span> <span class='hs-varid'>cont</span>
<a name="line-1272"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>inc</span>
<a name="line-1273"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>expr2</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>expr1</span>
<a name="line-1274"></a>             <span class='hs-varid'>tickish'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplTickish</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tickish</span>
<a name="line-1275"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTick</span> <span class='hs-varid'>tickish'</span> <span class='hs-varid'>expr2</span><span class='hs-layout'>)</span> <span class='hs-varid'>outc</span>
<a name="line-1276"></a>       <span class='hs-layout'>}</span>
<a name="line-1277"></a>
<a name="line-1278"></a><span class='hs-comment'>-- Alternative version that wraps outgoing floats with the tick.  This</span>
<a name="line-1279"></a><span class='hs-comment'>-- results in ticks being duplicated, as we don't make any attempt to</span>
<a name="line-1280"></a><span class='hs-comment'>-- eliminate the tick if we re-inline the binding (because the tick</span>
<a name="line-1281"></a><span class='hs-comment'>-- semantics allows unrestricted inlining of HNFs), so I'm not doing</span>
<a name="line-1282"></a><span class='hs-comment'>-- this any more.  FloatOut will catch any real opportunities for</span>
<a name="line-1283"></a><span class='hs-comment'>-- floating.</span>
<a name="line-1284"></a><span class='hs-comment'>--</span>
<a name="line-1285"></a><span class='hs-comment'>--  wrap_floats =</span>
<a name="line-1286"></a><span class='hs-comment'>--    do { let (inc,outc) = splitCont cont</span>
<a name="line-1287"></a><span class='hs-comment'>--       ; (env', expr') &lt;- simplExprF (zapFloats env) expr inc</span>
<a name="line-1288"></a><span class='hs-comment'>--       ; let tickish' = simplTickish env tickish</span>
<a name="line-1289"></a><span class='hs-comment'>--       ; let wrap_float (b,rhs) = (zapIdStrictness (setIdArity b 0),</span>
<a name="line-1290"></a><span class='hs-comment'>--                                   mkTick (mkNoCount tickish') rhs)</span>
<a name="line-1291"></a><span class='hs-comment'>--              -- when wrapping a float with mkTick, we better zap the Id's</span>
<a name="line-1292"></a><span class='hs-comment'>--              -- strictness info and arity, because it might be wrong now.</span>
<a name="line-1293"></a><span class='hs-comment'>--       ; let env'' = addFloats env (mapFloats env' wrap_float)</span>
<a name="line-1294"></a><span class='hs-comment'>--       ; rebuild env'' expr' (TickIt tickish' outc)</span>
<a name="line-1295"></a><span class='hs-comment'>--       }</span>
<a name="line-1296"></a>
<a name="line-1297"></a>
<a name="line-1298"></a>  <span class='hs-varid'>simplTickish</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tickish</span>
<a name="line-1299"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Breakpoint</span> <span class='hs-varid'>ext</span> <span class='hs-varid'>n</span> <span class='hs-varid'>ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tickish</span>
<a name="line-1300"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Breakpoint</span> <span class='hs-varid'>ext</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>getDoneId</span> <span class='hs-varop'>.</span> <span class='hs-varid'>substId</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>ids</span><span class='hs-layout'>)</span>
<a name="line-1301"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tickish</span>
<a name="line-1302"></a>
<a name="line-1303"></a>  <span class='hs-comment'>-- Push type application and coercion inside a tick</span>
<a name="line-1304"></a>  <span class='hs-varid'>splitCont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplCont</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>
<a name="line-1305"></a>  <span class='hs-varid'>splitCont</span> <span class='hs-varid'>cont</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>cont</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>outc</span><span class='hs-layout'>)</span>
<a name="line-1306"></a>    <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-varid'>inc</span><span class='hs-layout'>,</span><span class='hs-varid'>outc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitCont</span> <span class='hs-varid'>tail</span>
<a name="line-1307"></a>  <span class='hs-varid'>splitCont</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>inc</span><span class='hs-layout'>,</span> <span class='hs-varid'>outc</span><span class='hs-layout'>)</span>
<a name="line-1308"></a>    <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-varid'>inc</span><span class='hs-layout'>,</span><span class='hs-varid'>outc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitCont</span> <span class='hs-varid'>c</span>
<a name="line-1309"></a>  <span class='hs-varid'>splitCont</span> <span class='hs-varid'>other</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkBoringStop</span> <span class='hs-layout'>(</span><span class='hs-varid'>contHoleType</span> <span class='hs-varid'>other</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>other</span><span class='hs-layout'>)</span>
<a name="line-1310"></a>
<a name="line-1311"></a>  <span class='hs-varid'>getDoneId</span> <span class='hs-layout'>(</span><span class='hs-conid'>DoneId</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span>
<a name="line-1312"></a>  <span class='hs-varid'>getDoneId</span> <span class='hs-layout'>(</span><span class='hs-conid'>DoneEx</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getIdFromTrivialExpr</span> <span class='hs-varid'>e</span> <span class='hs-comment'>-- Note [substTickish] in GHC.Core.Subst</span>
<a name="line-1313"></a>  <span class='hs-varid'>getDoneId</span> <span class='hs-varid'>other</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"getDoneId"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>other</span><span class='hs-layout'>)</span>
<a name="line-1314"></a>
<a name="line-1315"></a><span class='hs-comment'>-- Note [case-of-scc-of-case]</span>
<a name="line-1316"></a><span class='hs-comment'>-- It's pretty important to be able to transform case-of-case when</span>
<a name="line-1317"></a><span class='hs-comment'>-- there's an SCC in the way.  For example, the following comes up</span>
<a name="line-1318"></a><span class='hs-comment'>-- in nofib/real/compress/Encode.hs:</span>
<a name="line-1319"></a><span class='hs-comment'>--</span>
<a name="line-1320"></a><span class='hs-comment'>--        case scctick&lt;code_string.r1&gt;</span>
<a name="line-1321"></a><span class='hs-comment'>--             case $wcode_string_r13s wild_XC w1_s137 w2_s138 l_aje</span>
<a name="line-1322"></a><span class='hs-comment'>--             of _ { (# ww1_s13f, ww2_s13g, ww3_s13h #) -&gt;</span>
<a name="line-1323"></a><span class='hs-comment'>--             (ww1_s13f, ww2_s13g, ww3_s13h)</span>
<a name="line-1324"></a><span class='hs-comment'>--             }</span>
<a name="line-1325"></a><span class='hs-comment'>--        of _ { (ww_s12Y, ww1_s12Z, ww2_s130) -&gt;</span>
<a name="line-1326"></a><span class='hs-comment'>--        tick&lt;code_string.f1&gt;</span>
<a name="line-1327"></a><span class='hs-comment'>--        (ww_s12Y,</span>
<a name="line-1328"></a><span class='hs-comment'>--         ww1_s12Z,</span>
<a name="line-1329"></a><span class='hs-comment'>--         PTTrees.PT</span>
<a name="line-1330"></a><span class='hs-comment'>--           @ GHC.Types.Char @ GHC.Types.Int wild2_Xj ww2_s130 r_ajf)</span>
<a name="line-1331"></a><span class='hs-comment'>--        }</span>
<a name="line-1332"></a><span class='hs-comment'>--</span>
<a name="line-1333"></a><span class='hs-comment'>-- We really want this case-of-case to fire, because then the 3-tuple</span>
<a name="line-1334"></a><span class='hs-comment'>-- will go away (indeed, the CPR optimisation is relying on this</span>
<a name="line-1335"></a><span class='hs-comment'>-- happening).  But the scctick is in the way - we need to push it</span>
<a name="line-1336"></a><span class='hs-comment'>-- inside to expose the case-of-case.  So we perform this</span>
<a name="line-1337"></a><span class='hs-comment'>-- transformation on the inner case:</span>
<a name="line-1338"></a><span class='hs-comment'>--</span>
<a name="line-1339"></a><span class='hs-comment'>--   scctick c (case e of { p1 -&gt; e1; ...; pn -&gt; en })</span>
<a name="line-1340"></a><span class='hs-comment'>--    ==&gt;</span>
<a name="line-1341"></a><span class='hs-comment'>--   case (scctick c e) of { p1 -&gt; scc c e1; ...; pn -&gt; scc c en }</span>
<a name="line-1342"></a><span class='hs-comment'>--</span>
<a name="line-1343"></a><span class='hs-comment'>-- So we've moved a constant amount of work out of the scc to expose</span>
<a name="line-1344"></a><span class='hs-comment'>-- the case.  We only do this when the continuation is interesting: in</span>
<a name="line-1345"></a><span class='hs-comment'>-- for now, it has to be another Case (maybe generalise this later).</span>
<a name="line-1346"></a>
<a name="line-1347"></a><span class='hs-comment'>{-
<a name="line-1348"></a>************************************************************************
<a name="line-1349"></a>*                                                                      *
<a name="line-1350"></a>\subsection{The main rebuilder}
<a name="line-1351"></a>*                                                                      *
<a name="line-1352"></a>************************************************************************
<a name="line-1353"></a>-}</span>
<a name="line-1354"></a>
<a name="line-1355"></a><a name="rebuild"></a><span class='hs-definition'>rebuild</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1356"></a><span class='hs-comment'>-- At this point the substitution in the SimplEnv should be irrelevant;</span>
<a name="line-1357"></a><span class='hs-comment'>-- only the in-scope set matters</span>
<a name="line-1358"></a><span class='hs-definition'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1359"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cont</span> <span class='hs-keyword'>of</span>
<a name="line-1360"></a>      <span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1361"></a>      <span class='hs-conid'>TickIt</span> <span class='hs-varid'>t</span> <span class='hs-varid'>cont</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1362"></a>      <span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCast</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1363"></a>                       <span class='hs-comment'>-- NB: mkCast implements the (Coercion co |&gt; g) optimisation</span>
<a name="line-1364"></a>
<a name="line-1365"></a>      <span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1366"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rebuildCase</span> <span class='hs-layout'>(</span><span class='hs-varid'>se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-1367"></a>
<a name="line-1368"></a>      <span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>}</span>
<a name="line-1369"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>addValArgTo</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1370"></a>      <span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1371"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1372"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecX</span> <span class='hs-layout'>(</span><span class='hs-varid'>se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-varid'>expr</span>
<a name="line-1373"></a>                                  <span class='hs-comment'>-- expr satisfies let/app since it started life</span>
<a name="line-1374"></a>                                  <span class='hs-comment'>-- in a call to simplNonRecE</span>
<a name="line-1375"></a>              <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLam</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1376"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1377"></a>
<a name="line-1378"></a>      <span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>}</span>
<a name="line-1379"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1380"></a>
<a name="line-1381"></a>      <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup_flag</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>}</span>
<a name="line-1382"></a>        <span class='hs-comment'>-- See Note [Avoid redundant simplification]</span>
<a name="line-1383"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dup_flag</span> <span class='hs-varid'>se</span> <span class='hs-varid'>arg</span>
<a name="line-1384"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1385"></a>
<a name="line-1386"></a><span class='hs-comment'>{-
<a name="line-1387"></a>************************************************************************
<a name="line-1388"></a>*                                                                      *
<a name="line-1389"></a>\subsection{Lambdas}
<a name="line-1390"></a>*                                                                      *
<a name="line-1391"></a>************************************************************************
<a name="line-1392"></a>-}</span>
<a name="line-1393"></a>
<a name="line-1394"></a><span class='hs-comment'>{- Note [Optimising reflexivity]
<a name="line-1395"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1396"></a>It's important (for compiler performance) to get rid of reflexivity as soon
<a name="line-1397"></a>as it appears.  See #11735, #14737, and #15019.
<a name="line-1398"></a>
<a name="line-1399"></a>In particular, we want to behave well on
<a name="line-1400"></a>
<a name="line-1401"></a> *  e |&gt; co1 |&gt; co2
<a name="line-1402"></a>    where the two happen to cancel out entirely. That is quite common;
<a name="line-1403"></a>    e.g. a newtype wrapping and unwrapping cancel.
<a name="line-1404"></a>
<a name="line-1405"></a>
<a name="line-1406"></a> * (f |&gt; co) @t1 @t2 ... @tn x1 .. xm
<a name="line-1407"></a>   Here we will use pushCoTyArg and pushCoValArg successively, which
<a name="line-1408"></a>   build up NthCo stacks.  Silly to do that if co is reflexive.
<a name="line-1409"></a>
<a name="line-1410"></a>However, we don't want to call isReflexiveCo too much, because it uses
<a name="line-1411"></a>type equality which is expensive on big types (#14737 comment:7).
<a name="line-1412"></a>
<a name="line-1413"></a>A good compromise (determined experimentally) seems to be to call
<a name="line-1414"></a>isReflexiveCo
<a name="line-1415"></a> * when composing casts, and
<a name="line-1416"></a> * at the end
<a name="line-1417"></a>
<a name="line-1418"></a>In investigating this I saw missed opportunities for on-the-fly
<a name="line-1419"></a>coercion shrinkage. See #15090.
<a name="line-1420"></a>-}</span>
<a name="line-1421"></a>
<a name="line-1422"></a>
<a name="line-1423"></a><a name="simplCast"></a><span class='hs-definition'>simplCast</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1424"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1425"></a><span class='hs-definition'>simplCast</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span> <span class='hs-varid'>co0</span> <span class='hs-varid'>cont0</span>
<a name="line-1426"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>co1</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "simplCast-simplCoercion" #-}</span> <span class='hs-varid'>simplCoercion</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co0</span>
<a name="line-1427"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>cont1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-comment'>{-#SCC "simplCast-addCoerce" #-}</span>
<a name="line-1428"></a>                   <span class='hs-keyword'>if</span> <span class='hs-varid'>isReflCo</span> <span class='hs-varid'>co1</span>
<a name="line-1429"></a>                   <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>cont0</span>  <span class='hs-comment'>-- See Note [Optimising reflexivity]</span>
<a name="line-1430"></a>                   <span class='hs-keyword'>else</span> <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>cont0</span>
<a name="line-1431"></a>        <span class='hs-layout'>;</span> <span class='hs-comment'>{-#SCC "simplCast-simplExprF" #-}</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont1</span> <span class='hs-layout'>}</span>
<a name="line-1432"></a>  <span class='hs-keyword'>where</span>
<a name="line-1433"></a>        <span class='hs-comment'>-- If the first parameter is MRefl, then simplifying revealed a</span>
<a name="line-1434"></a>        <span class='hs-comment'>-- reflexive coercion. Omit.</span>
<a name="line-1435"></a>        <span class='hs-varid'>addCoerceM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MOutCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1436"></a>        <span class='hs-varid'>addCoerceM</span> <span class='hs-conid'>MRefl</span>   <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>cont</span>
<a name="line-1437"></a>        <span class='hs-varid'>addCoerceM</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>
<a name="line-1438"></a>
<a name="line-1439"></a>        <span class='hs-varid'>addCoerce</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutCoercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1440"></a>        <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co1</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co2</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [Optimising reflexivity]</span>
<a name="line-1441"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isReflexiveCo</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>cont</span>
<a name="line-1442"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co'</span> <span class='hs-varid'>cont</span>
<a name="line-1443"></a>          <span class='hs-keyword'>where</span>
<a name="line-1444"></a>            <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTransCo</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-1445"></a>
<a name="line-1446"></a>        <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1447"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushCoTyArg</span> <span class='hs-varid'>co</span> <span class='hs-varid'>arg_ty</span>
<a name="line-1448"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "addCoerce-pushCoTyArg" #-}</span>
<a name="line-1449"></a>            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tail'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addCoerceM</span> <span class='hs-varid'>m_co'</span> <span class='hs-varid'>tail</span>
<a name="line-1450"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty'</span>
<a name="line-1451"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail'</span>
<a name="line-1452"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionLKind</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1453"></a>                                        <span class='hs-comment'>-- NB!  As the cast goes past, the</span>
<a name="line-1454"></a>                                        <span class='hs-comment'>-- type of the hole changes (#16312)</span>
<a name="line-1455"></a>
<a name="line-1456"></a>        <span class='hs-comment'>-- (f |&gt; co) e   ===&gt;   (f (e |&gt; co1)) |&gt; co2</span>
<a name="line-1457"></a>        <span class='hs-comment'>-- where   co :: (s1-&gt;s2) ~ (t1-&gt;t2)</span>
<a name="line-1458"></a>        <span class='hs-comment'>--         co1 :: t1 ~ s1</span>
<a name="line-1459"></a>        <span class='hs-comment'>--         co2 :: s2 ~ t2</span>
<a name="line-1460"></a>        <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_se</span>
<a name="line-1461"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1462"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>m_co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushCoValArg</span> <span class='hs-varid'>co</span>
<a name="line-1463"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>levity_ok</span> <span class='hs-varid'>m_co1</span>
<a name="line-1464"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-#SCC "addCoerce-pushCoValArg" #-}</span>
<a name="line-1465"></a>            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tail'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addCoerceM</span> <span class='hs-varid'>m_co2</span> <span class='hs-varid'>tail</span>
<a name="line-1466"></a>               <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m_co1</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-1467"></a>                   <span class='hs-conid'>MRefl</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>cont</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail'</span>
<a name="line-1468"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionLKind</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>;</span>
<a name="line-1469"></a>                      <span class='hs-comment'>-- Avoid simplifying if possible;</span>
<a name="line-1470"></a>                      <span class='hs-comment'>-- See Note [Avoiding exponential behaviour]</span>
<a name="line-1471"></a>
<a name="line-1472"></a>                   <span class='hs-conid'>MCo</span> <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1473"></a>            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>dup'</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_se'</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>arg_se</span> <span class='hs-varid'>arg</span>
<a name="line-1474"></a>                    <span class='hs-comment'>-- When we build the ApplyTo we can't mix the OutCoercion</span>
<a name="line-1475"></a>                    <span class='hs-comment'>-- 'co' with the InExpr 'arg', so we simplify</span>
<a name="line-1476"></a>                    <span class='hs-comment'>-- to make it all consistent.  It's a bit messy.</span>
<a name="line-1477"></a>                    <span class='hs-comment'>-- But it isn't a common case.</span>
<a name="line-1478"></a>                    <span class='hs-comment'>-- Example of use: #995</span>
<a name="line-1479"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCast</span> <span class='hs-varid'>arg'</span> <span class='hs-varid'>co1</span>
<a name="line-1480"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_se'</span>
<a name="line-1481"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup'</span>
<a name="line-1482"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail'</span>
<a name="line-1483"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionLKind</span> <span class='hs-varid'>co</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1484"></a>
<a name="line-1485"></a>        <span class='hs-varid'>addCoerce</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span>
<a name="line-1486"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isReflexiveCo</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>cont</span>  <span class='hs-comment'>-- Having this at the end makes a huge</span>
<a name="line-1487"></a>                                            <span class='hs-comment'>-- difference in T12227, for some reason</span>
<a name="line-1488"></a>                                            <span class='hs-comment'>-- See Note [Optimising reflexivity]</span>
<a name="line-1489"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-1490"></a>
<a name="line-1491"></a>        <span class='hs-varid'>levity_ok</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MCoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1492"></a>        <span class='hs-varid'>levity_ok</span> <span class='hs-conid'>MRefl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1493"></a>        <span class='hs-varid'>levity_ok</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varop'>$</span> <span class='hs-varid'>isTypeLevPoly</span> <span class='hs-varop'>$</span> <span class='hs-varid'>coercionRKind</span> <span class='hs-varid'>co</span>
<a name="line-1494"></a>          <span class='hs-comment'>-- Without this check, we get a lev-poly arg</span>
<a name="line-1495"></a>          <span class='hs-comment'>-- See Note [Levity polymorphism invariants] in GHC.Core</span>
<a name="line-1496"></a>          <span class='hs-comment'>-- test: typecheck/should_run/EtaExpandLevPoly</span>
<a name="line-1497"></a>
<a name="line-1498"></a><a name="simplArg"></a><span class='hs-definition'>simplArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DupFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StaticEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1499"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>DupFlag</span><span class='hs-layout'>,</span> <span class='hs-conid'>StaticEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1500"></a><span class='hs-definition'>simplArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dup_flag</span> <span class='hs-varid'>arg_env</span> <span class='hs-varid'>arg</span>
<a name="line-1501"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSimplified</span> <span class='hs-varid'>dup_flag</span>
<a name="line-1502"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>dup_flag</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-1503"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1504"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_env</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span>
<a name="line-1505"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>arg'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExpr</span> <span class='hs-varid'>arg_env'</span>  <span class='hs-varid'>arg</span>
<a name="line-1506"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Simplified</span><span class='hs-layout'>,</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>arg_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1507"></a>         <span class='hs-comment'>-- Return a StaticEnv that includes the in-scope set from 'env',</span>
<a name="line-1508"></a>         <span class='hs-comment'>-- because arg' may well mention those variables (#20639)</span>
<a name="line-1509"></a>
<a name="line-1510"></a><span class='hs-comment'>{-
<a name="line-1511"></a>************************************************************************
<a name="line-1512"></a>*                                                                      *
<a name="line-1513"></a>\subsection{Lambdas}
<a name="line-1514"></a>*                                                                      *
<a name="line-1515"></a>************************************************************************
<a name="line-1516"></a>-}</span>
<a name="line-1517"></a>
<a name="line-1518"></a><a name="simplLam"></a><span class='hs-definition'>simplLam</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InId</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1519"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1520"></a>
<a name="line-1521"></a><span class='hs-definition'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1522"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1523"></a>
<a name="line-1524"></a><span class='hs-definition'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-conop'>:</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1525"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>BetaReduction</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1526"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplLam</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendTvSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1527"></a>
<a name="line-1528"></a><span class='hs-definition'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-conop'>:</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_se</span>
<a name="line-1529"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1530"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSimplified</span> <span class='hs-varid'>dup</span>  <span class='hs-comment'>-- Don't re-simplify if we've simplified it once</span>
<a name="line-1531"></a>                      <span class='hs-comment'>-- See Note [Avoiding exponential behaviour]</span>
<a name="line-1532"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>BetaReduction</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1533"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecX</span> <span class='hs-varid'>env</span> <span class='hs-varid'>zapped_bndr</span> <span class='hs-varid'>arg</span>
<a name="line-1534"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLam</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1535"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1536"></a>
<a name="line-1537"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1538"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>BetaReduction</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1539"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>simplNonRecE</span> <span class='hs-varid'>env</span> <span class='hs-varid'>zapped_bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_se</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1540"></a>  <span class='hs-keyword'>where</span>
<a name="line-1541"></a>    <span class='hs-varid'>zapped_bndr</span>  <span class='hs-comment'>-- See Note [Zap unfolding when beta-reducing]</span>
<a name="line-1542"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapStableUnfolding</span> <span class='hs-varid'>bndr</span>
<a name="line-1543"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span>
<a name="line-1544"></a>
<a name="line-1545"></a>      <span class='hs-comment'>-- Discard a non-counting tick on a lambda.  This may change the</span>
<a name="line-1546"></a>      <span class='hs-comment'>-- cost attribution slightly (moving the allocation of the</span>
<a name="line-1547"></a>      <span class='hs-comment'>-- lambda elsewhere), but we don't care: optimisation changes</span>
<a name="line-1548"></a>      <span class='hs-comment'>-- cost attribution all the time.</span>
<a name="line-1549"></a><span class='hs-definition'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-1550"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>tickish</span><span class='hs-layout'>)</span>
<a name="line-1551"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1552"></a>
<a name="line-1553"></a>        <span class='hs-comment'>-- Not enough args, so there are real lambdas left to put in the result</span>
<a name="line-1554"></a><span class='hs-definition'>simplLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1555"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLamBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-1556"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>body'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExpr</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body</span>
<a name="line-1557"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>new_lam</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkLam</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>body'</span> <span class='hs-varid'>cont</span>
<a name="line-1558"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>new_lam</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1559"></a>
<a name="line-1560"></a><a name="simplLamBndr"></a><span class='hs-comment'>-------------</span>
<a name="line-1561"></a><span class='hs-definition'>simplLamBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBndr</span><span class='hs-layout'>)</span>
<a name="line-1562"></a><span class='hs-comment'>-- Used for lambda binders.  These sometimes have unfoldings added by</span>
<a name="line-1563"></a><span class='hs-comment'>-- the worker/wrapper pass that must be preserved, because they can't</span>
<a name="line-1564"></a><span class='hs-comment'>-- be reconstructed from context.  For example:</span>
<a name="line-1565"></a><span class='hs-comment'>--      f x = case x of (a,b) -&gt; fw a b x</span>
<a name="line-1566"></a><span class='hs-comment'>--      fw a b x{=(a,b)} = ...</span>
<a name="line-1567"></a><span class='hs-comment'>-- The "{=(a,b)}" is an unfolding we can't reconstruct otherwise.</span>
<a name="line-1568"></a><span class='hs-definition'>simplLamBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-1569"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>hasCoreUnfolding</span> <span class='hs-varid'>old_unf</span>   <span class='hs-comment'>-- Special case</span>
<a name="line-1570"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-1571"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unf'</span>          <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplStableUnfolding</span> <span class='hs-varid'>env1</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>bndr</span>
<a name="line-1572"></a>                                      <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArityType</span> <span class='hs-varid'>bndr1</span><span class='hs-layout'>)</span> <span class='hs-varid'>old_unf</span>
<a name="line-1573"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>bndr2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr1</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>unf'</span>
<a name="line-1574"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>modifyInScope</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>bndr2</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1575"></a>
<a name="line-1576"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>                <span class='hs-comment'>-- Normal case</span>
<a name="line-1578"></a>  <span class='hs-keyword'>where</span>
<a name="line-1579"></a>    <span class='hs-varid'>old_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span>
<a name="line-1580"></a>
<a name="line-1581"></a><a name="simplLamBndrs"></a><span class='hs-definition'>simplLamBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1582"></a><span class='hs-definition'>simplLamBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumLM</span> <span class='hs-varid'>simplLamBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-1583"></a>
<a name="line-1584"></a><a name="simplNonRecE"></a><span class='hs-comment'>------------------</span>
<a name="line-1585"></a><span class='hs-definition'>simplNonRecE</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-1586"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>                    <span class='hs-comment'>-- The binder, always an Id</span>
<a name="line-1587"></a>                                        <span class='hs-comment'>-- Never a join point</span>
<a name="line-1588"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>InExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Rhs of binding (or arg of lambda)</span>
<a name="line-1589"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>InBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Body of the let/lambda</span>
<a name="line-1590"></a>                                        <span class='hs-comment'>--      \xs.e</span>
<a name="line-1591"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1592"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1593"></a>
<a name="line-1594"></a><span class='hs-comment'>-- simplNonRecE is used for</span>
<a name="line-1595"></a><span class='hs-comment'>--  * non-top-level non-recursive non-join-point lets in expressions</span>
<a name="line-1596"></a><span class='hs-comment'>--  * beta reduction</span>
<a name="line-1597"></a><span class='hs-comment'>--</span>
<a name="line-1598"></a><span class='hs-comment'>-- simplNonRec env b (rhs, rhs_se) (bs, body) k</span>
<a name="line-1599"></a><span class='hs-comment'>--   = let env in</span>
<a name="line-1600"></a><span class='hs-comment'>--     cont&lt; let b = rhs_se(rhs) in \bs.body &gt;</span>
<a name="line-1601"></a><span class='hs-comment'>--</span>
<a name="line-1602"></a><span class='hs-comment'>-- It deals with strict bindings, via the StrictBind continuation,</span>
<a name="line-1603"></a><span class='hs-comment'>-- which may abort the whole process</span>
<a name="line-1604"></a><span class='hs-comment'>--</span>
<a name="line-1605"></a><span class='hs-comment'>-- Precondition: rhs satisfies the let/app invariant</span>
<a name="line-1606"></a><span class='hs-comment'>--               Note [Core let/app invariant] in GHC.Core</span>
<a name="line-1607"></a><span class='hs-comment'>--</span>
<a name="line-1608"></a><span class='hs-comment'>-- The "body" of the binding comes as a pair of ([InId],InExpr)</span>
<a name="line-1609"></a><span class='hs-comment'>-- representing a lambda; so we recurse back to simplLam</span>
<a name="line-1610"></a><span class='hs-comment'>-- Why?  Because of the binder-occ-info-zapping done before</span>
<a name="line-1611"></a><span class='hs-comment'>--       the call to simplLam in simplExprF (Lam ...)</span>
<a name="line-1612"></a>
<a name="line-1613"></a><span class='hs-definition'>simplNonRecE</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_se</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1614"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-1615"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>preInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rhs_se</span>
<a name="line-1616"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>PreInlineUnconditionally</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1617"></a>       <span class='hs-layout'>;</span> <span class='hs-comment'>-- pprTrace "preInlineUncond" (ppr bndr &lt;+&gt; ppr rhs) $</span>
<a name="line-1618"></a>         <span class='hs-varid'>simplLam</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1619"></a>
<a name="line-1620"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1621"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-1622"></a>
<a name="line-1623"></a>       <span class='hs-comment'>-- Deal with strict bindings</span>
<a name="line-1624"></a>       <span class='hs-comment'>-- See Note [Dark corner with levity polymorphism]</span>
<a name="line-1625"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isStrictId</span> <span class='hs-varid'>bndr1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>sm_case_case</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1626"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>simplExprF</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-1627"></a>                   <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1628"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoDup</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1629"></a>
<a name="line-1630"></a>       <span class='hs-comment'>-- Deal with lazy bindings</span>
<a name="line-1631"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-1632"></a>       <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env2</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addBndrRules</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr1</span> <span class='hs-conid'>Nothing</span>
<a name="line-1633"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env3</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLazyBind</span> <span class='hs-varid'>env2</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr2</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rhs_se</span>
<a name="line-1634"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLam</span> <span class='hs-varid'>env3</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1635"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1636"></a>
<a name="line-1637"></a><a name="simplRecE"></a><span class='hs-comment'>------------------</span>
<a name="line-1638"></a><span class='hs-definition'>simplRecE</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-1639"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>InId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1640"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>
<a name="line-1641"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1642"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1643"></a>
<a name="line-1644"></a><span class='hs-comment'>-- simplRecE is used for</span>
<a name="line-1645"></a><span class='hs-comment'>--  * non-top-level recursive lets in expressions</span>
<a name="line-1646"></a><span class='hs-definition'>simplRecE</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1647"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs</span>
<a name="line-1648"></a>        <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isJoinId</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-1649"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplRecBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-1650"></a>                <span class='hs-comment'>-- NB: bndrs' don't have unfoldings or rules</span>
<a name="line-1651"></a>                <span class='hs-comment'>-- We add them as we go down</span>
<a name="line-1652"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplRecBind</span> <span class='hs-varid'>env1</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>pairs</span>
<a name="line-1653"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1654"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1655"></a>
<a name="line-1656"></a><span class='hs-comment'>{- Note [Dark corner with levity polymorphism]
<a name="line-1657"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1658"></a>In `simplNonRecE`, the call to `isStrictId` will fail if the binder
<a name="line-1659"></a>has a levity-polymorphic type, of kind (TYPE r).  So we are careful to
<a name="line-1660"></a>call `isStrictId` on the OutId, not the InId, in case we have
<a name="line-1661"></a>     ((\(r::RuntimeRep) \(x::Type r). blah) Lifted arg)
<a name="line-1662"></a>That will lead to `simplNonRecE env (x::Type r) arg`, and we can't tell
<a name="line-1663"></a>if x is lifted or unlifted from that.
<a name="line-1664"></a>
<a name="line-1665"></a>We only get such redexes from the compulsory inlining of a wired-in,
<a name="line-1666"></a>levity-polymorphic function like `rightSection` (see
<a name="line-1667"></a>GHC.Types.Id.Make).  Mind you, SimpleOpt should probably have inlined
<a name="line-1668"></a>such compulsory inlinings already, but belt and braces does no harm.
<a name="line-1669"></a>
<a name="line-1670"></a>Plus, it turns out that GHC.Driver.Main.hscCompileCoreExpr calls the
<a name="line-1671"></a>Simplifier without first calling SimpleOpt, so anything involving
<a name="line-1672"></a>GHCi or TH and operator sections will fall over if we don't take
<a name="line-1673"></a>care here.
<a name="line-1674"></a>
<a name="line-1675"></a>Note [Avoiding exponential behaviour]
<a name="line-1676"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1677"></a>One way in which we can get exponential behaviour is if we simplify a
<a name="line-1678"></a>big expression, and the re-simplify it -- and then this happens in a
<a name="line-1679"></a>deeply-nested way.  So we must be jolly careful about re-simplifying
<a name="line-1680"></a>an expression.  That is why completeNonRecX does not try
<a name="line-1681"></a>preInlineUnconditionally.
<a name="line-1682"></a>
<a name="line-1683"></a>Example:
<a name="line-1684"></a>  f BIG, where f has a RULE
<a name="line-1685"></a>Then
<a name="line-1686"></a> * We simplify BIG before trying the rule; but the rule does not fire
<a name="line-1687"></a> * We inline f = \x. x True
<a name="line-1688"></a> * So if we did preInlineUnconditionally we'd re-simplify (BIG True)
<a name="line-1689"></a>
<a name="line-1690"></a>However, if BIG has /not/ already been simplified, we'd /like/ to
<a name="line-1691"></a>simplify BIG True; maybe good things happen.  That is why
<a name="line-1692"></a>
<a name="line-1693"></a>* simplLam has
<a name="line-1694"></a>    - a case for (isSimplified dup), which goes via simplNonRecX, and
<a name="line-1695"></a>    - a case for the un-simplified case, which goes via simplNonRecE
<a name="line-1696"></a>
<a name="line-1697"></a>* We go to some efforts to avoid unnecessarily simplifying ApplyToVal,
<a name="line-1698"></a>  in at least two places
<a name="line-1699"></a>    - In simplCast/addCoerce, where we check for isReflCo
<a name="line-1700"></a>    - In rebuildCall we avoid simplifying arguments before we have to
<a name="line-1701"></a>      (see Note [Trying rewrite rules])
<a name="line-1702"></a>
<a name="line-1703"></a>
<a name="line-1704"></a>Note [Zap unfolding when beta-reducing]
<a name="line-1705"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1706"></a>Lambda-bound variables can have stable unfoldings, such as
<a name="line-1707"></a>   $j = \x. \b{Unf=Just x}. e
<a name="line-1708"></a>See Note [Case binders and join points] below; the unfolding for lets
<a name="line-1709"></a>us optimise e better.  However when we beta-reduce it we want to
<a name="line-1710"></a>revert to using the actual value, otherwise we can end up in the
<a name="line-1711"></a>stupid situation of
<a name="line-1712"></a>          let x = blah in
<a name="line-1713"></a>          let b{Unf=Just x} = y
<a name="line-1714"></a>          in ...b...
<a name="line-1715"></a>Here it'd be far better to drop the unfolding and use the actual RHS.
<a name="line-1716"></a>
<a name="line-1717"></a>************************************************************************
<a name="line-1718"></a>*                                                                      *
<a name="line-1719"></a>                     Join points
<a name="line-1720"></a>*                                                                      *
<a name="line-1721"></a>********************************************************************* -}</span>
<a name="line-1722"></a>
<a name="line-1723"></a><span class='hs-comment'>{- Note [Rules and unfolding for join points]
<a name="line-1724"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1725"></a>Suppose we have
<a name="line-1726"></a>
<a name="line-1727"></a>   simplExpr (join j x = rhs                         ) cont
<a name="line-1728"></a>             (      {- RULE j (p:ps) = blah -}       )
<a name="line-1729"></a>             (      {- StableUnfolding j = blah -}   )
<a name="line-1730"></a>             (in blah                                )
<a name="line-1731"></a>
<a name="line-1732"></a>Then we will push 'cont' into the rhs of 'j'.  But we should *also* push
<a name="line-1733"></a>'cont' into the RHS of
<a name="line-1734"></a>  * Any RULEs for j, e.g. generated by SpecConstr
<a name="line-1735"></a>  * Any stable unfolding for j, e.g. the result of an INLINE pragma
<a name="line-1736"></a>
<a name="line-1737"></a>Simplifying rules and stable-unfoldings happens a bit after
<a name="line-1738"></a>simplifying the right-hand side, so we remember whether or not it
<a name="line-1739"></a>is a join point, and what 'cont' is, in a value of type MaybeJoinCont
<a name="line-1740"></a>
<a name="line-1741"></a>#13900 was caused by forgetting to push 'cont' into the RHS
<a name="line-1742"></a>of a SpecConstr-generated RULE for a join point.
<a name="line-1743"></a>-}</span>
<a name="line-1744"></a>
<a name="line-1745"></a><a name="MaybeJoinCont"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>MaybeJoinCont</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1746"></a>  <span class='hs-comment'>-- Nothing =&gt; Not a join point</span>
<a name="line-1747"></a>  <span class='hs-comment'>-- Just k  =&gt; This is a join binding with continuation k</span>
<a name="line-1748"></a>  <span class='hs-comment'>-- See Note [Rules and unfolding for join points]</span>
<a name="line-1749"></a>
<a name="line-1750"></a><a name="simplNonRecJoinPoint"></a><span class='hs-definition'>simplNonRecJoinPoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>
<a name="line-1751"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1752"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1753"></a><span class='hs-definition'>simplNonRecJoinPoint</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1754"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-1755"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>preInlineUnconditionally</span> <span class='hs-varid'>env</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>env</span>
<a name="line-1756"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>PreInlineUnconditionally</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1757"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1758"></a>
<a name="line-1759"></a>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1760"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapJoinCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1761"></a>     <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- We push join_cont into the join RHS and the body;</span>
<a name="line-1762"></a>          <span class='hs-comment'>-- and wrap wrap_cont around the whole thing</span>
<a name="line-1763"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mult</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>cont</span>
<a name="line-1764"></a>              <span class='hs-varid'>res_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-1765"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr1</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecJoinBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>res_ty</span>
<a name="line-1766"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>env2</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr2</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addBndrRules</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr1</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-1767"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env3</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplJoinBind</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>cont</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bndr2</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>env</span>
<a name="line-1768"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env3</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1769"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1770"></a>
<a name="line-1771"></a>
<a name="line-1772"></a><a name="simplRecJoinPoint"></a><span class='hs-comment'>------------------</span>
<a name="line-1773"></a><span class='hs-definition'>simplRecJoinPoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>InId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1774"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1775"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1776"></a><span class='hs-definition'>simplRecJoinPoint</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1777"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapJoinCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1778"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>bndrs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs</span>
<a name="line-1779"></a>             <span class='hs-varid'>mult</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>cont</span>
<a name="line-1780"></a>             <span class='hs-varid'>res_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-1781"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplRecJoinBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>res_ty</span>
<a name="line-1782"></a>               <span class='hs-comment'>-- NB: bndrs' don't have unfoldings or rules</span>
<a name="line-1783"></a>               <span class='hs-comment'>-- We add them as we go down</span>
<a name="line-1784"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplRecBind</span> <span class='hs-varid'>env1</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span>
<a name="line-1785"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-1786"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1787"></a>
<a name="line-1788"></a><a name="wrapJoinCont"></a><span class='hs-comment'>--------------------</span>
<a name="line-1789"></a><span class='hs-definition'>wrapJoinCont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1790"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1791"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1792"></a><span class='hs-comment'>-- Deal with making the continuation duplicable if necessary,</span>
<a name="line-1793"></a><span class='hs-comment'>-- and with the no-case-of-case situation.</span>
<a name="line-1794"></a><span class='hs-definition'>wrapJoinCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span> <span class='hs-varid'>thing_inside</span>
<a name="line-1795"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>contIsStop</span> <span class='hs-varid'>cont</span>        <span class='hs-comment'>-- Common case; no need for fancy footwork</span>
<a name="line-1796"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span>
<a name="line-1797"></a>
<a name="line-1798"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_case_case</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1799"></a>    <span class='hs-comment'>-- See Note [Join points with -fno-case-of-case]</span>
<a name="line-1800"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>thing_inside</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkBoringStop</span> <span class='hs-layout'>(</span><span class='hs-varid'>contHoleType</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1801"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapJoinFloatsX</span> <span class='hs-varid'>floats1</span> <span class='hs-varid'>expr1</span>
<a name="line-1802"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats3</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr3</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rebuild</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr2</span> <span class='hs-varid'>cont</span>
<a name="line-1803"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats3</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1804"></a>
<a name="line-1805"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1806"></a>    <span class='hs-comment'>-- Normal case; see Note [Join points and case-of-case]</span>
<a name="line-1807"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span>
<a name="line-1808"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>result</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>thing_inside</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>floats1</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont'</span>
<a name="line-1809"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>result</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1810"></a>
<a name="line-1811"></a>
<a name="line-1812"></a><a name="trimJoinCont"></a><span class='hs-comment'>--------------------</span>
<a name="line-1813"></a><span class='hs-definition'>trimJoinCont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-1814"></a><span class='hs-comment'>-- Drop outer context from join point invocation (jump)</span>
<a name="line-1815"></a><span class='hs-comment'>-- See Note [Join points and case-of-case]</span>
<a name="line-1816"></a>
<a name="line-1817"></a><span class='hs-definition'>trimJoinCont</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Nothing</span> <span class='hs-varid'>cont</span>
<a name="line-1818"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-comment'>-- Not a jump</span>
<a name="line-1819"></a><span class='hs-definition'>trimJoinCont</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>arity</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1820"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trim</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>cont</span>
<a name="line-1821"></a>  <span class='hs-keyword'>where</span>
<a name="line-1822"></a>    <span class='hs-varid'>trim</span> <span class='hs-num'>0</span> <span class='hs-varid'>cont</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1823"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span>
<a name="line-1824"></a>    <span class='hs-varid'>trim</span> <span class='hs-num'>0</span> <span class='hs-varid'>cont</span>
<a name="line-1825"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkBoringStop</span> <span class='hs-layout'>(</span><span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-1826"></a>    <span class='hs-varid'>trim</span> <span class='hs-varid'>n</span> <span class='hs-varid'>cont</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1827"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trim</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span>
<a name="line-1828"></a>    <span class='hs-varid'>trim</span> <span class='hs-varid'>n</span> <span class='hs-varid'>cont</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1829"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trim</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span> <span class='hs-comment'>-- join arity counts types!</span>
<a name="line-1830"></a>    <span class='hs-varid'>trim</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cont</span>
<a name="line-1831"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"completeCall"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>var</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span>
<a name="line-1832"></a>
<a name="line-1833"></a>
<a name="line-1834"></a><span class='hs-comment'>{- Note [Join points and case-of-case]
<a name="line-1835"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1836"></a>When we perform the case-of-case transform (or otherwise push continuations
<a name="line-1837"></a>inward), we want to treat join points specially. Since they're always
<a name="line-1838"></a>tail-called and we want to maintain this invariant, we can do this (for any
<a name="line-1839"></a>evaluation context E):
<a name="line-1840"></a>
<a name="line-1841"></a>  E[join j = e
<a name="line-1842"></a>    in case ... of
<a name="line-1843"></a>         A -&gt; jump j 1
<a name="line-1844"></a>         B -&gt; jump j 2
<a name="line-1845"></a>         C -&gt; f 3]
<a name="line-1846"></a>
<a name="line-1847"></a>    --&gt;
<a name="line-1848"></a>
<a name="line-1849"></a>  join j = E[e]
<a name="line-1850"></a>  in case ... of
<a name="line-1851"></a>       A -&gt; jump j 1
<a name="line-1852"></a>       B -&gt; jump j 2
<a name="line-1853"></a>       C -&gt; E[f 3]
<a name="line-1854"></a>
<a name="line-1855"></a>As is evident from the example, there are two components to this behavior:
<a name="line-1856"></a>
<a name="line-1857"></a>  1. When entering the RHS of a join point, copy the context inside.
<a name="line-1858"></a>  2. When a join point is invoked, discard the outer context.
<a name="line-1859"></a>
<a name="line-1860"></a>We need to be very careful here to remain consistent---neither part is
<a name="line-1861"></a>optional!
<a name="line-1862"></a>
<a name="line-1863"></a>We need do make the continuation E duplicable (since we are duplicating it)
<a name="line-1864"></a>with mkDupableCont.
<a name="line-1865"></a>
<a name="line-1866"></a>
<a name="line-1867"></a>Note [Join points with -fno-case-of-case]
<a name="line-1868"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1869"></a>Supose case-of-case is switched off, and we are simplifying
<a name="line-1870"></a>
<a name="line-1871"></a>    case (join j x = &lt;j-rhs&gt; in
<a name="line-1872"></a>          case y of
<a name="line-1873"></a>             A -&gt; j 1
<a name="line-1874"></a>             B -&gt; j 2
<a name="line-1875"></a>             C -&gt; e) of &lt;outer-alts&gt;
<a name="line-1876"></a>
<a name="line-1877"></a>Usually, we'd push the outer continuation (case . of &lt;outer-alts&gt;) into
<a name="line-1878"></a>both the RHS and the body of the join point j.  But since we aren't doing
<a name="line-1879"></a>case-of-case we may then end up with this totally bogus result
<a name="line-1880"></a>
<a name="line-1881"></a>    join x = case &lt;j-rhs&gt; of &lt;outer-alts&gt; in
<a name="line-1882"></a>    case (case y of
<a name="line-1883"></a>             A -&gt; j 1
<a name="line-1884"></a>             B -&gt; j 2
<a name="line-1885"></a>             C -&gt; e) of &lt;outer-alts&gt;
<a name="line-1886"></a>
<a name="line-1887"></a>This would be OK in the language of the paper, but not in GHC: j is no longer
<a name="line-1888"></a>a join point.  We can only do the "push continuation into the RHS of the
<a name="line-1889"></a>join point j" if we also push the continuation right down to the /jumps/ to
<a name="line-1890"></a>j, so that it can evaporate there.  If we are doing case-of-case, we'll get to
<a name="line-1891"></a>
<a name="line-1892"></a>    join x = case &lt;j-rhs&gt; of &lt;outer-alts&gt; in
<a name="line-1893"></a>    case y of
<a name="line-1894"></a>      A -&gt; j 1
<a name="line-1895"></a>      B -&gt; j 2
<a name="line-1896"></a>      C -&gt; case e of &lt;outer-alts&gt;
<a name="line-1897"></a>
<a name="line-1898"></a>which is great.
<a name="line-1899"></a>
<a name="line-1900"></a>Bottom line: if case-of-case is off, we must stop pushing the continuation
<a name="line-1901"></a>inwards altogether at any join point.  Instead simplify the (join ... in ...)
<a name="line-1902"></a>with a Stop continuation, and wrap the original continuation around the
<a name="line-1903"></a>outside.  Surprisingly tricky!
<a name="line-1904"></a>
<a name="line-1905"></a>
<a name="line-1906"></a>************************************************************************
<a name="line-1907"></a>*                                                                      *
<a name="line-1908"></a>                     Variables
<a name="line-1909"></a>*                                                                      *
<a name="line-1910"></a>************************************************************************
<a name="line-1911"></a>-}</span>
<a name="line-1912"></a>
<a name="line-1913"></a><a name="simplVar"></a><span class='hs-definition'>simplVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1914"></a><span class='hs-comment'>-- Look up an InVar in the environment</span>
<a name="line-1915"></a><span class='hs-definition'>simplVar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span>
<a name="line-1916"></a>  <span class='hs-comment'>-- Why $! ? See Note [Bangs in the Simplifier]</span>
<a name="line-1917"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$!</span> <span class='hs-conid'>Type</span> <span class='hs-varop'>$!</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTyVar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-1918"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$!</span> <span class='hs-conid'>Coercion</span> <span class='hs-varop'>$!</span> <span class='hs-layout'>(</span><span class='hs-varid'>substCoVar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-1919"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1920"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>substId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-keyword'>of</span>
<a name="line-1921"></a>        <span class='hs-conid'>ContEx</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSubstEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span>
<a name="line-1922"></a>                                <span class='hs-keyword'>in</span> <span class='hs-varid'>simplExpr</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span>
<a name="line-1923"></a>        <span class='hs-conid'>DoneId</span> <span class='hs-varid'>var1</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>var1</span><span class='hs-layout'>)</span>
<a name="line-1924"></a>        <span class='hs-conid'>DoneEx</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>e</span>
<a name="line-1925"></a>
<a name="line-1926"></a><a name="simplIdF"></a><span class='hs-definition'>simplIdF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1927"></a><span class='hs-definition'>simplIdF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>cont</span>
<a name="line-1928"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>substId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-keyword'>of</span>
<a name="line-1929"></a>      <span class='hs-conid'>ContEx</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1930"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSubstEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cvs</span> <span class='hs-varid'>ids</span>
<a name="line-1931"></a>          <span class='hs-keyword'>in</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span> <span class='hs-varid'>cont</span>
<a name="line-1932"></a>          <span class='hs-comment'>-- Don't trim; haven't already simplified e,</span>
<a name="line-1933"></a>          <span class='hs-comment'>-- so the cont is not embodied in e</span>
<a name="line-1934"></a>
<a name="line-1935"></a>      <span class='hs-conid'>DoneId</span> <span class='hs-varid'>var1</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1936"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>cont'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trimJoinCont</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>var1</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-1937"></a>          <span class='hs-keyword'>in</span> <span class='hs-varid'>completeCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var1</span> <span class='hs-varid'>cont'</span>
<a name="line-1938"></a>
<a name="line-1939"></a>      <span class='hs-conid'>DoneEx</span> <span class='hs-varid'>e</span> <span class='hs-varid'>mb_join</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1940"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>env</span>
<a name="line-1941"></a>              <span class='hs-varid'>cont'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trimJoinCont</span> <span class='hs-varid'>var</span> <span class='hs-varid'>mb_join</span> <span class='hs-varid'>cont</span>
<a name="line-1942"></a>          <span class='hs-keyword'>in</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span> <span class='hs-varid'>cont'</span>
<a name="line-1943"></a>              <span class='hs-comment'>-- Note [zapSubstEnv]</span>
<a name="line-1944"></a>              <span class='hs-comment'>-- The template is already simplified, so don't re-substitute.</span>
<a name="line-1945"></a>              <span class='hs-comment'>-- This is VITAL.  Consider</span>
<a name="line-1946"></a>              <span class='hs-comment'>--      let x = e in</span>
<a name="line-1947"></a>              <span class='hs-comment'>--      let y = \z -&gt; ...x... in</span>
<a name="line-1948"></a>              <span class='hs-comment'>--      \ x -&gt; ...y...</span>
<a name="line-1949"></a>              <span class='hs-comment'>-- We'll clone the inner \x, adding x-&gt;x' in the id_subst</span>
<a name="line-1950"></a>              <span class='hs-comment'>-- Then when we inline y, we must *not* replace x by x' in</span>
<a name="line-1951"></a>              <span class='hs-comment'>-- the inlined copy!!</span>
<a name="line-1952"></a>
<a name="line-1953"></a><span class='hs-comment'>---------------------------------------------------------</span>
<a name="line-1954"></a><span class='hs-comment'>--      Dealing with a call site</span>
<a name="line-1955"></a>
<a name="line-1956"></a><a name="completeCall"></a><span class='hs-definition'>completeCall</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-1957"></a><span class='hs-definition'>completeCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>cont</span>
<a name="line-1958"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>callSiteInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>case_depth</span> <span class='hs-varid'>var</span> <span class='hs-varid'>active_unf</span>
<a name="line-1959"></a>                                <span class='hs-varid'>lone_variable</span> <span class='hs-varid'>arg_infos</span> <span class='hs-varid'>interesting_cont</span>
<a name="line-1960"></a>  <span class='hs-comment'>-- Inline the variable's RHS</span>
<a name="line-1961"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkedTick</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnfoldingDone</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-1962"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dump_inline</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-1963"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>env</span>
<a name="line-1964"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1965"></a>
<a name="line-1966"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1967"></a>  <span class='hs-comment'>-- Don't inline; instead rebuild the call</span>
<a name="line-1968"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rule_base</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getSimplRules</span>
<a name="line-1969"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getRules</span> <span class='hs-varid'>rule_base</span> <span class='hs-varid'>var</span>
<a name="line-1970"></a>             <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkArgInfo</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>rules</span>
<a name="line-1971"></a>                              <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>call_cont</span>
<a name="line-1972"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>info</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-1973"></a>
<a name="line-1974"></a>  <span class='hs-keyword'>where</span>
<a name="line-1975"></a>    <span class='hs-varid'>dflags</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env</span>
<a name="line-1976"></a>    <span class='hs-varid'>case_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seCaseDepth</span> <span class='hs-varid'>env</span>
<a name="line-1977"></a>    <span class='hs-varid'>logger</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seLogger</span> <span class='hs-varid'>env</span>
<a name="line-1978"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>lone_variable</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_infos</span><span class='hs-layout'>,</span> <span class='hs-varid'>call_cont</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contArgs</span> <span class='hs-varid'>cont</span>
<a name="line-1979"></a>    <span class='hs-varid'>n_val_args</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>arg_infos</span>
<a name="line-1980"></a>    <span class='hs-varid'>interesting_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interestingCallContext</span> <span class='hs-varid'>env</span> <span class='hs-varid'>call_cont</span>
<a name="line-1981"></a>    <span class='hs-varid'>active_unf</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>activeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>var</span>
<a name="line-1982"></a>
<a name="line-1983"></a>    <span class='hs-varid'>log_inlining</span> <span class='hs-varid'>doc</span>
<a name="line-1984"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-varid'>putDumpMsg</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span>
<a name="line-1985"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>mkDumpStyle</span> <span class='hs-varid'>alwaysQualify</span><span class='hs-layout'>)</span>
<a name="line-1986"></a>           <span class='hs-conid'>Opt_D_dump_inlinings</span>
<a name="line-1987"></a>           <span class='hs-str'>""</span> <span class='hs-conid'>FormatText</span> <span class='hs-varid'>doc</span>
<a name="line-1988"></a>
<a name="line-1989"></a>    <span class='hs-varid'>dump_inline</span> <span class='hs-varid'>unfolding</span> <span class='hs-varid'>cont</span>
<a name="line-1990"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_dump_inlinings</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1991"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_verbose_core2core</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1992"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isExternalName</span> <span class='hs-layout'>(</span><span class='hs-varid'>idName</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1993"></a>            <span class='hs-varid'>log_inlining</span> <span class='hs-varop'>$</span>
<a name="line-1994"></a>                <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Inlining done:"</span><span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>4</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1995"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1996"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>log_inlining</span> <span class='hs-varop'>$</span>
<a name="line-1997"></a>           <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Inlining done: "</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>var</span><span class='hs-layout'>,</span>
<a name="line-1998"></a>                <span class='hs-varid'>nest</span> <span class='hs-num'>4</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Inlined fn: "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>unfolding</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-1999"></a>                              <span class='hs-varid'>text</span> <span class='hs-str'>"Cont:  "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2000"></a>
<a name="line-2001"></a><a name="rebuildCall"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-2002"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgInfo</span>
<a name="line-2003"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-2004"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-2005"></a><span class='hs-comment'>-- We decided not to inline, so</span>
<a name="line-2006"></a><span class='hs-comment'>--    - simplify the arguments</span>
<a name="line-2007"></a><span class='hs-comment'>--    - try rewrite rules</span>
<a name="line-2008"></a><span class='hs-comment'>--    - and rebuild</span>
<a name="line-2009"></a>
<a name="line-2010"></a><span class='hs-comment'>---------- Bottoming applications --------------</span>
<a name="line-2011"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rev_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2012"></a>  <span class='hs-comment'>-- When we run out of strictness args, it means</span>
<a name="line-2013"></a>  <span class='hs-comment'>-- that the call is definitely bottom; see GHC.Core.Opt.Simplify.Utils.mkArgInfo</span>
<a name="line-2014"></a>  <span class='hs-comment'>-- Then we want to discard the entire strict continuation.  E.g.</span>
<a name="line-2015"></a>  <span class='hs-comment'>--    * case (error "hello") of { ... }</span>
<a name="line-2016"></a>  <span class='hs-comment'>--    * (error "Hello") arg</span>
<a name="line-2017"></a>  <span class='hs-comment'>--    * f (error "Hello") where f is strict</span>
<a name="line-2018"></a>  <span class='hs-comment'>--    etc</span>
<a name="line-2019"></a>  <span class='hs-comment'>-- Then, especially in the first of these cases, we'd like to discard</span>
<a name="line-2020"></a>  <span class='hs-comment'>-- the continuation, leaving just the bottoming expression.  But the</span>
<a name="line-2021"></a>  <span class='hs-comment'>-- type might not be right, so we may have to add a coerce.</span>
<a name="line-2022"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>contIsTrivial</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- Only do this if there is a non-trivial</span>
<a name="line-2023"></a>                                 <span class='hs-comment'>-- continuation to discard, else we do it</span>
<a name="line-2024"></a>                                 <span class='hs-comment'>-- again and again!</span>
<a name="line-2025"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seqType</span> <span class='hs-varid'>cont_ty</span> <span class='hs-varop'>`seq`</span>        <span class='hs-comment'>-- See Note [Avoiding space leaks in OutType]</span>
<a name="line-2026"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>castBottomExpr</span> <span class='hs-varid'>res</span> <span class='hs-varid'>cont_ty</span><span class='hs-layout'>)</span>
<a name="line-2027"></a>  <span class='hs-keyword'>where</span>
<a name="line-2028"></a>    <span class='hs-varid'>res</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>argInfoExpr</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>rev_args</span>
<a name="line-2029"></a>    <span class='hs-varid'>cont_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-2030"></a>
<a name="line-2031"></a><span class='hs-comment'>---------- Try rewrite RULES --------------</span>
<a name="line-2032"></a><span class='hs-comment'>-- See Note [Trying rewrite rules]</span>
<a name="line-2033"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rev_args</span>
<a name="line-2034"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>nr_wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>rules</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2035"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>nr_wanted</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-varop'>||</span> <span class='hs-varid'>no_more_args</span>
<a name="line-2036"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>info'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-2037"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- We've accumulated a simplified call in &lt;fun,rev_args&gt;</span>
<a name="line-2038"></a>    <span class='hs-comment'>-- so try rewrite rules; see Note [RULEs apply to simplified arguments]</span>
<a name="line-2039"></a>    <span class='hs-comment'>-- See also Note [Rules for recursive functions]</span>
<a name="line-2040"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_args</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2041"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyword'>of</span>
<a name="line-2042"></a>             <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont'</span>
<a name="line-2043"></a>             <span class='hs-conid'>Nothing</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>info'</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-2044"></a>  <span class='hs-keyword'>where</span>
<a name="line-2045"></a>    <span class='hs-varid'>no_more_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cont</span> <span class='hs-keyword'>of</span>
<a name="line-2046"></a>                      <span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2047"></a>                      <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2048"></a>                      <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2049"></a>
<a name="line-2050"></a>
<a name="line-2051"></a><span class='hs-comment'>---------- Simplify applications and casts --------------</span>
<a name="line-2052"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>info</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>co</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-2053"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>addCastTo</span> <span class='hs-varid'>info</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2054"></a>
<a name="line-2055"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>info</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2056"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>addTyArgTo</span> <span class='hs-varid'>info</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>hole_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2057"></a>
<a name="line-2058"></a><span class='hs-comment'>---------- The runRW# rule. Do this after absorbing all arguments ------</span>
<a name="line-2059"></a><span class='hs-comment'>-- See Note [Simplification of runRW#] in GHC.CoreToSTG.Prep.</span>
<a name="line-2060"></a><span class='hs-comment'>--</span>
<a name="line-2061"></a><span class='hs-comment'>-- runRW# :: forall (r :: RuntimeRep) (o :: TYPE r). (State# RealWorld -&gt; o) -&gt; o</span>
<a name="line-2062"></a><span class='hs-comment'>-- K[ runRW# rr ty body ]   --&gt;   runRW rr' ty' (\s. K[ body s ])</span>
<a name="line-2063"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rev_args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2064"></a>            <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_se</span>
<a name="line-2065"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2066"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fun_id</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>runRWKey</span>
<a name="line-2067"></a>  <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rev_args</span>
<a name="line-2068"></a>  <span class='hs-comment'>-- Do this even if (contIsStop cont)</span>
<a name="line-2069"></a>  <span class='hs-comment'>-- See Note [No eta-expansion in runRW#]</span>
<a name="line-2070"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span>
<a name="line-2071"></a>             <span class='hs-varid'>ty'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-2072"></a>
<a name="line-2073"></a>       <span class='hs-comment'>-- If the argument is a literal lambda already, take a short cut</span>
<a name="line-2074"></a>       <span class='hs-comment'>-- This isn't just efficiency; if we don't do this we get a beta-redex</span>
<a name="line-2075"></a>       <span class='hs-comment'>-- every time, so the simplifier keeps doing more iterations.</span>
<a name="line-2076"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>arg'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg</span> <span class='hs-keyword'>of</span>
<a name="line-2077"></a>           <span class='hs-conid'>Lam</span> <span class='hs-varid'>s</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>s'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>arg_env</span> <span class='hs-varid'>s</span>
<a name="line-2078"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>body'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-2079"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>s'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2080"></a>                            <span class='hs-comment'>-- Important: do not try to eta-expand this lambda</span>
<a name="line-2081"></a>                            <span class='hs-comment'>-- See Note [No eta-expansion in runRW#]</span>
<a name="line-2082"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>s'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newId</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"s"</span><span class='hs-layout'>)</span> <span class='hs-conid'>Many</span> <span class='hs-varid'>realWorldStatePrimTy</span>
<a name="line-2083"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>m</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitFunTy</span> <span class='hs-varid'>fun_ty</span>
<a name="line-2084"></a>                         <span class='hs-varid'>env'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_env</span> <span class='hs-varop'>`addNewInScopeIds`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s'</span><span class='hs-keyglyph'>]</span>
<a name="line-2085"></a>                         <span class='hs-varid'>cont'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Simplified</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>s'</span>
<a name="line-2086"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span>
<a name="line-2087"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVisFunTy</span> <span class='hs-varid'>m</span> <span class='hs-varid'>realWorldStatePrimTy</span> <span class='hs-varid'>ty'</span> <span class='hs-layout'>}</span>
<a name="line-2088"></a>                                <span class='hs-comment'>-- cont' applies to s', then K</span>
<a name="line-2089"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>body'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>cont'</span>
<a name="line-2090"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>s'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2091"></a>
<a name="line-2092"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rr'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getRuntimeRep</span> <span class='hs-varid'>ty'</span>
<a name="line-2093"></a>             <span class='hs-varid'>call'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkTyArg</span> <span class='hs-varid'>rr'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyArg</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-keyglyph'>]</span>
<a name="line-2094"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>call'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2095"></a>
<a name="line-2096"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun_info</span>
<a name="line-2097"></a>            <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_se</span>
<a name="line-2098"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup_flag</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span>
<a name="line-2099"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2100"></a>  <span class='hs-comment'>-- Argument is already simplified</span>
<a name="line-2101"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSimplified</span> <span class='hs-varid'>dup_flag</span>     <span class='hs-comment'>-- See Note [Avoid redundant simplification]</span>
<a name="line-2102"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>addValArgTo</span> <span class='hs-varid'>fun_info</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2103"></a>
<a name="line-2104"></a>  <span class='hs-comment'>-- Strict arguments</span>
<a name="line-2105"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStrictArgInfo</span> <span class='hs-varid'>fun_info</span>
<a name="line-2106"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>sm_case_case</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-2107"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "Strict Arg" (ppr arg $$ ppr (seIdSubst env) $$ ppr (seInScope env)) $</span>
<a name="line-2108"></a>    <span class='hs-varid'>simplExprF</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-2109"></a>               <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_info</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span>
<a name="line-2110"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Simplified</span>
<a name="line-2111"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2112"></a>                <span class='hs-comment'>-- Note [Shadowing]</span>
<a name="line-2113"></a>
<a name="line-2114"></a>  <span class='hs-comment'>-- Lazy arguments</span>
<a name="line-2115"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2116"></a>        <span class='hs-comment'>-- DO NOT float anything outside, hence simplExprC</span>
<a name="line-2117"></a>        <span class='hs-comment'>-- There is no benefit (unlike in a let-binding), and we'd</span>
<a name="line-2118"></a>        <span class='hs-comment'>-- have to be very careful about bogus strictness through</span>
<a name="line-2119"></a>        <span class='hs-comment'>-- floating a demanded let.</span>
<a name="line-2120"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>arg'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-2121"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>mkLazyArgStop</span> <span class='hs-varid'>arg_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>lazyArgContext</span> <span class='hs-varid'>fun_info</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2122"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>addValArgTo</span> <span class='hs-varid'>fun_info</span>  <span class='hs-varid'>arg'</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-2123"></a>  <span class='hs-keyword'>where</span>
<a name="line-2124"></a>    <span class='hs-varid'>arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funArgTy</span> <span class='hs-varid'>fun_ty</span>
<a name="line-2125"></a>
<a name="line-2126"></a>
<a name="line-2127"></a><span class='hs-comment'>---------- No further useful info, revert to generic rebuild ------------</span>
<a name="line-2128"></a><span class='hs-definition'>rebuildCall</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rev_args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2129"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>argInfoExpr</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>rev_args</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-2130"></a>
<a name="line-2131"></a><span class='hs-comment'>{- Note [Trying rewrite rules]
<a name="line-2132"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2133"></a>Consider an application (f e1 e2 e3) where the e1,e2,e3 are not yet
<a name="line-2134"></a>simplified.  We want to simplify enough arguments to allow the rules
<a name="line-2135"></a>to apply, but it's more efficient to avoid simplifying e2,e3 if e1 alone
<a name="line-2136"></a>is sufficient.  Example: class ops
<a name="line-2137"></a>   (+) dNumInt e2 e3
<a name="line-2138"></a>If we rewrite ((+) dNumInt) to plusInt, we can take advantage of the
<a name="line-2139"></a>latter's strictness when simplifying e2, e3.  Moreover, suppose we have
<a name="line-2140"></a>  RULE  f Int = \x. x True
<a name="line-2141"></a>
<a name="line-2142"></a>Then given (f Int e1) we rewrite to
<a name="line-2143"></a>   (\x. x True) e1
<a name="line-2144"></a>without simplifying e1.  Now we can inline x into its unique call site,
<a name="line-2145"></a>and absorb the True into it all in the same pass.  If we simplified
<a name="line-2146"></a>e1 first, we couldn't do that; see Note [Avoiding exponential behaviour].
<a name="line-2147"></a>
<a name="line-2148"></a>So we try to apply rules if either
<a name="line-2149"></a>  (a) no_more_args: we've run out of argument that the rules can "see"
<a name="line-2150"></a>  (b) nr_wanted: none of the rules wants any more arguments
<a name="line-2151"></a>
<a name="line-2152"></a>
<a name="line-2153"></a>Note [RULES apply to simplified arguments]
<a name="line-2154"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2155"></a>It's very desirable to try RULES once the arguments have been simplified, because
<a name="line-2156"></a>doing so ensures that rule cascades work in one pass.  Consider
<a name="line-2157"></a>   {-# RULES g (h x) = k x
<a name="line-2158"></a>             f (k x) = x #-}
<a name="line-2159"></a>   ...f (g (h x))...
<a name="line-2160"></a>Then we want to rewrite (g (h x)) to (k x) and only then try f's rules. If
<a name="line-2161"></a>we match f's rules against the un-simplified RHS, it won't match.  This
<a name="line-2162"></a>makes a particularly big difference when superclass selectors are involved:
<a name="line-2163"></a>        op ($p1 ($p2 (df d)))
<a name="line-2164"></a>We want all this to unravel in one sweep.
<a name="line-2165"></a>
<a name="line-2166"></a>Note [Avoid redundant simplification]
<a name="line-2167"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2168"></a>Because RULES apply to simplified arguments, there's a danger of repeatedly
<a name="line-2169"></a>simplifying already-simplified arguments.  An important example is that of
<a name="line-2170"></a>        (&gt;&gt;=) d e1 e2
<a name="line-2171"></a>Here e1, e2 are simplified before the rule is applied, but don't really
<a name="line-2172"></a>participate in the rule firing. So we mark them as Simplified to avoid
<a name="line-2173"></a>re-simplifying them.
<a name="line-2174"></a>
<a name="line-2175"></a>Note [Shadowing]
<a name="line-2176"></a>~~~~~~~~~~~~~~~~
<a name="line-2177"></a>This part of the simplifier may break the no-shadowing invariant
<a name="line-2178"></a>Consider
<a name="line-2179"></a>        f (...(\a -&gt; e)...) (case y of (a,b) -&gt; e')
<a name="line-2180"></a>where f is strict in its second arg
<a name="line-2181"></a>If we simplify the innermost one first we get (...(\a -&gt; e)...)
<a name="line-2182"></a>Simplifying the second arg makes us float the case out, so we end up with
<a name="line-2183"></a>        case y of (a,b) -&gt; f (...(\a -&gt; e)...) e'
<a name="line-2184"></a>So the output does not have the no-shadowing invariant.  However, there is
<a name="line-2185"></a>no danger of getting name-capture, because when the first arg was simplified
<a name="line-2186"></a>we used an in-scope set that at least mentioned all the variables free in its
<a name="line-2187"></a>static environment, and that is enough.
<a name="line-2188"></a>
<a name="line-2189"></a>We can't just do innermost first, or we'd end up with a dual problem:
<a name="line-2190"></a>        case x of (a,b) -&gt; f e (...(\a -&gt; e')...)
<a name="line-2191"></a>
<a name="line-2192"></a>I spent hours trying to recover the no-shadowing invariant, but I just could
<a name="line-2193"></a>not think of an elegant way to do it.  The simplifier is already knee-deep in
<a name="line-2194"></a>continuations.  We have to keep the right in-scope set around; AND we have
<a name="line-2195"></a>to get the effect that finding (error "foo") in a strict arg position will
<a name="line-2196"></a>discard the entire application and replace it with (error "foo").  Getting
<a name="line-2197"></a>all this at once is TOO HARD!
<a name="line-2198"></a>
<a name="line-2199"></a>Note [No eta-expansion in runRW#]
<a name="line-2200"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2201"></a>When we see `runRW# (\s. blah)` we must not attempt to eta-expand that
<a name="line-2202"></a>lambda.  Why not?  Because
<a name="line-2203"></a>* `blah` can mention join points bound outside the runRW#
<a name="line-2204"></a>* eta-expansion uses arityType, and
<a name="line-2205"></a>* `arityType` cannot cope with free join Ids:
<a name="line-2206"></a>
<a name="line-2207"></a>So the simplifier spots the literal lambda, and simplifies inside it.
<a name="line-2208"></a>It's a very special lambda, because it is the one the OccAnal spots and
<a name="line-2209"></a>allows join points bound /outside/ to be called /inside/.
<a name="line-2210"></a>
<a name="line-2211"></a>See Note [No free join points in arityType] in GHC.Core.Opt.Arity
<a name="line-2212"></a>
<a name="line-2213"></a>************************************************************************
<a name="line-2214"></a>*                                                                      *
<a name="line-2215"></a>                Rewrite rules
<a name="line-2216"></a>*                                                                      *
<a name="line-2217"></a>************************************************************************
<a name="line-2218"></a>-}</span>
<a name="line-2219"></a>
<a name="line-2220"></a><a name="tryRules"></a><span class='hs-definition'>tryRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span>
<a name="line-2221"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSpec</span><span class='hs-keyglyph'>]</span>
<a name="line-2222"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-2223"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2224"></a>
<a name="line-2225"></a><span class='hs-definition'>tryRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>args</span> <span class='hs-varid'>call_cont</span>
<a name="line-2226"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>rules</span>
<a name="line-2227"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-2228"></a>
<a name="line-2229"></a><span class='hs-comment'>{- Disabled until we fix #8326
<a name="line-2230"></a>  | fn `hasKey` tagToEnumKey   -- See Note [Optimising tagToEnum#]
<a name="line-2231"></a>  , [_type_arg, val_arg] &lt;- args
<a name="line-2232"></a>  , Select dup bndr ((_,[],rhs1) : rest_alts) se cont &lt;- call_cont
<a name="line-2233"></a>  , isDeadBinder bndr
<a name="line-2234"></a>  = do { let enum_to_tag :: CoreAlt -&gt; CoreAlt
<a name="line-2235"></a>                -- Takes   K -&gt; e  into   tagK# -&gt; e
<a name="line-2236"></a>                -- where tagK# is the tag of constructor K
<a name="line-2237"></a>             enum_to_tag (DataAlt con, [], rhs)
<a name="line-2238"></a>               = ASSERT( isEnumerationTyCon (dataConTyCon con) )
<a name="line-2239"></a>                (LitAlt tag, [], rhs)
<a name="line-2240"></a>              where
<a name="line-2241"></a>                tag = mkLitInt dflags (toInteger (dataConTag con - fIRST_TAG))
<a name="line-2242"></a>             enum_to_tag alt = pprPanic "tryRules: tagToEnum" (ppr alt)
<a name="line-2243"></a>
<a name="line-2244"></a>             new_alts = (DEFAULT, [], rhs1) : map enum_to_tag rest_alts
<a name="line-2245"></a>             new_bndr = setIdType bndr intPrimTy
<a name="line-2246"></a>                 -- The binder is dead, but should have the right type
<a name="line-2247"></a>      ; return (Just (val_arg, Select dup new_bndr new_alts se cont)) }
<a name="line-2248"></a>-}</span>
<a name="line-2249"></a>
<a name="line-2250"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>rule</span><span class='hs-layout'>,</span> <span class='hs-varid'>rule_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupRule</span> <span class='hs-varid'>ropts</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUnfoldingInRuleMatch</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-2251"></a>                                        <span class='hs-layout'>(</span><span class='hs-varid'>activeRule</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>fn</span>
<a name="line-2252"></a>                                        <span class='hs-layout'>(</span><span class='hs-varid'>argInfoAppArgs</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>rules</span>
<a name="line-2253"></a>  <span class='hs-comment'>-- Fire a rule for the function</span>
<a name="line-2254"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkedTick</span> <span class='hs-layout'>(</span><span class='hs-conid'>RuleFired</span> <span class='hs-layout'>(</span><span class='hs-varid'>ruleName</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2255"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cont'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushSimplifiedArgs</span> <span class='hs-varid'>zapped_env</span>
<a name="line-2256"></a>                                        <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>ruleArity</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-2257"></a>                                        <span class='hs-varid'>call_cont</span>
<a name="line-2258"></a>                     <span class='hs-comment'>-- (ruleArity rule) says how</span>
<a name="line-2259"></a>                     <span class='hs-comment'>-- many args the rule consumed</span>
<a name="line-2260"></a>
<a name="line-2261"></a>             <span class='hs-varid'>occ_anald_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occurAnalyseExpr</span> <span class='hs-varid'>rule_rhs</span>
<a name="line-2262"></a>                 <span class='hs-comment'>-- See Note [Occurrence-analyse after rule firing]</span>
<a name="line-2263"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dump</span> <span class='hs-varid'>rule</span> <span class='hs-varid'>rule_rhs</span>
<a name="line-2264"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapped_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_anald_rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2265"></a>            <span class='hs-comment'>-- The occ_anald_rhs and cont' are all Out things</span>
<a name="line-2266"></a>            <span class='hs-comment'>-- hence zapping the environment</span>
<a name="line-2267"></a>
<a name="line-2268"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- No rule fires</span>
<a name="line-2269"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nodump</span>  <span class='hs-comment'>-- This ensures that an empty file is written</span>
<a name="line-2270"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-2271"></a>
<a name="line-2272"></a>  <span class='hs-keyword'>where</span>
<a name="line-2273"></a>    <span class='hs-comment'>-- Force this to avoid retaining DynFlags and hence SimplEnv</span>
<a name="line-2274"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>ropts</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initRuleOpts</span> <span class='hs-varid'>dflags</span>
<a name="line-2275"></a>    <span class='hs-varid'>dflags</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env</span>
<a name="line-2276"></a>    <span class='hs-varid'>logger</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seLogger</span> <span class='hs-varid'>env</span>
<a name="line-2277"></a>    <span class='hs-varid'>zapped_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>env</span>  <span class='hs-comment'>-- See Note [zapSubstEnv]</span>
<a name="line-2278"></a>
<a name="line-2279"></a>    <span class='hs-varid'>printRuleModule</span> <span class='hs-varid'>rule</span>
<a name="line-2280"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"BUILTIN"</span><span class='hs-layout'>)</span>
<a name="line-2281"></a>                      <span class='hs-layout'>(</span><span class='hs-varid'>pprModuleName</span> <span class='hs-varop'>.</span> <span class='hs-varid'>moduleName</span><span class='hs-layout'>)</span>
<a name="line-2282"></a>                      <span class='hs-layout'>(</span><span class='hs-varid'>ruleModule</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2283"></a>
<a name="line-2284"></a>    <span class='hs-varid'>dump</span> <span class='hs-varid'>rule</span> <span class='hs-varid'>rule_rhs</span>
<a name="line-2285"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_dump_rule_rewrites</span> <span class='hs-varid'>dflags</span>
<a name="line-2286"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>log_rule</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_rule_rewrites</span> <span class='hs-str'>"Rule fired"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-2287"></a>          <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Rule:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ftext</span> <span class='hs-layout'>(</span><span class='hs-varid'>ruleName</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span>
<a name="line-2288"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Module:"</span> <span class='hs-varop'>&lt;+&gt;</span>  <span class='hs-varid'>printRuleModule</span> <span class='hs-varid'>rule</span>
<a name="line-2289"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Before:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2290"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"After: "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCoreExpr</span> <span class='hs-varid'>rule_rhs</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span>
<a name="line-2291"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>ppr</span> <span class='hs-varop'>$</span> <span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>ruleArity</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-2292"></a>          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Cont:  "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>call_cont</span> <span class='hs-keyglyph'>]</span>
<a name="line-2293"></a>
<a name="line-2294"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_dump_rule_firings</span> <span class='hs-varid'>dflags</span>
<a name="line-2295"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>log_rule</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_rule_firings</span> <span class='hs-str'>"Rule fired:"</span> <span class='hs-varop'>$</span>
<a name="line-2296"></a>          <span class='hs-varid'>ftext</span> <span class='hs-layout'>(</span><span class='hs-varid'>ruleName</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span>
<a name="line-2297"></a>            <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>printRuleModule</span> <span class='hs-varid'>rule</span>
<a name="line-2298"></a>
<a name="line-2299"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2300"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-2301"></a>
<a name="line-2302"></a>    <span class='hs-varid'>nodump</span>
<a name="line-2303"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_dump_rule_rewrites</span> <span class='hs-varid'>dflags</span>
<a name="line-2304"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span>
<a name="line-2305"></a>          <span class='hs-varid'>touchDumpFile</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_rule_rewrites</span>
<a name="line-2306"></a>
<a name="line-2307"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_dump_rule_firings</span> <span class='hs-varid'>dflags</span>
<a name="line-2308"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span>
<a name="line-2309"></a>          <span class='hs-varid'>touchDumpFile</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_rule_firings</span>
<a name="line-2310"></a>
<a name="line-2311"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2312"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-2313"></a>
<a name="line-2314"></a>    <span class='hs-varid'>log_rule</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>flag</span> <span class='hs-varid'>hdr</span> <span class='hs-varid'>details</span>
<a name="line-2315"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftIO</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-2316"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>sty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDumpStyle</span> <span class='hs-varid'>alwaysQualify</span>
<a name="line-2317"></a>          <span class='hs-varid'>putDumpMsg</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>sty</span> <span class='hs-varid'>flag</span> <span class='hs-str'>""</span> <span class='hs-conid'>FormatText</span> <span class='hs-varop'>$</span>
<a name="line-2318"></a>              <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-varid'>hdr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>4</span> <span class='hs-varid'>details</span><span class='hs-keyglyph'>]</span>
<a name="line-2319"></a>
<a name="line-2320"></a><a name="trySeqRules"></a><span class='hs-definition'>trySeqRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-2321"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>   <span class='hs-comment'>-- Scrutinee and RHS</span>
<a name="line-2322"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-2323"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2324"></a><span class='hs-comment'>-- See Note [User-defined RULES for seq]</span>
<a name="line-2325"></a><span class='hs-definition'>trySeqRules</span> <span class='hs-varid'>in_env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-2326"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rule_base</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getSimplRules</span>
<a name="line-2327"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tryRules</span> <span class='hs-varid'>in_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>getRules</span> <span class='hs-varid'>rule_base</span> <span class='hs-varid'>seqId</span><span class='hs-layout'>)</span> <span class='hs-varid'>seqId</span> <span class='hs-varid'>out_args</span> <span class='hs-varid'>rule_cont</span> <span class='hs-layout'>}</span>
<a name="line-2328"></a>  <span class='hs-keyword'>where</span>
<a name="line-2329"></a>    <span class='hs-varid'>no_cast_scrut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drop_casts</span> <span class='hs-varid'>scrut</span>
<a name="line-2330"></a>    <span class='hs-varid'>scrut_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>no_cast_scrut</span>
<a name="line-2331"></a>    <span class='hs-varid'>seq_id_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>seqId</span>                    <span class='hs-comment'>-- forall r a (b::TYPE r). a -&gt; b -&gt; b</span>
<a name="line-2332"></a>    <span class='hs-varid'>res1_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>piResultTy</span> <span class='hs-varid'>seq_id_ty</span> <span class='hs-varid'>rhs_rep</span>    <span class='hs-comment'>-- forall a (b::TYPE rhs_rep). a -&gt; b -&gt; b</span>
<a name="line-2333"></a>    <span class='hs-varid'>res2_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>piResultTy</span> <span class='hs-varid'>res1_ty</span>   <span class='hs-varid'>scrut_ty</span>   <span class='hs-comment'>-- forall (b::TYPE rhs_rep). scrut_ty -&gt; b -&gt; b</span>
<a name="line-2334"></a>    <span class='hs-varid'>res3_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>piResultTy</span> <span class='hs-varid'>res2_ty</span>   <span class='hs-varid'>rhs_ty</span>     <span class='hs-comment'>-- scrut_ty -&gt; rhs_ty -&gt; rhs_ty</span>
<a name="line-2335"></a>    <span class='hs-varid'>res4_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funResultTy</span> <span class='hs-varid'>res3_ty</span>             <span class='hs-comment'>-- rhs_ty -&gt; rhs_ty</span>
<a name="line-2336"></a>    <span class='hs-varid'>rhs_ty</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>in_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2337"></a>    <span class='hs-varid'>rhs_rep</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getRuntimeRep</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-2338"></a>    <span class='hs-varid'>out_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_rep</span>
<a name="line-2339"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seq_id_ty</span> <span class='hs-layout'>}</span>
<a name="line-2340"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut_ty</span>
<a name="line-2341"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res1_ty</span> <span class='hs-layout'>}</span>
<a name="line-2342"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>TyArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg_ty</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-2343"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res2_ty</span> <span class='hs-layout'>}</span>
<a name="line-2344"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>ValArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>as_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_cast_scrut</span>
<a name="line-2345"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>as_dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seqDmd</span>
<a name="line-2346"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>as_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res3_ty</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>]</span>
<a name="line-2347"></a>    <span class='hs-varid'>rule_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoDup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-2348"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span>
<a name="line-2349"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res4_ty</span> <span class='hs-layout'>}</span>
<a name="line-2350"></a>
<a name="line-2351"></a>    <span class='hs-comment'>-- Lazily evaluated, so we don't do most of this</span>
<a name="line-2352"></a>
<a name="line-2353"></a>    <span class='hs-varid'>drop_casts</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drop_casts</span> <span class='hs-varid'>e</span>
<a name="line-2354"></a>    <span class='hs-varid'>drop_casts</span> <span class='hs-varid'>e</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>e</span>
<a name="line-2355"></a>
<a name="line-2356"></a><span class='hs-comment'>{- Note [User-defined RULES for seq]
<a name="line-2357"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2358"></a>Given
<a name="line-2359"></a>   case (scrut |&gt; co) of _ -&gt; rhs
<a name="line-2360"></a>look for rules that match the expression
<a name="line-2361"></a>   seq @t1 @t2 scrut
<a name="line-2362"></a>where scrut :: t1
<a name="line-2363"></a>      rhs   :: t2
<a name="line-2364"></a>
<a name="line-2365"></a>If you find a match, rewrite it, and apply to 'rhs'.
<a name="line-2366"></a>
<a name="line-2367"></a>Notice that we can simply drop casts on the fly here, which
<a name="line-2368"></a>makes it more likely that a rule will match.
<a name="line-2369"></a>
<a name="line-2370"></a>See Note [User-defined RULES for seq] in GHC.Types.Id.Make.
<a name="line-2371"></a>
<a name="line-2372"></a>Note [Occurrence-analyse after rule firing]
<a name="line-2373"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2374"></a>After firing a rule, we occurrence-analyse the instantiated RHS before
<a name="line-2375"></a>simplifying it.  Usually this doesn't make much difference, but it can
<a name="line-2376"></a>be huge.  Here's an example (simplCore/should_compile/T7785)
<a name="line-2377"></a>
<a name="line-2378"></a>  map f (map f (map f xs)
<a name="line-2379"></a>
<a name="line-2380"></a>= -- Use build/fold form of map, twice
<a name="line-2381"></a>  map f (build (\cn. foldr (mapFB c f) n
<a name="line-2382"></a>                           (build (\cn. foldr (mapFB c f) n xs))))
<a name="line-2383"></a>
<a name="line-2384"></a>= -- Apply fold/build rule
<a name="line-2385"></a>  map f (build (\cn. (\cn. foldr (mapFB c f) n xs) (mapFB c f) n))
<a name="line-2386"></a>
<a name="line-2387"></a>= -- Beta-reduce
<a name="line-2388"></a>  -- Alas we have no occurrence-analysed, so we don't know
<a name="line-2389"></a>  -- that c is used exactly once
<a name="line-2390"></a>  map f (build (\cn. let c1 = mapFB c f in
<a name="line-2391"></a>                     foldr (mapFB c1 f) n xs))
<a name="line-2392"></a>
<a name="line-2393"></a>= -- Use mapFB rule:   mapFB (mapFB c f) g = mapFB c (f.g)
<a name="line-2394"></a>  -- We can do this because (mapFB c n) is a PAP and hence expandable
<a name="line-2395"></a>  map f (build (\cn. let c1 = mapFB c n in
<a name="line-2396"></a>                     foldr (mapFB c (f.f)) n x))
<a name="line-2397"></a>
<a name="line-2398"></a>This is not too bad.  But now do the same with the outer map, and
<a name="line-2399"></a>we get another use of mapFB, and t can interact with /both/ remaining
<a name="line-2400"></a>mapFB calls in the above expression.  This is stupid because actually
<a name="line-2401"></a>that 'c1' binding is dead.  The outer map introduces another c2. If
<a name="line-2402"></a>there is a deep stack of maps we get lots of dead bindings, and lots
<a name="line-2403"></a>of redundant work as we repeatedly simplify the result of firing rules.
<a name="line-2404"></a>
<a name="line-2405"></a>The easy thing to do is simply to occurrence analyse the result of
<a name="line-2406"></a>the rule firing.  Note that this occ-anals not only the RHS of the
<a name="line-2407"></a>rule, but also the function arguments, which by now are OutExprs.
<a name="line-2408"></a>E.g.
<a name="line-2409"></a>      RULE f (g x) = x+1
<a name="line-2410"></a>
<a name="line-2411"></a>Call   f (g BIG)  --&gt;   (\x. x+1) BIG
<a name="line-2412"></a>
<a name="line-2413"></a>The rule binders are lambda-bound and applied to the OutExpr arguments
<a name="line-2414"></a>(here BIG) which lack all internal occurrence info.
<a name="line-2415"></a>
<a name="line-2416"></a>Is this inefficient?  Not really: we are about to walk over the result
<a name="line-2417"></a>of the rule firing to simplify it, so occurrence analysis is at most
<a name="line-2418"></a>a constant factor.
<a name="line-2419"></a>
<a name="line-2420"></a>Possible improvement: occ-anal the rules when putting them in the
<a name="line-2421"></a>database; and in the simplifier just occ-anal the OutExpr arguments.
<a name="line-2422"></a>But that's more complicated and the rule RHS is usually tiny; so I'm
<a name="line-2423"></a>just doing the simple thing.
<a name="line-2424"></a>
<a name="line-2425"></a>Historical note: previously we did occ-anal the rules in Rule.hs,
<a name="line-2426"></a>but failed to occ-anal the OutExpr arguments, which led to the
<a name="line-2427"></a>nasty performance problem described above.
<a name="line-2428"></a>
<a name="line-2429"></a>
<a name="line-2430"></a>Note [Optimising tagToEnum#]
<a name="line-2431"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2432"></a>If we have an enumeration data type:
<a name="line-2433"></a>
<a name="line-2434"></a>  data Foo = A | B | C
<a name="line-2435"></a>
<a name="line-2436"></a>Then we want to transform
<a name="line-2437"></a>
<a name="line-2438"></a>   case tagToEnum# x of   ==&gt;    case x of
<a name="line-2439"></a>     A -&gt; e1                       DEFAULT -&gt; e1
<a name="line-2440"></a>     B -&gt; e2                       1#      -&gt; e2
<a name="line-2441"></a>     C -&gt; e3                       2#      -&gt; e3
<a name="line-2442"></a>
<a name="line-2443"></a>thereby getting rid of the tagToEnum# altogether.  If there was a DEFAULT
<a name="line-2444"></a>alternative we retain it (remember it comes first).  If not the case must
<a name="line-2445"></a>be exhaustive, and we reflect that in the transformed version by adding
<a name="line-2446"></a>a DEFAULT.  Otherwise Lint complains that the new case is not exhaustive.
<a name="line-2447"></a>See #8317.
<a name="line-2448"></a>
<a name="line-2449"></a>Note [Rules for recursive functions]
<a name="line-2450"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2451"></a>You might think that we shouldn't apply rules for a loop breaker:
<a name="line-2452"></a>doing so might give rise to an infinite loop, because a RULE is
<a name="line-2453"></a>rather like an extra equation for the function:
<a name="line-2454"></a>     RULE:           f (g x) y = x+y
<a name="line-2455"></a>     Eqn:            f a     y = a-y
<a name="line-2456"></a>
<a name="line-2457"></a>But it's too drastic to disable rules for loop breakers.
<a name="line-2458"></a>Even the foldr/build rule would be disabled, because foldr
<a name="line-2459"></a>is recursive, and hence a loop breaker:
<a name="line-2460"></a>     foldr k z (build g) = g k z
<a name="line-2461"></a>So it's up to the programmer: rules can cause divergence
<a name="line-2462"></a>
<a name="line-2463"></a>
<a name="line-2464"></a>************************************************************************
<a name="line-2465"></a>*                                                                      *
<a name="line-2466"></a>                Rebuilding a case expression
<a name="line-2467"></a>*                                                                      *
<a name="line-2468"></a>************************************************************************
<a name="line-2469"></a>
<a name="line-2470"></a>Note [Case elimination]
<a name="line-2471"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2472"></a>The case-elimination transformation discards redundant case expressions.
<a name="line-2473"></a>Start with a simple situation:
<a name="line-2474"></a>
<a name="line-2475"></a>        case x# of      ===&gt;   let y# = x# in e
<a name="line-2476"></a>          y# -&gt; e
<a name="line-2477"></a>
<a name="line-2478"></a>(when x#, y# are of primitive type, of course).  We can't (in general)
<a name="line-2479"></a>do this for algebraic cases, because we might turn bottom into
<a name="line-2480"></a>non-bottom!
<a name="line-2481"></a>
<a name="line-2482"></a>The code in GHC.Core.Opt.Simplify.Utils.prepareAlts has the effect of generalise
<a name="line-2483"></a>this idea to look for a case where we're scrutinising a variable, and we know
<a name="line-2484"></a>that only the default case can match.  For example:
<a name="line-2485"></a>
<a name="line-2486"></a>        case x of
<a name="line-2487"></a>          0#      -&gt; ...
<a name="line-2488"></a>          DEFAULT -&gt; ...(case x of
<a name="line-2489"></a>                         0#      -&gt; ...
<a name="line-2490"></a>                         DEFAULT -&gt; ...) ...
<a name="line-2491"></a>
<a name="line-2492"></a>Here the inner case is first trimmed to have only one alternative, the
<a name="line-2493"></a>DEFAULT, after which it's an instance of the previous case.  This
<a name="line-2494"></a>really only shows up in eliminating error-checking code.
<a name="line-2495"></a>
<a name="line-2496"></a>Note that GHC.Core.Opt.Simplify.Utils.mkCase combines identical RHSs.  So
<a name="line-2497"></a>
<a name="line-2498"></a>        case e of       ===&gt; case e of DEFAULT -&gt; r
<a name="line-2499"></a>           True  -&gt; r
<a name="line-2500"></a>           False -&gt; r
<a name="line-2501"></a>
<a name="line-2502"></a>Now again the case may be eliminated by the CaseElim transformation.
<a name="line-2503"></a>This includes things like (==# a# b#)::Bool so that we simplify
<a name="line-2504"></a>      case ==# a# b# of { True -&gt; x; False -&gt; x }
<a name="line-2505"></a>to just
<a name="line-2506"></a>      x
<a name="line-2507"></a>This particular example shows up in default methods for
<a name="line-2508"></a>comparison operations (e.g. in (&gt;=) for Int.Int32)
<a name="line-2509"></a>
<a name="line-2510"></a>Note [Case to let transformation]
<a name="line-2511"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2512"></a>If a case over a lifted type has a single alternative, and is being
<a name="line-2513"></a>used as a strict 'let' (all isDeadBinder bndrs), we may want to do
<a name="line-2514"></a>this transformation:
<a name="line-2515"></a>
<a name="line-2516"></a>    case e of r       ===&gt;   let r = e in ...r...
<a name="line-2517"></a>      _ -&gt; ...r...
<a name="line-2518"></a>
<a name="line-2519"></a>We treat the unlifted and lifted cases separately:
<a name="line-2520"></a>
<a name="line-2521"></a>* Unlifted case: 'e' satisfies exprOkForSpeculation
<a name="line-2522"></a>  (ok-for-spec is needed to satisfy the let/app invariant).
<a name="line-2523"></a>  This turns     case a +# b of r -&gt; ...r...
<a name="line-2524"></a>  into           let r = a +# b in ...r...
<a name="line-2525"></a>  and thence     .....(a +# b)....
<a name="line-2526"></a>
<a name="line-2527"></a>  However, if we have
<a name="line-2528"></a>      case indexArray# a i of r -&gt; ...r...
<a name="line-2529"></a>  we might like to do the same, and inline the (indexArray# a i).
<a name="line-2530"></a>  But indexArray# is not okForSpeculation, so we don't build a let
<a name="line-2531"></a>  in rebuildCase (lest it get floated *out*), so the inlining doesn't
<a name="line-2532"></a>  happen either.  Annoying.
<a name="line-2533"></a>
<a name="line-2534"></a>* Lifted case: we need to be sure that the expression is already
<a name="line-2535"></a>  evaluated (exprIsHNF).  If it's not already evaluated
<a name="line-2536"></a>      - we risk losing exceptions, divergence or
<a name="line-2537"></a>        user-specified thunk-forcing
<a name="line-2538"></a>      - even if 'e' is guaranteed to converge, we don't want to
<a name="line-2539"></a>        create a thunk (call by need) instead of evaluating it
<a name="line-2540"></a>        right away (call by value)
<a name="line-2541"></a>
<a name="line-2542"></a>  However, we can turn the case into a /strict/ let if the 'r' is
<a name="line-2543"></a>  used strictly in the body.  Then we won't lose divergence; and
<a name="line-2544"></a>  we won't build a thunk because the let is strict.
<a name="line-2545"></a>  See also Note [Case-to-let for strictly-used binders]
<a name="line-2546"></a>
<a name="line-2547"></a>  NB: absentError satisfies exprIsHNF: see Note [aBSENT_ERROR_ID] in GHC.Core.Make.
<a name="line-2548"></a>  We want to turn
<a name="line-2549"></a>     case (absentError "foo") of r -&gt; ...MkT r...
<a name="line-2550"></a>  into
<a name="line-2551"></a>     let r = absentError "foo" in ...MkT r...
<a name="line-2552"></a>
<a name="line-2553"></a>
<a name="line-2554"></a>Note [Case-to-let for strictly-used binders]
<a name="line-2555"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2556"></a>If we have this:
<a name="line-2557"></a>   case &lt;scrut&gt; of r { _ -&gt; ..r.. }
<a name="line-2558"></a>
<a name="line-2559"></a>where 'r' is used strictly in (..r..), we can safely transform to
<a name="line-2560"></a>   let r = &lt;scrut&gt; in ...r...
<a name="line-2561"></a>
<a name="line-2562"></a>This is a Good Thing, because 'r' might be dead (if the body just
<a name="line-2563"></a>calls error), or might be used just once (in which case it can be
<a name="line-2564"></a>inlined); or we might be able to float the let-binding up or down.
<a name="line-2565"></a>E.g. #15631 has an example.
<a name="line-2566"></a>
<a name="line-2567"></a>Note that this can change the error behaviour.  For example, we might
<a name="line-2568"></a>transform
<a name="line-2569"></a>    case x of { _ -&gt; error "bad" }
<a name="line-2570"></a>    --&gt; error "bad"
<a name="line-2571"></a>which is might be puzzling if 'x' currently lambda-bound, but later gets
<a name="line-2572"></a>let-bound to (error "good").
<a name="line-2573"></a>
<a name="line-2574"></a>Nevertheless, the paper "A semantics for imprecise exceptions" allows
<a name="line-2575"></a>this transformation. If you want to fix the evaluation order, use
<a name="line-2576"></a>'pseq'.  See #8900 for an example where the loss of this
<a name="line-2577"></a>transformation bit us in practice.
<a name="line-2578"></a>
<a name="line-2579"></a>See also Note [Empty case alternatives] in GHC.Core.
<a name="line-2580"></a>
<a name="line-2581"></a>Historical notes
<a name="line-2582"></a>
<a name="line-2583"></a>There have been various earlier versions of this patch:
<a name="line-2584"></a>
<a name="line-2585"></a>* By Sept 18 the code looked like this:
<a name="line-2586"></a>     || scrut_is_demanded_var scrut
<a name="line-2587"></a>
<a name="line-2588"></a>    scrut_is_demanded_var :: CoreExpr -&gt; Bool
<a name="line-2589"></a>    scrut_is_demanded_var (Cast s _) = scrut_is_demanded_var s
<a name="line-2590"></a>    scrut_is_demanded_var (Var _)    = isStrUsedDmd (idDemandInfo case_bndr)
<a name="line-2591"></a>    scrut_is_demanded_var _          = False
<a name="line-2592"></a>
<a name="line-2593"></a>  This only fired if the scrutinee was a /variable/, which seems
<a name="line-2594"></a>  an unnecessary restriction. So in #15631 I relaxed it to allow
<a name="line-2595"></a>  arbitrary scrutinees.  Less code, less to explain -- but the change
<a name="line-2596"></a>  had 0.00% effect on nofib.
<a name="line-2597"></a>
<a name="line-2598"></a>* Previously, in Jan 13 the code looked like this:
<a name="line-2599"></a>     || case_bndr_evald_next rhs
<a name="line-2600"></a>
<a name="line-2601"></a>    case_bndr_evald_next :: CoreExpr -&gt; Bool
<a name="line-2602"></a>      -- See Note [Case binder next]
<a name="line-2603"></a>    case_bndr_evald_next (Var v)         = v == case_bndr
<a name="line-2604"></a>    case_bndr_evald_next (Cast e _)      = case_bndr_evald_next e
<a name="line-2605"></a>    case_bndr_evald_next (App e _)       = case_bndr_evald_next e
<a name="line-2606"></a>    case_bndr_evald_next (Case e _ _ _)  = case_bndr_evald_next e
<a name="line-2607"></a>    case_bndr_evald_next _               = False
<a name="line-2608"></a>
<a name="line-2609"></a>  This patch was part of fixing #7542. See also
<a name="line-2610"></a>  Note [Eta reduction of an eval'd function] in GHC.Core.Utils.)
<a name="line-2611"></a>
<a name="line-2612"></a>
<a name="line-2613"></a>Further notes about case elimination
<a name="line-2614"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2615"></a>Consider:       test :: Integer -&gt; IO ()
<a name="line-2616"></a>                test = print
<a name="line-2617"></a>
<a name="line-2618"></a>Turns out that this compiles to:
<a name="line-2619"></a>    Print.test
<a name="line-2620"></a>      = \ eta :: Integer
<a name="line-2621"></a>          eta1 :: Void# -&gt;
<a name="line-2622"></a>          case PrelNum.&lt; eta PrelNum.zeroInteger of wild { __DEFAULT -&gt;
<a name="line-2623"></a>          case hPutStr stdout
<a name="line-2624"></a>                 (PrelNum.jtos eta ($w[] @ Char))
<a name="line-2625"></a>                 eta1
<a name="line-2626"></a>          of wild1 { (# new_s, a4 #) -&gt; PrelIO.lvl23 new_s  }}
<a name="line-2627"></a>
<a name="line-2628"></a>Notice the strange '&lt;' which has no effect at all. This is a funny one.
<a name="line-2629"></a>It started like this:
<a name="line-2630"></a>
<a name="line-2631"></a>f x y = if x &lt; 0 then jtos x
<a name="line-2632"></a>          else if y==0 then "" else jtos x
<a name="line-2633"></a>
<a name="line-2634"></a>At a particular call site we have (f v 1).  So we inline to get
<a name="line-2635"></a>
<a name="line-2636"></a>        if v &lt; 0 then jtos x
<a name="line-2637"></a>        else if 1==0 then "" else jtos x
<a name="line-2638"></a>
<a name="line-2639"></a>Now simplify the 1==0 conditional:
<a name="line-2640"></a>
<a name="line-2641"></a>        if v&lt;0 then jtos v else jtos v
<a name="line-2642"></a>
<a name="line-2643"></a>Now common-up the two branches of the case:
<a name="line-2644"></a>
<a name="line-2645"></a>        case (v&lt;0) of DEFAULT -&gt; jtos v
<a name="line-2646"></a>
<a name="line-2647"></a>Why don't we drop the case?  Because it's strict in v.  It's technically
<a name="line-2648"></a>wrong to drop even unnecessary evaluations, and in practice they
<a name="line-2649"></a>may be a result of 'seq' so we *definitely* don't want to drop those.
<a name="line-2650"></a>I don't really know how to improve this situation.
<a name="line-2651"></a>
<a name="line-2652"></a>
<a name="line-2653"></a>Note [FloatBinds from constructor wrappers]
<a name="line-2654"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2655"></a>If we have FloatBinds coming from the constructor wrapper
<a name="line-2656"></a>(as in Note [exprIsConApp_maybe on data constructors with wrappers]),
<a name="line-2657"></a>we cannot float past them. We'd need to float the FloatBind
<a name="line-2658"></a>together with the simplify floats, unfortunately the
<a name="line-2659"></a>simplifier doesn't have case-floats. The simplest thing we can
<a name="line-2660"></a>do is to wrap all the floats here. The next iteration of the
<a name="line-2661"></a>simplifier will take care of all these cases and lets.
<a name="line-2662"></a>
<a name="line-2663"></a>Given data T = MkT !Bool, this allows us to simplify
<a name="line-2664"></a>case $WMkT b of { MkT x -&gt; f x }
<a name="line-2665"></a>to
<a name="line-2666"></a>case b of { b' -&gt; f b' }.
<a name="line-2667"></a>
<a name="line-2668"></a>We could try and be more clever (like maybe wfloats only contain
<a name="line-2669"></a>let binders, so we could float them). But the need for the
<a name="line-2670"></a>extra complication is not clear.
<a name="line-2671"></a>-}</span>
<a name="line-2672"></a>
<a name="line-2673"></a><span class='hs-comment'>---------------------------------------------------------</span>
<a name="line-2674"></a><span class='hs-comment'>--      Eliminate the case if possible</span>
<a name="line-2675"></a>
<a name="line-2676"></a><a name="rebuildCase"></a><span class='hs-definition'>rebuildCase</span><span class='hs-layout'>,</span> <span class='hs-varid'>reallyRebuildCase</span>
<a name="line-2677"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-2678"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>          <span class='hs-comment'>-- Scrutinee</span>
<a name="line-2679"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>             <span class='hs-comment'>-- Case binder</span>
<a name="line-2680"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- Alternatives (increasing order)</span>
<a name="line-2681"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-2682"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-2683"></a>
<a name="line-2684"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2685"></a><span class='hs-comment'>--      1. Eliminate the case if there's a known constructor</span>
<a name="line-2686"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2687"></a>
<a name="line-2688"></a><span class='hs-definition'>rebuildCase</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2689"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scrut</span>    <span class='hs-comment'>-- No need for same treatment as constructors</span>
<a name="line-2690"></a>                        <span class='hs-comment'>-- because literals are inlined more vigorously</span>
<a name="line-2691"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>litIsLifted</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-2692"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>KnownBranch</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2693"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>findAlt</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span> <span class='hs-keyword'>of</span>
<a name="line-2694"></a>            <span class='hs-conid'>Nothing</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>missingAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2695"></a>            <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>simple_rhs</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span>
<a name="line-2696"></a>
<a name="line-2697"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope'</span><span class='hs-layout'>,</span> <span class='hs-varid'>wfloats</span><span class='hs-layout'>,</span> <span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>other_args</span><span class='hs-layout'>)</span>
<a name="line-2698"></a>      <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>exprIsConApp_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUnfoldingInRuleMatch</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut</span>
<a name="line-2699"></a>        <span class='hs-comment'>-- Works when the scrutinee is a variable with a known unfolding</span>
<a name="line-2700"></a>        <span class='hs-comment'>-- as well as when it's an explicit constructor application</span>
<a name="line-2701"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setInScopeSet</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope'</span>
<a name="line-2702"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>KnownBranch</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2703"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>scaled_wfloats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>scale_float</span> <span class='hs-varid'>wfloats</span>
<a name="line-2704"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>findAlt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span> <span class='hs-keyword'>of</span>
<a name="line-2705"></a>            <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>missingAlt</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2706"></a>            <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>con_app</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-2707"></a>                                                 <span class='hs-varop'>`mkTyApps`</span> <span class='hs-varid'>ty_args</span>
<a name="line-2708"></a>                                                 <span class='hs-varop'>`mkApps`</span>   <span class='hs-varid'>other_args</span>
<a name="line-2709"></a>                                         <span class='hs-keyword'>in</span> <span class='hs-varid'>simple_rhs</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>scaled_wfloats</span> <span class='hs-varid'>con_app</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span>
<a name="line-2710"></a>            <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>knownCon</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>scaled_wfloats</span> <span class='hs-varid'>con</span> <span class='hs-varid'>ty_args</span> <span class='hs-varid'>other_args</span>
<a name="line-2711"></a>                                                  <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-2712"></a>        <span class='hs-layout'>}</span>
<a name="line-2713"></a>  <span class='hs-keyword'>where</span>
<a name="line-2714"></a>    <span class='hs-varid'>simple_rhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>wfloats</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span>
<a name="line-2715"></a>      <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>)</span>
<a name="line-2716"></a>      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecX</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>scrut'</span>
<a name="line-2717"></a>             <span class='hs-comment'>-- scrut is a constructor application,</span>
<a name="line-2718"></a>             <span class='hs-comment'>-- hence satisfies let/app invariant</span>
<a name="line-2719"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-2720"></a>         <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>wfloats</span> <span class='hs-keyword'>of</span>
<a name="line-2721"></a>             <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span>
<a name="line-2722"></a>             <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span>
<a name="line-2723"></a>               <span class='hs-comment'>-- See Note [FloatBinds from constructor wrappers]</span>
<a name="line-2724"></a>                   <span class='hs-layout'>(</span> <span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span>
<a name="line-2725"></a>                     <span class='hs-conid'>GHC.Core.Make.wrapFloats</span> <span class='hs-varid'>wfloats</span> <span class='hs-varop'>$</span>
<a name="line-2726"></a>                     <span class='hs-varid'>wrapFloats</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr'</span> <span class='hs-layout'>)</span><span class='hs-layout'>}</span>
<a name="line-2727"></a>
<a name="line-2728"></a>    <span class='hs-comment'>-- This scales case floats by the multiplicity of the continuation hole (see</span>
<a name="line-2729"></a>    <span class='hs-comment'>-- Note [Scaling in case-of-case]).  Let floats are _not_ scaled, because</span>
<a name="line-2730"></a>    <span class='hs-comment'>-- they are aliases anyway.</span>
<a name="line-2731"></a>    <span class='hs-varid'>scale_float</span> <span class='hs-layout'>(</span><span class='hs-conid'>GHC.Core.Make.FloatCase</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>con</span> <span class='hs-varid'>vars</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-2732"></a>      <span class='hs-keyword'>let</span>
<a name="line-2733"></a>        <span class='hs-varid'>scale_id</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scaleVarBy</span> <span class='hs-varid'>holeScaling</span> <span class='hs-varid'>id</span>
<a name="line-2734"></a>      <span class='hs-keyword'>in</span>
<a name="line-2735"></a>      <span class='hs-conid'>GHC.Core.Make.FloatCase</span> <span class='hs-varid'>scrut</span> <span class='hs-layout'>(</span><span class='hs-varid'>scale_id</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>con</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>scale_id</span> <span class='hs-varid'>vars</span><span class='hs-layout'>)</span>
<a name="line-2736"></a>    <span class='hs-varid'>scale_float</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span>
<a name="line-2737"></a>
<a name="line-2738"></a>    <span class='hs-varid'>holeScaling</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>cont</span> <span class='hs-varop'>`mkMultMul`</span> <span class='hs-varid'>idMult</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2739"></a>     <span class='hs-comment'>-- We are in the following situation</span>
<a name="line-2740"></a>     <span class='hs-comment'>--   case[p] case[q] u of { D x -&gt; C v } of { C x -&gt; w }</span>
<a name="line-2741"></a>     <span class='hs-comment'>-- And we are producing case[??] u of { D x -&gt; w[x\v]}</span>
<a name="line-2742"></a>     <span class='hs-comment'>--</span>
<a name="line-2743"></a>     <span class='hs-comment'>-- What should the multiplicity `??` be? In order to preserve the usage of</span>
<a name="line-2744"></a>     <span class='hs-comment'>-- variables in `u`, it needs to be `pq`.</span>
<a name="line-2745"></a>     <span class='hs-comment'>--</span>
<a name="line-2746"></a>     <span class='hs-comment'>-- As an illustration, consider the following</span>
<a name="line-2747"></a>     <span class='hs-comment'>--   case[Many] case[1] of { C x -&gt; C x } of { C x -&gt; (x, x) }</span>
<a name="line-2748"></a>     <span class='hs-comment'>-- Where C :: A %1 -&gt; T is linear</span>
<a name="line-2749"></a>     <span class='hs-comment'>-- If we were to produce a case[1], like the inner case, we would get</span>
<a name="line-2750"></a>     <span class='hs-comment'>--   case[1] of { C x -&gt; (x, x) }</span>
<a name="line-2751"></a>     <span class='hs-comment'>-- Which is ill-typed with respect to linearity. So it needs to be a</span>
<a name="line-2752"></a>     <span class='hs-comment'>-- case[Many].</span>
<a name="line-2753"></a>
<a name="line-2754"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2755"></a><span class='hs-comment'>--      2. Eliminate the case if scrutinee is evaluated</span>
<a name="line-2756"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2757"></a>
<a name="line-2758"></a><span class='hs-definition'>rebuildCase</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>cont</span>
<a name="line-2759"></a>  <span class='hs-comment'>-- See if we can get rid of the case altogether</span>
<a name="line-2760"></a>  <span class='hs-comment'>-- See Note [Case elimination]</span>
<a name="line-2761"></a>  <span class='hs-comment'>-- mkCase made sure that if all the alternatives are equal,</span>
<a name="line-2762"></a>  <span class='hs-comment'>-- then there is now only one (DEFAULT) rhs</span>
<a name="line-2763"></a>
<a name="line-2764"></a>  <span class='hs-comment'>-- 2a.  Dropping the case altogether, if</span>
<a name="line-2765"></a>  <span class='hs-comment'>--      a) it binds nothing (so it's really just a 'seq')</span>
<a name="line-2766"></a>  <span class='hs-comment'>--      b) evaluating the scrutinee has no side effects</span>
<a name="line-2767"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_plain_seq</span>
<a name="line-2768"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>exprOkForSideEffects</span> <span class='hs-varid'>scrut</span>
<a name="line-2769"></a>          <span class='hs-comment'>-- The entire case is dead, so we can drop it</span>
<a name="line-2770"></a>          <span class='hs-comment'>-- if the scrutinee converges without having imperative</span>
<a name="line-2771"></a>          <span class='hs-comment'>-- side effects or raising a Haskell exception</span>
<a name="line-2772"></a>          <span class='hs-comment'>-- See Note [PrimOp can_fail and has_side_effects] in GHC.Builtin.PrimOps</span>
<a name="line-2773"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-2774"></a>
<a name="line-2775"></a>  <span class='hs-comment'>-- 2b.  Turn the case into a let, if</span>
<a name="line-2776"></a>  <span class='hs-comment'>--      a) it binds only the case-binder</span>
<a name="line-2777"></a>  <span class='hs-comment'>--      b) unlifted case: the scrutinee is ok-for-speculation</span>
<a name="line-2778"></a>  <span class='hs-comment'>--           lifted case: the scrutinee is in HNF (or will later be demanded)</span>
<a name="line-2779"></a>  <span class='hs-comment'>-- See Note [Case to let transformation]</span>
<a name="line-2780"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all_dead_bndrs</span>
<a name="line-2781"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>doCaseToLet</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2782"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>CaseElim</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2783"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecX</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>scrut</span>
<a name="line-2784"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-2785"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2786"></a>
<a name="line-2787"></a>  <span class='hs-comment'>-- 2c. Try the seq rules if</span>
<a name="line-2788"></a>  <span class='hs-comment'>--     a) it binds only the case binder</span>
<a name="line-2789"></a>  <span class='hs-comment'>--     b) a rule for seq applies</span>
<a name="line-2790"></a>  <span class='hs-comment'>-- See Note [User-defined RULES for seq] in GHC.Types.Id.Make</span>
<a name="line-2791"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_plain_seq</span>
<a name="line-2792"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_rule</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>trySeqRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-2793"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_rule</span> <span class='hs-keyword'>of</span>
<a name="line-2794"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rule_rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rule_rhs</span> <span class='hs-varid'>cont'</span>
<a name="line-2795"></a>           <span class='hs-conid'>Nothing</span>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>reallyRebuildCase</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-2796"></a>  <span class='hs-keyword'>where</span>
<a name="line-2797"></a>    <span class='hs-varid'>all_dead_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndrs</span>       <span class='hs-comment'>-- bndrs are [InId]</span>
<a name="line-2798"></a>    <span class='hs-varid'>is_plain_seq</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all_dead_bndrs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>case_bndr</span> <span class='hs-comment'>-- Evaluation *only* for effect</span>
<a name="line-2799"></a>
<a name="line-2800"></a><span class='hs-definition'>rebuildCase</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2801"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reallyRebuildCase</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2802"></a>
<a name="line-2803"></a>
<a name="line-2804"></a><a name="doCaseToLet"></a><span class='hs-definition'>doCaseToLet</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span>          <span class='hs-comment'>-- Scrutinee</span>
<a name="line-2805"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>             <span class='hs-comment'>-- Case binder</span>
<a name="line-2806"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2807"></a><span class='hs-comment'>-- The situation is         case scrut of b { DEFAULT -&gt; body }</span>
<a name="line-2808"></a><span class='hs-comment'>-- Can we transform thus?   let { b = scrut } in body</span>
<a name="line-2809"></a><span class='hs-definition'>doCaseToLet</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2810"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyCoVar</span> <span class='hs-varid'>case_bndr</span>    <span class='hs-comment'>-- Respect GHC.Core</span>
<a name="line-2811"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyCoArg</span> <span class='hs-varid'>scrut</span>        <span class='hs-comment'>-- Note [Core type and coercion invariant]</span>
<a name="line-2812"></a>
<a name="line-2813"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2814"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprOkForSpeculation</span> <span class='hs-varid'>scrut</span>
<a name="line-2815"></a>
<a name="line-2816"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Scrut has a lifted type</span>
<a name="line-2817"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprIsHNF</span> <span class='hs-varid'>scrut</span>
<a name="line-2818"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>isStrUsedDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2819"></a>    <span class='hs-comment'>-- See Note [Case-to-let for strictly-used binders]</span>
<a name="line-2820"></a>
<a name="line-2821"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2822"></a><span class='hs-comment'>--      3. Catch-all case</span>
<a name="line-2823"></a><span class='hs-comment'>--------------------------------------------------</span>
<a name="line-2824"></a>
<a name="line-2825"></a><a name="reallyRebuildCase"></a><span class='hs-definition'>reallyRebuildCase</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2826"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>sm_case_case</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2827"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>case_expr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplAlts</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span>
<a name="line-2828"></a>                                <span class='hs-layout'>(</span><span class='hs-varid'>mkBoringStop</span> <span class='hs-layout'>(</span><span class='hs-varid'>contHoleType</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2829"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rebuild</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_expr</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span>
<a name="line-2830"></a>
<a name="line-2831"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2832"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableCaseCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-2833"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>case_expr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplAlts</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>scrut</span>
<a name="line-2834"></a>                                <span class='hs-layout'>(</span><span class='hs-varid'>scaleIdBy</span> <span class='hs-varid'>holeScaling</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-2835"></a>                                <span class='hs-layout'>(</span><span class='hs-varid'>scaleAltsBy</span> <span class='hs-varid'>holeScaling</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2836"></a>                                <span class='hs-varid'>cont'</span>
<a name="line-2837"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_expr</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2838"></a>  <span class='hs-keyword'>where</span>
<a name="line-2839"></a>    <span class='hs-varid'>holeScaling</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>cont</span>
<a name="line-2840"></a>    <span class='hs-comment'>-- Note [Scaling in case-of-case]</span>
<a name="line-2841"></a>
<a name="line-2842"></a><span class='hs-comment'>{-
<a name="line-2843"></a>simplCaseBinder checks whether the scrutinee is a variable, v.  If so,
<a name="line-2844"></a>try to eliminate uses of v in the RHSs in favour of case_bndr; that
<a name="line-2845"></a>way, there's a chance that v will now only be used once, and hence
<a name="line-2846"></a>inlined.
<a name="line-2847"></a>
<a name="line-2848"></a>Historical note: we use to do the "case binder swap" in the Simplifier
<a name="line-2849"></a>so there were additional complications if the scrutinee was a variable.
<a name="line-2850"></a>Now the binder-swap stuff is done in the occurrence analyser; see
<a name="line-2851"></a>"GHC.Core.Opt.OccurAnal" Note [Binder swap].
<a name="line-2852"></a>
<a name="line-2853"></a>Note [knownCon occ info]
<a name="line-2854"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2855"></a>If the case binder is not dead, then neither are the pattern bound
<a name="line-2856"></a>variables:
<a name="line-2857"></a>        case &lt;any&gt; of x { (a,b) -&gt;
<a name="line-2858"></a>        case x of { (p,q) -&gt; p } }
<a name="line-2859"></a>Here (a,b) both look dead, but come alive after the inner case is eliminated.
<a name="line-2860"></a>The point is that we bring into the envt a binding
<a name="line-2861"></a>        let x = (a,b)
<a name="line-2862"></a>after the outer case, and that makes (a,b) alive.  At least we do unless
<a name="line-2863"></a>the case binder is guaranteed dead.
<a name="line-2864"></a>
<a name="line-2865"></a>Note [Case alternative occ info]
<a name="line-2866"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2867"></a>When we are simply reconstructing a case (the common case), we always
<a name="line-2868"></a>zap the occurrence info on the binders in the alternatives.  Even
<a name="line-2869"></a>if the case binder is dead, the scrutinee is usually a variable, and *that*
<a name="line-2870"></a>can bring the case-alternative binders back to life.
<a name="line-2871"></a>See Note [Add unfolding for scrutinee]
<a name="line-2872"></a>
<a name="line-2873"></a>Note [Improving seq]
<a name="line-2874"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-2875"></a>Consider
<a name="line-2876"></a>        type family F :: * -&gt; *
<a name="line-2877"></a>        type instance F Int = Int
<a name="line-2878"></a>
<a name="line-2879"></a>We'd like to transform
<a name="line-2880"></a>        case e of (x :: F Int) { DEFAULT -&gt; rhs }
<a name="line-2881"></a>===&gt;
<a name="line-2882"></a>        case e `cast` co of (x'::Int)
<a name="line-2883"></a>           I# x# -&gt; let x = x' `cast` sym co
<a name="line-2884"></a>                    in rhs
<a name="line-2885"></a>
<a name="line-2886"></a>so that 'rhs' can take advantage of the form of x'.  Notice that Note
<a name="line-2887"></a>[Case of cast] (in OccurAnal) may then apply to the result.
<a name="line-2888"></a>
<a name="line-2889"></a>We'd also like to eliminate empty types (#13468). So if
<a name="line-2890"></a>
<a name="line-2891"></a>    data Void
<a name="line-2892"></a>    type instance F Bool = Void
<a name="line-2893"></a>
<a name="line-2894"></a>then we'd like to transform
<a name="line-2895"></a>        case (x :: F Bool) of { _ -&gt; error "urk" }
<a name="line-2896"></a>===&gt;
<a name="line-2897"></a>        case (x |&gt; co) of (x' :: Void) of {}
<a name="line-2898"></a>
<a name="line-2899"></a>Nota Bene: we used to have a built-in rule for 'seq' that dropped
<a name="line-2900"></a>casts, so that
<a name="line-2901"></a>    case (x |&gt; co) of { _ -&gt; blah }
<a name="line-2902"></a>dropped the cast; in order to improve the chances of trySeqRules
<a name="line-2903"></a>firing.  But that works in the /opposite/ direction to Note [Improving
<a name="line-2904"></a>seq] so there's a danger of flip/flopping.  Better to make trySeqRules
<a name="line-2905"></a>insensitive to the cast, which is now is.
<a name="line-2906"></a>
<a name="line-2907"></a>The need for [Improving seq] showed up in Roman's experiments.  Example:
<a name="line-2908"></a>  foo :: F Int -&gt; Int -&gt; Int
<a name="line-2909"></a>  foo t n = t `seq` bar n
<a name="line-2910"></a>     where
<a name="line-2911"></a>       bar 0 = 0
<a name="line-2912"></a>       bar n = bar (n - case t of TI i -&gt; i)
<a name="line-2913"></a>Here we'd like to avoid repeated evaluating t inside the loop, by
<a name="line-2914"></a>taking advantage of the `seq`.
<a name="line-2915"></a>
<a name="line-2916"></a>At one point I did transformation in LiberateCase, but it's more
<a name="line-2917"></a>robust here.  (Otherwise, there's a danger that we'll simply drop the
<a name="line-2918"></a>'seq' altogether, before LiberateCase gets to see it.)
<a name="line-2919"></a>
<a name="line-2920"></a>Note [Scaling in case-of-case]
<a name="line-2921"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2922"></a>
<a name="line-2923"></a>When two cases commute, if done naively, the multiplicities will be wrong:
<a name="line-2924"></a>
<a name="line-2925"></a>  case (case u of w[1] { (x[1], y[1]) } -&gt; f x y) of w'[Many]
<a name="line-2926"></a>  { (z[Many], t[Many]) -&gt; z
<a name="line-2927"></a>  }
<a name="line-2928"></a>
<a name="line-2929"></a>The multiplicities here, are correct, but if I perform a case of case:
<a name="line-2930"></a>
<a name="line-2931"></a>  case u of w[1]
<a name="line-2932"></a>  { (x[1], y[1]) -&gt; case f x y of w'[Many] of { (z[Many], t[Many]) -&gt; z }
<a name="line-2933"></a>  }
<a name="line-2934"></a>
<a name="line-2935"></a>This is wrong! Using `f x y` inside a `case … of w'[Many]` means that `x` and
<a name="line-2936"></a>`y` must have multiplicities `Many` not `1`! The correct solution is to make
<a name="line-2937"></a>all the `1`-s be `Many`-s instead:
<a name="line-2938"></a>
<a name="line-2939"></a>  case u of w[Many]
<a name="line-2940"></a>  { (x[Many], y[Many]) -&gt; case f x y of w'[Many] of { (z[Many], t[Many]) -&gt; z }
<a name="line-2941"></a>  }
<a name="line-2942"></a>
<a name="line-2943"></a>In general, when commuting two cases, the rule has to be:
<a name="line-2944"></a>
<a name="line-2945"></a>  case (case … of x[p] {…}) of y[q] { … }
<a name="line-2946"></a>  ===&gt; case … of x[p*q] { … case … of y[q] { … } }
<a name="line-2947"></a>
<a name="line-2948"></a>This is materialised, in the simplifier, by the fact that every time we simplify
<a name="line-2949"></a>case alternatives with a continuation (the surrounded case (or more!)), we must
<a name="line-2950"></a>scale the entire case we are simplifying, by a scaling factor which can be
<a name="line-2951"></a>computed in the continuation (with function `contHoleScaling`).
<a name="line-2952"></a>-}</span>
<a name="line-2953"></a>
<a name="line-2954"></a><a name="simplAlts"></a><span class='hs-definition'>simplAlts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-2955"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>         <span class='hs-comment'>-- Scrutinee</span>
<a name="line-2956"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>            <span class='hs-comment'>-- Case binder</span>
<a name="line-2957"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- Non-empty</span>
<a name="line-2958"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-2959"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutExpr</span>  <span class='hs-comment'>-- Returns the complete simplified case expression</span>
<a name="line-2960"></a>
<a name="line-2961"></a><span class='hs-definition'>simplAlts</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont'</span>
<a name="line-2962"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>traceSmpl</span> <span class='hs-str'>"simplAlts"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2963"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"cont':"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont'</span>
<a name="line-2964"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"in_scope"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>seInScope</span> <span class='hs-varid'>env0</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2965"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2966"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>case_bndr2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>case_bndr1</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>evaldUnfolding</span>
<a name="line-2967"></a>              <span class='hs-varid'>env2</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifyInScope</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>case_bndr2</span>
<a name="line-2968"></a>              <span class='hs-comment'>-- See Note [Case binder evaluated-ness]</span>
<a name="line-2969"></a>
<a name="line-2970"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>fam_envs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFamEnvs</span>
<a name="line-2971"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>improveSeq</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>scrut</span>
<a name="line-2972"></a>                                                       <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>case_bndr2</span> <span class='hs-varid'>alts</span>
<a name="line-2973"></a>
<a name="line-2974"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>imposs_deflt_cons</span><span class='hs-layout'>,</span> <span class='hs-varid'>in_alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prepareAlts</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>alts</span>
<a name="line-2975"></a>          <span class='hs-comment'>-- NB: it's possible that the returned in_alts is empty: this is handled</span>
<a name="line-2976"></a>          <span class='hs-comment'>-- by the caller (rebuildCase) in the missingAlt function</span>
<a name="line-2977"></a>
<a name="line-2978"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>alts'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplAlt</span> <span class='hs-varid'>alt_env'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span> <span class='hs-varid'>imposs_deflt_cons</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-varid'>in_alts</span>
<a name="line-2979"></a>        <span class='hs-layout'>;</span> <span class='hs-comment'>-- pprTrace "simplAlts" (ppr case_bndr $$ ppr alts_ty $$ ppr alts_ty' $$ ppr alts $$ ppr cont') $</span>
<a name="line-2980"></a>
<a name="line-2981"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>alts_ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont'</span>
<a name="line-2982"></a>        <span class='hs-comment'>-- See Note [Avoiding space leaks in OutType]</span>
<a name="line-2983"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>seqType</span> <span class='hs-varid'>alts_ty'</span> <span class='hs-varop'>`seq`</span>
<a name="line-2984"></a>          <span class='hs-varid'>mkCase</span> <span class='hs-layout'>(</span><span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env0</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>alts_ty'</span> <span class='hs-varid'>alts'</span> <span class='hs-layout'>}</span>
<a name="line-2985"></a>
<a name="line-2986"></a>
<a name="line-2987"></a><a name="improveSeq"></a><span class='hs-comment'>------------------------------------</span>
<a name="line-2988"></a><span class='hs-definition'>improveSeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>FamInstEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>FamInstEnv</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-2989"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span>
<a name="line-2990"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutId</span><span class='hs-layout'>)</span>
<a name="line-2991"></a><span class='hs-comment'>-- Note [Improving seq]</span>
<a name="line-2992"></a><span class='hs-definition'>improveSeq</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>case_bndr1</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span>
<a name="line-2993"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topNormaliseType_maybe</span> <span class='hs-varid'>fam_envs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr1</span><span class='hs-layout'>)</span>
<a name="line-2994"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>case_bndr2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newId</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"nt"</span><span class='hs-layout'>)</span> <span class='hs-conid'>Many</span> <span class='hs-varid'>ty2</span>
<a name="line-2995"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DoneEx</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>case_bndr2</span> <span class='hs-varop'>`Cast`</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-2996"></a>              <span class='hs-varid'>env2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendIdSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>rhs</span>
<a name="line-2997"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env2</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut</span> <span class='hs-varop'>`Cast`</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2998"></a>
<a name="line-2999"></a><span class='hs-definition'>improveSeq</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>case_bndr1</span> <span class='hs-keyword'>_</span>
<a name="line-3000"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr1</span><span class='hs-layout'>)</span>
<a name="line-3001"></a>
<a name="line-3002"></a>
<a name="line-3003"></a><a name="simplAlt"></a><span class='hs-comment'>------------------------------------</span>
<a name="line-3004"></a><span class='hs-definition'>simplAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-3005"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>OutExpr</span>  <span class='hs-comment'>-- The scrutinee</span>
<a name="line-3006"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- These constructors can't be present when</span>
<a name="line-3007"></a>                           <span class='hs-comment'>-- matching the DEFAULT alternative</span>
<a name="line-3008"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>          <span class='hs-comment'>-- The case binder</span>
<a name="line-3009"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-3010"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InAlt</span>
<a name="line-3011"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>OutAlt</span>
<a name="line-3012"></a>
<a name="line-3013"></a><span class='hs-definition'>simplAlt</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span> <span class='hs-varop'>!</span><span class='hs-varid'>imposs_deflt_cons</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>cont'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-3014"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>)</span>
<a name="line-3015"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addBinderUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr'</span>
<a name="line-3016"></a>                                        <span class='hs-layout'>(</span><span class='hs-varid'>mkOtherCon</span> <span class='hs-varid'>imposs_deflt_cons</span><span class='hs-layout'>)</span>
<a name="line-3017"></a>                <span class='hs-comment'>-- Record the constructors that the case-binder *can't* be.</span>
<a name="line-3018"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont'</span>
<a name="line-3019"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3020"></a>
<a name="line-3021"></a><span class='hs-definition'>simplAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut'</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>cont'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-3022"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>)</span>
<a name="line-3023"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addAltUnfoldings</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-3024"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont'</span>
<a name="line-3025"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3026"></a>
<a name="line-3027"></a><span class='hs-definition'>simplAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut'</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>cont'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-3028"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-comment'>-- See Note [Adding evaluatedness info to pattern-bound variables]</span>
<a name="line-3029"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>vs_with_evals</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addEvals</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>con</span> <span class='hs-varid'>vs</span>
<a name="line-3030"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>vs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLamBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>vs_with_evals</span>
<a name="line-3031"></a>
<a name="line-3032"></a>                <span class='hs-comment'>-- Bind the case-binder to (con args)</span>
<a name="line-3033"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>inst_tys'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-3034"></a>              <span class='hs-varid'>con_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span>
<a name="line-3035"></a>              <span class='hs-varid'>con_app</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>con</span> <span class='hs-varid'>inst_tys'</span> <span class='hs-varid'>vs'</span>
<a name="line-3036"></a>
<a name="line-3037"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>env''</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addAltUnfoldings</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>con_app</span>
<a name="line-3038"></a>        <span class='hs-comment'>-- Forced so that simplExprC forces wrapFloats which means we don't</span>
<a name="line-3039"></a>        <span class='hs-comment'>-- retain the InScopeSet in SimplFloats</span>
<a name="line-3040"></a>        <span class='hs-layout'>;</span> <span class='hs-varop'>!</span><span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>env''</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont'</span>
<a name="line-3041"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3042"></a>
<a name="line-3043"></a><span class='hs-comment'>{- Note [Adding evaluatedness info to pattern-bound variables]
<a name="line-3044"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3045"></a>addEvals records the evaluated-ness of the bound variables of
<a name="line-3046"></a>a case pattern.  This is *important*.  Consider
<a name="line-3047"></a>
<a name="line-3048"></a>     data T = T !Int !Int
<a name="line-3049"></a>
<a name="line-3050"></a>     case x of { T a b -&gt; T (a+1) b }
<a name="line-3051"></a>
<a name="line-3052"></a>We really must record that b is already evaluated so that we don't
<a name="line-3053"></a>go and re-evaluate it when constructing the result.
<a name="line-3054"></a>See Note [Data-con worker strictness] in GHC.Core.DataCon
<a name="line-3055"></a>
<a name="line-3056"></a>NB: simplLamBndrs preserves this eval info
<a name="line-3057"></a>
<a name="line-3058"></a>In addition to handling data constructor fields with !s, addEvals
<a name="line-3059"></a>also records the fact that the result of seq# is always in WHNF.
<a name="line-3060"></a>See Note [seq# magic] in GHC.Core.Opt.ConstantFold.  Example (#15226):
<a name="line-3061"></a>
<a name="line-3062"></a>  case seq# v s of
<a name="line-3063"></a>    (# s', v' #) -&gt; E
<a name="line-3064"></a>
<a name="line-3065"></a>we want the compiler to be aware that v' is in WHNF in E.
<a name="line-3066"></a>
<a name="line-3067"></a>Open problem: we don't record that v itself is in WHNF (and we can't
<a name="line-3068"></a>do it here).  The right thing is to do some kind of binder-swap;
<a name="line-3069"></a>see #15226 for discussion.
<a name="line-3070"></a>-}</span>
<a name="line-3071"></a>
<a name="line-3072"></a><a name="addEvals"></a><span class='hs-definition'>addEvals</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>
<a name="line-3073"></a><span class='hs-comment'>-- See Note [Adding evaluatedness info to pattern-bound variables]</span>
<a name="line-3074"></a><span class='hs-definition'>addEvals</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>con</span> <span class='hs-varid'>vs</span>
<a name="line-3075"></a>  <span class='hs-comment'>-- Deal with seq# applications</span>
<a name="line-3076"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>scr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scrut</span>
<a name="line-3077"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isUnboxedTupleDataCon</span> <span class='hs-varid'>con</span>
<a name="line-3078"></a>  <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>vs</span>
<a name="line-3079"></a>    <span class='hs-comment'>-- Use stripNArgs rather than collectArgsTicks to avoid building</span>
<a name="line-3080"></a>    <span class='hs-comment'>-- a list of arguments only to throw it away immediately.</span>
<a name="line-3081"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stripNArgs</span> <span class='hs-num'>4</span> <span class='hs-varid'>scr</span>
<a name="line-3082"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>SeqOp</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isPrimOpId_maybe</span> <span class='hs-varid'>f</span>
<a name="line-3083"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>x'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdOccInfoAndSetEvald</span> <span class='hs-conid'>MarkedStrict</span> <span class='hs-varid'>x</span>
<a name="line-3084"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-varid'>x'</span><span class='hs-keyglyph'>]</span>
<a name="line-3085"></a>
<a name="line-3086"></a>  <span class='hs-comment'>-- Deal with banged datacon fields</span>
<a name="line-3087"></a><span class='hs-definition'>addEvals</span> <span class='hs-sel'>_scrut</span> <span class='hs-varid'>con</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>vs</span> <span class='hs-varid'>the_strs</span>
<a name="line-3088"></a>    <span class='hs-keyword'>where</span>
<a name="line-3089"></a>      <span class='hs-varid'>the_strs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span>
<a name="line-3090"></a>
<a name="line-3091"></a>      <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-3092"></a>      <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>strs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>vs'</span> <span class='hs-varid'>strs</span>
<a name="line-3093"></a>      <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>str</span><span class='hs-conop'>:</span><span class='hs-varid'>strs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdOccInfoAndSetEvald</span> <span class='hs-varid'>str</span> <span class='hs-varid'>v</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>vs'</span> <span class='hs-varid'>strs</span>
<a name="line-3094"></a>      <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"Simplify.addEvals"</span>
<a name="line-3095"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span> <span class='hs-varop'>$$</span>
<a name="line-3096"></a>                 <span class='hs-varid'>ppr</span> <span class='hs-varid'>vs</span>  <span class='hs-varop'>$$</span>
<a name="line-3097"></a>                 <span class='hs-varid'>ppr_with_length</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>strdisp</span> <span class='hs-varid'>the_strs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span>
<a name="line-3098"></a>                 <span class='hs-varid'>ppr_with_length</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepArgTys</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span>
<a name="line-3099"></a>                 <span class='hs-varid'>ppr_with_length</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConRepStrictness</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3100"></a>        <span class='hs-keyword'>where</span>
<a name="line-3101"></a>          <span class='hs-varid'>ppr_with_length</span> <span class='hs-varid'>list</span>
<a name="line-3102"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>list</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"length ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>list</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3103"></a>          <span class='hs-varid'>strdisp</span> <span class='hs-conid'>MarkedStrict</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"MarkedStrict"</span>
<a name="line-3104"></a>          <span class='hs-varid'>strdisp</span> <span class='hs-conid'>NotMarkedStrict</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"NotMarkedStrict"</span>
<a name="line-3105"></a>
<a name="line-3106"></a><a name="zapIdOccInfoAndSetEvald"></a><span class='hs-definition'>zapIdOccInfoAndSetEvald</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>StrictnessMark</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-3107"></a><span class='hs-definition'>zapIdOccInfoAndSetEvald</span> <span class='hs-varid'>str</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span>
<a name="line-3108"></a>  <span class='hs-varid'>setCaseBndrEvald</span> <span class='hs-varid'>str</span> <span class='hs-varop'>$</span> <span class='hs-comment'>-- Add eval'dness info</span>
<a name="line-3109"></a>  <span class='hs-varid'>zapIdOccInfo</span> <span class='hs-varid'>v</span>         <span class='hs-comment'>-- And kill occ info;</span>
<a name="line-3110"></a>                         <span class='hs-comment'>-- see Note [Case alternative occ info]</span>
<a name="line-3111"></a>
<a name="line-3112"></a><a name="addAltUnfoldings"></a><span class='hs-definition'>addAltUnfoldings</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-3113"></a><span class='hs-definition'>addAltUnfoldings</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>con_app</span>
<a name="line-3114"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>con_app_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_simple_unf</span> <span class='hs-varid'>con_app</span>
<a name="line-3115"></a>             <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addBinderUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>con_app_unf</span>
<a name="line-3116"></a>
<a name="line-3117"></a>             <span class='hs-comment'>-- See Note [Add unfolding for scrutinee]</span>
<a name="line-3118"></a>             <span class='hs-varid'>env2</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Many</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>idMult</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>of</span>
<a name="line-3119"></a>                      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addBinderUnfolding</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>v</span> <span class='hs-varid'>con_app_unf</span>
<a name="line-3120"></a>                      <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addBinderUnfolding</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>v</span> <span class='hs-varop'>$</span>
<a name="line-3121"></a>                                                <span class='hs-varid'>mk_simple_unf</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>con_app</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3122"></a>                      <span class='hs-keyword'>_</span>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>env1</span>
<a name="line-3123"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env1</span>
<a name="line-3124"></a>
<a name="line-3125"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceSmpl</span> <span class='hs-str'>"addAltUnf"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>scrut</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con_app</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-3126"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>env2</span> <span class='hs-layout'>}</span>
<a name="line-3127"></a>  <span class='hs-keyword'>where</span>
<a name="line-3128"></a>    <span class='hs-comment'>-- Force the opts, so that the whole SimplEnv isn't retained</span>
<a name="line-3129"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seUnfoldingOpts</span> <span class='hs-varid'>env</span>
<a name="line-3130"></a>    <span class='hs-varid'>mk_simple_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSimpleUnfolding</span> <span class='hs-varid'>opts</span>
<a name="line-3131"></a>
<a name="line-3132"></a><a name="addBinderUnfolding"></a><span class='hs-definition'>addBinderUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-3133"></a><span class='hs-definition'>addBinderUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>unf</span>
<a name="line-3134"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>debugIsOn</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tmpl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>maybeUnfoldingTemplate</span> <span class='hs-varid'>unf</span>
<a name="line-3135"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>tmpl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-3136"></a>          <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tmpl</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>tmpl</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-3137"></a>    <span class='hs-varid'>modifyInScope</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>
<a name="line-3138"></a>
<a name="line-3139"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3140"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifyInScope</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>
<a name="line-3141"></a>
<a name="line-3142"></a><a name="zapBndrOccInfo"></a><span class='hs-definition'>zapBndrOccInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-3143"></a><span class='hs-comment'>-- Consider  case e of b { (a,b) -&gt; ... }</span>
<a name="line-3144"></a><span class='hs-comment'>-- Then if we bind b to (a,b) in "...", and b is not dead,</span>
<a name="line-3145"></a><span class='hs-comment'>-- then we must zap the deadness info on a,b</span>
<a name="line-3146"></a><span class='hs-definition'>zapBndrOccInfo</span> <span class='hs-varid'>keep_occ_info</span> <span class='hs-varid'>pat_id</span>
<a name="line-3147"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>keep_occ_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pat_id</span>
<a name="line-3148"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdOccInfo</span> <span class='hs-varid'>pat_id</span>
<a name="line-3149"></a>
<a name="line-3150"></a><span class='hs-comment'>{- Note [Case binder evaluated-ness]
<a name="line-3151"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3152"></a>We pin on a (OtherCon []) unfolding to the case-binder of a Case,
<a name="line-3153"></a>even though it'll be over-ridden in every case alternative with a more
<a name="line-3154"></a>informative unfolding.  Why?  Because suppose a later, less clever, pass
<a name="line-3155"></a>simply replaces all occurrences of the case binder with the binder itself;
<a name="line-3156"></a>then Lint may complain about the let/app invariant.  Example
<a name="line-3157"></a>    case e of b { DEFAULT -&gt; let v = reallyUnsafePtrEq# b y in ....
<a name="line-3158"></a>                ; K       -&gt; blah }
<a name="line-3159"></a>
<a name="line-3160"></a>The let/app invariant requires that y is evaluated in the call to
<a name="line-3161"></a>reallyUnsafePtrEq#, which it is.  But we still want that to be true if we
<a name="line-3162"></a>propagate binders to occurrences.
<a name="line-3163"></a>
<a name="line-3164"></a>This showed up in #13027.
<a name="line-3165"></a>
<a name="line-3166"></a>Note [Add unfolding for scrutinee]
<a name="line-3167"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3168"></a>In general it's unlikely that a variable scrutinee will appear
<a name="line-3169"></a>in the case alternatives   case x of { ...x unlikely to appear... }
<a name="line-3170"></a>because the binder-swap in OccurAnal has got rid of all such occurrences
<a name="line-3171"></a>See Note [Binder swap] in "GHC.Core.Opt.OccurAnal".
<a name="line-3172"></a>
<a name="line-3173"></a>BUT it is still VERY IMPORTANT to add a suitable unfolding for a
<a name="line-3174"></a>variable scrutinee, in simplAlt.  Here's why
<a name="line-3175"></a>   case x of y
<a name="line-3176"></a>     (a,b) -&gt; case b of c
<a name="line-3177"></a>                I# v -&gt; ...(f y)...
<a name="line-3178"></a>There is no occurrence of 'b' in the (...(f y)...).  But y gets
<a name="line-3179"></a>the unfolding (a,b), and *that* mentions b.  If f has a RULE
<a name="line-3180"></a>    RULE f (p, I# q) = ...
<a name="line-3181"></a>we want that rule to match, so we must extend the in-scope env with a
<a name="line-3182"></a>suitable unfolding for 'y'.  It's *essential* for rule matching; but
<a name="line-3183"></a>it's also good for case-elimination -- suppose that 'f' was inlined
<a name="line-3184"></a>and did multi-level case analysis, then we'd solve it in one
<a name="line-3185"></a>simplifier sweep instead of two.
<a name="line-3186"></a>
<a name="line-3187"></a>Exactly the same issue arises in GHC.Core.Opt.SpecConstr;
<a name="line-3188"></a>see Note [Add scrutinee to ValueEnv too] in GHC.Core.Opt.SpecConstr
<a name="line-3189"></a>
<a name="line-3190"></a>HOWEVER, given
<a name="line-3191"></a>  case x of y { Just a -&gt; r1; Nothing -&gt; r2 }
<a name="line-3192"></a>we do not want to add the unfolding x -&gt; y to 'x', which might seem cool,
<a name="line-3193"></a>since 'y' itself has different unfoldings in r1 and r2.  Reason: if we
<a name="line-3194"></a>did that, we'd have to zap y's deadness info and that is a very useful
<a name="line-3195"></a>piece of information.
<a name="line-3196"></a>
<a name="line-3197"></a>So instead we add the unfolding x -&gt; Just a, and x -&gt; Nothing in the
<a name="line-3198"></a>respective RHSs.
<a name="line-3199"></a>
<a name="line-3200"></a>Since this transformation is tantamount to a binder swap, the same caveat as in
<a name="line-3201"></a>Note [Suppressing binder-swaps on linear case] in OccurAnal apply.
<a name="line-3202"></a>
<a name="line-3203"></a>
<a name="line-3204"></a>************************************************************************
<a name="line-3205"></a>*                                                                      *
<a name="line-3206"></a>\subsection{Known constructor}
<a name="line-3207"></a>*                                                                      *
<a name="line-3208"></a>************************************************************************
<a name="line-3209"></a>
<a name="line-3210"></a>We are a bit careful with occurrence info.  Here's an example
<a name="line-3211"></a>
<a name="line-3212"></a>        (\x* -&gt; case x of (a*, b) -&gt; f a) (h v, e)
<a name="line-3213"></a>
<a name="line-3214"></a>where the * means "occurs once".  This effectively becomes
<a name="line-3215"></a>        case (h v, e) of (a*, b) -&gt; f a)
<a name="line-3216"></a>and then
<a name="line-3217"></a>        let a* = h v; b = e in f a
<a name="line-3218"></a>and then
<a name="line-3219"></a>        f (h v)
<a name="line-3220"></a>
<a name="line-3221"></a>All this should happen in one sweep.
<a name="line-3222"></a>-}</span>
<a name="line-3223"></a>
<a name="line-3224"></a><a name="knownCon"></a><span class='hs-definition'>knownCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-3225"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>                                           <span class='hs-comment'>-- The scrutinee</span>
<a name="line-3226"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>FloatBind</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutExpr</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- The scrutinee (in pieces)</span>
<a name="line-3227"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>                        <span class='hs-comment'>-- The alternative</span>
<a name="line-3228"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-3229"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-3230"></a>
<a name="line-3231"></a><span class='hs-definition'>knownCon</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>dc_floats</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>dc_ty_args</span> <span class='hs-varid'>dc_args</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-3232"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env1</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bind_args</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>dc_args</span>
<a name="line-3233"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bind_case_bndr</span> <span class='hs-varid'>env1</span>
<a name="line-3234"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats3</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprF</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>cont</span>
<a name="line-3235"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>dc_floats</span> <span class='hs-keyword'>of</span>
<a name="line-3236"></a>            <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-3237"></a>              <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats3</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span>
<a name="line-3238"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-3239"></a>              <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span>
<a name="line-3240"></a>               <span class='hs-comment'>-- See Note [FloatBinds from constructor wrappers]</span>
<a name="line-3241"></a>                     <span class='hs-layout'>,</span> <span class='hs-conid'>GHC.Core.Make.wrapFloats</span> <span class='hs-varid'>dc_floats</span> <span class='hs-varop'>$</span>
<a name="line-3242"></a>                       <span class='hs-varid'>wrapFloats</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats3</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3243"></a>  <span class='hs-keyword'>where</span>
<a name="line-3244"></a>    <span class='hs-varid'>zap_occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapBndrOccInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- bndr is an InId</span>
<a name="line-3245"></a>
<a name="line-3246"></a>                  <span class='hs-comment'>-- Ugh!</span>
<a name="line-3247"></a>    <span class='hs-varid'>bind_args</span> <span class='hs-varid'>env'</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span>
<a name="line-3248"></a>
<a name="line-3249"></a>    <span class='hs-varid'>bind_args</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-3250"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span> <span class='hs-layout'>)</span>
<a name="line-3251"></a>        <span class='hs-varid'>bind_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendTvSubst</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>b</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs'</span> <span class='hs-varid'>args</span>
<a name="line-3252"></a>
<a name="line-3253"></a>    <span class='hs-varid'>bind_args</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-3254"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>b</span> <span class='hs-layout'>)</span>
<a name="line-3255"></a>        <span class='hs-varid'>bind_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendCvSubst</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>b</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs'</span> <span class='hs-varid'>args</span>
<a name="line-3256"></a>
<a name="line-3257"></a>    <span class='hs-varid'>bind_args</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-3258"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span> <span class='hs-layout'>)</span>
<a name="line-3259"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>b'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zap_occ</span> <span class='hs-varid'>b</span>
<a name="line-3260"></a>             <span class='hs-comment'>-- Note that the binder might be "dead", because it doesn't</span>
<a name="line-3261"></a>             <span class='hs-comment'>-- occur in the RHS; and simplNonRecX may therefore discard</span>
<a name="line-3262"></a>             <span class='hs-comment'>-- it via postInlineUnconditionally.</span>
<a name="line-3263"></a>             <span class='hs-comment'>-- Nevertheless we must keep it if the case-binder is alive,</span>
<a name="line-3264"></a>             <span class='hs-comment'>-- because it may be used in the con_app.  See Note [knownCon occ info]</span>
<a name="line-3265"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>env2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplNonRecX</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>b'</span> <span class='hs-varid'>arg</span>  <span class='hs-comment'>-- arg satisfies let/app invariant</span>
<a name="line-3266"></a>           <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>env3</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bind_args</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>bs'</span> <span class='hs-varid'>args</span>
<a name="line-3267"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span> <span class='hs-varop'>`addFloats`</span> <span class='hs-varid'>floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>env3</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3268"></a>
<a name="line-3269"></a>    <span class='hs-varid'>bind_args</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span>
<a name="line-3270"></a>      <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"bind_args"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc_args</span> <span class='hs-varop'>$$</span>
<a name="line-3271"></a>                             <span class='hs-varid'>text</span> <span class='hs-str'>"scrut:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>scrut</span>
<a name="line-3272"></a>
<a name="line-3273"></a>       <span class='hs-comment'>-- It's useful to bind bndr to scrut, rather than to a fresh</span>
<a name="line-3274"></a>       <span class='hs-comment'>-- binding      x = Con arg1 .. argn</span>
<a name="line-3275"></a>       <span class='hs-comment'>-- because very often the scrut is a variable, so we avoid</span>
<a name="line-3276"></a>       <span class='hs-comment'>-- creating, and then subsequently eliminating, a let-binding</span>
<a name="line-3277"></a>       <span class='hs-comment'>-- BUT, if scrut is a not a variable, we must be careful</span>
<a name="line-3278"></a>       <span class='hs-comment'>-- about duplicating the arg redexes; in that case, make</span>
<a name="line-3279"></a>       <span class='hs-comment'>-- a new con-app from the args</span>
<a name="line-3280"></a>    <span class='hs-varid'>bind_case_bndr</span> <span class='hs-varid'>env</span>
<a name="line-3281"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndr</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-3282"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>scrut</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span>
<a name="line-3283"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>extendIdSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>DoneEx</span> <span class='hs-varid'>scrut</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3284"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dc_args</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplVar</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span>
<a name="line-3285"></a>                                         <span class='hs-comment'>-- dc_ty_args are already OutTypes,</span>
<a name="line-3286"></a>                                         <span class='hs-comment'>-- but bs are InBndrs</span>
<a name="line-3287"></a>                                 <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>con_app</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-3288"></a>                                                 <span class='hs-varop'>`mkTyApps`</span> <span class='hs-varid'>dc_ty_args</span>
<a name="line-3289"></a>                                                 <span class='hs-varop'>`mkApps`</span>   <span class='hs-varid'>dc_args</span>
<a name="line-3290"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>simplNonRecX</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>con_app</span> <span class='hs-layout'>}</span>
<a name="line-3291"></a>
<a name="line-3292"></a><a name="missingAlt"></a><span class='hs-comment'>-------------------</span>
<a name="line-3293"></a><span class='hs-definition'>missingAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-3294"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span>
<a name="line-3295"></a>                <span class='hs-comment'>-- This isn't strictly an error, although it is unusual.</span>
<a name="line-3296"></a>                <span class='hs-comment'>-- It's possible that the simplifier might "see" that</span>
<a name="line-3297"></a>                <span class='hs-comment'>-- an inner case has no accessible alternatives before</span>
<a name="line-3298"></a>                <span class='hs-comment'>-- it "sees" that the entire branch of an outer case is</span>
<a name="line-3299"></a>                <span class='hs-comment'>-- inaccessible.  So we simply put an error case here instead.</span>
<a name="line-3300"></a><span class='hs-definition'>missingAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cont</span>
<a name="line-3301"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"missingAlt"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>case_bndr</span> <span class='hs-layout'>)</span>
<a name="line-3302"></a>    <span class='hs-comment'>-- See Note [Avoiding space leaks in OutType]</span>
<a name="line-3303"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>cont_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-3304"></a>    <span class='hs-keyword'>in</span> <span class='hs-varid'>seqType</span> <span class='hs-varid'>cont_ty</span> <span class='hs-varop'>`seq`</span>
<a name="line-3305"></a>       <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkImpossibleExpr</span> <span class='hs-varid'>cont_ty</span><span class='hs-layout'>)</span>
<a name="line-3306"></a>
<a name="line-3307"></a><span class='hs-comment'>{-
<a name="line-3308"></a>************************************************************************
<a name="line-3309"></a>*                                                                      *
<a name="line-3310"></a>\subsection{Duplicating continuations}
<a name="line-3311"></a>*                                                                      *
<a name="line-3312"></a>************************************************************************
<a name="line-3313"></a>
<a name="line-3314"></a>Consider
<a name="line-3315"></a>  let x* = case e of { True -&gt; e1; False -&gt; e2 }
<a name="line-3316"></a>  in b
<a name="line-3317"></a>where x* is a strict binding.  Then mkDupableCont will be given
<a name="line-3318"></a>the continuation
<a name="line-3319"></a>   case [] of { True -&gt; e1; False -&gt; e2 } ; let x* = [] in b ; stop
<a name="line-3320"></a>and will split it into
<a name="line-3321"></a>   dupable:      case [] of { True -&gt; $j1; False -&gt; $j2 } ; stop
<a name="line-3322"></a>   join floats:  $j1 = e1, $j2 = e2
<a name="line-3323"></a>   non_dupable:  let x* = [] in b; stop
<a name="line-3324"></a>
<a name="line-3325"></a>Putting this back together would give
<a name="line-3326"></a>   let x* = let { $j1 = e1; $j2 = e2 } in
<a name="line-3327"></a>            case e of { True -&gt; $j1; False -&gt; $j2 }
<a name="line-3328"></a>   in b
<a name="line-3329"></a>(Of course we only do this if 'e' wants to duplicate that continuation.)
<a name="line-3330"></a>Note how important it is that the new join points wrap around the
<a name="line-3331"></a>inner expression, and not around the whole thing.
<a name="line-3332"></a>
<a name="line-3333"></a>In contrast, any let-bindings introduced by mkDupableCont can wrap
<a name="line-3334"></a>around the entire thing.
<a name="line-3335"></a>
<a name="line-3336"></a>Note [Bottom alternatives]
<a name="line-3337"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3338"></a>When we have
<a name="line-3339"></a>     case (case x of { A -&gt; error .. ; B -&gt; e; C -&gt; error ..)
<a name="line-3340"></a>       of alts
<a name="line-3341"></a>then we can just duplicate those alts because the A and C cases
<a name="line-3342"></a>will disappear immediately.  This is more direct than creating
<a name="line-3343"></a>join points and inlining them away.  See #4930.
<a name="line-3344"></a>-}</span>
<a name="line-3345"></a>
<a name="line-3346"></a><a name="mkDupableCaseCont"></a><span class='hs-comment'>--------------------</span>
<a name="line-3347"></a><span class='hs-definition'>mkDupableCaseCont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-3348"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SimplFloats</span>  <span class='hs-comment'>-- Join points (if any)</span>
<a name="line-3349"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>SimplEnv</span>     <span class='hs-comment'>-- Use this for the alts</span>
<a name="line-3350"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>
<a name="line-3351"></a><span class='hs-definition'>mkDupableCaseCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-3352"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>altsWouldDup</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span>
<a name="line-3353"></a>                           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCaseDepth</span> <span class='hs-varop'>$</span>
<a name="line-3354"></a>                                        <span class='hs-varid'>env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>floats</span>
<a name="line-3355"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3356"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-3357"></a>
<a name="line-3358"></a><a name="altsWouldDup"></a><span class='hs-definition'>altsWouldDup</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-comment'>-- True iff strictly &gt; 1 non-bottom alternative</span>
<a name="line-3359"></a><span class='hs-definition'>altsWouldDup</span> <span class='hs-conid'>[]</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>        <span class='hs-comment'>-- See Note [Bottom alternatives]</span>
<a name="line-3360"></a><span class='hs-definition'>altsWouldDup</span> <span class='hs-keyglyph'>[</span><span class='hs-keyword'>_</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-3361"></a><span class='hs-definition'>altsWouldDup</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt</span><span class='hs-conop'>:</span><span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-3362"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_bot_alt</span> <span class='hs-varid'>alt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>altsWouldDup</span> <span class='hs-varid'>alts</span>
<a name="line-3363"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>is_bot_alt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-3364"></a>    <span class='hs-comment'>-- otherwise case: first alt is non-bot, so all the rest must be bot</span>
<a name="line-3365"></a>  <span class='hs-keyword'>where</span>
<a name="line-3366"></a>    <span class='hs-varid'>is_bot_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprIsDeadEnd</span> <span class='hs-varid'>rhs</span>
<a name="line-3367"></a>
<a name="line-3368"></a><a name="mkDupableCont"></a><span class='hs-comment'>-------------------------</span>
<a name="line-3369"></a><span class='hs-definition'>mkDupableCont</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>
<a name="line-3370"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span>
<a name="line-3371"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SimplFloats</span>  <span class='hs-comment'>-- Incoming SimplEnv augmented with</span>
<a name="line-3372"></a>                                       <span class='hs-comment'>--   extra let/join-floats and in-scope variables</span>
<a name="line-3373"></a>                        <span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- dup_cont: duplicable continuation</span>
<a name="line-3374"></a><span class='hs-definition'>mkDupableCont</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cont</span>
<a name="line-3375"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-3376"></a>
<a name="line-3377"></a><a name="mkDupableContWithDmds"></a><span class='hs-definition'>mkDupableContWithDmds</span>
<a name="line-3378"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Demands on arguments; always infinite</span>
<a name="line-3379"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>
<a name="line-3380"></a>
<a name="line-3381"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cont</span>
<a name="line-3382"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>contIsDupable</span> <span class='hs-varid'>cont</span>
<a name="line-3383"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-3384"></a>
<a name="line-3385"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkDupableCont"</span>     <span class='hs-comment'>-- Handled by previous eqn</span>
<a name="line-3386"></a>
<a name="line-3387"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-3388"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>cont</span>
<a name="line-3389"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>CastIt</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3390"></a>
<a name="line-3391"></a><span class='hs-comment'>-- Duplicating ticks for now, not sure if this is good or not</span>
<a name="line-3392"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-varid'>t</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span>
<a name="line-3393"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>cont</span>
<a name="line-3394"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>TickIt</span> <span class='hs-varid'>t</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3395"></a>
<a name="line-3396"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>
<a name="line-3397"></a>     <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span>
<a name="line-3398"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>sc_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3399"></a><span class='hs-comment'>-- See Note [Duplicating StrictBind]</span>
<a name="line-3400"></a><span class='hs-comment'>-- K[ let x = &lt;&gt; in b ]  --&gt;   join j x = K[ b ]</span>
<a name="line-3401"></a><span class='hs-comment'>--                             j &lt;&gt;</span>
<a name="line-3402"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sb_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span>
<a name="line-3403"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>sb_env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>sb_env</span> <span class='hs-varid'>bndr</span>
<a name="line-3404"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>join_inner</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplLam</span> <span class='hs-varid'>sb_env1</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-varid'>cont</span>
<a name="line-3405"></a>          <span class='hs-comment'>-- No need to use mkDupableCont before simplLam; we</span>
<a name="line-3406"></a>          <span class='hs-comment'>-- use cont once here, and then share the result if necessary</span>
<a name="line-3407"></a>
<a name="line-3408"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>join_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>floats1</span> <span class='hs-varid'>join_inner</span>
<a name="line-3409"></a>             <span class='hs-varid'>res_ty</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-3410"></a>
<a name="line-3411"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mkDupableStrictBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>join_body</span> <span class='hs-varid'>res_ty</span> <span class='hs-layout'>}</span>
<a name="line-3412"></a>
<a name="line-3413"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>
<a name="line-3414"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span>
<a name="line-3415"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3416"></a>  <span class='hs-comment'>-- NB: sc_dup /= OkToDup; that is caught earlier by contIsDupable</span>
<a name="line-3417"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDataConId_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ai_fun</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3418"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-varid'>cont</span>  <span class='hs-comment'>-- See point (3) of Note [Duplicating join points]</span>
<a name="line-3419"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Use Plan A of Note [Duplicating StrictArg]</span>
<a name="line-3420"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span> <span class='hs-conop'>:</span> <span class='hs-varid'>dmds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ai_dmds</span> <span class='hs-varid'>fun</span>
<a name="line-3421"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>cont</span>
<a name="line-3422"></a>                              <span class='hs-comment'>-- Use the demands from the function to add the right</span>
<a name="line-3423"></a>                              <span class='hs-comment'>-- demand info on any bindings we make for further args</span>
<a name="line-3424"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>makeTrivialArg</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3425"></a>                                           <span class='hs-layout'>(</span><span class='hs-varid'>ai_args</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>
<a name="line-3426"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>addLetFloats</span> <span class='hs-varid'>floats1</span> <span class='hs-varid'>floats_s</span>
<a name="line-3427"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args'</span> <span class='hs-layout'>}</span>
<a name="line-3428"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont'</span>
<a name="line-3429"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_ty</span>
<a name="line-3430"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span><span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3431"></a>
<a name="line-3432"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3433"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Use Plan B of Note [Duplicating StrictArg]</span>
<a name="line-3434"></a>    <span class='hs-comment'>--   K[ f a b &lt;&gt; ]   --&gt;   join j x = K[ f a b x ]</span>
<a name="line-3435"></a>    <span class='hs-comment'>--                         j &lt;&gt;</span>
<a name="line-3436"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_ty</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span>
<a name="line-3437"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>m</span><span class='hs-layout'>,</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitFunTy</span> <span class='hs-varid'>fun_ty</span>
<a name="line-3438"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>arg_bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newId</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"arg"</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span> <span class='hs-varid'>arg_ty</span>
<a name="line-3439"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addNewInScopeIds`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_bndr</span><span class='hs-keyglyph'>]</span>
<a name="line-3440"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>join_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rebuildCall</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>addValArgTo</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>arg_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>fun_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>cont</span>
<a name="line-3441"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mkDupableStrictBind</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>arg_bndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrapFloats</span> <span class='hs-varid'>floats</span> <span class='hs-varid'>join_rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-layout'>}</span>
<a name="line-3442"></a>  <span class='hs-keyword'>where</span>
<a name="line-3443"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-3444"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-varid'>k</span>
<a name="line-3445"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>TickIt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>k</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-varid'>k</span>
<a name="line-3446"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-varid'>k</span>
<a name="line-3447"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-varid'>k</span>
<a name="line-3448"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-3449"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-3450"></a>    <span class='hs-varid'>thumbsUpPlanA</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-3451"></a>
<a name="line-3452"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span>
<a name="line-3453"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3454"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>cont</span>
<a name="line-3455"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-conid'>ApplyToTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont'</span>
<a name="line-3456"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>sc_arg_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3457"></a>
<a name="line-3458"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span>
<a name="line-3459"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span>
<a name="line-3460"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3461"></a>  <span class='hs-keyglyph'>=</span>     <span class='hs-comment'>-- e.g.         [...hole...] (...arg...)</span>
<a name="line-3462"></a>        <span class='hs-comment'>--      ==&gt;</span>
<a name="line-3463"></a>        <span class='hs-comment'>--              let a = ...arg...</span>
<a name="line-3464"></a>        <span class='hs-comment'>--              in [...hole...] a</span>
<a name="line-3465"></a>        <span class='hs-comment'>-- NB: sc_dup /= OkToDup; that is caught earlier by contIsDupable</span>
<a name="line-3466"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>dmd</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dmds</span>   <span class='hs-comment'>-- Never fails</span>
<a name="line-3467"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats1</span><span class='hs-layout'>,</span> <span class='hs-varid'>cont'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>cont</span>
<a name="line-3468"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>floats1</span>
<a name="line-3469"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>se'</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplArg</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>dup</span> <span class='hs-varid'>se</span> <span class='hs-varid'>arg</span>
<a name="line-3470"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>let_floats2</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg''</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeTrivial</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"karg"</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg'</span>
<a name="line-3471"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_floats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floats1</span> <span class='hs-varop'>`addLetFloats`</span> <span class='hs-varid'>let_floats2</span>
<a name="line-3472"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>all_floats</span>
<a name="line-3473"></a>                 <span class='hs-layout'>,</span> <span class='hs-conid'>ApplyToVal</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg''</span>
<a name="line-3474"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se'</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>all_floats</span>
<a name="line-3475"></a>                                         <span class='hs-comment'>-- Ensure that sc_env includes the free vars of</span>
<a name="line-3476"></a>                                         <span class='hs-comment'>-- arg'' in its in-scope set, even if makeTrivial</span>
<a name="line-3477"></a>                                         <span class='hs-comment'>-- has turned arg'' into a fresh variable</span>
<a name="line-3478"></a>                                         <span class='hs-comment'>-- See Note [StaticEnv invariant] in GHC.Core.Opt.Simplify.Utils</span>
<a name="line-3479"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont'</span>
<a name="line-3480"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>sc_hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hole_ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3481"></a>
<a name="line-3482"></a><span class='hs-definition'>mkDupableContWithDmds</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>
<a name="line-3483"></a>    <span class='hs-layout'>(</span><span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>se</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cont</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3484"></a>  <span class='hs-keyglyph'>=</span>     <span class='hs-comment'>-- e.g.         (case [...hole...] of { pi -&gt; ei })</span>
<a name="line-3485"></a>        <span class='hs-comment'>--      ===&gt;</span>
<a name="line-3486"></a>        <span class='hs-comment'>--              let ji = \xij -&gt; ei</span>
<a name="line-3487"></a>        <span class='hs-comment'>--              in case [...hole...] of { pi -&gt; ji xij }</span>
<a name="line-3488"></a>        <span class='hs-comment'>-- NB: sc_dup /= OkToDup; that is caught earlier by contIsDupable</span>
<a name="line-3489"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-conid'>CaseOfCase</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-3490"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>alt_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>alt_cont</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkDupableCaseCont</span> <span class='hs-layout'>(</span><span class='hs-varid'>se</span> <span class='hs-varop'>`setInScopeFromE`</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span> <span class='hs-varid'>cont</span>
<a name="line-3491"></a>                <span class='hs-comment'>-- NB: We call mkDupableCaseCont here to make cont duplicable</span>
<a name="line-3492"></a>                <span class='hs-comment'>--     (if necessary, depending on the number of alts)</span>
<a name="line-3493"></a>                <span class='hs-comment'>-- And this is important: see Note [Fusing case continuations]</span>
<a name="line-3494"></a>
<a name="line-3495"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cont_scaling</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>contHoleScaling</span> <span class='hs-varid'>cont</span>
<a name="line-3496"></a>          <span class='hs-comment'>-- See Note [Scaling in case-of-case]</span>
<a name="line-3497"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinder</span> <span class='hs-varid'>alt_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaleIdBy</span> <span class='hs-varid'>cont_scaling</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-3498"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>alts'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplAlt</span> <span class='hs-varid'>alt_env'</span> <span class='hs-conid'>Nothing</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>case_bndr'</span> <span class='hs-varid'>alt_cont</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>scaleAltsBy</span> <span class='hs-varid'>cont_scaling</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-3499"></a>        <span class='hs-comment'>-- Safe to say that there are no handled-cons for the DEFAULT case</span>
<a name="line-3500"></a>                <span class='hs-comment'>-- NB: simplBinder does not zap deadness occ-info, so</span>
<a name="line-3501"></a>                <span class='hs-comment'>-- a dead case_bndr' will still advertise its deadness</span>
<a name="line-3502"></a>                <span class='hs-comment'>-- This is really important because in</span>
<a name="line-3503"></a>                <span class='hs-comment'>--      case e of b { (# p,q #) -&gt; ... }</span>
<a name="line-3504"></a>                <span class='hs-comment'>-- b is always dead, and indeed we are not allowed to bind b to (# p,q #),</span>
<a name="line-3505"></a>                <span class='hs-comment'>-- which might happen if e was an explicit unboxed pair and b wasn't marked dead.</span>
<a name="line-3506"></a>                <span class='hs-comment'>-- In the new alts we build, we have the new case binder, so it must retain</span>
<a name="line-3507"></a>                <span class='hs-comment'>-- its deadness.</span>
<a name="line-3508"></a>        <span class='hs-comment'>-- NB: we don't use alt_env further; it has the substEnv for</span>
<a name="line-3509"></a>        <span class='hs-comment'>--     the alternatives, and we don't want that</span>
<a name="line-3510"></a>
<a name="line-3511"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>join_floats</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts''</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAccumLM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkDupableAlt</span> <span class='hs-layout'>(</span><span class='hs-varid'>targetPlatform</span> <span class='hs-layout'>(</span><span class='hs-varid'>seDynFlags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>case_bndr'</span><span class='hs-layout'>)</span>
<a name="line-3512"></a>                                              <span class='hs-varid'>emptyJoinFloats</span> <span class='hs-varid'>alts'</span>
<a name="line-3513"></a>
<a name="line-3514"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_floats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floats</span> <span class='hs-varop'>`addJoinFloats`</span> <span class='hs-varid'>join_floats</span>
<a name="line-3515"></a>                           <span class='hs-comment'>-- Note [Duplicated env]</span>
<a name="line-3516"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>all_floats</span>
<a name="line-3517"></a>                 <span class='hs-layout'>,</span> <span class='hs-conid'>Select</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span>
<a name="line-3518"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>case_bndr'</span>
<a name="line-3519"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>sc_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts''</span>
<a name="line-3520"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>se</span> <span class='hs-varop'>`setInScopeFromF`</span> <span class='hs-varid'>all_floats</span>
<a name="line-3521"></a>                                      <span class='hs-comment'>-- See Note [StaticEnv invariant] in GHC.Core.Opt.Simplify.Utils</span>
<a name="line-3522"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkBoringStop</span> <span class='hs-layout'>(</span><span class='hs-varid'>contResultType</span> <span class='hs-varid'>cont</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3523"></a>
<a name="line-3524"></a><a name="mkDupableStrictBind"></a><span class='hs-definition'>mkDupableStrictBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>
<a name="line-3525"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>SimplCont</span><span class='hs-layout'>)</span>
<a name="line-3526"></a><span class='hs-definition'>mkDupableStrictBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_bndr</span> <span class='hs-varid'>join_rhs</span> <span class='hs-varid'>res_ty</span>
<a name="line-3527"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>join_rhs</span>   <span class='hs-comment'>-- See point (2) of Note [Duplicating join points]</span>
<a name="line-3528"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span>
<a name="line-3529"></a>           <span class='hs-layout'>,</span> <span class='hs-conid'>StrictBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-3530"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>join_rhs</span>
<a name="line-3531"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-varid'>env</span>
<a name="line-3532"></a>                          <span class='hs-comment'>-- See Note [StaticEnv invariant] in GHC.Core.Opt.Simplify.Utils</span>
<a name="line-3533"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_dup</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span>
<a name="line-3534"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkBoringStop</span> <span class='hs-varid'>res_ty</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span>
<a name="line-3535"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3536"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>join_bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newJoinId</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg_bndr</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>res_ty</span>
<a name="line-3537"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArgInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_fun</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>join_bndr</span>
<a name="line-3538"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ai_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-3539"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ai_encl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>ai_dmds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>repeat</span> <span class='hs-varid'>topDmd</span>
<a name="line-3540"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ai_discs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>repeat</span> <span class='hs-num'>0</span> <span class='hs-layout'>}</span>
<a name="line-3541"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>addJoinFloats</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyFloats</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-3542"></a>                  <span class='hs-varid'>unitJoinFloat</span>                   <span class='hs-varop'>$</span>
<a name="line-3543"></a>                  <span class='hs-conid'>NonRec</span> <span class='hs-varid'>join_bndr</span>                <span class='hs-varop'>$</span>
<a name="line-3544"></a>                  <span class='hs-conid'>Lam</span> <span class='hs-layout'>(</span><span class='hs-varid'>setOneShotLambda</span> <span class='hs-varid'>arg_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>join_rhs</span>
<a name="line-3545"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>StrictArg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dup</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OkToDup</span>
<a name="line-3546"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_info</span>
<a name="line-3547"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_fun_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>join_bndr</span>
<a name="line-3548"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>sc_cont</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkBoringStop</span> <span class='hs-varid'>res_ty</span>
<a name="line-3549"></a>                            <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3550"></a>
<a name="line-3551"></a><a name="mkDupableAlt"></a><span class='hs-definition'>mkDupableAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Platform</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>
<a name="line-3552"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>JoinFloats</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutAlt</span>
<a name="line-3553"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>JoinFloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutAlt</span><span class='hs-layout'>)</span>
<a name="line-3554"></a><span class='hs-definition'>mkDupableAlt</span> <span class='hs-sel'>_platform</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>jfloats</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-3555"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs'</span>   <span class='hs-comment'>-- See point (2) of Note [Duplicating join points]</span>
<a name="line-3556"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>jfloats</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-3557"></a>
<a name="line-3558"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3559"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>simpl_opts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initSimpleOpts</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-3560"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_ty'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>rhs'</span>
<a name="line-3561"></a>              <span class='hs-varid'>scrut_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr</span>
<a name="line-3562"></a>              <span class='hs-varid'>case_bndr_w_unf</span>
<a name="line-3563"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>con</span> <span class='hs-keyword'>of</span>
<a name="line-3564"></a>                      <span class='hs-conid'>DEFAULT</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>case_bndr</span>
<a name="line-3565"></a>                      <span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>setIdUnfolding</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>unf</span>
<a name="line-3566"></a>                          <span class='hs-keyword'>where</span>
<a name="line-3567"></a>                                 <span class='hs-comment'>-- See Note [Case binders and join points]</span>
<a name="line-3568"></a>                             <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInlineUnfolding</span> <span class='hs-varid'>simpl_opts</span> <span class='hs-varid'>rhs</span>
<a name="line-3569"></a>                             <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConApp2</span> <span class='hs-varid'>dc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConAppArgs</span> <span class='hs-varid'>scrut_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs'</span>
<a name="line-3570"></a>
<a name="line-3571"></a>                      <span class='hs-conid'>LitAlt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mkDupableAlt"</span>
<a name="line-3572"></a>                                                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span> <span class='hs-layout'>)</span>
<a name="line-3573"></a>                                   <span class='hs-varid'>case_bndr</span>
<a name="line-3574"></a>                           <span class='hs-comment'>-- The case binder is alive but trivial, so why has</span>
<a name="line-3575"></a>                           <span class='hs-comment'>-- it not been substituted away?</span>
<a name="line-3576"></a>
<a name="line-3577"></a>              <span class='hs-varid'>final_bndrs'</span>
<a name="line-3578"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>case_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>abstract_over</span> <span class='hs-varid'>bndrs'</span>
<a name="line-3579"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>case_bndr_w_unf</span><span class='hs-keyglyph'>]</span>
<a name="line-3580"></a>
<a name="line-3581"></a>              <span class='hs-varid'>abstract_over</span> <span class='hs-varid'>bndr</span>
<a name="line-3582"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- Abstract over all type variables just in case</span>
<a name="line-3583"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3584"></a>                        <span class='hs-comment'>-- The deadness info on the new Ids is preserved by simplBinders</span>
<a name="line-3585"></a>              <span class='hs-varid'>final_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varsToCoreExprs</span> <span class='hs-varid'>final_bndrs'</span>
<a name="line-3586"></a>                           <span class='hs-comment'>-- Note [Join point abstraction]</span>
<a name="line-3587"></a>
<a name="line-3588"></a>                <span class='hs-comment'>-- We make the lambdas into one-shot-lambdas.  The</span>
<a name="line-3589"></a>                <span class='hs-comment'>-- join point is sure to be applied at most once, and doing so</span>
<a name="line-3590"></a>                <span class='hs-comment'>-- prevents the body of the join point being floated out by</span>
<a name="line-3591"></a>                <span class='hs-comment'>-- the full laziness pass</span>
<a name="line-3592"></a>              <span class='hs-varid'>really_final_bndrs</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>one_shot</span> <span class='hs-varid'>final_bndrs'</span>
<a name="line-3593"></a>              <span class='hs-varid'>one_shot</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setOneShotLambda</span> <span class='hs-varid'>v</span>
<a name="line-3594"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span>
<a name="line-3595"></a>              <span class='hs-varid'>join_rhs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>really_final_bndrs</span> <span class='hs-varid'>rhs'</span>
<a name="line-3596"></a>
<a name="line-3597"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>join_bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newJoinId</span> <span class='hs-varid'>final_bndrs'</span> <span class='hs-varid'>rhs_ty'</span>
<a name="line-3598"></a>
<a name="line-3599"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>join_call</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>join_bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>final_args</span>
<a name="line-3600"></a>              <span class='hs-varid'>alt'</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>join_call</span>
<a name="line-3601"></a>
<a name="line-3602"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>jfloats</span> <span class='hs-varop'>`addJoinFlts`</span> <span class='hs-varid'>unitJoinFloat</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>join_bndr</span> <span class='hs-varid'>join_rhs</span><span class='hs-layout'>)</span>
<a name="line-3603"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>alt'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3604"></a>                <span class='hs-comment'>-- See Note [Duplicated env]</span>
<a name="line-3605"></a>
<a name="line-3606"></a><span class='hs-comment'>{-
<a name="line-3607"></a>Note [Fusing case continuations]
<a name="line-3608"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3609"></a>It's important to fuse two successive case continuations when the
<a name="line-3610"></a>first has one alternative.  That's why we call prepareCaseCont here.
<a name="line-3611"></a>Consider this, which arises from thunk splitting (see Note [Thunk
<a name="line-3612"></a>splitting] in GHC.Core.Opt.WorkWrap):
<a name="line-3613"></a>
<a name="line-3614"></a>      let
<a name="line-3615"></a>        x* = case (case v of {pn -&gt; rn}) of
<a name="line-3616"></a>               I# a -&gt; I# a
<a name="line-3617"></a>      in body
<a name="line-3618"></a>
<a name="line-3619"></a>The simplifier will find
<a name="line-3620"></a>    (Var v) with continuation
<a name="line-3621"></a>            Select (pn -&gt; rn) (
<a name="line-3622"></a>            Select [I# a -&gt; I# a] (
<a name="line-3623"></a>            StrictBind body Stop
<a name="line-3624"></a>
<a name="line-3625"></a>So we'll call mkDupableCont on
<a name="line-3626"></a>   Select [I# a -&gt; I# a] (StrictBind body Stop)
<a name="line-3627"></a>There is just one alternative in the first Select, so we want to
<a name="line-3628"></a>simplify the rhs (I# a) with continuation (StrictBind body Stop)
<a name="line-3629"></a>Supposing that body is big, we end up with
<a name="line-3630"></a>          let $j a = &lt;let x = I# a in body&gt;
<a name="line-3631"></a>          in case v of { pn -&gt; case rn of
<a name="line-3632"></a>                                 I# a -&gt; $j a }
<a name="line-3633"></a>This is just what we want because the rn produces a box that
<a name="line-3634"></a>the case rn cancels with.
<a name="line-3635"></a>
<a name="line-3636"></a>See #4957 a fuller example.
<a name="line-3637"></a>
<a name="line-3638"></a>Note [Duplicating join points]
<a name="line-3639"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3640"></a>IN #19996 we discovered that we want to be really careful about
<a name="line-3641"></a>inlining join points.   Consider
<a name="line-3642"></a>    case (join $j x = K f x )
<a name="line-3643"></a>         (in case v of      )
<a name="line-3644"></a>         (     p1 -&gt; $j x1  ) of
<a name="line-3645"></a>         (     p2 -&gt; $j x2  )
<a name="line-3646"></a>         (     p3 -&gt; $j x3  )
<a name="line-3647"></a>      K g y -&gt; blah[g,y]
<a name="line-3648"></a>
<a name="line-3649"></a>Here the join-point RHS is very small, just a constructor
<a name="line-3650"></a>application (K x y).  So we might inline it to get
<a name="line-3651"></a>    case (case v of        )
<a name="line-3652"></a>         (     p1 -&gt; K f x1  ) of
<a name="line-3653"></a>         (     p2 -&gt; K f x2  )
<a name="line-3654"></a>         (     p3 -&gt; K f x3  )
<a name="line-3655"></a>      K g y -&gt; blah[g,y]
<a name="line-3656"></a>
<a name="line-3657"></a>But now we have to make `blah` into a join point, /abstracted/
<a name="line-3658"></a>over `g` and `y`.   In contrast, if we /don't/ inline $j we
<a name="line-3659"></a>don't need a join point for `blah` and we'll get
<a name="line-3660"></a>    join $j x = let g=f, y=x in blah[g,y]
<a name="line-3661"></a>    in case v of
<a name="line-3662"></a>       p1 -&gt; $j x1
<a name="line-3663"></a>       p2 -&gt; $j x2
<a name="line-3664"></a>       p3 -&gt; $j x3
<a name="line-3665"></a>
<a name="line-3666"></a>This can make a /massive/ difference, because `blah` can see
<a name="line-3667"></a>what `f` is, instead of lambda-abstracting over it.
<a name="line-3668"></a>
<a name="line-3669"></a>To achieve this:
<a name="line-3670"></a>
<a name="line-3671"></a>1. Do not postInlineUnconditionally a join point, until the Final
<a name="line-3672"></a>   phase.  (The Final phase is still quite early, so we might consider
<a name="line-3673"></a>   delaying still more.)
<a name="line-3674"></a>
<a name="line-3675"></a>2. In mkDupableAlt and mkDupableStrictBind, generate an alterative for
<a name="line-3676"></a>   all alternatives, except for exprIsTrival RHSs. Previously we used
<a name="line-3677"></a>   exprIsDupable.  This generates a lot more join points, but makes
<a name="line-3678"></a>   them much more case-of-case friendly.
<a name="line-3679"></a>
<a name="line-3680"></a>   It is definitely worth checking for exprIsTrivial, otherwise we get
<a name="line-3681"></a>   an extra Simplifier iteration, because it is inlined in the next
<a name="line-3682"></a>   round.
<a name="line-3683"></a>
<a name="line-3684"></a>3. By the same token we want to use Plan B in
<a name="line-3685"></a>   Note [Duplicating StrictArg] when the RHS of the new join point
<a name="line-3686"></a>   is a data constructor application.  That same Note explains why we
<a name="line-3687"></a>   want Plan A when the RHS of the new join point would be a
<a name="line-3688"></a>   non-data-constructor application
<a name="line-3689"></a>
<a name="line-3690"></a>4. You might worry that $j will be inlined by the call-site inliner,
<a name="line-3691"></a>   but it won't because the call-site context for a join is usually
<a name="line-3692"></a>   extremely boring (the arguments come from the pattern match).
<a name="line-3693"></a>   And if not, then perhaps inlining it would be a good idea.
<a name="line-3694"></a>
<a name="line-3695"></a>   You might also wonder if we get UnfWhen, because the RHS of the
<a name="line-3696"></a>   join point is no bigger than the call. But in the cases we care
<a name="line-3697"></a>   about it will be a little bigger, because of that free `f` in
<a name="line-3698"></a>       $j x = K f x
<a name="line-3699"></a>   So for now we don't do anything special in callSiteInline
<a name="line-3700"></a>
<a name="line-3701"></a>There is a bit of tension between (2) and (3).  Do we want to retain
<a name="line-3702"></a>the join point only when the RHS is
<a name="line-3703"></a>* a constructor application? or
<a name="line-3704"></a>* just non-trivial?
<a name="line-3705"></a>Currently, a bit ad-hoc, but we definitely want to retain the join
<a name="line-3706"></a>point for data constructors in mkDupalbleALt (point 2); that is the
<a name="line-3707"></a>whole point of #19996 described above.
<a name="line-3708"></a>
<a name="line-3709"></a>Note [Case binders and join points]
<a name="line-3710"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3711"></a>Consider this
<a name="line-3712"></a>   case (case .. ) of c {
<a name="line-3713"></a>     I# c# -&gt; ....c....
<a name="line-3714"></a>
<a name="line-3715"></a>If we make a join point with c but not c# we get
<a name="line-3716"></a>  $j = \c -&gt; ....c....
<a name="line-3717"></a>
<a name="line-3718"></a>But if later inlining scrutinises the c, thus
<a name="line-3719"></a>
<a name="line-3720"></a>  $j = \c -&gt; ... case c of { I# y -&gt; ... } ...
<a name="line-3721"></a>
<a name="line-3722"></a>we won't see that 'c' has already been scrutinised.  This actually
<a name="line-3723"></a>happens in the 'tabulate' function in wave4main, and makes a significant
<a name="line-3724"></a>difference to allocation.
<a name="line-3725"></a>
<a name="line-3726"></a>An alternative plan is this:
<a name="line-3727"></a>
<a name="line-3728"></a>   $j = \c# -&gt; let c = I# c# in ...c....
<a name="line-3729"></a>
<a name="line-3730"></a>but that is bad if 'c' is *not* later scrutinised.
<a name="line-3731"></a>
<a name="line-3732"></a>So instead we do both: we pass 'c' and 'c#' , and record in c's inlining
<a name="line-3733"></a>(a stable unfolding) that it's really I# c#, thus
<a name="line-3734"></a>
<a name="line-3735"></a>   $j = \c# -&gt; \c[=I# c#] -&gt; ...c....
<a name="line-3736"></a>
<a name="line-3737"></a>Absence analysis may later discard 'c'.
<a name="line-3738"></a>
<a name="line-3739"></a>NB: take great care when doing strictness analysis;
<a name="line-3740"></a>    see Note [Lambda-bound unfoldings] in GHC.Core.Opt.DmdAnal.
<a name="line-3741"></a>
<a name="line-3742"></a>Also note that we can still end up passing stuff that isn't used.  Before
<a name="line-3743"></a>strictness analysis we have
<a name="line-3744"></a>   let $j x y c{=(x,y)} = (h c, ...)
<a name="line-3745"></a>   in ...
<a name="line-3746"></a>After strictness analysis we see that h is strict, we end up with
<a name="line-3747"></a>   let $j x y c{=(x,y)} = ($wh x y, ...)
<a name="line-3748"></a>and c is unused.
<a name="line-3749"></a>
<a name="line-3750"></a>Note [Duplicated env]
<a name="line-3751"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-3752"></a>Some of the alternatives are simplified, but have not been turned into a join point
<a name="line-3753"></a>So they *must* have a zapped subst-env.  So we can't use completeNonRecX to
<a name="line-3754"></a>bind the join point, because it might to do PostInlineUnconditionally, and
<a name="line-3755"></a>we'd lose that when zapping the subst-env.  We could have a per-alt subst-env,
<a name="line-3756"></a>but zapping it (as we do in mkDupableCont, the Select case) is safe, and
<a name="line-3757"></a>at worst delays the join-point inlining.
<a name="line-3758"></a>
<a name="line-3759"></a>Note [Funky mkLamTypes]
<a name="line-3760"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3761"></a>Notice the funky mkLamTypes.  If the constructor has existentials
<a name="line-3762"></a>it's possible that the join point will be abstracted over
<a name="line-3763"></a>type variables as well as term variables.
<a name="line-3764"></a> Example:  Suppose we have
<a name="line-3765"></a>        data T = forall t.  C [t]
<a name="line-3766"></a> Then faced with
<a name="line-3767"></a>        case (case e of ...) of
<a name="line-3768"></a>            C t xs::[t] -&gt; rhs
<a name="line-3769"></a> We get the join point
<a name="line-3770"></a>        let j :: forall t. [t] -&gt; ...
<a name="line-3771"></a>            j = /\t \xs::[t] -&gt; rhs
<a name="line-3772"></a>        in
<a name="line-3773"></a>        case (case e of ...) of
<a name="line-3774"></a>            C t xs::[t] -&gt; j t xs
<a name="line-3775"></a>
<a name="line-3776"></a>Note [Duplicating StrictArg]
<a name="line-3777"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3778"></a>Dealing with making a StrictArg continuation duplicable has turned out
<a name="line-3779"></a>to be one of the trickiest corners of the simplifier, giving rise
<a name="line-3780"></a>to several cases in which the simplier expanded the program's size
<a name="line-3781"></a>*exponentially*.  They include
<a name="line-3782"></a>  #13253 exponential inlining
<a name="line-3783"></a>  #10421 ditto
<a name="line-3784"></a>  #18140 strict constructors
<a name="line-3785"></a>  #18282 another nested-function call case
<a name="line-3786"></a>
<a name="line-3787"></a>Suppose we have a call
<a name="line-3788"></a>  f e1 (case x of { True -&gt; r1; False -&gt; r2 }) e3
<a name="line-3789"></a>and f is strict in its second argument.  Then we end up in
<a name="line-3790"></a>mkDupableCont with a StrictArg continuation for (f e1 &lt;&gt; e3).
<a name="line-3791"></a>There are two ways to make it duplicable.
<a name="line-3792"></a>
<a name="line-3793"></a>* Plan A: move the entire call inwards, being careful not
<a name="line-3794"></a>  to duplicate e1 or e3, thus:
<a name="line-3795"></a>     let a1 = e1
<a name="line-3796"></a>         a3 = e3
<a name="line-3797"></a>     in case x of { True  -&gt; f a1 r1 a3
<a name="line-3798"></a>                  ; False -&gt; f a1 r2 a3 }
<a name="line-3799"></a>
<a name="line-3800"></a>* Plan B: make a join point:
<a name="line-3801"></a>     join $j x = f e1 x e3
<a name="line-3802"></a>     in case x of { True  -&gt; jump $j r1
<a name="line-3803"></a>                  ; False -&gt; jump $j r2 }
<a name="line-3804"></a>
<a name="line-3805"></a>  Notice that Plan B is very like the way we handle strict bindings;
<a name="line-3806"></a>  see Note [Duplicating StrictBind].  And Plan B is exactly what we'd
<a name="line-3807"></a>  get if we turned use a case expression to evaluate the strict arg:
<a name="line-3808"></a>
<a name="line-3809"></a>       case (case x of { True -&gt; r1; False -&gt; r2 }) of
<a name="line-3810"></a>         r -&gt; f e1 r e3
<a name="line-3811"></a>
<a name="line-3812"></a>  So, looking at Note [Duplicating join points], we also want Plan B
<a name="line-3813"></a>  when `f` is a data constructor.
<a name="line-3814"></a>
<a name="line-3815"></a>Plan A is often good. Here's an example from #3116
<a name="line-3816"></a>     go (n+1) (case l of
<a name="line-3817"></a>                 1  -&gt; bs'
<a name="line-3818"></a>                 _  -&gt; Chunk p fpc (o+1) (l-1) bs')
<a name="line-3819"></a>
<a name="line-3820"></a>If we pushed the entire call for 'go' inside the case, we get
<a name="line-3821"></a>call-pattern specialisation for 'go', which is *crucial* for
<a name="line-3822"></a>this particular program.
<a name="line-3823"></a>
<a name="line-3824"></a>Here is another example.
<a name="line-3825"></a>        &amp;&amp; E (case x of { T -&gt; F; F -&gt; T })
<a name="line-3826"></a>
<a name="line-3827"></a>Pushing the call inward (being careful not to duplicate E)
<a name="line-3828"></a>        let a = E
<a name="line-3829"></a>        in case x of { T -&gt; &amp;&amp; a F; F -&gt; &amp;&amp; a T }
<a name="line-3830"></a>
<a name="line-3831"></a>and now the (&amp;&amp; a F) etc can optimise.  Moreover there might
<a name="line-3832"></a>be a RULE for the function that can fire when it "sees" the
<a name="line-3833"></a>particular case alternative.
<a name="line-3834"></a>
<a name="line-3835"></a>But Plan A can have terrible, terrible behaviour. Here is a classic
<a name="line-3836"></a>case:
<a name="line-3837"></a>  f (f (f (f (f True))))
<a name="line-3838"></a>
<a name="line-3839"></a>Suppose f is strict, and has a body that is small enough to inline.
<a name="line-3840"></a>The innermost call inlines (seeing the True) to give
<a name="line-3841"></a>  f (f (f (f (case v of { True -&gt; e1; False -&gt; e2 }))))
<a name="line-3842"></a>
<a name="line-3843"></a>Now, suppose we naively push the entire continuation into both
<a name="line-3844"></a>case branches (it doesn't look large, just f.f.f.f). We get
<a name="line-3845"></a>  case v of
<a name="line-3846"></a>    True  -&gt; f (f (f (f e1)))
<a name="line-3847"></a>    False -&gt; f (f (f (f e2)))
<a name="line-3848"></a>
<a name="line-3849"></a>And now the process repeats, so we end up with an exponentially large
<a name="line-3850"></a>number of copies of f. No good!
<a name="line-3851"></a>
<a name="line-3852"></a>CONCLUSION: we want Plan A in general, but do Plan B is there a
<a name="line-3853"></a>danger of this nested call behaviour. The function that decides
<a name="line-3854"></a>this is called thumbsUpPlanA.
<a name="line-3855"></a>
<a name="line-3856"></a>Note [Keeping demand info in StrictArg Plan A]
<a name="line-3857"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3858"></a>Following on from Note [Duplicating StrictArg], another common code
<a name="line-3859"></a>pattern that can go bad is this:
<a name="line-3860"></a>   f (case x1 of { T -&gt; F; F -&gt; T })
<a name="line-3861"></a>     (case x2 of { T -&gt; F; F -&gt; T })
<a name="line-3862"></a>     ...etc...
<a name="line-3863"></a>when f is strict in all its arguments.  (It might, for example, be a
<a name="line-3864"></a>strict data constructor whose wrapper has not yet been inlined.)
<a name="line-3865"></a>
<a name="line-3866"></a>We use Plan A (because there is no nesting) giving
<a name="line-3867"></a>  let a2 = case x2 of ...
<a name="line-3868"></a>      a3 = case x3 of ...
<a name="line-3869"></a>  in case x1 of { T -&gt; f F a2 a3 ... ; F -&gt; f T a2 a3 ... }
<a name="line-3870"></a>
<a name="line-3871"></a>Now we must be careful!  a2 and a3 are small, and the OneOcc code in
<a name="line-3872"></a>postInlineUnconditionally may inline them both at both sites; see Note
<a name="line-3873"></a>Note [Inline small things to avoid creating a thunk] in
<a name="line-3874"></a>Simplify.Utils. But if we do inline them, the entire process will
<a name="line-3875"></a>repeat -- back to exponential behaviour.
<a name="line-3876"></a>
<a name="line-3877"></a>So we are careful to keep the demand-info on a2 and a3.  Then they'll
<a name="line-3878"></a>be /strict/ let-bindings, which will be dealt with by StrictBind.
<a name="line-3879"></a>That's why contIsDupableWithDmds is careful to propagage demand
<a name="line-3880"></a>info to the auxiliary bindings it creates.  See the Demand argument
<a name="line-3881"></a>to makeTrivial.
<a name="line-3882"></a>
<a name="line-3883"></a>Note [Duplicating StrictBind]
<a name="line-3884"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3885"></a>We make a StrictBind duplicable in a very similar way to
<a name="line-3886"></a>that for case expressions.  After all,
<a name="line-3887"></a>   let x* = e in b   is similar to    case e of x -&gt; b
<a name="line-3888"></a>
<a name="line-3889"></a>So we potentially make a join-point for the body, thus:
<a name="line-3890"></a>   let x = &lt;&gt; in b   ==&gt;   join j x = b
<a name="line-3891"></a>                           in j &lt;&gt;
<a name="line-3892"></a>
<a name="line-3893"></a>Just like StrictArg in fact -- and indeed they share code.
<a name="line-3894"></a>
<a name="line-3895"></a>Note [Join point abstraction]  Historical note
<a name="line-3896"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3897"></a>NB: This note is now historical, describing how (in the past) we used
<a name="line-3898"></a>to add a void argument to nullary join points.  But now that "join
<a name="line-3899"></a>point" is not a fuzzy concept but a formal syntactic construct (as
<a name="line-3900"></a>distinguished by the JoinId constructor of IdDetails), each of these
<a name="line-3901"></a>concerns is handled separately, with no need for a vestigial extra
<a name="line-3902"></a>argument.
<a name="line-3903"></a>
<a name="line-3904"></a>Join points always have at least one value argument,
<a name="line-3905"></a>for several reasons
<a name="line-3906"></a>
<a name="line-3907"></a>* If we try to lift a primitive-typed something out
<a name="line-3908"></a>  for let-binding-purposes, we will *caseify* it (!),
<a name="line-3909"></a>  with potentially-disastrous strictness results.  So
<a name="line-3910"></a>  instead we turn it into a function: \v -&gt; e
<a name="line-3911"></a>  where v::Void#.  The value passed to this function is void,
<a name="line-3912"></a>  which generates (almost) no code.
<a name="line-3913"></a>
<a name="line-3914"></a>* CPR.  We used to say "&amp;&amp; isUnliftedType rhs_ty'" here, but now
<a name="line-3915"></a>  we make the join point into a function whenever used_bndrs'
<a name="line-3916"></a>  is empty.  This makes the join-point more CPR friendly.
<a name="line-3917"></a>  Consider:       let j = if .. then I# 3 else I# 4
<a name="line-3918"></a>                  in case .. of { A -&gt; j; B -&gt; j; C -&gt; ... }
<a name="line-3919"></a>
<a name="line-3920"></a>  Now CPR doesn't w/w j because it's a thunk, so
<a name="line-3921"></a>  that means that the enclosing function can't w/w either,
<a name="line-3922"></a>  which is a lose.  Here's the example that happened in practice:
<a name="line-3923"></a>          kgmod :: Int -&gt; Int -&gt; Int
<a name="line-3924"></a>          kgmod x y = if x &gt; 0 &amp;&amp; y &lt; 0 || x &lt; 0 &amp;&amp; y &gt; 0
<a name="line-3925"></a>                      then 78
<a name="line-3926"></a>                      else 5
<a name="line-3927"></a>
<a name="line-3928"></a>* Let-no-escape.  We want a join point to turn into a let-no-escape
<a name="line-3929"></a>  so that it is implemented as a jump, and one of the conditions
<a name="line-3930"></a>  for LNE is that it's not updatable.  In CoreToStg, see
<a name="line-3931"></a>  Note [What is a non-escaping let]
<a name="line-3932"></a>
<a name="line-3933"></a>* Floating.  Since a join point will be entered once, no sharing is
<a name="line-3934"></a>  gained by floating out, but something might be lost by doing
<a name="line-3935"></a>  so because it might be allocated.
<a name="line-3936"></a>
<a name="line-3937"></a>I have seen a case alternative like this:
<a name="line-3938"></a>        True -&gt; \v -&gt; ...
<a name="line-3939"></a>It's a bit silly to add the realWorld dummy arg in this case, making
<a name="line-3940"></a>        $j = \s v -&gt; ...
<a name="line-3941"></a>           True -&gt; $j s
<a name="line-3942"></a>(the \v alone is enough to make CPR happy) but I think it's rare
<a name="line-3943"></a>
<a name="line-3944"></a>There's a slight infelicity here: we pass the overall
<a name="line-3945"></a>case_bndr to all the join points if it's used in *any* RHS,
<a name="line-3946"></a>because we don't know its usage in each RHS separately
<a name="line-3947"></a>
<a name="line-3948"></a>
<a name="line-3949"></a>
<a name="line-3950"></a>************************************************************************
<a name="line-3951"></a>*                                                                      *
<a name="line-3952"></a>                    Unfoldings
<a name="line-3953"></a>*                                                                      *
<a name="line-3954"></a>************************************************************************
<a name="line-3955"></a>-}</span>
<a name="line-3956"></a>
<a name="line-3957"></a><a name="simplLetUnfolding"></a><span class='hs-definition'>simplLetUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span><span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-3958"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span>
<a name="line-3959"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>
<a name="line-3960"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-3961"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>Unfolding</span>
<a name="line-3962"></a><span class='hs-definition'>simplLetUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>cont_mb</span> <span class='hs-varid'>id</span> <span class='hs-varid'>new_rhs</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>unf</span>
<a name="line-3963"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-varid'>unf</span>
<a name="line-3964"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplStableUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>cont_mb</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>unf</span>
<a name="line-3965"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isExitJoinId</span> <span class='hs-varid'>id</span>
<a name="line-3966"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>noUnfolding</span> <span class='hs-comment'>-- See Note [Do not inline exit join points] in GHC.Core.Opt.Exitify</span>
<a name="line-3967"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3968"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Otherwise, we end up retaining all the SimpleEnv</span>
<a name="line-3969"></a>    <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seUnfoldingOpts</span> <span class='hs-varid'>env</span>
<a name="line-3970"></a>    <span class='hs-keyword'>in</span> <span class='hs-varid'>mkLetUnfolding</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>top_lvl</span> <span class='hs-conid'>InlineRhs</span> <span class='hs-varid'>id</span> <span class='hs-varid'>new_rhs</span>
<a name="line-3971"></a>
<a name="line-3972"></a><a name="mkLetUnfolding"></a><span class='hs-comment'>-------------------</span>
<a name="line-3973"></a><span class='hs-definition'>mkLetUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingSource</span>
<a name="line-3974"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-conid'>Unfolding</span>
<a name="line-3975"></a><span class='hs-definition'>mkLetUnfolding</span> <span class='hs-varop'>!</span><span class='hs-varid'>uf_opts</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>src</span> <span class='hs-varid'>id</span> <span class='hs-varid'>new_rhs</span>
<a name="line-3976"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkUnfolding</span> <span class='hs-varid'>uf_opts</span> <span class='hs-varid'>src</span> <span class='hs-varid'>is_top_lvl</span> <span class='hs-varid'>is_bottoming</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
<a name="line-3977"></a>            <span class='hs-comment'>-- We make an  unfolding *even for loop-breakers*.</span>
<a name="line-3978"></a>            <span class='hs-comment'>-- Reason: (a) It might be useful to know that they are WHNF</span>
<a name="line-3979"></a>            <span class='hs-comment'>--         (b) In GHC.Iface.Tidy we currently assume that, if we want to</span>
<a name="line-3980"></a>            <span class='hs-comment'>--             expose the unfolding then indeed we *have* an unfolding</span>
<a name="line-3981"></a>            <span class='hs-comment'>--             to expose.  (We could instead use the RHS, but currently</span>
<a name="line-3982"></a>            <span class='hs-comment'>--             we don't.)  The simple thing is always to have one.</span>
<a name="line-3983"></a>  <span class='hs-keyword'>where</span>
<a name="line-3984"></a>    <span class='hs-comment'>-- Might as well force this, profiles indicate up to 0.5MB of thunks</span>
<a name="line-3985"></a>    <span class='hs-comment'>-- just from this site.</span>
<a name="line-3986"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>is_top_lvl</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>
<a name="line-3987"></a>    <span class='hs-comment'>-- See Note [Force bottoming field]</span>
<a name="line-3988"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>is_bottoming</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isDeadEndId</span> <span class='hs-varid'>id</span>
<a name="line-3989"></a>
<a name="line-3990"></a><a name="simplStableUnfolding"></a><span class='hs-comment'>-------------------</span>
<a name="line-3991"></a><span class='hs-definition'>simplStableUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-3992"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span>  <span class='hs-comment'>-- Just k =&gt; a join point with continuation k</span>
<a name="line-3993"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InId</span>
<a name="line-3994"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutType</span>
<a name="line-3995"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>      <span class='hs-comment'>-- Used to eta expand, but only for non-join-points</span>
<a name="line-3996"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span>
<a name="line-3997"></a>                     <span class='hs-keyglyph'>-&gt;</span><span class='hs-conid'>SimplM</span> <span class='hs-conid'>Unfolding</span>
<a name="line-3998"></a><span class='hs-comment'>-- Note [Setting the new unfolding]</span>
<a name="line-3999"></a><span class='hs-definition'>simplStableUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>mb_cont</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varid'>id_arity</span> <span class='hs-varid'>unf</span>
<a name="line-4000"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>unf</span> <span class='hs-keyword'>of</span>
<a name="line-4001"></a>      <span class='hs-conid'>NoUnfolding</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unf</span>
<a name="line-4002"></a>      <span class='hs-conid'>BootUnfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unf</span>
<a name="line-4003"></a>      <span class='hs-conid'>OtherCon</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>unf</span>
<a name="line-4004"></a>
<a name="line-4005"></a>      <span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>df_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span>
<a name="line-4006"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinders</span> <span class='hs-varid'>unf_env</span> <span class='hs-varid'>bndrs</span>
<a name="line-4007"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>args'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplExpr</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-4008"></a>              <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkDFunUnfolding</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-4009"></a>
<a name="line-4010"></a>      <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expr</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>guide</span> <span class='hs-layout'>}</span>
<a name="line-4011"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableSource</span> <span class='hs-varid'>src</span>
<a name="line-4012"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>expr'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_cont</span> <span class='hs-keyword'>of</span>
<a name="line-4013"></a>                           <span class='hs-conid'>Just</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Binder is a join point</span>
<a name="line-4014"></a>                                        <span class='hs-comment'>-- See Note [Rules and unfolding for join points]</span>
<a name="line-4015"></a>                                        <span class='hs-varid'>simplJoinRhs</span> <span class='hs-varid'>unf_env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>cont</span>
<a name="line-4016"></a>                           <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Binder is not a join point</span>
<a name="line-4017"></a>                                        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>expr'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>unf_env</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkBoringStop</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>)</span>
<a name="line-4018"></a>                                           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>eta_expand</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-4019"></a>              <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>guide</span> <span class='hs-keyword'>of</span>
<a name="line-4020"></a>                  <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arity</span>
<a name="line-4021"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ug_unsat_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sat_ok</span>
<a name="line-4022"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>boring_ok</span>
<a name="line-4023"></a>                          <span class='hs-layout'>}</span>
<a name="line-4024"></a>                          <span class='hs-comment'>-- Happens for INLINE things</span>
<a name="line-4025"></a>                        <span class='hs-comment'>-- Really important to force new_boring_ok as otherwise</span>
<a name="line-4026"></a>                        <span class='hs-comment'>-- `ug_boring_ok` is a thunk chain of</span>
<a name="line-4027"></a>                        <span class='hs-comment'>-- inlineBoringExprOk expr0</span>
<a name="line-4028"></a>                        <span class='hs-comment'>--  || inlineBoringExprOk expr1 || ...</span>
<a name="line-4029"></a>                        <span class='hs-comment'>--  See #20134</span>
<a name="line-4030"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>new_boring_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>boring_ok</span> <span class='hs-varop'>||</span> <span class='hs-varid'>inlineBoringOk</span> <span class='hs-varid'>expr'</span>
<a name="line-4031"></a>                            <span class='hs-varid'>guide'</span> <span class='hs-keyglyph'>=</span>
<a name="line-4032"></a>                              <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arity</span>
<a name="line-4033"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>ug_unsat_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sat_ok</span>
<a name="line-4034"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_boring_ok</span>
<a name="line-4035"></a>
<a name="line-4036"></a>                                      <span class='hs-layout'>}</span>
<a name="line-4037"></a>                        <span class='hs-comment'>-- Refresh the boring-ok flag, in case expr'</span>
<a name="line-4038"></a>                        <span class='hs-comment'>-- has got small. This happens, notably in the inlinings</span>
<a name="line-4039"></a>                        <span class='hs-comment'>-- for dfuns for single-method classes; see</span>
<a name="line-4040"></a>                        <span class='hs-comment'>-- Note [Single-method classes] in GHC.Tc.TyCl.Instance.</span>
<a name="line-4041"></a>                        <span class='hs-comment'>-- A test case is #4138</span>
<a name="line-4042"></a>                        <span class='hs-comment'>-- But retain a previous boring_ok of True; e.g. see</span>
<a name="line-4043"></a>                        <span class='hs-comment'>-- the way it is set in calcUnfoldingGuidanceWithArity</span>
<a name="line-4044"></a>                        <span class='hs-keyword'>in</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoreUnfolding</span> <span class='hs-varid'>src</span> <span class='hs-varid'>is_top_lvl</span> <span class='hs-varid'>expr'</span> <span class='hs-varid'>guide'</span><span class='hs-layout'>)</span>
<a name="line-4045"></a>                            <span class='hs-comment'>-- See Note [Top-level flag on inline rules] in GHC.Core.Unfold</span>
<a name="line-4046"></a>
<a name="line-4047"></a>                  <span class='hs-sel'>_other</span>              <span class='hs-comment'>-- Happens for INLINABLE things</span>
<a name="line-4048"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkLetUnfolding</span> <span class='hs-varid'>uf_opts</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>src</span> <span class='hs-varid'>id</span> <span class='hs-varid'>expr'</span> <span class='hs-layout'>}</span>
<a name="line-4049"></a>                <span class='hs-comment'>-- If the guidance is UnfIfGoodArgs, this is an INLINABLE</span>
<a name="line-4050"></a>                <span class='hs-comment'>-- unfolding, and we need to make sure the guidance is kept up</span>
<a name="line-4051"></a>                <span class='hs-comment'>-- to date with respect to any changes in the unfolding.</span>
<a name="line-4052"></a>
<a name="line-4053"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>noUnfolding</span>   <span class='hs-comment'>-- Discard unstable unfoldings</span>
<a name="line-4054"></a>  <span class='hs-keyword'>where</span>
<a name="line-4055"></a>    <span class='hs-varid'>uf_opts</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seUnfoldingOpts</span> <span class='hs-varid'>env</span>
<a name="line-4056"></a>    <span class='hs-comment'>-- Forcing this can save about 0.5MB of max residency and the result</span>
<a name="line-4057"></a>    <span class='hs-comment'>-- is small and easy to compute so might as well force it.</span>
<a name="line-4058"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>is_top_lvl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>
<a name="line-4059"></a>    <span class='hs-varid'>act</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>id</span>
<a name="line-4060"></a>    <span class='hs-varid'>unf_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updMode</span> <span class='hs-layout'>(</span><span class='hs-varid'>updModeForStableUnfoldings</span> <span class='hs-varid'>act</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span>
<a name="line-4061"></a>         <span class='hs-comment'>-- See Note [Simplifying inside stable unfoldings] in GHC.Core.Opt.Simplify.Utils</span>
<a name="line-4062"></a>
<a name="line-4063"></a>    <span class='hs-comment'>-- See Note [Eta-expand stable unfoldings]</span>
<a name="line-4064"></a>    <span class='hs-varid'>eta_expand</span> <span class='hs-varid'>expr</span>
<a name="line-4065"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>eta_on</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expr</span>
<a name="line-4066"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expr</span>
<a name="line-4067"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>etaExpandAT</span> <span class='hs-varid'>id_arity</span> <span class='hs-varid'>expr</span>
<a name="line-4068"></a>    <span class='hs-varid'>eta_on</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sm_eta_expand</span> <span class='hs-layout'>(</span><span class='hs-varid'>getMode</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-4069"></a>
<a name="line-4070"></a><span class='hs-comment'>{- Note [Eta-expand stable unfoldings]
<a name="line-4071"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-4072"></a>For INLINE/INLINABLE things (which get stable unfoldings) there's a danger
<a name="line-4073"></a>of getting
<a name="line-4074"></a>   f :: Int -&gt; Int -&gt; Int -&gt; Blah
<a name="line-4075"></a>   [ Arity = 3                 -- Good arity
<a name="line-4076"></a>   , Unf=Stable (\xy. blah)    -- Less good arity, only 2
<a name="line-4077"></a>   f = \pqr. e
<a name="line-4078"></a>
<a name="line-4079"></a>This can happen because f's RHS is optimised more vigorously than
<a name="line-4080"></a>its stable unfolding.  Now suppose we have a call
<a name="line-4081"></a>   g = f x
<a name="line-4082"></a>Because f has arity=3, g will have arity=2.  But if we inline f (using
<a name="line-4083"></a>its stable unfolding) g's arity will reduce to 1, because &lt;blah&gt;
<a name="line-4084"></a>hasn't been optimised yet.  This happened in the 'parsec' library,
<a name="line-4085"></a>for Text.Pasec.Char.string.
<a name="line-4086"></a>
<a name="line-4087"></a>Generally, if we know that 'f' has arity N, it seems sensible to
<a name="line-4088"></a>eta-expand the stable unfolding to arity N too. Simple and consistent.
<a name="line-4089"></a>
<a name="line-4090"></a>Wrinkles
<a name="line-4091"></a>
<a name="line-4092"></a>* See Note [Eta-expansion in stable unfoldings] in
<a name="line-4093"></a>  GHC.Core.Opt.Simplify.Utils
<a name="line-4094"></a>
<a name="line-4095"></a>* Don't eta-expand a trivial expr, else each pass will eta-reduce it,
<a name="line-4096"></a>  and then eta-expand again. See Note [Do not eta-expand trivial expressions]
<a name="line-4097"></a>  in GHC.Core.Opt.Simplify.Utils.
<a name="line-4098"></a>
<a name="line-4099"></a>* Don't eta-expand join points; see Note [Do not eta-expand join points]
<a name="line-4100"></a>  in GHC.Core.Opt.Simplify.Utils.  We uphold this because the join-point
<a name="line-4101"></a>  case (mb_cont = Just _) doesn't use eta_expand.
<a name="line-4102"></a>
<a name="line-4103"></a>Note [Force bottoming field]
<a name="line-4104"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-4105"></a>We need to force bottoming, or the new unfolding holds
<a name="line-4106"></a>on to the old unfolding (which is part of the id).
<a name="line-4107"></a>
<a name="line-4108"></a>Note [Setting the new unfolding]
<a name="line-4109"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-4110"></a>* If there's an INLINE pragma, we simplify the RHS gently.  Maybe we
<a name="line-4111"></a>  should do nothing at all, but simplifying gently might get rid of
<a name="line-4112"></a>  more crap.
<a name="line-4113"></a>
<a name="line-4114"></a>* If not, we make an unfolding from the new RHS.  But *only* for
<a name="line-4115"></a>  non-loop-breakers. Making loop breakers not have an unfolding at all
<a name="line-4116"></a>  means that we can avoid tests in exprIsConApp, for example.  This is
<a name="line-4117"></a>  important: if exprIsConApp says 'yes' for a recursive thing, then we
<a name="line-4118"></a>  can get into an infinite loop
<a name="line-4119"></a>
<a name="line-4120"></a>If there's a stable unfolding on a loop breaker (which happens for
<a name="line-4121"></a>INLINABLE), we hang on to the inlining.  It's pretty dodgy, but the
<a name="line-4122"></a>user did say 'INLINE'.  May need to revisit this choice.
<a name="line-4123"></a>
<a name="line-4124"></a>************************************************************************
<a name="line-4125"></a>*                                                                      *
<a name="line-4126"></a>                    Rules
<a name="line-4127"></a>*                                                                      *
<a name="line-4128"></a>************************************************************************
<a name="line-4129"></a>
<a name="line-4130"></a>Note [Rules in a letrec]
<a name="line-4131"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-4132"></a>After creating fresh binders for the binders of a letrec, we
<a name="line-4133"></a>substitute the RULES and add them back onto the binders; this is done
<a name="line-4134"></a>*before* processing any of the RHSs.  This is important.  Manuel found
<a name="line-4135"></a>cases where he really, really wanted a RULE for a recursive function
<a name="line-4136"></a>to apply in that function's own right-hand side.
<a name="line-4137"></a>
<a name="line-4138"></a>See Note [Forming Rec groups] in "GHC.Core.Opt.OccurAnal"
<a name="line-4139"></a>-}</span>
<a name="line-4140"></a>
<a name="line-4141"></a><a name="addBndrRules"></a><span class='hs-definition'>addBndrRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutBndr</span>
<a name="line-4142"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span>   <span class='hs-comment'>-- Just k for a join point binder</span>
<a name="line-4143"></a>                                <span class='hs-comment'>-- Nothing otherwise</span>
<a name="line-4144"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-layout'>(</span><span class='hs-conid'>SimplEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBndr</span><span class='hs-layout'>)</span>
<a name="line-4145"></a><span class='hs-comment'>-- Rules are added back into the bin</span>
<a name="line-4146"></a><span class='hs-definition'>addBndrRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_id</span> <span class='hs-varid'>out_id</span> <span class='hs-varid'>mb_cont</span>
<a name="line-4147"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>old_rules</span>
<a name="line-4148"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>out_id</span><span class='hs-layout'>)</span>
<a name="line-4149"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-4150"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>new_rules</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplRules</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>out_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>old_rules</span> <span class='hs-varid'>mb_cont</span>
<a name="line-4151"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_id</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>out_id</span> <span class='hs-varop'>`setIdSpecialisation`</span> <span class='hs-varid'>mkRuleInfo</span> <span class='hs-varid'>new_rules</span>
<a name="line-4152"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>modifyInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>final_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_id</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-4153"></a>  <span class='hs-keyword'>where</span>
<a name="line-4154"></a>    <span class='hs-varid'>old_rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ruleInfoRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>idSpecialisation</span> <span class='hs-varid'>in_id</span><span class='hs-layout'>)</span>
<a name="line-4155"></a>
<a name="line-4156"></a><a name="simplRules"></a><span class='hs-definition'>simplRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SimplEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span>
<a name="line-4157"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MaybeJoinCont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SimplM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span>
<a name="line-4158"></a><span class='hs-definition'>simplRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>mb_new_id</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>mb_cont</span>
<a name="line-4159"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>simpl_rule</span> <span class='hs-varid'>rules</span>
<a name="line-4160"></a>  <span class='hs-keyword'>where</span>
<a name="line-4161"></a>    <span class='hs-varid'>simpl_rule</span> <span class='hs-varid'>rule</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-4162"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rule</span>
<a name="line-4163"></a>
<a name="line-4164"></a>    <span class='hs-varid'>simpl_rule</span> <span class='hs-varid'>rule</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span>
<a name="line-4165"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ru_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn_name</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-4166"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ru_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-4167"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplBinders</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-4168"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>env'</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-4169"></a>                 <span class='hs-varid'>rhs_cont</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_cont</span> <span class='hs-keyword'>of</span>  <span class='hs-comment'>-- See Note [Rules and unfolding for join points]</span>
<a name="line-4170"></a>                                <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkBoringStop</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-4171"></a>                                <span class='hs-conid'>Just</span> <span class='hs-varid'>cont</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>join_ok</span><span class='hs-layout'>,</span> <span class='hs-varid'>bad_join_msg</span> <span class='hs-layout'>)</span>
<a name="line-4172"></a>                                             <span class='hs-varid'>cont</span>
<a name="line-4173"></a>                 <span class='hs-varid'>lhs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updMode</span> <span class='hs-varid'>updModeForRules</span> <span class='hs-varid'>env'</span>
<a name="line-4174"></a>                 <span class='hs-varid'>rhs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updMode</span> <span class='hs-layout'>(</span><span class='hs-varid'>updModeForStableUnfoldings</span> <span class='hs-varid'>act</span><span class='hs-layout'>)</span> <span class='hs-varid'>env'</span>
<a name="line-4175"></a>                           <span class='hs-comment'>-- See Note [Simplifying the RHS of a RULE]</span>
<a name="line-4176"></a>                 <span class='hs-varid'>fn_name'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_new_id</span> <span class='hs-keyword'>of</span>
<a name="line-4177"></a>                              <span class='hs-conid'>Just</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>idName</span> <span class='hs-varid'>id</span>
<a name="line-4178"></a>                              <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>fn_name</span>
<a name="line-4179"></a>
<a name="line-4180"></a>                 <span class='hs-comment'>-- join_ok is an assertion check that the join-arity of the</span>
<a name="line-4181"></a>                 <span class='hs-comment'>-- binder matches that of the rule, so that pushing the</span>
<a name="line-4182"></a>                 <span class='hs-comment'>-- continuation into the RHS makes sense</span>
<a name="line-4183"></a>                 <span class='hs-varid'>join_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_new_id</span> <span class='hs-keyword'>of</span>
<a name="line-4184"></a>                             <span class='hs-conid'>Just</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>id</span>
<a name="line-4185"></a>                                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span> <span class='hs-varop'>==</span> <span class='hs-varid'>join_arity</span>
<a name="line-4186"></a>                             <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-4187"></a>                 <span class='hs-varid'>bad_join_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mb_new_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rule</span>
<a name="line-4188"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>mb_new_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-4189"></a>
<a name="line-4190"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>args'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplExpr</span> <span class='hs-varid'>lhs_env</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-4191"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>rhs'</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplExprC</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rhs_cont</span>
<a name="line-4192"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs'</span>
<a name="line-4193"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ru_fn</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn_name'</span>
<a name="line-4194"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ru_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args'</span>
<a name="line-4195"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-4196"></a>
<a name="line-4197"></a><span class='hs-comment'>{- Note [Simplifying the RHS of a RULE]
<a name="line-4198"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-4199"></a>We can simplify the RHS of a RULE much as we do the RHS of a stable
<a name="line-4200"></a>unfolding.  We used to use the much more conservative updModeForRules
<a name="line-4201"></a>for the RHS as well as the LHS, but that seems more conservative
<a name="line-4202"></a>than necesary.  Allowing some inlining might, for example, eliminate
<a name="line-4203"></a>a binding.
<a name="line-4204"></a>-}</span>
<a name="line-4205"></a>
</pre></body>
</html>
