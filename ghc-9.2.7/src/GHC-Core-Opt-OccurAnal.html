<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/OccurAnal.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE CPP          #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE ViewPatterns #-}</span>
<a name="line-4"></a>
<a name="line-5"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-record-updates #-}</span>
<a name="line-6"></a>
<a name="line-7"></a><span class='hs-comment'>{-
<a name="line-8"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-9"></a>
<a name="line-10"></a>************************************************************************
<a name="line-11"></a>*                                                                      *
<a name="line-12"></a>\section[OccurAnal]{Occurrence analysis pass}
<a name="line-13"></a>*                                                                      *
<a name="line-14"></a>************************************************************************
<a name="line-15"></a>
<a name="line-16"></a>The occurrence analyser re-typechecks a core expression, returning a new
<a name="line-17"></a>core expression with (hopefully) improved usage information.
<a name="line-18"></a>-}</span>
<a name="line-19"></a>
<a name="line-20"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.OccurAnal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>occurAnalysePgm</span><span class='hs-layout'>,</span> <span class='hs-varid'>occurAnalyseExpr</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-23"></a>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-27"></a>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>exprIsTrivial</span><span class='hs-layout'>,</span> <span class='hs-varid'>isDefaultAlt</span><span class='hs-layout'>,</span> <span class='hs-varid'>isExpandableApp</span><span class='hs-layout'>,</span>
<a name="line-31"></a>                          <span class='hs-varid'>stripTicksTopE</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTicks</span> <span class='hs-layout'>)</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Arity</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>joinRhsArity</span> <span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module</span><span class='hs-layout'>(</span> <span class='hs-conid'>Module</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.FVs</span><span class='hs-layout'>(</span> <span class='hs-varid'>tyCoVarsOfMCo</span> <span class='hs-layout'>)</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span> <span class='hs-layout'>(</span> <span class='hs-varid'>argOneShots</span><span class='hs-layout'>,</span> <span class='hs-varid'>argsOneShots</span> <span class='hs-layout'>)</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Graph.Directed</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SCC</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Node</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-47"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>stronglyConnCompFromEdgedVerticesUniq</span>
<a name="line-48"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>stronglyConnCompFromEdgedVerticesUniqR</span> <span class='hs-layout'>)</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span><span class='hs-layout'>(</span> <span class='hs-varid'>runRWKey</span> <span class='hs-layout'>)</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.FM</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Set</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span><span class='hs-layout'>(</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>)</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span> <span class='hs-layout'>(</span><span class='hs-varid'>mapAccumL</span><span class='hs-layout'>,</span> <span class='hs-varid'>mapAccumR</span><span class='hs-layout'>)</span>
<a name="line-58"></a>
<a name="line-59"></a><span class='hs-comment'>{-
<a name="line-60"></a>************************************************************************
<a name="line-61"></a>*                                                                      *
<a name="line-62"></a>    occurAnalysePgm, occurAnalyseExpr
<a name="line-63"></a>*                                                                      *
<a name="line-64"></a>************************************************************************
<a name="line-65"></a>
<a name="line-66"></a>Here's the externally-callable interface:
<a name="line-67"></a>-}</span>
<a name="line-68"></a>
<a name="line-69"></a><a name="occurAnalyseExpr"></a><span class='hs-definition'>occurAnalyseExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-70"></a><span class='hs-comment'>-- Do occurrence analysis, and discard occurrence info returned</span>
<a name="line-71"></a><span class='hs-definition'>occurAnalyseExpr</span> <span class='hs-varid'>expr</span>
<a name="line-72"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-layout'>(</span><span class='hs-varid'>occAnal</span> <span class='hs-varid'>initOccEnv</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-73"></a>
<a name="line-74"></a><a name="occurAnalysePgm"></a><span class='hs-definition'>occurAnalysePgm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Module</span>         <span class='hs-comment'>-- Used only in debug output</span>
<a name="line-75"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- Active unfoldings</span>
<a name="line-76"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Active rules</span>
<a name="line-77"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span>           <span class='hs-comment'>-- Local rules for imported Ids</span>
<a name="line-78"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span>
<a name="line-79"></a><span class='hs-definition'>occurAnalysePgm</span> <span class='hs-varid'>this_mod</span> <span class='hs-varid'>active_unf</span> <span class='hs-varid'>active_rule</span> <span class='hs-varid'>imp_rules</span> <span class='hs-varid'>binds</span>
<a name="line-80"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyDetails</span> <span class='hs-varid'>final_usage</span>
<a name="line-81"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ_anald_binds</span>
<a name="line-82"></a>
<a name="line-83"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- See Note [Glomming]</span>
<a name="line-84"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Glomming in"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>this_mod</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>colon</span><span class='hs-layout'>)</span>
<a name="line-85"></a>                   <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>final_usage</span> <span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-86"></a>    <span class='hs-varid'>occ_anald_glommed_binds</span>
<a name="line-87"></a>  <span class='hs-keyword'>where</span>
<a name="line-88"></a>    <span class='hs-varid'>init_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initOccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_rule_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>active_rule</span>
<a name="line-89"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>occ_unf_act</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>active_unf</span> <span class='hs-layout'>}</span>
<a name="line-90"></a>
<a name="line-91"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_anald_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>init_env</span> <span class='hs-varid'>binds</span>
<a name="line-92"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_anald_glommed_binds</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRecBind</span> <span class='hs-varid'>init_env</span> <span class='hs-conid'>TopLevel</span>
<a name="line-93"></a>                                                    <span class='hs-varid'>imp_rule_edges</span>
<a name="line-94"></a>                                                    <span class='hs-layout'>(</span><span class='hs-varid'>flattenBinds</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-95"></a>                                                    <span class='hs-varid'>initial_uds</span>
<a name="line-96"></a>          <span class='hs-comment'>-- It's crucial to re-analyse the glommed-together bindings</span>
<a name="line-97"></a>          <span class='hs-comment'>-- so that we establish the right loop breakers. Otherwise</span>
<a name="line-98"></a>          <span class='hs-comment'>-- we can easily create an infinite loop (#9583 is an example)</span>
<a name="line-99"></a>          <span class='hs-comment'>--</span>
<a name="line-100"></a>          <span class='hs-comment'>-- Also crucial to re-analyse the /original/ bindings</span>
<a name="line-101"></a>          <span class='hs-comment'>-- in case the first pass accidentally discarded as dead code</span>
<a name="line-102"></a>          <span class='hs-comment'>-- a binding that was actually needed (albeit before its</span>
<a name="line-103"></a>          <span class='hs-comment'>-- definition site).  #17724 threw this up.</span>
<a name="line-104"></a>
<a name="line-105"></a>    <span class='hs-varid'>initial_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addManyOccs</span> <span class='hs-varid'>emptyDetails</span> <span class='hs-layout'>(</span><span class='hs-varid'>rulesFreeVars</span> <span class='hs-varid'>imp_rules</span><span class='hs-layout'>)</span>
<a name="line-106"></a>    <span class='hs-comment'>-- The RULES declarations keep things alive!</span>
<a name="line-107"></a>
<a name="line-108"></a>    <span class='hs-comment'>-- imp_rule_edges maps a top-level local binder 'f' to the</span>
<a name="line-109"></a>    <span class='hs-comment'>-- RHS free vars of any IMP-RULE, a local RULE for an imported function,</span>
<a name="line-110"></a>    <span class='hs-comment'>-- where 'f' appears on the LHS</span>
<a name="line-111"></a>    <span class='hs-comment'>--   e.g.  RULE foldr f = blah</span>
<a name="line-112"></a>    <span class='hs-comment'>--         imp_rule_edges contains f :-&gt; fvs(blah)</span>
<a name="line-113"></a>    <span class='hs-comment'>-- We treat such RULES as extra rules for 'f'</span>
<a name="line-114"></a>    <span class='hs-comment'>-- See Note [Preventing loops due to imported functions rules]</span>
<a name="line-115"></a>    <span class='hs-varid'>imp_rule_edges</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ImpRuleEdges</span>
<a name="line-116"></a>    <span class='hs-varid'>imp_rule_edges</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>plusVarEnv_C</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-117"></a>                           <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mapVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>act</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs_fvs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getUniqSet</span> <span class='hs-varop'>$</span>
<a name="line-118"></a>                             <span class='hs-varid'>exprsFreeIds</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`delVarSetList`</span> <span class='hs-varid'>bndrs</span>
<a name="line-119"></a>                           <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span>
<a name="line-120"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>imp_rules</span>
<a name="line-121"></a>                                   <span class='hs-comment'>-- Not BuiltinRules; see Note [Plugin rules]</span>
<a name="line-122"></a>                           <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprFreeIds</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>`delVarSetList`</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>]</span>
<a name="line-123"></a>
<a name="line-124"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-125"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-126"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>initial_uds</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-127"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind</span><span class='hs-conop'>:</span><span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-128"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>bind'</span> <span class='hs-varop'>++</span> <span class='hs-varid'>binds'</span><span class='hs-layout'>)</span>
<a name="line-129"></a>        <span class='hs-keyword'>where</span>
<a name="line-130"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>bs_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>binds</span>
<a name="line-131"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>bind'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalBind</span> <span class='hs-varid'>env</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bind</span>
<a name="line-132"></a>                                              <span class='hs-varid'>bs_usage</span>
<a name="line-133"></a>
<a name="line-134"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-135"></a>*                                                                      *
<a name="line-136"></a>                IMP-RULES
<a name="line-137"></a>         Local rules for imported functions
<a name="line-138"></a>*                                                                      *
<a name="line-139"></a>********************************************************************* -}</span>
<a name="line-140"></a>
<a name="line-141"></a><a name="ImpRuleEdges"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ImpRuleEdges</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IdEnv</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Activation</span><span class='hs-layout'>,</span> <span class='hs-conid'>VarSet</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-142"></a>    <span class='hs-comment'>-- Mapping from a local Id 'f' to info about its IMP-RULES,</span>
<a name="line-143"></a>    <span class='hs-comment'>-- i.e. /local/ rules for an imported Id that mention 'f' on the LHS</span>
<a name="line-144"></a>    <span class='hs-comment'>-- We record (a) its Activation and (b) the RHS free vars</span>
<a name="line-145"></a>    <span class='hs-comment'>-- See Note [IMP-RULES: local rules for imported functions]</span>
<a name="line-146"></a>
<a name="line-147"></a><a name="noImpRuleEdges"></a><span class='hs-definition'>noImpRuleEdges</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ImpRuleEdges</span>
<a name="line-148"></a><span class='hs-definition'>noImpRuleEdges</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-149"></a>
<a name="line-150"></a><a name="lookupImpRules"></a><span class='hs-definition'>lookupImpRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ImpRuleEdges</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Activation</span><span class='hs-layout'>,</span><span class='hs-conid'>VarSet</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-151"></a><span class='hs-definition'>lookupImpRules</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr</span>
<a name="line-152"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr</span> <span class='hs-keyword'>of</span>
<a name="line-153"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-154"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>vs</span>
<a name="line-155"></a>
<a name="line-156"></a><a name="impRulesScopeUsage"></a><span class='hs-definition'>impRulesScopeUsage</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Activation</span><span class='hs-layout'>,</span><span class='hs-conid'>VarSet</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-157"></a><span class='hs-comment'>-- Variable mentioned in RHS of an IMP-RULE for the bndr,</span>
<a name="line-158"></a><span class='hs-comment'>-- whether active or not</span>
<a name="line-159"></a><span class='hs-definition'>impRulesScopeUsage</span> <span class='hs-varid'>imp_rules_info</span>
<a name="line-160"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add</span> <span class='hs-varid'>emptyDetails</span> <span class='hs-varid'>imp_rules_info</span>
<a name="line-161"></a>  <span class='hs-keyword'>where</span>
<a name="line-162"></a>    <span class='hs-varid'>add</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-varid'>usage</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addManyOccs</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>vs</span>
<a name="line-163"></a>
<a name="line-164"></a><a name="impRulesActiveFvs"></a><span class='hs-definition'>impRulesActiveFvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-165"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Activation</span><span class='hs-layout'>,</span><span class='hs-conid'>VarSet</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-166"></a><span class='hs-definition'>impRulesActiveFvs</span> <span class='hs-varid'>is_active</span> <span class='hs-varid'>bndr_set</span> <span class='hs-varid'>vs</span>
<a name="line-167"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>vs</span> <span class='hs-varop'>`intersectVarSet`</span> <span class='hs-varid'>bndr_set</span>
<a name="line-168"></a>  <span class='hs-keyword'>where</span>
<a name="line-169"></a>    <span class='hs-varid'>add</span> <span class='hs-layout'>(</span><span class='hs-varid'>act</span><span class='hs-layout'>,</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_active</span> <span class='hs-varid'>act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>acc</span>
<a name="line-170"></a>                     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>acc</span>
<a name="line-171"></a>
<a name="line-172"></a><span class='hs-comment'>{- Note [IMP-RULES: local rules for imported functions]
<a name="line-173"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-174"></a>We quite often have
<a name="line-175"></a>  * A /local/ rule
<a name="line-176"></a>  * for an /imported/ function
<a name="line-177"></a>like this:
<a name="line-178"></a>  foo x = blah
<a name="line-179"></a>  {-# RULE "map/foo" forall xs. map foo xs = xs #-}
<a name="line-180"></a>We call them IMP-RULES.  They are important in practice, and occur a
<a name="line-181"></a>lot in the libraries.
<a name="line-182"></a>
<a name="line-183"></a>IMP-RULES are held in mg_rules of ModGuts, and passed in to
<a name="line-184"></a>occurAnalysePgm.
<a name="line-185"></a>
<a name="line-186"></a>Main Invariant:
<a name="line-187"></a>
<a name="line-188"></a>* Throughout, we treat an IMP-RULE that mentions 'f' on its LHS
<a name="line-189"></a>  just like a RULE for f.
<a name="line-190"></a>
<a name="line-191"></a>Note [IMP-RULES: unavoidable loops]
<a name="line-192"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-193"></a>Consider this
<a name="line-194"></a>   f = /\a. B.g a
<a name="line-195"></a>   RULE B.g Int = 1 + f Int
<a name="line-196"></a>Note that
<a name="line-197"></a>  * The RULE is for an imported function.
<a name="line-198"></a>  * f is non-recursive
<a name="line-199"></a>Now we
<a name="line-200"></a>can get
<a name="line-201"></a>   f Int --&gt; B.g Int      Inlining f
<a name="line-202"></a>         --&gt; 1 + f Int    Firing RULE
<a name="line-203"></a>and so the simplifier goes into an infinite loop. This
<a name="line-204"></a>would not happen if the RULE was for a local function,
<a name="line-205"></a>because we keep track of dependencies through rules.  But
<a name="line-206"></a>that is pretty much impossible to do for imported Ids.  Suppose
<a name="line-207"></a>f's definition had been
<a name="line-208"></a>   f = /\a. C.h a
<a name="line-209"></a>where (by some long and devious process), C.h eventually inlines to
<a name="line-210"></a>B.g.  We could only spot such loops by exhaustively following
<a name="line-211"></a>unfoldings of C.h etc, in case we reach B.g, and hence (via the RULE)
<a name="line-212"></a>f.
<a name="line-213"></a>
<a name="line-214"></a>We regard this potential infinite loop as a *programmer* error.
<a name="line-215"></a>It's up the programmer not to write silly rules like
<a name="line-216"></a>     RULE f x = f x
<a name="line-217"></a>and the example above is just a more complicated version.
<a name="line-218"></a>
<a name="line-219"></a>Note [Specialising imported functions] (referred to from Specialise)
<a name="line-220"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-221"></a>For *automatically-generated* rules, the programmer can't be
<a name="line-222"></a>responsible for the "programmer error" in Note [IMP-RULES: unavoidable
<a name="line-223"></a>loops].  In particular, consider specialising a recursive function
<a name="line-224"></a>defined in another module.  If we specialise a recursive function B.g,
<a name="line-225"></a>we get
<a name="line-226"></a>  g_spec = .....(B.g Int).....
<a name="line-227"></a>  RULE B.g Int = g_spec
<a name="line-228"></a>Here, g_spec doesn't look recursive, but when the rule fires, it
<a name="line-229"></a>becomes so.  And if B.g was mutually recursive, the loop might not be
<a name="line-230"></a>as obvious as it is here.
<a name="line-231"></a>
<a name="line-232"></a>To avoid this,
<a name="line-233"></a> * When specialising a function that is a loop breaker,
<a name="line-234"></a>   give a NOINLINE pragma to the specialised function
<a name="line-235"></a>
<a name="line-236"></a>Note [Preventing loops due to imported functions rules]
<a name="line-237"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-238"></a>Consider:
<a name="line-239"></a>  import GHC.Base (foldr)
<a name="line-240"></a>
<a name="line-241"></a>  {-# RULES "filterList" forall p. foldr (filterFB (:) p) [] = filter p #-}
<a name="line-242"></a>  filter p xs = build (\c n -&gt; foldr (filterFB c p) n xs)
<a name="line-243"></a>  filterFB c p = ...
<a name="line-244"></a>
<a name="line-245"></a>  f = filter p xs
<a name="line-246"></a>
<a name="line-247"></a>Note that filter is not a loop-breaker, so what happens is:
<a name="line-248"></a>  f =          filter p xs
<a name="line-249"></a>    = {inline} build (\c n -&gt; foldr (filterFB c p) n xs)
<a name="line-250"></a>    = {inline} foldr (filterFB (:) p) [] xs
<a name="line-251"></a>    = {RULE}   filter p xs
<a name="line-252"></a>
<a name="line-253"></a>We are in an infinite loop.
<a name="line-254"></a>
<a name="line-255"></a>A more elaborate example (that I actually saw in practice when I went to
<a name="line-256"></a>mark GHC.List.filter as INLINABLE) is as follows. Say I have this module:
<a name="line-257"></a>  {-# LANGUAGE RankNTypes #-}
<a name="line-258"></a>  module GHCList where
<a name="line-259"></a>
<a name="line-260"></a>  import Prelude hiding (filter)
<a name="line-261"></a>  import GHC.Base (build)
<a name="line-262"></a>
<a name="line-263"></a>  {-# INLINABLE filter #-}
<a name="line-264"></a>  filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
<a name="line-265"></a>  filter p [] = []
<a name="line-266"></a>  filter p (x:xs) = if p x then x : filter p xs else filter p xs
<a name="line-267"></a>
<a name="line-268"></a>  {-# NOINLINE [0] filterFB #-}
<a name="line-269"></a>  filterFB :: (a -&gt; b -&gt; b) -&gt; (a -&gt; Bool) -&gt; a -&gt; b -&gt; b
<a name="line-270"></a>  filterFB c p x r | p x       = x `c` r
<a name="line-271"></a>                   | otherwise = r
<a name="line-272"></a>
<a name="line-273"></a>  {-# RULES
<a name="line-274"></a>  "filter"     [~1] forall p xs.  filter p xs = build (\c n -&gt; foldr
<a name="line-275"></a>  (filterFB c p) n xs)
<a name="line-276"></a>  "filterList" [1]  forall p.     foldr (filterFB (:) p) [] = filter p
<a name="line-277"></a>   #-}
<a name="line-278"></a>
<a name="line-279"></a>Then (because RULES are applied inside INLINABLE unfoldings, but inlinings
<a name="line-280"></a>are not), the unfolding given to "filter" in the interface file will be:
<a name="line-281"></a>  filter p []     = []
<a name="line-282"></a>  filter p (x:xs) = if p x then x : build (\c n -&gt; foldr (filterFB c p) n xs)
<a name="line-283"></a>                           else     build (\c n -&gt; foldr (filterFB c p) n xs
<a name="line-284"></a>
<a name="line-285"></a>Note that because this unfolding does not mention "filter", filter is not
<a name="line-286"></a>marked as a strong loop breaker. Therefore at a use site in another module:
<a name="line-287"></a>  filter p xs
<a name="line-288"></a>    = {inline}
<a name="line-289"></a>      case xs of []     -&gt; []
<a name="line-290"></a>                 (x:xs) -&gt; if p x then x : build (\c n -&gt; foldr (filterFB c p) n xs)
<a name="line-291"></a>                                  else     build (\c n -&gt; foldr (filterFB c p) n xs)
<a name="line-292"></a>
<a name="line-293"></a>  build (\c n -&gt; foldr (filterFB c p) n xs)
<a name="line-294"></a>    = {inline} foldr (filterFB (:) p) [] xs
<a name="line-295"></a>    = {RULE}   filter p xs
<a name="line-296"></a>
<a name="line-297"></a>And we are in an infinite loop again, except that this time the loop is producing an
<a name="line-298"></a>infinitely large *term* (an unrolling of filter) and so the simplifier finally
<a name="line-299"></a>dies with "ticks exhausted"
<a name="line-300"></a>
<a name="line-301"></a>SOLUTION: we treat the rule "filterList" as an extra rule for 'filterFB'
<a name="line-302"></a>because it mentions 'filterFB' on the LHS.  This is the Main Invariant
<a name="line-303"></a>in Note [IMP-RULES: local rules for imported functions].
<a name="line-304"></a>
<a name="line-305"></a>So, during loop-breaker analysis:
<a name="line-306"></a>
<a name="line-307"></a>- for each active RULE for a local function 'f' we add an edge between
<a name="line-308"></a>  'f' and the local FVs of the rule RHS
<a name="line-309"></a>
<a name="line-310"></a>- for each active RULE for an *imported* function we add dependency
<a name="line-311"></a>  edges between the *local* FVS of the rule LHS and the *local* FVS of
<a name="line-312"></a>  the rule RHS.
<a name="line-313"></a>
<a name="line-314"></a>Even with this extra hack we aren't always going to get things
<a name="line-315"></a>right. For example, it might be that the rule LHS mentions an imported
<a name="line-316"></a>Id, and another module has a RULE that can rewrite that imported Id to
<a name="line-317"></a>one of our local Ids.
<a name="line-318"></a>
<a name="line-319"></a>Note [Plugin rules]
<a name="line-320"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-321"></a>Conal Elliott (#11651) built a GHC plugin that added some
<a name="line-322"></a>BuiltinRules (for imported Ids) to the mg_rules field of ModGuts, to
<a name="line-323"></a>do some domain-specific transformations that could not be expressed
<a name="line-324"></a>with an ordinary pattern-matching CoreRule.  But then we can't extract
<a name="line-325"></a>the dependencies (in imp_rule_edges) from ru_rhs etc, because a
<a name="line-326"></a>BuiltinRule doesn't have any of that stuff.
<a name="line-327"></a>
<a name="line-328"></a>So we simply assume that BuiltinRules have no dependencies, and filter
<a name="line-329"></a>them out from the imp_rule_edges comprehension.
<a name="line-330"></a>
<a name="line-331"></a>Note [Glomming]
<a name="line-332"></a>~~~~~~~~~~~~~~~
<a name="line-333"></a>RULES for imported Ids can make something at the top refer to
<a name="line-334"></a>something at the bottom:
<a name="line-335"></a>
<a name="line-336"></a>        foo = ...(B.f @Int)...
<a name="line-337"></a>        $sf = blah
<a name="line-338"></a>        RULE:  B.f @Int = $sf
<a name="line-339"></a>
<a name="line-340"></a>Applying this rule makes foo refer to $sf, although foo doesn't appear to
<a name="line-341"></a>depend on $sf.  (And, as in Note [Rules for imported functions], the
<a name="line-342"></a>dependency might be more indirect. For example, foo might mention C.t
<a name="line-343"></a>rather than B.f, where C.t eventually inlines to B.f.)
<a name="line-344"></a>
<a name="line-345"></a>NOTICE that this cannot happen for rules whose head is a
<a name="line-346"></a>locally-defined function, because we accurately track dependencies
<a name="line-347"></a>through RULES.  It only happens for rules whose head is an imported
<a name="line-348"></a>function (B.f in the example above).
<a name="line-349"></a>
<a name="line-350"></a>Solution:
<a name="line-351"></a>  - When simplifying, bring all top level identifiers into
<a name="line-352"></a>    scope at the start, ignoring the Rec/NonRec structure, so
<a name="line-353"></a>    that when 'h' pops up in f's rhs, we find it in the in-scope set
<a name="line-354"></a>    (as the simplifier generally expects). This happens in simplTopBinds.
<a name="line-355"></a>
<a name="line-356"></a>  - In the occurrence analyser, if there are any out-of-scope
<a name="line-357"></a>    occurrences that pop out of the top, which will happen after
<a name="line-358"></a>    firing the rule:      f = \x -&gt; h x
<a name="line-359"></a>                          h = \y -&gt; 3
<a name="line-360"></a>    then just glom all the bindings into a single Rec, so that
<a name="line-361"></a>    the *next* iteration of the occurrence analyser will sort
<a name="line-362"></a>    them all out.   This part happens in occurAnalysePgm.
<a name="line-363"></a>-}</span>
<a name="line-364"></a>
<a name="line-365"></a><span class='hs-comment'>{-
<a name="line-366"></a>************************************************************************
<a name="line-367"></a>*                                                                      *
<a name="line-368"></a>                Bindings
<a name="line-369"></a>*                                                                      *
<a name="line-370"></a>************************************************************************
<a name="line-371"></a>
<a name="line-372"></a>Note [Recursive bindings: the grand plan]
<a name="line-373"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-374"></a>Loop breaking is surprisingly subtle.  First read the section 4 of
<a name="line-375"></a>"Secrets of the GHC inliner".  This describes our basic plan.  We
<a name="line-376"></a>avoid infinite inlinings by choosing loop breakers, and ensuring that
<a name="line-377"></a>a loop breaker cuts each loop.
<a name="line-378"></a>
<a name="line-379"></a>See also Note [Inlining and hs-boot files] in GHC.Core.ToIface, which
<a name="line-380"></a>deals with a closely related source of infinite loops.
<a name="line-381"></a>
<a name="line-382"></a>When we come across a binding group
<a name="line-383"></a>  Rec { x1 = r1; ...; xn = rn }
<a name="line-384"></a>we treat it like this (occAnalRecBind):
<a name="line-385"></a>
<a name="line-386"></a>1. Note [Forming Rec groups]
<a name="line-387"></a>   Occurrence-analyse each right hand side, and build a
<a name="line-388"></a>   "Details" for each binding to capture the results.
<a name="line-389"></a>   Wrap the details in a LetrecNode, ready for SCC analysis.
<a name="line-390"></a>   All this is done by makeNode.
<a name="line-391"></a>
<a name="line-392"></a>   The edges of this graph are the "scope edges".
<a name="line-393"></a>
<a name="line-394"></a>2. Do SCC-analysis on these Nodes:
<a name="line-395"></a>   - Each CyclicSCC will become a new Rec
<a name="line-396"></a>   - Each AcyclicSCC will become a new NonRec
<a name="line-397"></a>
<a name="line-398"></a>   The key property is that every free variable of a binding is
<a name="line-399"></a>   accounted for by the scope edges, so that when we are done
<a name="line-400"></a>   everything is still in scope.
<a name="line-401"></a>
<a name="line-402"></a>3. For each AcyclicSCC, just make a NonRec binding.
<a name="line-403"></a>
<a name="line-404"></a>4. For each CyclicSCC of the scope-edge SCC-analysis in (2), we
<a name="line-405"></a>   identify suitable loop-breakers to ensure that inlining terminates.
<a name="line-406"></a>   This is done by occAnalRec.
<a name="line-407"></a>
<a name="line-408"></a>   To do so, form the loop-breaker graph, do SCC analysis. For each
<a name="line-409"></a>   CyclicSCC we choose a loop breaker, delete all edges to that node,
<a name="line-410"></a>   re-analyse the SCC, and iterate. See Note [Choosing loop breakers]
<a name="line-411"></a>   for the details
<a name="line-412"></a>
<a name="line-413"></a>
<a name="line-414"></a>Note [Dead code]
<a name="line-415"></a>~~~~~~~~~~~~~~~~
<a name="line-416"></a>Dropping dead code for a cyclic Strongly Connected Component is done
<a name="line-417"></a>in a very simple way:
<a name="line-418"></a>
<a name="line-419"></a>        the entire SCC is dropped if none of its binders are mentioned
<a name="line-420"></a>        in the body; otherwise the whole thing is kept.
<a name="line-421"></a>
<a name="line-422"></a>The key observation is that dead code elimination happens after
<a name="line-423"></a>dependency analysis: so 'occAnalBind' processes SCCs instead of the
<a name="line-424"></a>original term's binding groups.
<a name="line-425"></a>
<a name="line-426"></a>Thus 'occAnalBind' does indeed drop 'f' in an example like
<a name="line-427"></a>
<a name="line-428"></a>        letrec f = ...g...
<a name="line-429"></a>               g = ...(...g...)...
<a name="line-430"></a>        in
<a name="line-431"></a>           ...g...
<a name="line-432"></a>
<a name="line-433"></a>when 'g' no longer uses 'f' at all (eg 'f' does not occur in a RULE in
<a name="line-434"></a>'g'). 'occAnalBind' first consumes 'CyclicSCC g' and then it consumes
<a name="line-435"></a>'AcyclicSCC f', where 'body_usage' won't contain 'f'.
<a name="line-436"></a>
<a name="line-437"></a>Note [Forming Rec groups]
<a name="line-438"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-439"></a>The key point about the "Forming Rec groups" step is that it /preserves
<a name="line-440"></a>scoping/.  If 'x' is mentioned, it had better be bound somewhere.  So if
<a name="line-441"></a>we start with
<a name="line-442"></a>  Rec { f = ...h...
<a name="line-443"></a>      ; g = ...f...
<a name="line-444"></a>      ; h = ...f... }
<a name="line-445"></a>we can split into SCCs
<a name="line-446"></a>  Rec { f = ...h...
<a name="line-447"></a>      ; h = ..f... }
<a name="line-448"></a>  NonRec { g = ...f... }
<a name="line-449"></a>
<a name="line-450"></a>We put bindings {f = ef; g = eg } in a Rec group if "f uses g" and "g
<a name="line-451"></a>uses f", no matter how indirectly.  We do a SCC analysis with an edge
<a name="line-452"></a>f -&gt; g if "f mentions g". That is, g is free in:
<a name="line-453"></a>  a) the rhs 'ef'
<a name="line-454"></a>  b) or the RHS of a rule for f, whether active or inactive
<a name="line-455"></a>       Note [Rules are extra RHSs]
<a name="line-456"></a>  c) or the LHS or a rule for f, whether active or inactive
<a name="line-457"></a>       Note [Rule dependency info]
<a name="line-458"></a>  d) the RHS of an /active/ local IMP-RULE
<a name="line-459"></a>       Note [IMP-RULES: local rules for imported functions]
<a name="line-460"></a>
<a name="line-461"></a>(b) and (c) apply regardless of the activation of the RULE, because even if
<a name="line-462"></a>the rule is inactive its free variables must be bound.  But (d) doesn't need
<a name="line-463"></a>to worry about this because IMP-RULES are always notionally at the bottom
<a name="line-464"></a>of the file.
<a name="line-465"></a>
<a name="line-466"></a>  * Note [Rules are extra RHSs]
<a name="line-467"></a>    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-468"></a>    A RULE for 'f' is like an extra RHS for 'f'. That way the "parent"
<a name="line-469"></a>    keeps the specialised "children" alive.  If the parent dies
<a name="line-470"></a>    (because it isn't referenced any more), then the children will die
<a name="line-471"></a>    too (unless they are already referenced directly).
<a name="line-472"></a>
<a name="line-473"></a>    So in Example [eftInt], eftInt and eftIntFB will be put in the
<a name="line-474"></a>    same Rec, even though their 'main' RHSs are both non-recursive.
<a name="line-475"></a>
<a name="line-476"></a>    We must also include inactive rules, so that their free vars
<a name="line-477"></a>    remain in scope.
<a name="line-478"></a>
<a name="line-479"></a>  * Note [Rule dependency info]
<a name="line-480"></a>    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-481"></a>    The VarSet in a RuleInfo is used for dependency analysis in the
<a name="line-482"></a>    occurrence analyser.  We must track free vars in *both* lhs and rhs.
<a name="line-483"></a>    Hence use of idRuleVars, rather than idRuleRhsVars in occAnalBind.
<a name="line-484"></a>    Why both? Consider
<a name="line-485"></a>        x = y
<a name="line-486"></a>        RULE f x = v+4
<a name="line-487"></a>    Then if we substitute y for x, we'd better do so in the
<a name="line-488"></a>    rule's LHS too, so we'd better ensure the RULE appears to mention 'x'
<a name="line-489"></a>    as well as 'v'
<a name="line-490"></a>
<a name="line-491"></a>  * Note [Rules are visible in their own rec group]
<a name="line-492"></a>    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-493"></a>    We want the rules for 'f' to be visible in f's right-hand side.
<a name="line-494"></a>    And we'd like them to be visible in other functions in f's Rec
<a name="line-495"></a>    group.  E.g. in Note [Specialisation rules] we want f' rule
<a name="line-496"></a>    to be visible in both f's RHS, and fs's RHS.
<a name="line-497"></a>
<a name="line-498"></a>    This means that we must simplify the RULEs first, before looking
<a name="line-499"></a>    at any of the definitions.  This is done by Simplify.simplRecBind,
<a name="line-500"></a>    when it calls addLetIdInfo.
<a name="line-501"></a>
<a name="line-502"></a>Note [Stable unfoldings]
<a name="line-503"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-504"></a>None of the above stuff about RULES applies to a stable unfolding
<a name="line-505"></a>stored in a CoreUnfolding.  The unfolding, if any, is simplified
<a name="line-506"></a>at the same time as the regular RHS of the function (ie *not* like
<a name="line-507"></a>Note [Rules are visible in their own rec group]), so it should be
<a name="line-508"></a>treated *exactly* like an extra RHS.
<a name="line-509"></a>
<a name="line-510"></a>Or, rather, when computing loop-breaker edges,
<a name="line-511"></a>  * If f has an INLINE pragma, and it is active, we treat the
<a name="line-512"></a>    INLINE rhs as f's rhs
<a name="line-513"></a>  * If it's inactive, we treat f as having no rhs
<a name="line-514"></a>  * If it has no INLINE pragma, we look at f's actual rhs
<a name="line-515"></a>
<a name="line-516"></a>
<a name="line-517"></a>There is a danger that we'll be sub-optimal if we see this
<a name="line-518"></a>     f = ...f...
<a name="line-519"></a>     [INLINE f = ..no f...]
<a name="line-520"></a>where f is recursive, but the INLINE is not. This can just about
<a name="line-521"></a>happen with a sufficiently odd set of rules; eg
<a name="line-522"></a>
<a name="line-523"></a>        foo :: Int -&gt; Int
<a name="line-524"></a>        {-# INLINE [1] foo #-}
<a name="line-525"></a>        foo x = x+1
<a name="line-526"></a>
<a name="line-527"></a>        bar :: Int -&gt; Int
<a name="line-528"></a>        {-# INLINE [1] bar #-}
<a name="line-529"></a>        bar x = foo x + 1
<a name="line-530"></a>
<a name="line-531"></a>        {-# RULES "foo" [~1] forall x. foo x = bar x #-}
<a name="line-532"></a>
<a name="line-533"></a>Here the RULE makes bar recursive; but it's INLINE pragma remains
<a name="line-534"></a>non-recursive. It's tempting to then say that 'bar' should not be
<a name="line-535"></a>a loop breaker, but an attempt to do so goes wrong in two ways:
<a name="line-536"></a>   a) We may get
<a name="line-537"></a>         $df = ...$cfoo...
<a name="line-538"></a>         $cfoo = ...$df....
<a name="line-539"></a>         [INLINE $cfoo = ...no-$df...]
<a name="line-540"></a>      But we want $cfoo to depend on $df explicitly so that we
<a name="line-541"></a>      put the bindings in the right order to inline $df in $cfoo
<a name="line-542"></a>      and perhaps break the loop altogether.  (Maybe this
<a name="line-543"></a>   b)
<a name="line-544"></a>
<a name="line-545"></a>
<a name="line-546"></a>Example [eftInt]
<a name="line-547"></a>~~~~~~~~~~~~~~~
<a name="line-548"></a>Example (from GHC.Enum):
<a name="line-549"></a>
<a name="line-550"></a>  eftInt :: Int# -&gt; Int# -&gt; [Int]
<a name="line-551"></a>  eftInt x y = ...(non-recursive)...
<a name="line-552"></a>
<a name="line-553"></a>  {-# INLINE [0] eftIntFB #-}
<a name="line-554"></a>  eftIntFB :: (Int -&gt; r -&gt; r) -&gt; r -&gt; Int# -&gt; Int# -&gt; r
<a name="line-555"></a>  eftIntFB c n x y = ...(non-recursive)...
<a name="line-556"></a>
<a name="line-557"></a>  {-# RULES
<a name="line-558"></a>  "eftInt"  [~1] forall x y. eftInt x y = build (\ c n -&gt; eftIntFB c n x y)
<a name="line-559"></a>  "eftIntList"  [1] eftIntFB  (:) [] = eftInt
<a name="line-560"></a>   #-}
<a name="line-561"></a>
<a name="line-562"></a>Note [Specialisation rules]
<a name="line-563"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-564"></a>Consider this group, which is typical of what SpecConstr builds:
<a name="line-565"></a>
<a name="line-566"></a>   fs a = ....f (C a)....
<a name="line-567"></a>   f  x = ....f (C a)....
<a name="line-568"></a>   {-# RULE f (C a) = fs a #-}
<a name="line-569"></a>
<a name="line-570"></a>So 'f' and 'fs' are in the same Rec group (since f refers to fs via its RULE).
<a name="line-571"></a>
<a name="line-572"></a>But watch out!  If 'fs' is not chosen as a loop breaker, we may get an infinite loop:
<a name="line-573"></a>  - the RULE is applied in f's RHS (see Note [Self-recursive rules] in GHC.Core.Opt.Simplify
<a name="line-574"></a>  - fs is inlined (say it's small)
<a name="line-575"></a>  - now there's another opportunity to apply the RULE
<a name="line-576"></a>
<a name="line-577"></a>This showed up when compiling Control.Concurrent.Chan.getChanContents.
<a name="line-578"></a>Hence the transitive rule_fv_env stuff described in
<a name="line-579"></a>Note [Rules and  loop breakers].
<a name="line-580"></a>
<a name="line-581"></a>------------------------------------------------------------
<a name="line-582"></a>Note [Finding join points]
<a name="line-583"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-584"></a>It's the occurrence analyser's job to find bindings that we can turn into join
<a name="line-585"></a>points, but it doesn't perform that transformation right away. Rather, it marks
<a name="line-586"></a>the eligible bindings as part of their occurrence data, leaving it to the
<a name="line-587"></a>simplifier (or to simpleOptPgm) to actually change the binder's 'IdDetails'.
<a name="line-588"></a>The simplifier then eta-expands the RHS if needed and then updates the
<a name="line-589"></a>occurrence sites. Dividing the work this way means that the occurrence analyser
<a name="line-590"></a>still only takes one pass, yet one can always tell the difference between a
<a name="line-591"></a>function call and a jump by looking at the occurrence (because the same pass
<a name="line-592"></a>changes the 'IdDetails' and propagates the binders to their occurrence sites).
<a name="line-593"></a>
<a name="line-594"></a>To track potential join points, we use the 'occ_tail' field of OccInfo. A value
<a name="line-595"></a>of `AlwaysTailCalled n` indicates that every occurrence of the variable is a
<a name="line-596"></a>tail call with `n` arguments (counting both value and type arguments). Otherwise
<a name="line-597"></a>'occ_tail' will be 'NoTailCallInfo'. The tail call info flows bottom-up with the
<a name="line-598"></a>rest of 'OccInfo' until it goes on the binder.
<a name="line-599"></a>
<a name="line-600"></a>Note [Join points and unfoldings/rules]
<a name="line-601"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-602"></a>Consider
<a name="line-603"></a>   let j2 y = blah
<a name="line-604"></a>   let j x = j2 (x+x)
<a name="line-605"></a>       {-# INLINE [2] j #-}
<a name="line-606"></a>   in case e of { A -&gt; j 1; B -&gt; ...; C -&gt; j 2 }
<a name="line-607"></a>
<a name="line-608"></a>Before j is inlined, we'll have occurrences of j2 in
<a name="line-609"></a>both j's RHS and in its stable unfolding.  We want to discover
<a name="line-610"></a>j2 as a join point.  So we must do the adjustRhsUsage thing
<a name="line-611"></a>on j's RHS.  That's why we pass mb_join_arity to calcUnfolding.
<a name="line-612"></a>
<a name="line-613"></a>Aame with rules. Suppose we have:
<a name="line-614"></a>
<a name="line-615"></a>  let j :: Int -&gt; Int
<a name="line-616"></a>      j y = 2 * y
<a name="line-617"></a>  let k :: Int -&gt; Int -&gt; Int
<a name="line-618"></a>      {-# RULES "SPEC k 0" k 0 y = j y #-}
<a name="line-619"></a>      k x y = x + 2 * y
<a name="line-620"></a>  in case e of { A -&gt; k 1 2; B -&gt; k 3 5; C -&gt; blah }
<a name="line-621"></a>
<a name="line-622"></a>We identify k as a join point, and we want j to be a join point too.
<a name="line-623"></a>Without the RULE it would be, and we don't want the RULE to mess it
<a name="line-624"></a>up.  So provided the join-point arity of k matches the args of the
<a name="line-625"></a>rule we can allow the tail-cal info from the RHS of the rule to
<a name="line-626"></a>propagate.
<a name="line-627"></a>
<a name="line-628"></a>* Wrinkle for Rec case. In the recursive case we don't know the
<a name="line-629"></a>  join-point arity in advance, when calling occAnalUnfolding and
<a name="line-630"></a>  occAnalRules.  (See makeNode.)  We don't want to pass Nothing,
<a name="line-631"></a>  because then a recursive joinrec might lose its join-poin-hood
<a name="line-632"></a>  when SpecConstr adds a RULE.  So we just make do with the
<a name="line-633"></a>  *current* join-poin-hood, stored in the Id.
<a name="line-634"></a>
<a name="line-635"></a>  In the non-recursive case things are simple: see occAnalNonRecBind
<a name="line-636"></a>
<a name="line-637"></a>* Wrinkle for RULES.  Suppose the example was a bit different:
<a name="line-638"></a>      let j :: Int -&gt; Int
<a name="line-639"></a>          j y = 2 * y
<a name="line-640"></a>          k :: Int -&gt; Int -&gt; Int
<a name="line-641"></a>          {-# RULES "SPEC k 0" k 0 = j #-}
<a name="line-642"></a>          k x y = x + 2 * y
<a name="line-643"></a>      in ...
<a name="line-644"></a>  If we eta-expanded the rule all would be well, but as it stands the
<a name="line-645"></a>  one arg of the rule don't match the join-point arity of 2.
<a name="line-646"></a>
<a name="line-647"></a>  Conceivably we could notice that a potential join point would have
<a name="line-648"></a>  an "undersaturated" rule and account for it. This would mean we
<a name="line-649"></a>  could make something that's been specialised a join point, for
<a name="line-650"></a>  instance. But local bindings are rarely specialised, and being
<a name="line-651"></a>  overly cautious about rules only costs us anything when, for some `j`:
<a name="line-652"></a>
<a name="line-653"></a>  * Before specialisation, `j` has non-tail calls, so it can't be a join point.
<a name="line-654"></a>  * During specialisation, `j` gets specialised and thus acquires rules.
<a name="line-655"></a>  * Sometime afterward, the non-tail calls to `j` disappear (as dead code, say),
<a name="line-656"></a>    and so now `j` *could* become a join point.
<a name="line-657"></a>
<a name="line-658"></a>  This appears to be very rare in practice. TODO Perhaps we should gather
<a name="line-659"></a>  statistics to be sure.
<a name="line-660"></a>
<a name="line-661"></a>Note [Unfoldings and join points]
<a name="line-662"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-663"></a>We assume that anything in an unfolding occurs multiple times, since
<a name="line-664"></a>unfoldings are often copied (that's the whole point!). But we still
<a name="line-665"></a>need to track tail calls for the purpose of finding join points.
<a name="line-666"></a>
<a name="line-667"></a>
<a name="line-668"></a>------------------------------------------------------------
<a name="line-669"></a>Note [Adjusting right-hand sides]
<a name="line-670"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-671"></a>There's a bit of a dance we need to do after analysing a lambda expression or
<a name="line-672"></a>a right-hand side. In particular, we need to
<a name="line-673"></a>
<a name="line-674"></a>  a) call 'markAllInsideLam' *unless* the binding is for a thunk, a one-shot
<a name="line-675"></a>     lambda, or a non-recursive join point; and
<a name="line-676"></a>  b) call 'markAllNonTail' *unless* the binding is for a join point.
<a name="line-677"></a>
<a name="line-678"></a>Some examples, with how the free occurrences in e (assumed not to be a value
<a name="line-679"></a>lambda) get marked:
<a name="line-680"></a>
<a name="line-681"></a>                             inside lam    non-tail-called
<a name="line-682"></a>  ------------------------------------------------------------
<a name="line-683"></a>  let x = e                  No            Yes
<a name="line-684"></a>  let f = \x -&gt; e            Yes           Yes
<a name="line-685"></a>  let f = \x{OneShot} -&gt; e   No            Yes
<a name="line-686"></a>  \x -&gt; e                    Yes           Yes
<a name="line-687"></a>  join j x = e               No            No
<a name="line-688"></a>  joinrec j x = e            Yes           No
<a name="line-689"></a>
<a name="line-690"></a>There are a few other caveats; most importantly, if we're marking a binding as
<a name="line-691"></a>'AlwaysTailCalled', it's *going* to be a join point, so we treat it as one so
<a name="line-692"></a>that the effect cascades properly. Consequently, at the time the RHS is
<a name="line-693"></a>analysed, we won't know what adjustments to make; thus 'occAnalLamOrRhs' must
<a name="line-694"></a>return the unadjusted 'UsageDetails', to be adjusted by 'adjustRhsUsage' once
<a name="line-695"></a>join-point-hood has been decided.
<a name="line-696"></a>
<a name="line-697"></a>Thus the overall sequence taking place in 'occAnalNonRecBind' and
<a name="line-698"></a>'occAnalRecBind' is as follows:
<a name="line-699"></a>
<a name="line-700"></a>  1. Call 'occAnalLamOrRhs' to find usage information for the RHS.
<a name="line-701"></a>  2. Call 'tagNonRecBinder' or 'tagRecBinders', which decides whether to make
<a name="line-702"></a>     the binding a join point.
<a name="line-703"></a>  3. Call 'adjustRhsUsage' accordingly. (Done as part of 'tagRecBinders' when
<a name="line-704"></a>     recursive.)
<a name="line-705"></a>
<a name="line-706"></a>(In the recursive case, this logic is spread between 'makeNode' and
<a name="line-707"></a>'occAnalRec'.)
<a name="line-708"></a>-}</span>
<a name="line-709"></a>
<a name="line-710"></a><span class='hs-comment'>------------------------------------------------------------------</span>
<a name="line-711"></a><span class='hs-comment'>--                 occAnalBind</span>
<a name="line-712"></a><span class='hs-comment'>------------------------------------------------------------------</span>
<a name="line-713"></a>
<a name="line-714"></a><a name="occAnalBind"></a><span class='hs-definition'>occAnalBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>           <span class='hs-comment'>-- The incoming OccEnv</span>
<a name="line-715"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-716"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ImpRuleEdges</span>
<a name="line-717"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-718"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>             <span class='hs-comment'>-- Usage details of scope</span>
<a name="line-719"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>           <span class='hs-comment'>-- Of the whole let(rec)</span>
<a name="line-720"></a>                <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-721"></a>
<a name="line-722"></a><span class='hs-definition'>occAnalBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>top_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body_usage</span>
<a name="line-723"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalNonRecBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>top_env</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>body_usage</span>
<a name="line-724"></a><span class='hs-definition'>occAnalBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>top_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body_usage</span>
<a name="line-725"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRecBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>top_env</span> <span class='hs-varid'>pairs</span> <span class='hs-varid'>body_usage</span>
<a name="line-726"></a>
<a name="line-727"></a><a name="occAnalNonRecBind"></a><span class='hs-comment'>-----------------</span>
<a name="line-728"></a><span class='hs-definition'>occAnalNonRecBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ImpRuleEdges</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-729"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-730"></a><span class='hs-definition'>occAnalNonRecBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>body_usage</span>
<a name="line-731"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span>      <span class='hs-comment'>-- A type let; we don't gather usage info</span>
<a name="line-732"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-733"></a>
<a name="line-734"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span> <span class='hs-varop'>`usedIn`</span> <span class='hs-varid'>body_usage</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- It's not mentioned</span>
<a name="line-735"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-736"></a>
<a name="line-737"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                   <span class='hs-comment'>-- It's mentioned in the body</span>
<a name="line-738"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage'</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>rhs_usage</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>final_bndr</span> <span class='hs-varid'>rhs'</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-739"></a>  <span class='hs-keyword'>where</span>
<a name="line-740"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_usage'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_bndr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagNonRecBinder</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>body_usage</span> <span class='hs-varid'>bndr</span>
<a name="line-741"></a>    <span class='hs-varid'>final_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagged_bndr</span> <span class='hs-varop'>`setIdUnfolding`</span> <span class='hs-varid'>unf'</span>
<a name="line-742"></a>                             <span class='hs-varop'>`setIdSpecialisation`</span> <span class='hs-varid'>mkRuleInfo</span> <span class='hs-varid'>rules'</span>
<a name="line-743"></a>    <span class='hs-varid'>rhs_usage</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_uds</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>unf_uds</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>rule_uds</span>
<a name="line-744"></a>
<a name="line-745"></a>    <span class='hs-comment'>-- Get the join info from the *new* decision</span>
<a name="line-746"></a>    <span class='hs-comment'>-- See Note [Join points and unfoldings/rules]</span>
<a name="line-747"></a>    <span class='hs-varid'>mb_join_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>willBeJoinId_maybe</span> <span class='hs-varid'>tagged_bndr</span>
<a name="line-748"></a>    <span class='hs-varid'>is_join_point</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>mb_join_arity</span>
<a name="line-749"></a>
<a name="line-750"></a>    <span class='hs-comment'>--------- Right hand side ---------</span>
<a name="line-751"></a>    <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_join_point</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>  <span class='hs-comment'>-- See Note [Join point RHSs]</span>
<a name="line-752"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>certainly_inline</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>  <span class='hs-comment'>-- See Note [Cascading inlines]</span>
<a name="line-753"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhsCtxt</span> <span class='hs-varid'>env</span>
<a name="line-754"></a>
<a name="line-755"></a>    <span class='hs-comment'>-- See Note [Sources of one-shot information]</span>
<a name="line-756"></a>    <span class='hs-varid'>rhs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env1</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>argOneShots</span> <span class='hs-varid'>dmd</span> <span class='hs-layout'>}</span>
<a name="line-757"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rhs_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRhs</span> <span class='hs-varid'>rhs_env</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>rhs</span>
<a name="line-758"></a>
<a name="line-759"></a>    <span class='hs-comment'>--------- Unfolding ---------</span>
<a name="line-760"></a>    <span class='hs-comment'>-- See Note [Unfoldings and join points]</span>
<a name="line-761"></a>    <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span>
<a name="line-762"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unf_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>unf'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalUnfolding</span> <span class='hs-varid'>rhs_env</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>unf</span>
<a name="line-763"></a>
<a name="line-764"></a>    <span class='hs-comment'>--------- Rules ---------</span>
<a name="line-765"></a>    <span class='hs-comment'>-- See Note [Rules are extra RHSs] and Note [Rule dependency info]</span>
<a name="line-766"></a>    <span class='hs-varid'>rules_w_uds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRules</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndr</span>
<a name="line-767"></a>    <span class='hs-varid'>rules'</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fstOf3</span> <span class='hs-varid'>rules_w_uds</span>
<a name="line-768"></a>    <span class='hs-varid'>imp_rule_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>impRulesScopeUsage</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupImpRules</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-769"></a>         <span class='hs-comment'>-- imp_rule_uds: consider</span>
<a name="line-770"></a>         <span class='hs-comment'>--     h = ...</span>
<a name="line-771"></a>         <span class='hs-comment'>--     g = ...</span>
<a name="line-772"></a>         <span class='hs-comment'>--     RULE map g = h</span>
<a name="line-773"></a>         <span class='hs-comment'>-- Then we want to ensure that h is in scope everwhere</span>
<a name="line-774"></a>         <span class='hs-comment'>-- that g is (since the RULE might turn g into h), so</span>
<a name="line-775"></a>         <span class='hs-comment'>-- we make g mention h.</span>
<a name="line-776"></a>
<a name="line-777"></a>    <span class='hs-varid'>rule_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add_rule_uds</span> <span class='hs-varid'>imp_rule_uds</span> <span class='hs-varid'>rules_w_uds</span>
<a name="line-778"></a>    <span class='hs-varid'>add_rule_uds</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>r</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>uds</span>
<a name="line-779"></a>
<a name="line-780"></a>    <span class='hs-comment'>----------</span>
<a name="line-781"></a>    <span class='hs-varid'>occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>tagged_bndr</span>
<a name="line-782"></a>    <span class='hs-varid'>certainly_inline</span> <span class='hs-comment'>-- See Note [Cascading inlines]</span>
<a name="line-783"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occ</span> <span class='hs-keyword'>of</span>
<a name="line-784"></a>          <span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NotInsideLam</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_n_br</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-layout'>}</span>
<a name="line-785"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>active</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not_stable</span>
<a name="line-786"></a>          <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-787"></a>
<a name="line-788"></a>    <span class='hs-varid'>dmd</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>bndr</span>
<a name="line-789"></a>    <span class='hs-varid'>active</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isAlwaysActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-790"></a>    <span class='hs-varid'>not_stable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-791"></a>
<a name="line-792"></a><a name="occAnalRecBind"></a><span class='hs-comment'>-----------------</span>
<a name="line-793"></a><span class='hs-definition'>occAnalRecBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ImpRuleEdges</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-794"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-795"></a><span class='hs-comment'>-- For a recursive group, we</span>
<a name="line-796"></a><span class='hs-comment'>--      * occ-analyse all the RHSs</span>
<a name="line-797"></a><span class='hs-comment'>--      * compute strongly-connected components</span>
<a name="line-798"></a><span class='hs-comment'>--      * feed those components to occAnalRec</span>
<a name="line-799"></a><span class='hs-comment'>-- See Note [Recursive bindings: the grand plan]</span>
<a name="line-800"></a><span class='hs-definition'>occAnalRecBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>pairs</span> <span class='hs-varid'>body_usage</span>
<a name="line-801"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>occAnalRec</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>lvl</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>sccs</span>
<a name="line-802"></a>  <span class='hs-keyword'>where</span>
<a name="line-803"></a>    <span class='hs-varid'>sccs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>SCC</span> <span class='hs-conid'>Details</span><span class='hs-keyglyph'>]</span>
<a name="line-804"></a>    <span class='hs-varid'>sccs</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "occAnalBind.scc" #-}</span>
<a name="line-805"></a>           <span class='hs-varid'>stronglyConnCompFromEdgedVerticesUniq</span> <span class='hs-varid'>nodes</span>
<a name="line-806"></a>
<a name="line-807"></a>    <span class='hs-varid'>nodes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span>
<a name="line-808"></a>    <span class='hs-varid'>nodes</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "occAnalBind.assoc" #-}</span>
<a name="line-809"></a>            <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>makeNode</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr_set</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span>
<a name="line-810"></a>
<a name="line-811"></a>    <span class='hs-varid'>bndrs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>pairs</span>
<a name="line-812"></a>    <span class='hs-varid'>bndr_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>bndrs</span>
<a name="line-813"></a>    <span class='hs-varid'>rhs_env</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-varid'>bndrs</span>
<a name="line-814"></a>
<a name="line-815"></a>
<a name="line-816"></a><a name="occAnalRec"></a><span class='hs-comment'>-----------------------------</span>
<a name="line-817"></a><span class='hs-definition'>occAnalRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-818"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SCC</span> <span class='hs-conid'>Details</span>
<a name="line-819"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-820"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-821"></a>
<a name="line-822"></a>        <span class='hs-comment'>-- The NonRec case is just like a Let (NonRec ...) above</span>
<a name="line-823"></a><span class='hs-definition'>occAnalRec</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>lvl</span> <span class='hs-layout'>(</span><span class='hs-conid'>AcyclicSCC</span> <span class='hs-layout'>(</span><span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-824"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_bndrs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-825"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>body_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-826"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span> <span class='hs-varop'>`usedIn`</span> <span class='hs-varid'>body_uds</span><span class='hs-layout'>)</span>
<a name="line-827"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- See Note [Dead code]</span>
<a name="line-828"></a>
<a name="line-829"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                   <span class='hs-comment'>-- It's mentioned in the body</span>
<a name="line-830"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_uds'</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>rhs_uds'</span><span class='hs-layout'>,</span>
<a name="line-831"></a>     <span class='hs-conid'>NonRec</span> <span class='hs-varid'>tagged_bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-832"></a>  <span class='hs-keyword'>where</span>
<a name="line-833"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_uds'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_bndr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagNonRecBinder</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>body_uds</span> <span class='hs-varid'>bndr</span>
<a name="line-834"></a>    <span class='hs-varid'>rhs_uds'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adjustRhsUsage</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-layout'>(</span><span class='hs-varid'>willBeJoinId_maybe</span> <span class='hs-varid'>tagged_bndr</span><span class='hs-layout'>)</span>
<a name="line-835"></a>                                <span class='hs-varid'>rhs_bndrs</span> <span class='hs-varid'>rhs_uds</span>
<a name="line-836"></a>
<a name="line-837"></a>        <span class='hs-comment'>-- The Rec case is the interesting one</span>
<a name="line-838"></a>        <span class='hs-comment'>-- See Note [Recursive bindings: the grand plan]</span>
<a name="line-839"></a>        <span class='hs-comment'>-- See Note [Loop breaking]</span>
<a name="line-840"></a><span class='hs-definition'>occAnalRec</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-layout'>(</span><span class='hs-conid'>CyclicSCC</span> <span class='hs-varid'>details_s</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-841"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`usedIn`</span> <span class='hs-varid'>body_uds</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- NB: look at body_uds, not total_uds</span>
<a name="line-842"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>                   <span class='hs-comment'>-- See Note [Dead code]</span>
<a name="line-843"></a>
<a name="line-844"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- At this point we always build a single Rec</span>
<a name="line-845"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "occAnalRec" (ppr loop_breaker_nodes)</span>
<a name="line-846"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_uds</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-847"></a>
<a name="line-848"></a>  <span class='hs-keyword'>where</span>
<a name="line-849"></a>    <span class='hs-varid'>bndrs</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-varid'>details_s</span>
<a name="line-850"></a>    <span class='hs-varid'>all_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>nd_simple</span> <span class='hs-varid'>details_s</span>
<a name="line-851"></a>
<a name="line-852"></a>    <span class='hs-comment'>------------------------------</span>
<a name="line-853"></a>    <span class='hs-comment'>-- Make the nodes for the loop-breaker analysis</span>
<a name="line-854"></a>    <span class='hs-comment'>-- See Note [Choosing loop breakers] for loop_breaker_nodes</span>
<a name="line-855"></a>    <span class='hs-varid'>final_uds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-856"></a>    <span class='hs-varid'>loop_breaker_nodes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span>
<a name="line-857"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>loop_breaker_nodes</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLoopBreakerNodes</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>body_uds</span> <span class='hs-varid'>details_s</span>
<a name="line-858"></a>
<a name="line-859"></a>    <span class='hs-comment'>------------------------------</span>
<a name="line-860"></a>    <span class='hs-varid'>weak_fvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span>
<a name="line-861"></a>    <span class='hs-varid'>weak_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapUnionVarSet</span> <span class='hs-varid'>nd_weak_fvs</span> <span class='hs-varid'>details_s</span>
<a name="line-862"></a>
<a name="line-863"></a>    <span class='hs-comment'>---------------------------</span>
<a name="line-864"></a>    <span class='hs-comment'>-- Now reconstruct the cycle</span>
<a name="line-865"></a>    <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-866"></a>    <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reOrderNodes</span>   <span class='hs-num'>0</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-varid'>loop_breaker_nodes</span> <span class='hs-conid'>[]</span>
<a name="line-867"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loopBreakNodes</span> <span class='hs-num'>0</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-varid'>loop_breaker_nodes</span> <span class='hs-conid'>[]</span>
<a name="line-868"></a>          <span class='hs-comment'>-- In the common case when all are "simple" (no rules at all)</span>
<a name="line-869"></a>          <span class='hs-comment'>-- the loop_breaker_nodes will include all the scope edges</span>
<a name="line-870"></a>          <span class='hs-comment'>-- so a SCC computation would yield a single CyclicSCC result;</span>
<a name="line-871"></a>          <span class='hs-comment'>-- and reOrderNodes deals with exactly that case.</span>
<a name="line-872"></a>          <span class='hs-comment'>-- Saves a SCC analysis in a common case</span>
<a name="line-873"></a>
<a name="line-874"></a>
<a name="line-875"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-876"></a>*                                                                      *
<a name="line-877"></a>                Loop breaking
<a name="line-878"></a>*                                                                      *
<a name="line-879"></a>********************************************************************* -}</span>
<a name="line-880"></a>
<a name="line-881"></a><span class='hs-comment'>{- Note [Choosing loop breakers]
<a name="line-882"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-883"></a>In Step 4 in Note [Recursive bindings: the grand plan]), occAnalRec does
<a name="line-884"></a>loop-breaking on each CyclicSCC of the original program:
<a name="line-885"></a>
<a name="line-886"></a>* mkLoopBreakerNodes: Form the loop-breaker graph for that CyclicSCC
<a name="line-887"></a>
<a name="line-888"></a>* loopBreakNodes: Do SCC analysis on it
<a name="line-889"></a>
<a name="line-890"></a>* reOrderNodes: For each CyclicSCC, pick a loop breaker
<a name="line-891"></a>    * Delete edges to that loop breaker
<a name="line-892"></a>    * Do another SCC analysis on that reduced SCC
<a name="line-893"></a>    * Repeat
<a name="line-894"></a>
<a name="line-895"></a>To form the loop-breaker graph, we construct a new set of Nodes, the
<a name="line-896"></a>"loop-breaker nodes", with the same details but different edges, the
<a name="line-897"></a>"loop-breaker edges".  The loop-breaker nodes have both more and fewer
<a name="line-898"></a>dependencies than the scope edges:
<a name="line-899"></a>
<a name="line-900"></a>  More edges:
<a name="line-901"></a>     If f calls g, and g has an active rule that mentions h then
<a name="line-902"></a>     we add an edge from f -&gt; h.  See Note [Rules and loop breakers].
<a name="line-903"></a>
<a name="line-904"></a>  Fewer edges: we only include dependencies
<a name="line-905"></a>     * only on /active/ rules,
<a name="line-906"></a>     * on rule /RHSs/ (not LHSs)
<a name="line-907"></a>
<a name="line-908"></a>The scope edges, by contrast, must be much more inclusive.
<a name="line-909"></a>
<a name="line-910"></a>The nd_simple flag tracks the common case when a binding has no RULES
<a name="line-911"></a>at all, in which case the loop-breaker edges will be identical to the
<a name="line-912"></a>scope edges.
<a name="line-913"></a>
<a name="line-914"></a>Note that in Example [eftInt], *neither* eftInt *nor* eftIntFB is
<a name="line-915"></a>chosen as a loop breaker, because their RHSs don't mention each other.
<a name="line-916"></a>And indeed both can be inlined safely.
<a name="line-917"></a>
<a name="line-918"></a>Note [inl_fvs]
<a name="line-919"></a>~~~~~~~~~~~~~~
<a name="line-920"></a>Note that the loop-breaker graph includes edges for occurrences in
<a name="line-921"></a>/both/ the RHS /and/ the stable unfolding.  Consider this, which actually
<a name="line-922"></a>occurred when compiling BooleanFormula.hs in GHC:
<a name="line-923"></a>
<a name="line-924"></a>  Rec { lvl1 = go
<a name="line-925"></a>      ; lvl2[StableUnf = go] = lvl1
<a name="line-926"></a>      ; go = ...go...lvl2... }
<a name="line-927"></a>
<a name="line-928"></a>From the point of view of infinite inlining, we need only these edges:
<a name="line-929"></a>   lvl1 :-&gt; go
<a name="line-930"></a>   lvl2 :-&gt; go       -- The RHS lvl1 will never be used for inlining
<a name="line-931"></a>   go   :-&gt; go, lvl2
<a name="line-932"></a>
<a name="line-933"></a>But the danger is that, lacking any edge to lvl1, we'll put it at the
<a name="line-934"></a>end thus
<a name="line-935"></a>  Rec { lvl2[ StableUnf = go] = lvl1
<a name="line-936"></a>      ; go[LoopBreaker] = ...go...lvl2... }
<a name="line-937"></a>      ; lvl1[Occ=Once]  = go }
<a name="line-938"></a>
<a name="line-939"></a>And now the Simplifer will try to use PreInlineUnconditionally on lvl1
<a name="line-940"></a>(which occurs just once), but because it is last we won't actually
<a name="line-941"></a>substitute in lvl2.  Sigh.
<a name="line-942"></a>
<a name="line-943"></a>To avoid this possiblity, we include edges from lvl2 to /both/ its
<a name="line-944"></a>stable unfolding /and/ its RHS.  Hence the defn of inl_fvs in
<a name="line-945"></a>makeNode.  Maybe we could be more clever, but it's very much a corner
<a name="line-946"></a>case.
<a name="line-947"></a>
<a name="line-948"></a>Note [Weak loop breakers]
<a name="line-949"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-950"></a>There is a last nasty wrinkle.  Suppose we have
<a name="line-951"></a>
<a name="line-952"></a>    Rec { f = f_rhs
<a name="line-953"></a>          RULE f [] = g
<a name="line-954"></a>
<a name="line-955"></a>          h = h_rhs
<a name="line-956"></a>          g = h
<a name="line-957"></a>          ...more... }
<a name="line-958"></a>
<a name="line-959"></a>Remember that we simplify the RULES before any RHS (see Note
<a name="line-960"></a>[Rules are visible in their own rec group] above).
<a name="line-961"></a>
<a name="line-962"></a>So we must *not* postInlineUnconditionally 'g', even though
<a name="line-963"></a>its RHS turns out to be trivial.  (I'm assuming that 'g' is
<a name="line-964"></a>not chosen as a loop breaker.)  Why not?  Because then we
<a name="line-965"></a>drop the binding for 'g', which leaves it out of scope in the
<a name="line-966"></a>RULE!
<a name="line-967"></a>
<a name="line-968"></a>Here's a somewhat different example of the same thing
<a name="line-969"></a>    Rec { q = r
<a name="line-970"></a>        ; r = ...p...
<a name="line-971"></a>        ; p = p_rhs
<a name="line-972"></a>          RULE p [] = q }
<a name="line-973"></a>Here the RULE is "below" q, but we *still* can't postInlineUnconditionally
<a name="line-974"></a>q, because the RULE for p is active throughout.  So the RHS of r
<a name="line-975"></a>might rewrite to     r = ...q...
<a name="line-976"></a>So q must remain in scope in the output program!
<a name="line-977"></a>
<a name="line-978"></a>We "solve" this by:
<a name="line-979"></a>
<a name="line-980"></a>    Make q a "weak" loop breaker (OccInfo = IAmLoopBreaker True)
<a name="line-981"></a>    iff q is a mentioned in the RHS of any RULE (active on not)
<a name="line-982"></a>    in the Rec group
<a name="line-983"></a>
<a name="line-984"></a>Note the "active or not" comment; even if a RULE is inactive, we
<a name="line-985"></a>want its RHS free vars to stay alive (#20820)!
<a name="line-986"></a>
<a name="line-987"></a>A normal "strong" loop breaker has IAmLoopBreaker False.  So:
<a name="line-988"></a>
<a name="line-989"></a>                                Inline  postInlineUnconditionally
<a name="line-990"></a>strong   IAmLoopBreaker False    no      no
<a name="line-991"></a>weak     IAmLoopBreaker True     yes     no
<a name="line-992"></a>         other                   yes     yes
<a name="line-993"></a>
<a name="line-994"></a>The **sole** reason for this kind of loop breaker is so that
<a name="line-995"></a>postInlineUnconditionally does not fire.  Ugh.
<a name="line-996"></a>
<a name="line-997"></a>Annoyingly, since we simplify the rules *first* we'll never inline
<a name="line-998"></a>q into p's RULE.  That trivial binding for q will hang around until
<a name="line-999"></a>we discard the rule.  Yuk.  But it's rare.
<a name="line-1000"></a>
<a name="line-1001"></a>Note [Rules and loop breakers]
<a name="line-1002"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1003"></a>When we form the loop-breaker graph (Step 4 in Note [Recursive
<a name="line-1004"></a>bindings: the grand plan]), we must be careful about RULEs.
<a name="line-1005"></a>
<a name="line-1006"></a>For a start, we want a loop breaker to cut every cycle, so inactive
<a name="line-1007"></a>rules play no part; we need only consider /active/ rules.
<a name="line-1008"></a>See Note [Finding rule RHS free vars]
<a name="line-1009"></a>
<a name="line-1010"></a>The second point is more subtle.  A RULE is like an equation for
<a name="line-1011"></a>'f' that is *always* inlined if it is applicable.  We do *not* disable
<a name="line-1012"></a>rules for loop-breakers.  It's up to whoever makes the rules to make
<a name="line-1013"></a>sure that the rules themselves always terminate.  See Note [Rules for
<a name="line-1014"></a>recursive functions] in GHC.Core.Opt.Simplify
<a name="line-1015"></a>
<a name="line-1016"></a>Hence, if
<a name="line-1017"></a>    f's RHS (or its stable unfolding if it has one) mentions g, and
<a name="line-1018"></a>    g has a RULE that mentions h, and
<a name="line-1019"></a>    h has a RULE that mentions f
<a name="line-1020"></a>
<a name="line-1021"></a>then we *must* choose f to be a loop breaker.  Example: see Note
<a name="line-1022"></a>[Specialisation rules]. So our plan is this:
<a name="line-1023"></a>
<a name="line-1024"></a>   Take the free variables of f's RHS, and augment it with all the
<a name="line-1025"></a>   variables reachable by a transitive sequence RULES from those
<a name="line-1026"></a>   starting points.
<a name="line-1027"></a>
<a name="line-1028"></a>That is the whole reason for computing rule_fv_env in mkLoopBreakerNodes.
<a name="line-1029"></a>Wrinkles:
<a name="line-1030"></a>
<a name="line-1031"></a>* We only consider /active/ rules. See Note [Finding rule RHS free vars]
<a name="line-1032"></a>
<a name="line-1033"></a>* We need only consider free vars that are also binders in this Rec
<a name="line-1034"></a>  group.  See also Note [Finding rule RHS free vars]
<a name="line-1035"></a>
<a name="line-1036"></a>* We only consider variables free in the *RHS* of the rule, in
<a name="line-1037"></a>  contrast to the way we build the Rec group in the first place (Note
<a name="line-1038"></a>  [Rule dependency info])
<a name="line-1039"></a>
<a name="line-1040"></a>* Why "transitive sequence of rules"?  Because active rules apply
<a name="line-1041"></a>  unconditionally, without checking loop-breaker-ness.
<a name="line-1042"></a> See Note [Loop breaker dependencies].
<a name="line-1043"></a>
<a name="line-1044"></a>Note [Finding rule RHS free vars]
<a name="line-1045"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1046"></a>Consider this real example from Data Parallel Haskell
<a name="line-1047"></a>     tagZero :: Array Int -&gt; Array Tag
<a name="line-1048"></a>     {-# INLINE [1] tagZeroes #-}
<a name="line-1049"></a>     tagZero xs = pmap (\x -&gt; fromBool (x==0)) xs
<a name="line-1050"></a>
<a name="line-1051"></a>     {-# RULES "tagZero" [~1] forall xs n.
<a name="line-1052"></a>         pmap fromBool &lt;blah blah&gt; = tagZero xs #-}
<a name="line-1053"></a>So tagZero's RHS mentions pmap, and pmap's RULE mentions tagZero.
<a name="line-1054"></a>However, tagZero can only be inlined in phase 1 and later, while
<a name="line-1055"></a>the RULE is only active *before* phase 1.  So there's no problem.
<a name="line-1056"></a>
<a name="line-1057"></a>To make this work, we look for the RHS free vars only for
<a name="line-1058"></a>*active* rules. That's the reason for the occ_rule_act field
<a name="line-1059"></a>of the OccEnv.
<a name="line-1060"></a>
<a name="line-1061"></a>Note [loopBreakNodes]
<a name="line-1062"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-1063"></a>loopBreakNodes is applied to the list of nodes for a cyclic strongly
<a name="line-1064"></a>connected component (there's guaranteed to be a cycle).  It returns
<a name="line-1065"></a>the same nodes, but
<a name="line-1066"></a>        a) in a better order,
<a name="line-1067"></a>        b) with some of the Ids having a IAmALoopBreaker pragma
<a name="line-1068"></a>
<a name="line-1069"></a>The "loop-breaker" Ids are sufficient to break all cycles in the SCC.  This means
<a name="line-1070"></a>that the simplifier can guarantee not to loop provided it never records an inlining
<a name="line-1071"></a>for these no-inline guys.
<a name="line-1072"></a>
<a name="line-1073"></a>Furthermore, the order of the binds is such that if we neglect dependencies
<a name="line-1074"></a>on the no-inline Ids then the binds are topologically sorted.  This means
<a name="line-1075"></a>that the simplifier will generally do a good job if it works from top bottom,
<a name="line-1076"></a>recording inlinings for any Ids which aren't marked as "no-inline" as it goes.
<a name="line-1077"></a>-}</span>
<a name="line-1078"></a>
<a name="line-1079"></a><a name="Binding"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Binding</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1080"></a>
<a name="line-1081"></a><a name="loopBreakNodes"></a><span class='hs-comment'>-- See Note [loopBreakNodes]</span>
<a name="line-1082"></a><span class='hs-definition'>loopBreakNodes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-1083"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>        <span class='hs-comment'>-- Binders whose dependencies may be "missing"</span>
<a name="line-1084"></a>                                <span class='hs-comment'>-- See Note [Weak loop breakers]</span>
<a name="line-1085"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span>
<a name="line-1086"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Binding</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- Append these to the end</span>
<a name="line-1087"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Binding</span><span class='hs-keyglyph'>]</span>
<a name="line-1088"></a>
<a name="line-1089"></a><span class='hs-comment'>-- Return the bindings sorted into a plausible order, and marked with loop breakers.</span>
<a name="line-1090"></a><span class='hs-comment'>-- See Note [loopBreakNodes]</span>
<a name="line-1091"></a><span class='hs-definition'>loopBreakNodes</span> <span class='hs-varid'>depth</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>binds</span>
<a name="line-1092"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "loopBreakNodes" (ppr nodes) $</span>
<a name="line-1093"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>stronglyConnCompFromEdgedVerticesUniqR</span> <span class='hs-varid'>nodes</span><span class='hs-layout'>)</span>
<a name="line-1094"></a>  <span class='hs-keyword'>where</span>
<a name="line-1095"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binds</span>
<a name="line-1096"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>scc</span><span class='hs-conop'>:</span><span class='hs-varid'>sccs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop_break_scc</span> <span class='hs-varid'>scc</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>sccs</span><span class='hs-layout'>)</span>
<a name="line-1097"></a>
<a name="line-1098"></a>    <span class='hs-varid'>loop_break_scc</span> <span class='hs-varid'>scc</span> <span class='hs-varid'>binds</span>
<a name="line-1099"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scc</span> <span class='hs-keyword'>of</span>
<a name="line-1100"></a>          <span class='hs-conid'>AcyclicSCC</span> <span class='hs-varid'>node</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>nodeBinding</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_non_loop_breaker</span> <span class='hs-varid'>weak_fvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>node</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span>
<a name="line-1101"></a>          <span class='hs-conid'>CyclicSCC</span> <span class='hs-varid'>nodes</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>reOrderNodes</span> <span class='hs-varid'>depth</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>binds</span>
<a name="line-1102"></a>
<a name="line-1103"></a><a name="reOrderNodes"></a><span class='hs-comment'>----------------------------------</span>
<a name="line-1104"></a><span class='hs-definition'>reOrderNodes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Binding</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Binding</span><span class='hs-keyglyph'>]</span>
<a name="line-1105"></a>    <span class='hs-comment'>-- Choose a loop breaker, mark it no-inline,</span>
<a name="line-1106"></a>    <span class='hs-comment'>-- and call loopBreakNodes on the rest</span>
<a name="line-1107"></a><span class='hs-definition'>reOrderNodes</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"reOrderNodes"</span>
<a name="line-1108"></a><span class='hs-definition'>reOrderNodes</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>node</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeBinding</span> <span class='hs-varid'>mk_loop_breaker</span> <span class='hs-varid'>node</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span>
<a name="line-1109"></a><span class='hs-definition'>reOrderNodes</span> <span class='hs-varid'>depth</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>node</span> <span class='hs-conop'>:</span> <span class='hs-varid'>nodes</span><span class='hs-layout'>)</span> <span class='hs-varid'>binds</span>
<a name="line-1110"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "reOrderNodes" (vcat [ text "unchosen" &lt;+&gt; ppr unchosen</span>
<a name="line-1111"></a>    <span class='hs-comment'>--                               , text "chosen" &lt;+&gt; ppr chosen_nodes ]) $</span>
<a name="line-1112"></a>    <span class='hs-varid'>loopBreakNodes</span> <span class='hs-varid'>new_depth</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-varid'>unchosen</span> <span class='hs-varop'>$</span>
<a name="line-1113"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>nodeBinding</span> <span class='hs-varid'>mk_loop_breaker</span><span class='hs-layout'>)</span> <span class='hs-varid'>chosen_nodes</span> <span class='hs-varop'>++</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-1114"></a>  <span class='hs-keyword'>where</span>
<a name="line-1115"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>chosen_nodes</span><span class='hs-layout'>,</span> <span class='hs-varid'>unchosen</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>chooseLoopBreaker</span> <span class='hs-varid'>approximate_lb</span>
<a name="line-1116"></a>                                                 <span class='hs-layout'>(</span><span class='hs-varid'>nd_score</span> <span class='hs-layout'>(</span><span class='hs-varid'>node_payload</span> <span class='hs-varid'>node</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1117"></a>                                                 <span class='hs-keyglyph'>[</span><span class='hs-varid'>node</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>nodes</span>
<a name="line-1118"></a>
<a name="line-1119"></a>    <span class='hs-varid'>approximate_lb</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>depth</span> <span class='hs-varop'>&gt;=</span> <span class='hs-num'>2</span>
<a name="line-1120"></a>    <span class='hs-varid'>new_depth</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>approximate_lb</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-1121"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>depth</span><span class='hs-varop'>+</span><span class='hs-num'>1</span>
<a name="line-1122"></a>        <span class='hs-comment'>-- After two iterations (d=0, d=1) give up</span>
<a name="line-1123"></a>        <span class='hs-comment'>-- and approximate, returning to d=0</span>
<a name="line-1124"></a>
<a name="line-1125"></a><a name="nodeBinding"></a><span class='hs-definition'>nodeBinding</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LetrecNode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Binding</span>
<a name="line-1126"></a><span class='hs-definition'>nodeBinding</span> <span class='hs-varid'>set_id_occ</span> <span class='hs-layout'>(</span><span class='hs-varid'>node_payload</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1127"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>set_id_occ</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1128"></a>
<a name="line-1129"></a><a name="mk_loop_breaker"></a><span class='hs-definition'>mk_loop_breaker</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1130"></a><span class='hs-definition'>mk_loop_breaker</span> <span class='hs-varid'>bndr</span>
<a name="line-1131"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`setIdOccInfo`</span> <span class='hs-varid'>occ'</span>
<a name="line-1132"></a>  <span class='hs-keyword'>where</span>
<a name="line-1133"></a>    <span class='hs-varid'>occ'</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strongLoopBreaker</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail_info</span> <span class='hs-layout'>}</span>
<a name="line-1134"></a>    <span class='hs-varid'>tail_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1135"></a>
<a name="line-1136"></a><a name="mk_non_loop_breaker"></a><span class='hs-definition'>mk_non_loop_breaker</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1137"></a><span class='hs-comment'>-- See Note [Weak loop breakers]</span>
<a name="line-1138"></a><span class='hs-definition'>mk_non_loop_breaker</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-varid'>bndr</span>
<a name="line-1139"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>weak_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdOccInfo</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>occ'</span>
<a name="line-1140"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span>
<a name="line-1141"></a>  <span class='hs-keyword'>where</span>
<a name="line-1142"></a>    <span class='hs-varid'>occ'</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>weakLoopBreaker</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail_info</span> <span class='hs-layout'>}</span>
<a name="line-1143"></a>    <span class='hs-varid'>tail_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1144"></a>
<a name="line-1145"></a><a name="chooseLoopBreaker"></a><span class='hs-comment'>----------------------------------</span>
<a name="line-1146"></a><span class='hs-definition'>chooseLoopBreaker</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>             <span class='hs-comment'>-- True &lt;=&gt; Too many iterations,</span>
<a name="line-1147"></a>                                      <span class='hs-comment'>--          so approximate</span>
<a name="line-1148"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NodeScore</span>            <span class='hs-comment'>-- Best score so far</span>
<a name="line-1149"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Nodes with this score</span>
<a name="line-1150"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Nodes with higher scores</span>
<a name="line-1151"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Unprocessed nodes</span>
<a name="line-1152"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1153"></a>    <span class='hs-comment'>-- This loop looks for the bind with the lowest score</span>
<a name="line-1154"></a>    <span class='hs-comment'>-- to pick as the loop  breaker.  The rest accumulate in</span>
<a name="line-1155"></a><span class='hs-definition'>chooseLoopBreaker</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>loop_nodes</span> <span class='hs-varid'>acc</span> <span class='hs-conid'>[]</span>
<a name="line-1156"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>loop_nodes</span><span class='hs-layout'>,</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Done</span>
<a name="line-1157"></a>
<a name="line-1158"></a>    <span class='hs-comment'>-- If approximate_loop_breaker is True, we pick *all*</span>
<a name="line-1159"></a>    <span class='hs-comment'>-- nodes with lowest score, else just one</span>
<a name="line-1160"></a>    <span class='hs-comment'>-- See Note [Complexity of loop breaking]</span>
<a name="line-1161"></a><span class='hs-definition'>chooseLoopBreaker</span> <span class='hs-varid'>approx_lb</span> <span class='hs-varid'>loop_sc</span> <span class='hs-varid'>loop_nodes</span> <span class='hs-varid'>acc</span> <span class='hs-layout'>(</span><span class='hs-varid'>node</span> <span class='hs-conop'>:</span> <span class='hs-varid'>nodes</span><span class='hs-layout'>)</span>
<a name="line-1162"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>approx_lb</span>
<a name="line-1163"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>sc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>loop_sc</span>
<a name="line-1164"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>chooseLoopBreaker</span> <span class='hs-varid'>approx_lb</span> <span class='hs-varid'>loop_sc</span> <span class='hs-layout'>(</span><span class='hs-varid'>node</span> <span class='hs-conop'>:</span> <span class='hs-varid'>loop_nodes</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-varid'>nodes</span>
<a name="line-1165"></a>
<a name="line-1166"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sc</span> <span class='hs-varop'>`betterLB`</span> <span class='hs-varid'>loop_sc</span>  <span class='hs-comment'>-- Better score so pick this new one</span>
<a name="line-1167"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>chooseLoopBreaker</span> <span class='hs-varid'>approx_lb</span> <span class='hs-varid'>sc</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>node</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>loop_nodes</span> <span class='hs-varop'>++</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-varid'>nodes</span>
<a name="line-1168"></a>
<a name="line-1169"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-comment'>-- Worse score so don't pick it</span>
<a name="line-1170"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>chooseLoopBreaker</span> <span class='hs-varid'>approx_lb</span> <span class='hs-varid'>loop_sc</span> <span class='hs-varid'>loop_nodes</span> <span class='hs-layout'>(</span><span class='hs-varid'>node</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-varid'>nodes</span>
<a name="line-1171"></a>  <span class='hs-keyword'>where</span>
<a name="line-1172"></a>    <span class='hs-varid'>sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nd_score</span> <span class='hs-layout'>(</span><span class='hs-varid'>node_payload</span> <span class='hs-varid'>node</span><span class='hs-layout'>)</span>
<a name="line-1173"></a>
<a name="line-1174"></a><span class='hs-comment'>{-
<a name="line-1175"></a>Note [Complexity of loop breaking]
<a name="line-1176"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1177"></a>The loop-breaking algorithm knocks out one binder at a time, and
<a name="line-1178"></a>performs a new SCC analysis on the remaining binders.  That can
<a name="line-1179"></a>behave very badly in tightly-coupled groups of bindings; in the
<a name="line-1180"></a>worst case it can be (N**2)*log N, because it does a full SCC
<a name="line-1181"></a>on N, then N-1, then N-2 and so on.
<a name="line-1182"></a>
<a name="line-1183"></a>To avoid this, we switch plans after 2 (or whatever) attempts:
<a name="line-1184"></a>  Plan A: pick one binder with the lowest score, make it
<a name="line-1185"></a>          a loop breaker, and try again
<a name="line-1186"></a>  Plan B: pick *all* binders with the lowest score, make them
<a name="line-1187"></a>          all loop breakers, and try again
<a name="line-1188"></a>Since there are only a small finite number of scores, this will
<a name="line-1189"></a>terminate in a constant number of iterations, rather than O(N)
<a name="line-1190"></a>iterations.
<a name="line-1191"></a>
<a name="line-1192"></a>You might thing that it's very unlikely, but RULES make it much
<a name="line-1193"></a>more likely.  Here's a real example from #1969:
<a name="line-1194"></a>  Rec { $dm = \d.\x. op d
<a name="line-1195"></a>        {-# RULES forall d. $dm Int d  = $s$dm1
<a name="line-1196"></a>                  forall d. $dm Bool d = $s$dm2 #-}
<a name="line-1197"></a>
<a name="line-1198"></a>        dInt = MkD .... opInt ...
<a name="line-1199"></a>        dInt = MkD .... opBool ...
<a name="line-1200"></a>        opInt  = $dm dInt
<a name="line-1201"></a>        opBool = $dm dBool
<a name="line-1202"></a>
<a name="line-1203"></a>        $s$dm1 = \x. op dInt
<a name="line-1204"></a>        $s$dm2 = \x. op dBool }
<a name="line-1205"></a>The RULES stuff means that we can't choose $dm as a loop breaker
<a name="line-1206"></a>(Note [Choosing loop breakers]), so we must choose at least (say)
<a name="line-1207"></a>opInt *and* opBool, and so on.  The number of loop breakders is
<a name="line-1208"></a>linear in the number of instance declarations.
<a name="line-1209"></a>
<a name="line-1210"></a>Note [Loop breakers and INLINE/INLINABLE pragmas]
<a name="line-1211"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1212"></a>Avoid choosing a function with an INLINE pramga as the loop breaker!
<a name="line-1213"></a>If such a function is mutually-recursive with a non-INLINE thing,
<a name="line-1214"></a>then the latter should be the loop-breaker.
<a name="line-1215"></a>
<a name="line-1216"></a>It's vital to distinguish between INLINE and INLINABLE (the
<a name="line-1217"></a>Bool returned by hasStableCoreUnfolding_maybe).  If we start with
<a name="line-1218"></a>   Rec { {-# INLINABLE f #-}
<a name="line-1219"></a>         f x = ...f... }
<a name="line-1220"></a>and then worker/wrapper it through strictness analysis, we'll get
<a name="line-1221"></a>   Rec { {-# INLINABLE $wf #-}
<a name="line-1222"></a>         $wf p q = let x = (p,q) in ...f...
<a name="line-1223"></a>
<a name="line-1224"></a>         {-# INLINE f #-}
<a name="line-1225"></a>         f x = case x of (p,q) -&gt; $wf p q }
<a name="line-1226"></a>
<a name="line-1227"></a>Now it is vital that we choose $wf as the loop breaker, so we can
<a name="line-1228"></a>inline 'f' in '$wf'.
<a name="line-1229"></a>
<a name="line-1230"></a>Note [DFuns should not be loop breakers]
<a name="line-1231"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1232"></a>It's particularly bad to make a DFun into a loop breaker.  See
<a name="line-1233"></a>Note [How instance declarations are translated] in GHC.Tc.TyCl.Instance
<a name="line-1234"></a>
<a name="line-1235"></a>We give DFuns a higher score than ordinary CONLIKE things because
<a name="line-1236"></a>if there's a choice we want the DFun to be the non-loop breaker. Eg
<a name="line-1237"></a>
<a name="line-1238"></a>rec { sc = /\ a \$dC. $fBWrap (T a) ($fCT @ a $dC)
<a name="line-1239"></a>
<a name="line-1240"></a>      $fCT :: forall a_afE. (Roman.C a_afE) =&gt; Roman.C (Roman.T a_afE)
<a name="line-1241"></a>      {-# DFUN #-}
<a name="line-1242"></a>      $fCT = /\a \$dC. MkD (T a) ((sc @ a $dC) |&gt; blah) ($ctoF @ a $dC)
<a name="line-1243"></a>    }
<a name="line-1244"></a>
<a name="line-1245"></a>Here 'sc' (the superclass) looks CONLIKE, but we'll never get to it
<a name="line-1246"></a>if we can't unravel the DFun first.
<a name="line-1247"></a>
<a name="line-1248"></a>Note [Constructor applications]
<a name="line-1249"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1250"></a>It's really really important to inline dictionaries.  Real
<a name="line-1251"></a>example (the Enum Ordering instance from GHC.Base):
<a name="line-1252"></a>
<a name="line-1253"></a>     rec     f = \ x -&gt; case d of (p,q,r) -&gt; p x
<a name="line-1254"></a>             g = \ x -&gt; case d of (p,q,r) -&gt; q x
<a name="line-1255"></a>             d = (v, f, g)
<a name="line-1256"></a>
<a name="line-1257"></a>Here, f and g occur just once; but we can't inline them into d.
<a name="line-1258"></a>On the other hand we *could* simplify those case expressions if
<a name="line-1259"></a>we didn't stupidly choose d as the loop breaker.
<a name="line-1260"></a>But we won't because constructor args are marked "Many".
<a name="line-1261"></a>Inlining dictionaries is really essential to unravelling
<a name="line-1262"></a>the loops in static numeric dictionaries, see GHC.Float.
<a name="line-1263"></a>
<a name="line-1264"></a>Note [Closure conversion]
<a name="line-1265"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1266"></a>We treat (\x. C p q) as a high-score candidate in the letrec scoring algorithm.
<a name="line-1267"></a>The immediate motivation came from the result of a closure-conversion transformation
<a name="line-1268"></a>which generated code like this:
<a name="line-1269"></a>
<a name="line-1270"></a>    data Clo a b = forall c. Clo (c -&gt; a -&gt; b) c
<a name="line-1271"></a>
<a name="line-1272"></a>    ($:) :: Clo a b -&gt; a -&gt; b
<a name="line-1273"></a>    Clo f env $: x = f env x
<a name="line-1274"></a>
<a name="line-1275"></a>    rec { plus = Clo plus1 ()
<a name="line-1276"></a>
<a name="line-1277"></a>        ; plus1 _ n = Clo plus2 n
<a name="line-1278"></a>
<a name="line-1279"></a>        ; plus2 Zero     n = n
<a name="line-1280"></a>        ; plus2 (Succ m) n = Succ (plus $: m $: n) }
<a name="line-1281"></a>
<a name="line-1282"></a>If we inline 'plus' and 'plus1', everything unravels nicely.  But if
<a name="line-1283"></a>we choose 'plus1' as the loop breaker (which is entirely possible
<a name="line-1284"></a>otherwise), the loop does not unravel nicely.
<a name="line-1285"></a>
<a name="line-1286"></a>
<a name="line-1287"></a>@occAnalUnfolding@ deals with the question of bindings where the Id is marked
<a name="line-1288"></a>by an INLINE pragma.  For these we record that anything which occurs
<a name="line-1289"></a>in its RHS occurs many times.  This pessimistically assumes that this
<a name="line-1290"></a>inlined binder also occurs many times in its scope, but if it doesn't
<a name="line-1291"></a>we'll catch it next time round.  At worst this costs an extra simplifier pass.
<a name="line-1292"></a>ToDo: try using the occurrence info for the inline'd binder.
<a name="line-1293"></a>
<a name="line-1294"></a>[March 97] We do the same for atomic RHSs.  Reason: see notes with loopBreakSCC.
<a name="line-1295"></a>[June 98, SLPJ]  I've undone this change; I don't understand it.  See notes with loopBreakSCC.
<a name="line-1296"></a>
<a name="line-1297"></a>
<a name="line-1298"></a>************************************************************************
<a name="line-1299"></a>*                                                                      *
<a name="line-1300"></a>                   Making nodes
<a name="line-1301"></a>*                                                                      *
<a name="line-1302"></a>************************************************************************
<a name="line-1303"></a>-}</span>
<a name="line-1304"></a>
<a name="line-1305"></a><a name="LetrecNode"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LetrecNode</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-conid'>Unique</span> <span class='hs-conid'>Details</span>  <span class='hs-comment'>-- Node comes from Digraph</span>
<a name="line-1306"></a>                                       <span class='hs-comment'>-- The Unique key is gotten from the Id</span>
<a name="line-1307"></a><a name="Details"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Details</span>
<a name="line-1308"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>          <span class='hs-comment'>-- Binder</span>
<a name="line-1309"></a>
<a name="line-1310"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span>    <span class='hs-comment'>-- RHS, already occ-analysed</span>
<a name="line-1311"></a>
<a name="line-1312"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Outer lambdas of RHS</span>
<a name="line-1313"></a>                                    <span class='hs-comment'>-- INVARIANT: (nd_rhs_bndrs nd, _) ==</span>
<a name="line-1314"></a>                                    <span class='hs-comment'>--              collectBinders (nd_rhs nd)</span>
<a name="line-1315"></a>
<a name="line-1316"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_uds</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span>  <span class='hs-comment'>-- Usage from RHS, and RULES, and stable unfoldings</span>
<a name="line-1317"></a>                                  <span class='hs-comment'>-- ignoring phase (ie assuming all are active)</span>
<a name="line-1318"></a>                                  <span class='hs-comment'>-- See Note [Forming Rec groups]</span>
<a name="line-1319"></a>
<a name="line-1320"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_inl</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IdSet</span>       <span class='hs-comment'>-- Free variables of the stable unfolding and the RHS</span>
<a name="line-1321"></a>                                <span class='hs-comment'>-- but excluding any RULES</span>
<a name="line-1322"></a>                                <span class='hs-comment'>-- This is the IdSet that may be used if the Id is inlined</span>
<a name="line-1323"></a>
<a name="line-1324"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_simple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>      <span class='hs-comment'>-- True iff this binding has no local RULES</span>
<a name="line-1325"></a>                                <span class='hs-comment'>-- If all nodes are simple we don't need a loop-breaker</span>
<a name="line-1326"></a>                                <span class='hs-comment'>-- dep-anal before reconstructing.</span>
<a name="line-1327"></a>
<a name="line-1328"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_weak_fvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IdSet</span>    <span class='hs-comment'>-- Variables bound in this Rec group that are free</span>
<a name="line-1329"></a>                                 <span class='hs-comment'>-- in the RHS of any rule (active or not) for this bndr</span>
<a name="line-1330"></a>                                 <span class='hs-comment'>-- See Note [Weak loop breakers]</span>
<a name="line-1331"></a>
<a name="line-1332"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_active_rule_fvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IdSet</span>    <span class='hs-comment'>-- Variables bound in this Rec group that are free</span>
<a name="line-1333"></a>                                        <span class='hs-comment'>-- in the RHS of an active rule for this bndr</span>
<a name="line-1334"></a>                                        <span class='hs-comment'>-- See Note [Rules and loop breakers]</span>
<a name="line-1335"></a>
<a name="line-1336"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>nd_score</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NodeScore</span>
<a name="line-1337"></a>  <span class='hs-layout'>}</span>
<a name="line-1338"></a>
<a name="line-1339"></a><a name="instance%20Outputable%20Details"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Details</span> <span class='hs-keyword'>where</span>
<a name="line-1340"></a>   <span class='hs-varid'>ppr</span> <span class='hs-varid'>nd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ND"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>braces</span>
<a name="line-1341"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"bndr ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>nd_bndr</span> <span class='hs-varid'>nd</span><span class='hs-layout'>)</span>
<a name="line-1342"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"uds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>nd_uds</span> <span class='hs-varid'>nd</span><span class='hs-layout'>)</span>
<a name="line-1343"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"inl ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>nd_inl</span> <span class='hs-varid'>nd</span><span class='hs-layout'>)</span>
<a name="line-1344"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"simple ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>nd_simple</span> <span class='hs-varid'>nd</span><span class='hs-layout'>)</span>
<a name="line-1345"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"active_rule_fvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>nd_active_rule_fvs</span> <span class='hs-varid'>nd</span><span class='hs-layout'>)</span>
<a name="line-1346"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"score ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>nd_score</span> <span class='hs-varid'>nd</span><span class='hs-layout'>)</span>
<a name="line-1347"></a>             <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1348"></a>
<a name="line-1349"></a><a name="NodeScore"></a><span class='hs-comment'>-- The NodeScore is compared lexicographically;</span>
<a name="line-1350"></a><a name="NodeScore"></a><span class='hs-comment'>--      e.g. lower rank wins regardless of size</span>
<a name="line-1351"></a><a name="NodeScore"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>NodeScore</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Int</span>     <span class='hs-comment'>-- Rank: lower =&gt; more likely to be picked as loop breaker</span>
<a name="line-1352"></a>                 <span class='hs-layout'>,</span> <span class='hs-conid'>Int</span>     <span class='hs-comment'>-- Size of rhs: higher =&gt; more likely to be picked as LB</span>
<a name="line-1353"></a>                           <span class='hs-comment'>-- Maxes out at maxExprSize; we just use it to prioritise</span>
<a name="line-1354"></a>                           <span class='hs-comment'>-- small functions</span>
<a name="line-1355"></a>                 <span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- Was it a loop breaker before?</span>
<a name="line-1356"></a>                           <span class='hs-comment'>-- True =&gt; more likely to be picked</span>
<a name="line-1357"></a>                           <span class='hs-comment'>-- Note [Loop breakers, node scoring, and stability]</span>
<a name="line-1358"></a>
<a name="line-1359"></a><a name="rank"></a><span class='hs-definition'>rank</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NodeScore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1360"></a><span class='hs-definition'>rank</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-1361"></a>
<a name="line-1362"></a><a name="makeNode"></a><span class='hs-definition'>makeNode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ImpRuleEdges</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-1363"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LetrecNode</span>
<a name="line-1364"></a><span class='hs-comment'>-- See Note [Recursive bindings: the grand plan]</span>
<a name="line-1365"></a><span class='hs-definition'>makeNode</span> <span class='hs-varid'>env</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr_set</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1366"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DigraphNode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>node_payload</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>details</span>
<a name="line-1367"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>node_key</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varUnique</span> <span class='hs-varid'>bndr</span>
<a name="line-1368"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>node_dependencies</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonDetKeysUniqSet</span> <span class='hs-varid'>scope_fvs</span> <span class='hs-layout'>}</span>
<a name="line-1369"></a>    <span class='hs-comment'>-- It's OK to use nonDetKeysUniqSet here as stronglyConnCompFromEdgedVerticesR</span>
<a name="line-1370"></a>    <span class='hs-comment'>-- is still deterministic with edges in nondeterministic order as</span>
<a name="line-1371"></a>    <span class='hs-comment'>-- explained in Note [Deterministic SCC] in GHC.Data.Graph.Directed.</span>
<a name="line-1372"></a>  <span class='hs-keyword'>where</span>
<a name="line-1373"></a>    <span class='hs-varid'>details</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr'</span>
<a name="line-1374"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs'</span>
<a name="line-1375"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs_bndrs</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs'</span>
<a name="line-1376"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_uds</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scope_uds</span>
<a name="line-1377"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_inl</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inl_fvs</span>
<a name="line-1378"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_simple</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>null</span> <span class='hs-varid'>rules_w_uds</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>imp_rule_info</span>
<a name="line-1379"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_weak_fvs</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>weak_fvs</span>
<a name="line-1380"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_active_rule_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>active_rule_fvs</span>
<a name="line-1381"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>nd_score</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"makeNodeDetails"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1382"></a>
<a name="line-1383"></a>    <span class='hs-varid'>bndr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>`setIdUnfolding`</span>      <span class='hs-varid'>unf'</span>
<a name="line-1384"></a>                 <span class='hs-varop'>`setIdSpecialisation`</span> <span class='hs-varid'>mkRuleInfo</span> <span class='hs-varid'>rules'</span>
<a name="line-1385"></a>
<a name="line-1386"></a>    <span class='hs-varid'>inl_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_uds</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>unf_uds</span>
<a name="line-1387"></a>    <span class='hs-varid'>scope_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inl_uds</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>rule_uds</span>
<a name="line-1388"></a>                   <span class='hs-comment'>-- Note [Rules are extra RHSs]</span>
<a name="line-1389"></a>                   <span class='hs-comment'>-- Note [Rule dependency info]</span>
<a name="line-1390"></a>    <span class='hs-varid'>scope_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>udFreeVars</span> <span class='hs-varid'>bndr_set</span> <span class='hs-varid'>scope_uds</span>
<a name="line-1391"></a>    <span class='hs-comment'>-- scope_fvs: all occurrences from this binder: RHS, unfolding,</span>
<a name="line-1392"></a>    <span class='hs-comment'>--            and RULES, both LHS and RHS thereof, active or inactive</span>
<a name="line-1393"></a>
<a name="line-1394"></a>    <span class='hs-varid'>inl_fvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>udFreeVars</span> <span class='hs-varid'>bndr_set</span> <span class='hs-varid'>inl_uds</span>
<a name="line-1395"></a>    <span class='hs-comment'>-- inl_fvs: vars that would become free if the function was inlined.</span>
<a name="line-1396"></a>    <span class='hs-comment'>-- We conservatively approximate that by thefree vars from the RHS</span>
<a name="line-1397"></a>    <span class='hs-comment'>-- and the unfolding together.</span>
<a name="line-1398"></a>    <span class='hs-comment'>-- See Note [inl_fvs]</span>
<a name="line-1399"></a>
<a name="line-1400"></a>    <span class='hs-varid'>mb_join_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>bndr</span>
<a name="line-1401"></a>    <span class='hs-comment'>-- Get join point info from the *current* decision</span>
<a name="line-1402"></a>    <span class='hs-comment'>-- We don't know what the new decision will be!</span>
<a name="line-1403"></a>    <span class='hs-comment'>-- Using the old decision at least allows us to</span>
<a name="line-1404"></a>    <span class='hs-comment'>-- preserve existing join point, even RULEs are added</span>
<a name="line-1405"></a>    <span class='hs-comment'>-- See Note [Join points and unfoldings/rules]</span>
<a name="line-1406"></a>
<a name="line-1407"></a>    <span class='hs-comment'>--------- Right hand side ---------</span>
<a name="line-1408"></a>    <span class='hs-comment'>-- Constructing the edges for the main Rec computation</span>
<a name="line-1409"></a>    <span class='hs-comment'>-- See Note [Forming Rec groups]</span>
<a name="line-1410"></a>    <span class='hs-comment'>-- Do not use occAnalRhs because we don't yet know</span>
<a name="line-1411"></a>    <span class='hs-comment'>-- the final answer for mb_join_arity</span>
<a name="line-1412"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>rhs</span>
<a name="line-1413"></a>    <span class='hs-varid'>rhs_env</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhsCtxt</span> <span class='hs-varid'>env</span>
<a name="line-1414"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rhs_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalLamOrRhs</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1415"></a>    <span class='hs-varid'>rhs'</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>body'</span>
<a name="line-1416"></a>
<a name="line-1417"></a>    <span class='hs-comment'>--------- Unfolding ---------</span>
<a name="line-1418"></a>    <span class='hs-comment'>-- See Note [Unfoldings and join points]</span>
<a name="line-1419"></a>    <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>bndr</span> <span class='hs-comment'>-- realIdUnfolding: Ignore loop-breaker-ness</span>
<a name="line-1420"></a>                               <span class='hs-comment'>-- here because that is what we are setting!</span>
<a name="line-1421"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unf_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>unf'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalUnfolding</span> <span class='hs-varid'>rhs_env</span> <span class='hs-conid'>Recursive</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>unf</span>
<a name="line-1422"></a>
<a name="line-1423"></a>    <span class='hs-comment'>--------- IMP-RULES --------</span>
<a name="line-1424"></a>    <span class='hs-varid'>is_active</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ_rule_act</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1425"></a>    <span class='hs-varid'>imp_rule_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupImpRules</span> <span class='hs-varid'>imp_rule_edges</span> <span class='hs-varid'>bndr</span>
<a name="line-1426"></a>    <span class='hs-varid'>imp_rule_uds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>impRulesScopeUsage</span> <span class='hs-varid'>imp_rule_info</span>
<a name="line-1427"></a>    <span class='hs-varid'>imp_rule_fvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>impRulesActiveFvs</span> <span class='hs-varid'>is_active</span> <span class='hs-varid'>bndr_set</span> <span class='hs-varid'>imp_rule_info</span>
<a name="line-1428"></a>
<a name="line-1429"></a>    <span class='hs-comment'>--------- All rules --------</span>
<a name="line-1430"></a>    <span class='hs-varid'>rules_w_uds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>CoreRule</span><span class='hs-layout'>,</span> <span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>UsageDetails</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1431"></a>    <span class='hs-varid'>rules_w_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRules</span> <span class='hs-varid'>rhs_env</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndr</span>
<a name="line-1432"></a>    <span class='hs-varid'>rules'</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fstOf3</span> <span class='hs-varid'>rules_w_uds</span>
<a name="line-1433"></a>
<a name="line-1434"></a>    <span class='hs-varid'>rule_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add_rule_uds</span> <span class='hs-varid'>imp_rule_uds</span> <span class='hs-varid'>rules_w_uds</span>
<a name="line-1435"></a>    <span class='hs-varid'>add_rule_uds</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>l</span><span class='hs-layout'>,</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>r</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>uds</span>
<a name="line-1436"></a>
<a name="line-1437"></a>    <span class='hs-comment'>-------- active_rule_fvs ------------</span>
<a name="line-1438"></a>    <span class='hs-varid'>active_rule_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add_active_rule</span> <span class='hs-varid'>imp_rule_fvs</span> <span class='hs-varid'>rules_w_uds</span>
<a name="line-1439"></a>    <span class='hs-varid'>add_active_rule</span> <span class='hs-layout'>(</span><span class='hs-varid'>rule</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_uds</span><span class='hs-layout'>)</span> <span class='hs-varid'>fvs</span>
<a name="line-1440"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_active</span> <span class='hs-layout'>(</span><span class='hs-varid'>ruleActivation</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span>
<a name="line-1441"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>udFreeVars</span> <span class='hs-varid'>bndr_set</span> <span class='hs-varid'>rhs_uds</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>fvs</span>
<a name="line-1442"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1443"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvs</span>
<a name="line-1444"></a>
<a name="line-1445"></a>    <span class='hs-comment'>-------- weak_fvs ------------</span>
<a name="line-1446"></a>    <span class='hs-comment'>-- See Note [Weak loop breakers]</span>
<a name="line-1447"></a>    <span class='hs-varid'>weak_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add_rule</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>rules_w_uds</span>
<a name="line-1448"></a>    <span class='hs-varid'>add_rule</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_uds</span><span class='hs-layout'>)</span> <span class='hs-varid'>fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>udFreeVars</span> <span class='hs-varid'>bndr_set</span> <span class='hs-varid'>rhs_uds</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>fvs</span>
<a name="line-1449"></a>
<a name="line-1450"></a><a name="mkLoopBreakerNodes"></a><span class='hs-definition'>mkLoopBreakerNodes</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-1451"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>   <span class='hs-comment'>-- for BODY of let</span>
<a name="line-1452"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Details</span><span class='hs-keyglyph'>]</span>
<a name="line-1453"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- adjusted</span>
<a name="line-1454"></a>                       <span class='hs-keyglyph'>[</span><span class='hs-conid'>LetrecNode</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1455"></a><span class='hs-comment'>-- See Note [Choosing loop breakers]</span>
<a name="line-1456"></a><span class='hs-comment'>-- This function primarily creates the Nodes for the</span>
<a name="line-1457"></a><span class='hs-comment'>-- loop-breaker SCC analysis.  More specifically:</span>
<a name="line-1458"></a><span class='hs-comment'>--   a) tag each binder with its occurrence info</span>
<a name="line-1459"></a><span class='hs-comment'>--   b) add a NodeScore to each node</span>
<a name="line-1460"></a><span class='hs-comment'>--   c) make a Node with the right dependency edges for</span>
<a name="line-1461"></a><span class='hs-comment'>--      the loop-breaker SCC analysis</span>
<a name="line-1462"></a><span class='hs-comment'>--   d) adjust each RHS's usage details according to</span>
<a name="line-1463"></a><span class='hs-comment'>--      the binder's (new) shotness and join-point-hood</span>
<a name="line-1464"></a><span class='hs-definition'>mkLoopBreakerNodes</span> <span class='hs-varid'>env</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>body_uds</span> <span class='hs-varid'>details_s</span>
<a name="line-1465"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>zipWithEqual</span> <span class='hs-str'>"mkLoopBreakerNodes"</span> <span class='hs-varid'>mk_lb_node</span> <span class='hs-varid'>details_s</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-1466"></a>  <span class='hs-keyword'>where</span>
<a name="line-1467"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-1468"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagRecBinders</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>body_uds</span>
<a name="line-1469"></a>            <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_bndrs</span><span class='hs-layout'>)</span>
<a name="line-1470"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_bndrs</span> <span class='hs-layout'>}</span>
<a name="line-1471"></a>                 <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>details_s</span> <span class='hs-keyglyph'>]</span>
<a name="line-1472"></a>
<a name="line-1473"></a>    <span class='hs-varid'>mk_lb_node</span> <span class='hs-varid'>nd</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_inl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inl_fvs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_bndr</span>
<a name="line-1474"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DigraphNode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>node_payload</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_nd</span>
<a name="line-1475"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>node_key</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varUnique</span> <span class='hs-varid'>old_bndr</span>
<a name="line-1476"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>node_dependencies</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonDetKeysUniqSet</span> <span class='hs-varid'>lb_deps</span> <span class='hs-layout'>}</span>
<a name="line-1477"></a>              <span class='hs-comment'>-- It's OK to use nonDetKeysUniqSet here as</span>
<a name="line-1478"></a>              <span class='hs-comment'>-- stronglyConnCompFromEdgedVerticesR is still deterministic with edges</span>
<a name="line-1479"></a>              <span class='hs-comment'>-- in nondeterministic order as explained in</span>
<a name="line-1480"></a>              <span class='hs-comment'>-- Note [Deterministic SCC] in GHC.Data.Graph.Directed.</span>
<a name="line-1481"></a>      <span class='hs-keyword'>where</span>
<a name="line-1482"></a>        <span class='hs-varid'>new_nd</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nd</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_score</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>score</span> <span class='hs-layout'>}</span>
<a name="line-1483"></a>        <span class='hs-varid'>score</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nodeScore</span> <span class='hs-varid'>env</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>lb_deps</span> <span class='hs-varid'>nd</span>
<a name="line-1484"></a>        <span class='hs-varid'>lb_deps</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendFvs_</span> <span class='hs-varid'>rule_fv_env</span> <span class='hs-varid'>inl_fvs</span>
<a name="line-1485"></a>        <span class='hs-comment'>-- See Note [Loop breaker dependencies]</span>
<a name="line-1486"></a>
<a name="line-1487"></a>    <span class='hs-varid'>rule_fv_env</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IdEnv</span> <span class='hs-conid'>IdSet</span>
<a name="line-1488"></a>    <span class='hs-comment'>-- Maps a variable f to the variables from this group</span>
<a name="line-1489"></a>    <span class='hs-comment'>--      reachable by a sequence of RULES starting with f</span>
<a name="line-1490"></a>    <span class='hs-comment'>-- Domain is *subset* of bound vars (others have no rule fvs)</span>
<a name="line-1491"></a>    <span class='hs-comment'>-- See Note [Finding rule RHS free vars]</span>
<a name="line-1492"></a>    <span class='hs-comment'>-- Why transClosureFV?  See Note [Loop breaker dependencies]</span>
<a name="line-1493"></a>    <span class='hs-varid'>rule_fv_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transClosureFV</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkVarEnv</span> <span class='hs-varop'>$</span>
<a name="line-1494"></a>                  <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>rule_fvs</span><span class='hs-layout'>)</span>
<a name="line-1495"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_active_rule_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule_fvs</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>details_s</span>
<a name="line-1496"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>rule_fvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1497"></a>
<a name="line-1498"></a><span class='hs-comment'>{- Note [Loop breaker dependencies]
<a name="line-1499"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1500"></a>The loop breaker dependencies of x in a recursive
<a name="line-1501"></a>group { f1 = e1; ...; fn = en } are:
<a name="line-1502"></a>
<a name="line-1503"></a>- The "inline free variables" of f: the fi free in
<a name="line-1504"></a>  f's stable unfolding and RHS; see Note [inl_fvs]
<a name="line-1505"></a>
<a name="line-1506"></a>- Any fi reachable from those inline free variables by a sequence
<a name="line-1507"></a>  of RULE rewrites.  Remember, rule rewriting is not affected
<a name="line-1508"></a>  by fi being a loop breaker, so we have to take the transitive
<a name="line-1509"></a>  closure in case f is the only possible loop breaker in the loop.
<a name="line-1510"></a>
<a name="line-1511"></a>  Hence rule_fv_env.  We need only account for /active/ rules.
<a name="line-1512"></a>-}</span>
<a name="line-1513"></a>
<a name="line-1514"></a><a name="nodeScore"></a><span class='hs-comment'>------------------------------------------</span>
<a name="line-1515"></a><span class='hs-definition'>nodeScore</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-1516"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>        <span class='hs-comment'>-- Binder with new occ-info</span>
<a name="line-1517"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>    <span class='hs-comment'>-- Loop-breaker dependencies</span>
<a name="line-1518"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Details</span>
<a name="line-1519"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NodeScore</span>
<a name="line-1520"></a><span class='hs-definition'>nodeScore</span> <span class='hs-varid'>env</span> <span class='hs-varid'>new_bndr</span> <span class='hs-varid'>lb_deps</span>
<a name="line-1521"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>ND</span> <span class='hs-layout'>{</span> <span class='hs-varid'>nd_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>nd_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bind_rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1522"></a>
<a name="line-1523"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isId</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- A type or coercion variable is never a loop breaker</span>
<a name="line-1524"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>100</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-1525"></a>
<a name="line-1526"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>old_bndr</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>lb_deps</span>  <span class='hs-comment'>-- Self-recursive things are great loop breakers</span>
<a name="line-1527"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>                   <span class='hs-comment'>-- See Note [Self-recursion and loop breakers]</span>
<a name="line-1528"></a>
<a name="line-1529"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>occ_unf_act</span> <span class='hs-varid'>env</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- A binder whose inlining is inactive (e.g. has</span>
<a name="line-1530"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>                   <span class='hs-comment'>-- a NOINLINE pragma) makes a great loop breaker</span>
<a name="line-1531"></a>
<a name="line-1532"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs</span>
<a name="line-1533"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_score</span> <span class='hs-num'>10</span>  <span class='hs-comment'>-- Practically certain to be inlined</span>
<a name="line-1534"></a>    <span class='hs-comment'>-- Used to have also: &amp;&amp; not (isExportedId bndr)</span>
<a name="line-1535"></a>    <span class='hs-comment'>-- But I found this sometimes cost an extra iteration when we have</span>
<a name="line-1536"></a>    <span class='hs-comment'>--      rec { d = (a,b); a = ...df...; b = ...df...; df = d }</span>
<a name="line-1537"></a>    <span class='hs-comment'>-- where df is the exported dictionary. Then df makes a really</span>
<a name="line-1538"></a>    <span class='hs-comment'>-- bad choice for loop breaker</span>
<a name="line-1539"></a>
<a name="line-1540"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>df_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>old_unf</span>
<a name="line-1541"></a>    <span class='hs-comment'>-- Never choose a DFun as a loop breaker</span>
<a name="line-1542"></a>    <span class='hs-comment'>-- Note [DFuns should not be loop breakers]</span>
<a name="line-1543"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>9</span><span class='hs-layout'>,</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_lb</span><span class='hs-layout'>)</span>
<a name="line-1544"></a>
<a name="line-1545"></a>    <span class='hs-comment'>-- Data structures are more important than INLINE pragmas</span>
<a name="line-1546"></a>    <span class='hs-comment'>-- so that dictionary/method recursion unravels</span>
<a name="line-1547"></a>
<a name="line-1548"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>old_unf</span>
<a name="line-1549"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_score</span> <span class='hs-num'>6</span>
<a name="line-1550"></a>
<a name="line-1551"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_con_app</span> <span class='hs-varid'>rhs</span>   <span class='hs-comment'>-- Data types help with cases:</span>
<a name="line-1552"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_score</span> <span class='hs-num'>5</span>       <span class='hs-comment'>-- Note [Constructor applications]</span>
<a name="line-1553"></a>
<a name="line-1554"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableUnfolding</span> <span class='hs-varid'>old_unf</span>
<a name="line-1555"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>can_unfold</span>
<a name="line-1556"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_score</span> <span class='hs-num'>3</span>
<a name="line-1557"></a>
<a name="line-1558"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isOneOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>new_bndr</span><span class='hs-layout'>)</span>
<a name="line-1559"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_score</span> <span class='hs-num'>2</span>  <span class='hs-comment'>-- Likely to be inlined</span>
<a name="line-1560"></a>
<a name="line-1561"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>can_unfold</span>  <span class='hs-comment'>-- The Id has some kind of unfolding</span>
<a name="line-1562"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_score</span> <span class='hs-num'>1</span>
<a name="line-1563"></a>
<a name="line-1564"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1565"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_lb</span><span class='hs-layout'>)</span>
<a name="line-1566"></a>
<a name="line-1567"></a>  <span class='hs-keyword'>where</span>
<a name="line-1568"></a>    <span class='hs-varid'>mk_score</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NodeScore</span>
<a name="line-1569"></a>    <span class='hs-varid'>mk_score</span> <span class='hs-varid'>rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_size</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_lb</span><span class='hs-layout'>)</span>
<a name="line-1570"></a>
<a name="line-1571"></a>    <span class='hs-comment'>-- is_lb: see Note [Loop breakers, node scoring, and stability]</span>
<a name="line-1572"></a>    <span class='hs-varid'>is_lb</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStrongLoopBreaker</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>old_bndr</span><span class='hs-layout'>)</span>
<a name="line-1573"></a>
<a name="line-1574"></a>    <span class='hs-varid'>old_unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>old_bndr</span>
<a name="line-1575"></a>    <span class='hs-varid'>can_unfold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canUnfold</span> <span class='hs-varid'>old_unf</span>
<a name="line-1576"></a>    <span class='hs-varid'>rhs</span>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>old_unf</span> <span class='hs-keyword'>of</span>
<a name="line-1577"></a>                   <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unf_rhs</span> <span class='hs-layout'>}</span>
<a name="line-1578"></a>                     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableSource</span> <span class='hs-varid'>src</span>
<a name="line-1579"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unf_rhs</span>
<a name="line-1580"></a>                   <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bind_rhs</span>
<a name="line-1581"></a>       <span class='hs-comment'>-- 'bind_rhs' is irrelevant for inlining things with a stable unfolding</span>
<a name="line-1582"></a>    <span class='hs-varid'>rhs_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>old_unf</span> <span class='hs-keyword'>of</span>
<a name="line-1583"></a>                 <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>guidance</span> <span class='hs-layout'>}</span>
<a name="line-1584"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>guidance</span>
<a name="line-1585"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>size</span>
<a name="line-1586"></a>                 <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cheapExprSize</span> <span class='hs-varid'>rhs</span>
<a name="line-1587"></a>
<a name="line-1588"></a>
<a name="line-1589"></a>        <span class='hs-comment'>-- Checking for a constructor application</span>
<a name="line-1590"></a>        <span class='hs-comment'>-- Cheap and cheerful; the simplifier moves casts out of the way</span>
<a name="line-1591"></a>        <span class='hs-comment'>-- The lambda case is important to spot x = /\a. C (f a)</span>
<a name="line-1592"></a>        <span class='hs-comment'>-- which comes up when C is a dictionary constructor and</span>
<a name="line-1593"></a>        <span class='hs-comment'>-- f is a default method.</span>
<a name="line-1594"></a>        <span class='hs-comment'>-- Example: the instance for Show (ST s a) in GHC.ST</span>
<a name="line-1595"></a>        <span class='hs-comment'>--</span>
<a name="line-1596"></a>        <span class='hs-comment'>-- However we *also* treat (\x. C p q) as a con-app-like thing,</span>
<a name="line-1597"></a>        <span class='hs-comment'>--      Note [Closure conversion]</span>
<a name="line-1598"></a>    <span class='hs-varid'>is_con_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isConLikeId</span> <span class='hs-varid'>v</span>
<a name="line-1599"></a>    <span class='hs-varid'>is_con_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_con_app</span> <span class='hs-varid'>f</span>
<a name="line-1600"></a>    <span class='hs-varid'>is_con_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_con_app</span> <span class='hs-varid'>e</span>
<a name="line-1601"></a>    <span class='hs-varid'>is_con_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_con_app</span> <span class='hs-varid'>e</span>
<a name="line-1602"></a>    <span class='hs-varid'>is_con_app</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1603"></a>
<a name="line-1604"></a><a name="maxExprSize"></a><span class='hs-definition'>maxExprSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-1605"></a><span class='hs-definition'>maxExprSize</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>20</span>  <span class='hs-comment'>-- Rather arbitrary</span>
<a name="line-1606"></a>
<a name="line-1607"></a><a name="cheapExprSize"></a><span class='hs-definition'>cheapExprSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1608"></a><span class='hs-comment'>-- Maxes out at maxExprSize</span>
<a name="line-1609"></a><span class='hs-definition'>cheapExprSize</span> <span class='hs-varid'>e</span>
<a name="line-1610"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>e</span>
<a name="line-1611"></a>  <span class='hs-keyword'>where</span>
<a name="line-1612"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>maxExprSize</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1613"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-1614"></a>
<a name="line-1615"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span>
<a name="line-1616"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span>
<a name="line-1617"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1618"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1619"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-1620"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-1621"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>
<a name="line-1622"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1623"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-1624"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1625"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gos</span> <span class='hs-layout'>(</span><span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhssOfBind</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-1626"></a>    <span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gos</span> <span class='hs-layout'>(</span><span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhssOfAlts</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-1627"></a>
<a name="line-1628"></a>    <span class='hs-varid'>gos</span> <span class='hs-varid'>n</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1629"></a>    <span class='hs-varid'>gos</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-conop'>:</span><span class='hs-varid'>es</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>maxExprSize</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1630"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gos</span> <span class='hs-layout'>(</span><span class='hs-varid'>go1</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>es</span>
<a name="line-1631"></a>
<a name="line-1632"></a><a name="betterLB"></a><span class='hs-definition'>betterLB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NodeScore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NodeScore</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1633"></a><span class='hs-comment'>-- If  n1 `betterLB` n2  then choose n1 as the loop breaker</span>
<a name="line-1634"></a><span class='hs-definition'>betterLB</span> <span class='hs-layout'>(</span><span class='hs-varid'>rank1</span><span class='hs-layout'>,</span> <span class='hs-varid'>size1</span><span class='hs-layout'>,</span> <span class='hs-varid'>lb1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>rank2</span><span class='hs-layout'>,</span> <span class='hs-varid'>size2</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-1635"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rank1</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>rank2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1636"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rank1</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>rank2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1637"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>size1</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>size2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>   <span class='hs-comment'>-- Make the bigger n2 into the loop breaker</span>
<a name="line-1638"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>size1</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>size2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1639"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lb1</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>    <span class='hs-comment'>-- Tie-break: if n1 was a loop breaker before, choose it</span>
<a name="line-1640"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>   <span class='hs-comment'>-- See Note [Loop breakers, node scoring, and stability]</span>
<a name="line-1641"></a>
<a name="line-1642"></a><span class='hs-comment'>{- Note [Self-recursion and loop breakers]
<a name="line-1643"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1644"></a>If we have
<a name="line-1645"></a>   rec { f = ...f...g...
<a name="line-1646"></a>       ; g = .....f...   }
<a name="line-1647"></a>then 'f' has to be a loop breaker anyway, so we may as well choose it
<a name="line-1648"></a>right away, so that g can inline freely.
<a name="line-1649"></a>
<a name="line-1650"></a>This is really just a cheap hack. Consider
<a name="line-1651"></a>   rec { f = ...g...
<a name="line-1652"></a>       ; g = ..f..h...
<a name="line-1653"></a>      ;  h = ...f....}
<a name="line-1654"></a>Here f or g are better loop breakers than h; but we might accidentally
<a name="line-1655"></a>choose h.  Finding the minimal set of loop breakers is hard.
<a name="line-1656"></a>
<a name="line-1657"></a>Note [Loop breakers, node scoring, and stability]
<a name="line-1658"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1659"></a>To choose a loop breaker, we give a NodeScore to each node in the SCC,
<a name="line-1660"></a>and pick the one with the best score (according to 'betterLB').
<a name="line-1661"></a>
<a name="line-1662"></a>We need to be jolly careful (#12425, #12234) about the stability
<a name="line-1663"></a>of this choice. Suppose we have
<a name="line-1664"></a>
<a name="line-1665"></a>    let rec { f = ...g...g...
<a name="line-1666"></a>            ; g = ...f...f... }
<a name="line-1667"></a>    in
<a name="line-1668"></a>    case x of
<a name="line-1669"></a>      True  -&gt; ...f..
<a name="line-1670"></a>      False -&gt; ..f...
<a name="line-1671"></a>
<a name="line-1672"></a>In each iteration of the simplifier the occurrence analyser OccAnal
<a name="line-1673"></a>chooses a loop breaker. Suppose in iteration 1 it choose g as the loop
<a name="line-1674"></a>breaker. That means it is free to inline f.
<a name="line-1675"></a>
<a name="line-1676"></a>Suppose that GHC decides to inline f in the branches of the case, but
<a name="line-1677"></a>(for some reason; eg it is not saturated) in the rhs of g. So we get
<a name="line-1678"></a>
<a name="line-1679"></a>    let rec { f = ...g...g...
<a name="line-1680"></a>            ; g = ...f...f... }
<a name="line-1681"></a>    in
<a name="line-1682"></a>    case x of
<a name="line-1683"></a>      True  -&gt; ...g...g.....
<a name="line-1684"></a>      False -&gt; ..g..g....
<a name="line-1685"></a>
<a name="line-1686"></a>Now suppose that, for some reason, in the next iteration the occurrence
<a name="line-1687"></a>analyser chooses f as the loop breaker, so it can freely inline g. And
<a name="line-1688"></a>again for some reason the simplifier inlines g at its calls in the case
<a name="line-1689"></a>branches, but not in the RHS of f. Then we get
<a name="line-1690"></a>
<a name="line-1691"></a>    let rec { f = ...g...g...
<a name="line-1692"></a>            ; g = ...f...f... }
<a name="line-1693"></a>    in
<a name="line-1694"></a>    case x of
<a name="line-1695"></a>      True  -&gt; ...(...f...f...)...(...f..f..).....
<a name="line-1696"></a>      False -&gt; ..(...f...f...)...(..f..f...)....
<a name="line-1697"></a>
<a name="line-1698"></a>You can see where this is going! Each iteration of the simplifier
<a name="line-1699"></a>doubles the number of calls to f or g. No wonder GHC is slow!
<a name="line-1700"></a>
<a name="line-1701"></a>(In the particular example in comment:3 of #12425, f and g are the two
<a name="line-1702"></a>mutually recursive fmap instances for CondT and Result. They are both
<a name="line-1703"></a>marked INLINE which, oddly, is why they don't inline in each other's
<a name="line-1704"></a>RHS, because the call there is not saturated.)
<a name="line-1705"></a>
<a name="line-1706"></a>The root cause is that we flip-flop on our choice of loop breaker. I
<a name="line-1707"></a>always thought it didn't matter, and indeed for any single iteration
<a name="line-1708"></a>to terminate, it doesn't matter. But when we iterate, it matters a
<a name="line-1709"></a>lot!!
<a name="line-1710"></a>
<a name="line-1711"></a>So The Plan is this:
<a name="line-1712"></a>   If there is a tie, choose the node that
<a name="line-1713"></a>   was a loop breaker last time round
<a name="line-1714"></a>
<a name="line-1715"></a>Hence the is_lb field of NodeScore
<a name="line-1716"></a>
<a name="line-1717"></a>************************************************************************
<a name="line-1718"></a>*                                                                      *
<a name="line-1719"></a>                   Right hand sides
<a name="line-1720"></a>*                                                                      *
<a name="line-1721"></a>************************************************************************
<a name="line-1722"></a>-}</span>
<a name="line-1723"></a>
<a name="line-1724"></a><a name="occAnalRhs"></a><span class='hs-definition'>occAnalRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span>
<a name="line-1725"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>   <span class='hs-comment'>-- RHS</span>
<a name="line-1726"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1727"></a><span class='hs-definition'>occAnalRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>rhs</span>
<a name="line-1728"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalLamOrRhs</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1729"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>final_bndrs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRec</span> <span class='hs-varid'>is_rec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs'</span>
<a name="line-1730"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markJoinOneShots</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndrs'</span>
<a name="line-1731"></a>               <span class='hs-comment'>-- For a /non-recursive/ join point we can mark all</span>
<a name="line-1732"></a>               <span class='hs-comment'>-- its join-lambda as one-shot; and it's a good idea to do so</span>
<a name="line-1733"></a>
<a name="line-1734"></a>        <span class='hs-comment'>-- Final adjustment</span>
<a name="line-1735"></a>        <span class='hs-varid'>rhs_usage</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adjustRhsUsage</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>final_bndrs</span> <span class='hs-varid'>body_usage</span>
<a name="line-1736"></a>
<a name="line-1737"></a>    <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>final_bndrs</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1738"></a>  <span class='hs-keyword'>where</span>
<a name="line-1739"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>rhs</span>
<a name="line-1740"></a>    <span class='hs-varid'>env1</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-1741"></a>
<a name="line-1742"></a><a name="occAnalUnfolding"></a><span class='hs-definition'>occAnalUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-1743"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RecFlag</span>
<a name="line-1744"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span>   <span class='hs-comment'>-- See Note [Join points and unfoldings/rules]</span>
<a name="line-1745"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1746"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>Unfolding</span><span class='hs-layout'>)</span>
<a name="line-1747"></a><span class='hs-comment'>-- Occurrence-analyse a stable unfolding;</span>
<a name="line-1748"></a><span class='hs-comment'>-- discard a non-stable one altogether.</span>
<a name="line-1749"></a><span class='hs-definition'>occAnalUnfolding</span> <span class='hs-varid'>env</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>unf</span>
<a name="line-1750"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>unf</span> <span class='hs-keyword'>of</span>
<a name="line-1751"></a>      <span class='hs-varid'>unf</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1752"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isStableSource</span> <span class='hs-varid'>src</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>markAllMany</span> <span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>unf'</span><span class='hs-layout'>)</span>
<a name="line-1753"></a>              <span class='hs-comment'>-- markAllMany: see Note [Occurrences in stable unfoldings]</span>
<a name="line-1754"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span>      <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>
<a name="line-1755"></a>              <span class='hs-comment'>-- For non-Stable unfoldings we leave them undisturbed, but</span>
<a name="line-1756"></a>              <span class='hs-comment'>-- don't count their usage because the simplifier will discard them.</span>
<a name="line-1757"></a>              <span class='hs-comment'>-- We leave them undisturbed because nodeScore uses their size info</span>
<a name="line-1758"></a>              <span class='hs-comment'>-- to guide its decisions.  It's ok to leave un-substituted</span>
<a name="line-1759"></a>              <span class='hs-comment'>-- expressions in the tree because all the variables that were in</span>
<a name="line-1760"></a>              <span class='hs-comment'>-- scope remain in scope; there is no cloning etc.</span>
<a name="line-1761"></a>        <span class='hs-keyword'>where</span>
<a name="line-1762"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>rhs</span>
<a name="line-1763"></a>
<a name="line-1764"></a>          <span class='hs-varid'>unf'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>noBinderSwaps</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unf</span> <span class='hs-comment'>-- Note [Unfoldings and rules]</span>
<a name="line-1765"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unf</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs'</span> <span class='hs-layout'>}</span>
<a name="line-1766"></a>
<a name="line-1767"></a>      <span class='hs-varid'>unf</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>df_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1768"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span> <span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>unf</span> <span class='hs-layout'>{</span> <span class='hs-varid'>df_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args'</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span>
<a name="line-1769"></a>        <span class='hs-keyword'>where</span>
<a name="line-1770"></a>          <span class='hs-varid'>env'</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-varid'>bndrs</span>
<a name="line-1771"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalList</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>args</span>
<a name="line-1772"></a>          <span class='hs-varid'>final_usage</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllManyNonTail</span> <span class='hs-layout'>(</span><span class='hs-varid'>delDetailsList</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-1773"></a>
<a name="line-1774"></a>      <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span> <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>
<a name="line-1775"></a>
<a name="line-1776"></a><a name="occAnalRules"></a><span class='hs-definition'>occAnalRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-1777"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span>  <span class='hs-comment'>-- See Note [Join points and unfoldings/rules]</span>
<a name="line-1778"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>               <span class='hs-comment'>-- Get rules from here</span>
<a name="line-1779"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>CoreRule</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Each (non-built-in) rule</span>
<a name="line-1780"></a>                  <span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Usage details for LHS</span>
<a name="line-1781"></a>                  <span class='hs-conid'>UsageDetails</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Usage details for RHS</span>
<a name="line-1782"></a><span class='hs-definition'>occAnalRules</span> <span class='hs-varid'>env</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndr</span>
<a name="line-1783"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>occ_anal_rule</span> <span class='hs-layout'>(</span><span class='hs-varid'>idCoreRules</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-1784"></a>  <span class='hs-keyword'>where</span>
<a name="line-1785"></a>    <span class='hs-varid'>occ_anal_rule</span> <span class='hs-varid'>rule</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1786"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>rule'</span><span class='hs-layout'>,</span> <span class='hs-varid'>lhs_uds'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_uds'</span><span class='hs-layout'>)</span>
<a name="line-1787"></a>      <span class='hs-keyword'>where</span>
<a name="line-1788"></a>        <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-varid'>bndrs</span>
<a name="line-1789"></a>        <span class='hs-varid'>rule'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>noBinderSwaps</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span>  <span class='hs-comment'>-- Note [Unfoldings and rules]</span>
<a name="line-1790"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args'</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs'</span> <span class='hs-layout'>}</span>
<a name="line-1791"></a>
<a name="line-1792"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>lhs_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalList</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>args</span>
<a name="line-1793"></a>        <span class='hs-varid'>lhs_uds'</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllManyNonTail</span> <span class='hs-varop'>$</span>
<a name="line-1794"></a>                           <span class='hs-varid'>lhs_uds</span> <span class='hs-varop'>`delDetailsList`</span> <span class='hs-varid'>bndrs</span>
<a name="line-1795"></a>
<a name="line-1796"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>rhs_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>rhs</span>
<a name="line-1797"></a>                            <span class='hs-comment'>-- Note [Rules are extra RHSs]</span>
<a name="line-1798"></a>                            <span class='hs-comment'>-- Note [Rule dependency info]</span>
<a name="line-1799"></a>        <span class='hs-varid'>rhs_uds'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllNonTailIf</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>exact_join</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1800"></a>                   <span class='hs-varid'>markAllMany</span>                             <span class='hs-varop'>$</span>
<a name="line-1801"></a>                   <span class='hs-varid'>rhs_uds</span> <span class='hs-varop'>`delDetailsList`</span> <span class='hs-varid'>bndrs</span>
<a name="line-1802"></a>
<a name="line-1803"></a>        <span class='hs-varid'>exact_join</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exactJoin</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>args</span>
<a name="line-1804"></a>                     <span class='hs-comment'>-- See Note [Join points and unfoldings/rules]</span>
<a name="line-1805"></a>
<a name="line-1806"></a>    <span class='hs-varid'>occ_anal_rule</span> <span class='hs-varid'>other_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>other_rule</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyDetails</span><span class='hs-layout'>)</span>
<a name="line-1807"></a>
<a name="line-1808"></a><span class='hs-comment'>{- Note [Join point RHSs]
<a name="line-1809"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1810"></a>Consider
<a name="line-1811"></a>   x = e
<a name="line-1812"></a>   join j = Just x
<a name="line-1813"></a>
<a name="line-1814"></a>We want to inline x into j right away, so we don't want to give
<a name="line-1815"></a>the join point a RhsCtxt (#14137).  It's not a huge deal, because
<a name="line-1816"></a>the FloatIn pass knows to float into join point RHSs; and the simplifier
<a name="line-1817"></a>does not float things out of join point RHSs.  But it's a simple, cheap
<a name="line-1818"></a>thing to do.  See #14137.
<a name="line-1819"></a>
<a name="line-1820"></a>Note [Occurrences in stable unfoldings]
<a name="line-1821"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1822"></a>Consider
<a name="line-1823"></a>    f p = BIG
<a name="line-1824"></a>    {-# INLINE g #-}
<a name="line-1825"></a>    g y = not (f y)
<a name="line-1826"></a>where this is the /only/ occurrence of 'f'.  So 'g' will get a stable
<a name="line-1827"></a>unfolding.  Now suppose that g's RHS gets optimised (perhaps by a rule
<a name="line-1828"></a>or inlining f) so that it doesn't mention 'f' any more.  Now the last
<a name="line-1829"></a>remaining call to f is in g's Stable unfolding. But, even though there
<a name="line-1830"></a>is only one syntactic occurrence of f, we do /not/ want to do
<a name="line-1831"></a>preinlineUnconditionally here!
<a name="line-1832"></a>
<a name="line-1833"></a>The INLINE pragma says "inline exactly this RHS"; perhaps the
<a name="line-1834"></a>programmer wants to expose that 'not', say. If we inline f that will make
<a name="line-1835"></a>the Stable unfoldign big, and that wasn't what the programmer wanted.
<a name="line-1836"></a>
<a name="line-1837"></a>Another way to think about it: if we inlined g as-is into multiple
<a name="line-1838"></a>call sites, now there's be multiple calls to f.
<a name="line-1839"></a>
<a name="line-1840"></a>Bottom line: treat all occurrences in a stable unfolding as "Many".
<a name="line-1841"></a>
<a name="line-1842"></a>Note [Unfoldings and rules]
<a name="line-1843"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1844"></a>Generally unfoldings and rules are already occurrence-analysed, so we
<a name="line-1845"></a>don't want to reconstruct their trees; we just want to analyse them to
<a name="line-1846"></a>find how they use their free variables.
<a name="line-1847"></a>
<a name="line-1848"></a>EXCEPT if there is a binder-swap going on, in which case we do want to
<a name="line-1849"></a>produce a new tree.
<a name="line-1850"></a>
<a name="line-1851"></a>So we have a fast-path that keeps the old tree if the occ_bs_env is
<a name="line-1852"></a>empty.   This just saves a bit of allocation and reconstruction; not
<a name="line-1853"></a>a big deal.
<a name="line-1854"></a>
<a name="line-1855"></a>Note [Cascading inlines]
<a name="line-1856"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1857"></a>By default we use an rhsCtxt for the RHS of a binding.  This tells the
<a name="line-1858"></a>occ anal n that it's looking at an RHS, which has an effect in
<a name="line-1859"></a>occAnalApp.  In particular, for constructor applications, it makes
<a name="line-1860"></a>the arguments appear to have NoOccInfo, so that we don't inline into
<a name="line-1861"></a>them. Thus    x = f y
<a name="line-1862"></a>              k = Just x
<a name="line-1863"></a>we do not want to inline x.
<a name="line-1864"></a>
<a name="line-1865"></a>But there's a problem.  Consider
<a name="line-1866"></a>     x1 = a0 : []
<a name="line-1867"></a>     x2 = a1 : x1
<a name="line-1868"></a>     x3 = a2 : x2
<a name="line-1869"></a>     g  = f x3
<a name="line-1870"></a>First time round, it looks as if x1 and x2 occur as an arg of a
<a name="line-1871"></a>let-bound constructor ==&gt; give them a many-occurrence.
<a name="line-1872"></a>But then x3 is inlined (unconditionally as it happens) and
<a name="line-1873"></a>next time round, x2 will be, and the next time round x1 will be
<a name="line-1874"></a>Result: multiple simplifier iterations.  Sigh.
<a name="line-1875"></a>
<a name="line-1876"></a>So, when analysing the RHS of x3 we notice that x3 will itself
<a name="line-1877"></a>definitely inline the next time round, and so we analyse x3's rhs in
<a name="line-1878"></a>an ordinary context, not rhsCtxt.  Hence the "certainly_inline" stuff.
<a name="line-1879"></a>
<a name="line-1880"></a>Annoyingly, we have to approximate GHC.Core.Opt.Simplify.Utils.preInlineUnconditionally.
<a name="line-1881"></a>If (a) the RHS is expandable (see isExpandableApp in occAnalApp), and
<a name="line-1882"></a>   (b) certainly_inline says "yes" when preInlineUnconditionally says "no"
<a name="line-1883"></a>then the simplifier iterates indefinitely:
<a name="line-1884"></a>        x = f y
<a name="line-1885"></a>        k = Just x   -- We decide that k is 'certainly_inline'
<a name="line-1886"></a>        v = ...k...  -- but preInlineUnconditionally doesn't inline it
<a name="line-1887"></a>inline ==&gt;
<a name="line-1888"></a>        k = Just (f y)
<a name="line-1889"></a>        v = ...k...
<a name="line-1890"></a>float ==&gt;
<a name="line-1891"></a>        x1 = f y
<a name="line-1892"></a>        k = Just x1
<a name="line-1893"></a>        v = ...k...
<a name="line-1894"></a>
<a name="line-1895"></a>This is worse than the slow cascade, so we only want to say "certainly_inline"
<a name="line-1896"></a>if it really is certain.  Look at the note with preInlineUnconditionally
<a name="line-1897"></a>for the various clauses.
<a name="line-1898"></a>
<a name="line-1899"></a>
<a name="line-1900"></a>************************************************************************
<a name="line-1901"></a>*                                                                      *
<a name="line-1902"></a>                Expressions
<a name="line-1903"></a>*                                                                      *
<a name="line-1904"></a>************************************************************************
<a name="line-1905"></a>-}</span>
<a name="line-1906"></a>
<a name="line-1907"></a><a name="occAnalList"></a><span class='hs-definition'>occAnalList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1908"></a><span class='hs-definition'>occAnalList</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1909"></a><span class='hs-definition'>occAnalList</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-conop'>:</span><span class='hs-varid'>es</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>      <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uds1</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1910"></a>                         <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalList</span> <span class='hs-varid'>env</span> <span class='hs-varid'>es</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uds2</span><span class='hs-layout'>,</span> <span class='hs-varid'>es'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1911"></a>                         <span class='hs-layout'>(</span><span class='hs-varid'>uds1</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>uds2</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>es'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1912"></a>
<a name="line-1913"></a><a name="occAnal"></a><span class='hs-definition'>occAnal</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-1914"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1915"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- Gives info only about the "interesting" Ids</span>
<a name="line-1916"></a>            <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1917"></a>
<a name="line-1918"></a><span class='hs-definition'>occAnal</span> <span class='hs-keyword'>_</span>   <span class='hs-varid'>expr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span>         <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1919"></a><span class='hs-definition'>occAnal</span> <span class='hs-keyword'>_</span>   <span class='hs-varid'>expr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span>         <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1920"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>expr</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1921"></a>    <span class='hs-comment'>-- At one stage, I gathered the idRuleVars for the variable here too,</span>
<a name="line-1922"></a>    <span class='hs-comment'>-- which in a way is the right thing to do.</span>
<a name="line-1923"></a>    <span class='hs-comment'>-- But that went wrong right after specialisation, when</span>
<a name="line-1924"></a>    <span class='hs-comment'>-- the *occurrences* of the overloaded function didn't have any</span>
<a name="line-1925"></a>    <span class='hs-comment'>-- rules in them, so the *specialised* versions looked as if they</span>
<a name="line-1926"></a>    <span class='hs-comment'>-- weren't used at all.</span>
<a name="line-1927"></a>
<a name="line-1928"></a><span class='hs-definition'>occAnal</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1929"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>addManyOccs</span> <span class='hs-varid'>emptyDetails</span> <span class='hs-layout'>(</span><span class='hs-varid'>coVarsOfCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1930"></a>        <span class='hs-comment'>-- See Note [Gather occurrences of coercion variables]</span>
<a name="line-1931"></a>
<a name="line-1932"></a><span class='hs-comment'>{-
<a name="line-1933"></a>Note [Gather occurrences of coercion variables]
<a name="line-1934"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1935"></a>We need to gather info about what coercion variables appear, so that
<a name="line-1936"></a>we can sort them into the right place when doing dependency analysis.
<a name="line-1937"></a>-}</span>
<a name="line-1938"></a>
<a name="line-1939"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1940"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tickish</span>
<a name="line-1941"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-1942"></a>                  <span class='hs-comment'>-- SourceNotes are best-effort; so we just proceed as usual.</span>
<a name="line-1943"></a>                  <span class='hs-comment'>-- If we drop a tick due to the issues described below it's</span>
<a name="line-1944"></a>                  <span class='hs-comment'>-- not the end of the world.</span>
<a name="line-1945"></a>
<a name="line-1946"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickish</span> <span class='hs-varop'>`tickishScopesLike`</span> <span class='hs-conid'>SoftScope</span>
<a name="line-1947"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>markAllNonTail</span> <span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-1948"></a>
<a name="line-1949"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Breakpoint</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tickish</span>
<a name="line-1950"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage_lam</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>addManyOcc</span> <span class='hs-varid'>emptyDetails</span> <span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-1951"></a>    <span class='hs-comment'>-- never substitute for any of the Ids in a Breakpoint</span>
<a name="line-1952"></a>
<a name="line-1953"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1954"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage_lam</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tickish</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-1955"></a>  <span class='hs-keyword'>where</span>
<a name="line-1956"></a>    <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span><span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span>
<a name="line-1957"></a>    <span class='hs-comment'>-- for a non-soft tick scope, we can inline lambdas only</span>
<a name="line-1958"></a>    <span class='hs-varid'>usage_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllNonTail</span> <span class='hs-layout'>(</span><span class='hs-varid'>markAllInsideLam</span> <span class='hs-varid'>usage</span><span class='hs-layout'>)</span>
<a name="line-1959"></a>                  <span class='hs-comment'>-- TODO There may be ways to make ticks and join points play</span>
<a name="line-1960"></a>                  <span class='hs-comment'>-- nicer together, but right now there are problems:</span>
<a name="line-1961"></a>                  <span class='hs-comment'>--   let j x = ... in tick&lt;t&gt; (j 1)</span>
<a name="line-1962"></a>                  <span class='hs-comment'>-- Making j a join point may cause the simplifier to drop t</span>
<a name="line-1963"></a>                  <span class='hs-comment'>-- (if the tick is put into the continuation). So we don't</span>
<a name="line-1964"></a>                  <span class='hs-comment'>-- count j 1 as a tail call.</span>
<a name="line-1965"></a>                  <span class='hs-comment'>-- See #14242.</span>
<a name="line-1966"></a>
<a name="line-1967"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1968"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1969"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>usage1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllManyNonTailIf</span> <span class='hs-layout'>(</span><span class='hs-varid'>isRhsEnv</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>usage</span>
<a name="line-1970"></a>          <span class='hs-comment'>-- usage1: if we see let x = y `cast` co</span>
<a name="line-1971"></a>          <span class='hs-comment'>-- then mark y as 'Many' so that we don't</span>
<a name="line-1972"></a>          <span class='hs-comment'>-- immediately inline y again.</span>
<a name="line-1973"></a>        <span class='hs-varid'>usage2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addManyOccs</span> <span class='hs-varid'>usage1</span> <span class='hs-layout'>(</span><span class='hs-varid'>coVarsOfCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1974"></a>          <span class='hs-comment'>-- usage2: see Note [Gather occurrences of coercion variables]</span>
<a name="line-1975"></a>    <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>markAllNonTail</span> <span class='hs-varid'>usage2</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>expr'</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1976"></a>    <span class='hs-layout'>}</span>
<a name="line-1977"></a>
<a name="line-1978"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>app</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-1979"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>collectArgsTicks</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>app</span><span class='hs-layout'>)</span>
<a name="line-1980"></a>
<a name="line-1981"></a><span class='hs-comment'>-- Ignore type variables altogether</span>
<a name="line-1982"></a><span class='hs-comment'>--   (a) occurrences inside type lambdas only not marked as InsideLam</span>
<a name="line-1983"></a><span class='hs-comment'>--   (b) type variables not in environment</span>
<a name="line-1984"></a>
<a name="line-1985"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>x</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1986"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>x</span>
<a name="line-1987"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1988"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>markAllNonTail</span> <span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>x</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-1989"></a>    <span class='hs-layout'>}</span>
<a name="line-1990"></a>
<a name="line-1991"></a><span class='hs-comment'>{- Note [Occurrence analysis for lambda binders]
<a name="line-1992"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1993"></a>For value lambdas we do a special hack.  Consider
<a name="line-1994"></a>     (\x. \y. ...x...)
<a name="line-1995"></a>If we did nothing, x is used inside the \y, so would be marked
<a name="line-1996"></a>as dangerous to dup.  But in the common case where the abstraction
<a name="line-1997"></a>is applied to two arguments this is over-pessimistic, which delays
<a name="line-1998"></a>inlining x, which forces more simplifier iterations.
<a name="line-1999"></a>
<a name="line-2000"></a>So instead, we just mark each binder with its occurrence info in the
<a name="line-2001"></a>*body* of the multiple lambda.  Then, the simplifier is careful when
<a name="line-2002"></a>partially applying lambdas. See the calls to zapLamBndrs in
<a name="line-2003"></a>  GHC.Core.Opt.Simplify.simplExprF1
<a name="line-2004"></a>  GHC.Core.SimpleOpt.simple_app
<a name="line-2005"></a>-}</span>
<a name="line-2006"></a>
<a name="line-2007"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>expr</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-2008"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See Note [Occurrence analysis for lambda binders]</span>
<a name="line-2009"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalLamOrRhs</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2010"></a>    <span class='hs-keyword'>let</span>
<a name="line-2011"></a>        <span class='hs-varid'>expr'</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>tagged_bndrs</span> <span class='hs-varid'>body'</span>
<a name="line-2012"></a>        <span class='hs-varid'>usage1</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllNonTail</span> <span class='hs-varid'>usage</span>
<a name="line-2013"></a>        <span class='hs-varid'>one_shot_gp</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isOneShotBndr</span> <span class='hs-varid'>tagged_bndrs</span>
<a name="line-2014"></a>        <span class='hs-varid'>final_usage</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllInsideLamIf</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>one_shot_gp</span><span class='hs-layout'>)</span> <span class='hs-varid'>usage1</span>
<a name="line-2015"></a>    <span class='hs-keyword'>in</span>
<a name="line-2016"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2017"></a>  <span class='hs-keyword'>where</span>
<a name="line-2018"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>expr</span>
<a name="line-2019"></a>    <span class='hs-varid'>env1</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-2020"></a>
<a name="line-2021"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2022"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-layout'>(</span><span class='hs-varid'>scrutCtxt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>scrut_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2023"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>alt_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addBndrSwap</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>$</span>
<a name="line-2024"></a>                  <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span> <span class='hs-layout'>}</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span>
<a name="line-2025"></a>    <span class='hs-keyword'>in</span>
<a name="line-2026"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>mapAndUnzip</span> <span class='hs-layout'>(</span><span class='hs-varid'>occAnalAlt</span> <span class='hs-varid'>alt_env</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>alts_usage_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2027"></a>    <span class='hs-keyword'>let</span>
<a name="line-2028"></a>        <span class='hs-varid'>alts_usage</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>orUDs</span> <span class='hs-varid'>emptyDetails</span> <span class='hs-varid'>alts_usage_s</span>
<a name="line-2029"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>alts_usage1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_bndr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagLamBinder</span> <span class='hs-varid'>alts_usage</span> <span class='hs-varid'>bndr</span>
<a name="line-2030"></a>        <span class='hs-varid'>total_usage</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllNonTail</span> <span class='hs-varid'>scrut_usage</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>alts_usage1</span>
<a name="line-2031"></a>                        <span class='hs-comment'>-- Alts can have tail calls, but the scrutinee can't</span>
<a name="line-2032"></a>    <span class='hs-keyword'>in</span>
<a name="line-2033"></a>    <span class='hs-varid'>total_usage</span> <span class='hs-varop'>`seq`</span> <span class='hs-layout'>(</span><span class='hs-varid'>total_usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>tagged_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-2034"></a>
<a name="line-2035"></a><span class='hs-definition'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2036"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-varid'>bindersOf</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span>
<a name="line-2037"></a>                 <span class='hs-varid'>body</span>                    <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2038"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalBind</span> <span class='hs-varid'>env</span> <span class='hs-conid'>NotTopLevel</span>
<a name="line-2039"></a>                     <span class='hs-varid'>noImpRuleEdges</span> <span class='hs-varid'>bind</span>
<a name="line-2040"></a>                     <span class='hs-varid'>body_usage</span>          <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2041"></a>       <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLets</span> <span class='hs-varid'>new_binds</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-2042"></a>
<a name="line-2043"></a><a name="occAnalArgs"></a><span class='hs-definition'>occAnalArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShots</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2044"></a><span class='hs-definition'>occAnalArgs</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span>
<a name="line-2045"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-2046"></a>
<a name="line-2047"></a><span class='hs-definition'>occAnalArgs</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-conop'>:</span><span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>one_shots</span>
<a name="line-2048"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeArg</span> <span class='hs-varid'>arg</span>
<a name="line-2049"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalArgs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>one_shots</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2050"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span><span class='hs-conop'>:</span><span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2051"></a>
<a name="line-2052"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2053"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>argCtxt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>one_shots</span>           <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>one_shots'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2054"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>arg_env</span> <span class='hs-varid'>arg</span>             <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uds1</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2055"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalArgs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>one_shots'</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>uds2</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2056"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>uds1</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>uds2</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-conop'>:</span><span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-2057"></a>
<a name="line-2058"></a><span class='hs-comment'>{-
<a name="line-2059"></a>Applications are dealt with specially because we want
<a name="line-2060"></a>the "build hack" to work.
<a name="line-2061"></a>
<a name="line-2062"></a>Note [Arguments of let-bound constructors]
<a name="line-2063"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2064"></a>Consider
<a name="line-2065"></a>    f x = let y = expensive x in
<a name="line-2066"></a>          let z = (True,y) in
<a name="line-2067"></a>          (case z of {(p,q)-&gt;q}, case z of {(p,q)-&gt;q})
<a name="line-2068"></a>We feel free to duplicate the WHNF (True,y), but that means
<a name="line-2069"></a>that y may be duplicated thereby.
<a name="line-2070"></a>
<a name="line-2071"></a>If we aren't careful we duplicate the (expensive x) call!
<a name="line-2072"></a>Constructors are rather like lambdas in this way.
<a name="line-2073"></a>-}</span>
<a name="line-2074"></a>
<a name="line-2075"></a><a name="occAnalApp"></a><span class='hs-definition'>occAnalApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2076"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-conid'>CoreBndr</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreTickish</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2077"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>CoreBndr</span><span class='hs-layout'>)</span>
<a name="line-2078"></a><span class='hs-comment'>-- Naked variables (not applied) end up here too</span>
<a name="line-2079"></a><span class='hs-definition'>occAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ticks</span><span class='hs-layout'>)</span>
<a name="line-2080"></a>  <span class='hs-comment'>-- Account for join arity of runRW# continuation</span>
<a name="line-2081"></a>  <span class='hs-comment'>-- See Note [Simplification of runRW#]</span>
<a name="line-2082"></a>  <span class='hs-comment'>--</span>
<a name="line-2083"></a>  <span class='hs-comment'>-- NB: Do not be tempted to make the next (Var fun, args, tick)</span>
<a name="line-2084"></a>  <span class='hs-comment'>--     equation into an 'otherwise' clause for this equation</span>
<a name="line-2085"></a>  <span class='hs-comment'>--     The former has a bang-pattern to occ-anal the args, and</span>
<a name="line-2086"></a>  <span class='hs-comment'>--     we don't want to occ-anal them twice in the runRW# case!</span>
<a name="line-2087"></a>  <span class='hs-comment'>--     This caused #18296</span>
<a name="line-2088"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>runRWKey</span>
<a name="line-2089"></a>  <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t1</span><span class='hs-layout'>,</span> <span class='hs-varid'>t2</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>args</span>
<a name="line-2090"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalRhs</span> <span class='hs-varid'>env</span> <span class='hs-conid'>NonRecursive</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-2091"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>t1</span><span class='hs-layout'>,</span> <span class='hs-varid'>t2</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2092"></a>
<a name="line-2093"></a><span class='hs-definition'>occAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ticks</span><span class='hs-layout'>)</span>
<a name="line-2094"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>all_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>fun'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>
<a name="line-2095"></a>  <span class='hs-keyword'>where</span>
<a name="line-2096"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>fun'</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_id'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupBndrSwap</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun_id</span>
<a name="line-2097"></a>
<a name="line-2098"></a>    <span class='hs-varid'>fun_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkOneOcc</span> <span class='hs-varid'>fun_id'</span> <span class='hs-varid'>int_cxt</span> <span class='hs-varid'>n_args</span>
<a name="line-2099"></a>       <span class='hs-comment'>-- NB: fun_uds is computed for fun_id', not fun_id</span>
<a name="line-2100"></a>       <span class='hs-comment'>-- See (BS1) in Note [The binder-swap substitution]</span>
<a name="line-2101"></a>
<a name="line-2102"></a>    <span class='hs-varid'>all_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun_uds</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>final_args_uds</span>
<a name="line-2103"></a>
<a name="line-2104"></a>    <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varid'>args_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalArgs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>one_shots</span>
<a name="line-2105"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>final_args_uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllNonTail</span>                        <span class='hs-varop'>$</span>
<a name="line-2106"></a>                      <span class='hs-varid'>markAllInsideLamIf</span> <span class='hs-layout'>(</span><span class='hs-varid'>isRhsEnv</span> <span class='hs-varid'>env</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>is_exp</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2107"></a>                      <span class='hs-varid'>args_uds</span>
<a name="line-2108"></a>       <span class='hs-comment'>-- We mark the free vars of the argument of a constructor or PAP</span>
<a name="line-2109"></a>       <span class='hs-comment'>-- as "inside-lambda", if it is the RHS of a let(rec).</span>
<a name="line-2110"></a>       <span class='hs-comment'>-- This means that nothing gets inlined into a constructor or PAP</span>
<a name="line-2111"></a>       <span class='hs-comment'>-- argument position, which is what we want.  Typically those</span>
<a name="line-2112"></a>       <span class='hs-comment'>-- constructor arguments are just variables, or trivial expressions.</span>
<a name="line-2113"></a>       <span class='hs-comment'>-- We use inside-lam because it's like eta-expanding the PAP.</span>
<a name="line-2114"></a>       <span class='hs-comment'>--</span>
<a name="line-2115"></a>       <span class='hs-comment'>-- This is the *whole point* of the isRhsEnv predicate</span>
<a name="line-2116"></a>       <span class='hs-comment'>-- See Note [Arguments of let-bound constructors]</span>
<a name="line-2117"></a>
<a name="line-2118"></a>    <span class='hs-varid'>n_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>valArgCount</span> <span class='hs-varid'>args</span>
<a name="line-2119"></a>    <span class='hs-varid'>n_args</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span>
<a name="line-2120"></a>    <span class='hs-varid'>int_cxt</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occ_encl</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>of</span>
<a name="line-2121"></a>                   <span class='hs-conid'>OccScrut</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IsInteresting</span>
<a name="line-2122"></a>                   <span class='hs-sel'>_other</span>   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IsInteresting</span>
<a name="line-2123"></a>                            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NotInteresting</span>
<a name="line-2124"></a>
<a name="line-2125"></a>    <span class='hs-varid'>is_exp</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isExpandableApp</span> <span class='hs-varid'>fun_id</span> <span class='hs-varid'>n_val_args</span>
<a name="line-2126"></a>        <span class='hs-comment'>-- See Note [CONLIKE pragma] in GHC.Types.Basic</span>
<a name="line-2127"></a>        <span class='hs-comment'>-- The definition of is_exp should match that in GHC.Core.Opt.Simplify.prepareRhs</span>
<a name="line-2128"></a>
<a name="line-2129"></a>    <span class='hs-varid'>one_shots</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>argsOneShots</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStrictness</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>guaranteed_val_args</span>
<a name="line-2130"></a>    <span class='hs-varid'>guaranteed_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>+</span> <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-varid'>takeWhile</span> <span class='hs-varid'>isOneShotInfo</span>
<a name="line-2131"></a>                                                         <span class='hs-layout'>(</span><span class='hs-varid'>occ_one_shots</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2132"></a>        <span class='hs-comment'>-- See Note [Sources of one-shot information], bullet point A']</span>
<a name="line-2133"></a>
<a name="line-2134"></a><span class='hs-definition'>occAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ticks</span><span class='hs-layout'>)</span>
<a name="line-2135"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>markAllNonTail</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun_uds</span> <span class='hs-varop'>`andUDs`</span> <span class='hs-varid'>args_uds</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-2136"></a>     <span class='hs-varid'>mkTicks</span> <span class='hs-varid'>ticks</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>fun'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>
<a name="line-2137"></a>  <span class='hs-keyword'>where</span>
<a name="line-2138"></a>    <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varid'>fun_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnal</span> <span class='hs-layout'>(</span><span class='hs-varid'>addAppCtxt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>fun</span>
<a name="line-2139"></a>        <span class='hs-comment'>-- The addAppCtxt is a bit cunning.  One iteration of the simplifier</span>
<a name="line-2140"></a>        <span class='hs-comment'>-- often leaves behind beta redexs like</span>
<a name="line-2141"></a>        <span class='hs-comment'>--      (\x y -&gt; e) a1 a2</span>
<a name="line-2142"></a>        <span class='hs-comment'>-- Here we would like to mark x,y as one-shot, and treat the whole</span>
<a name="line-2143"></a>        <span class='hs-comment'>-- thing much like a let.  We do this by pushing some True items</span>
<a name="line-2144"></a>        <span class='hs-comment'>-- onto the context stack.</span>
<a name="line-2145"></a>    <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-varid'>args_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occAnalArgs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span> <span class='hs-conid'>[]</span>
<a name="line-2146"></a>
<a name="line-2147"></a>
<a name="line-2148"></a><span class='hs-comment'>{-
<a name="line-2149"></a>Note [Sources of one-shot information]
<a name="line-2150"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2151"></a>The occurrence analyser obtains one-shot-lambda information from two sources:
<a name="line-2152"></a>
<a name="line-2153"></a>A:  Saturated applications:  eg   f e1 .. en
<a name="line-2154"></a>
<a name="line-2155"></a>    In general, given a call (f e1 .. en) we can propagate one-shot info from
<a name="line-2156"></a>    f's strictness signature into e1 .. en, but /only/ if n is enough to
<a name="line-2157"></a>    saturate the strictness signature. A strictness signature like
<a name="line-2158"></a>
<a name="line-2159"></a>          f :: C1(C1(L))LS
<a name="line-2160"></a>
<a name="line-2161"></a>    means that *if f is applied to three arguments* then it will guarantee to
<a name="line-2162"></a>    call its first argument at most once, and to call the result of that at
<a name="line-2163"></a>    most once. But if f has fewer than three arguments, all bets are off; e.g.
<a name="line-2164"></a>
<a name="line-2165"></a>          map (f (\x y. expensive) e2) xs
<a name="line-2166"></a>
<a name="line-2167"></a>    Here the \x y abstraction may be called many times (once for each element of
<a name="line-2168"></a>    xs) so we should not mark x and y as one-shot. But if it was
<a name="line-2169"></a>
<a name="line-2170"></a>          map (f (\x y. expensive) 3 2) xs
<a name="line-2171"></a>
<a name="line-2172"></a>    then the first argument of f will be called at most once.
<a name="line-2173"></a>
<a name="line-2174"></a>    The one-shot info, derived from f's strictness signature, is
<a name="line-2175"></a>    computed by 'argsOneShots', called in occAnalApp.
<a name="line-2176"></a>
<a name="line-2177"></a>A': Non-obviously saturated applications: eg    build (f (\x y -&gt; expensive))
<a name="line-2178"></a>    where f is as above.
<a name="line-2179"></a>
<a name="line-2180"></a>    In this case, f is only manifestly applied to one argument, so it does not
<a name="line-2181"></a>    look saturated. So by the previous point, we should not use its strictness
<a name="line-2182"></a>    signature to learn about the one-shotness of \x y. But in this case we can:
<a name="line-2183"></a>    build is fully applied, so we may use its strictness signature; and from
<a name="line-2184"></a>    that we learn that build calls its argument with two arguments *at most once*.
<a name="line-2185"></a>
<a name="line-2186"></a>    So there is really only one call to f, and it will have three arguments. In
<a name="line-2187"></a>    that sense, f is saturated, and we may proceed as described above.
<a name="line-2188"></a>
<a name="line-2189"></a>    Hence the computation of 'guaranteed_val_args' in occAnalApp, using
<a name="line-2190"></a>    '(occ_one_shots env)'.  See also #13227, comment:9
<a name="line-2191"></a>
<a name="line-2192"></a>B:  Let-bindings:  eg   let f = \c. let ... in \n -&gt; blah
<a name="line-2193"></a>                        in (build f, build f)
<a name="line-2194"></a>
<a name="line-2195"></a>    Propagate one-shot info from the demanand-info on 'f' to the
<a name="line-2196"></a>    lambdas in its RHS (which may not be syntactically at the top)
<a name="line-2197"></a>
<a name="line-2198"></a>    This information must have come from a previous run of the demanand
<a name="line-2199"></a>    analyser.
<a name="line-2200"></a>
<a name="line-2201"></a>Previously, the demand analyser would *also* set the one-shot information, but
<a name="line-2202"></a>that code was buggy (see #11770), so doing it only in on place, namely here, is
<a name="line-2203"></a>saner.
<a name="line-2204"></a>
<a name="line-2205"></a>Note [OneShots]
<a name="line-2206"></a>~~~~~~~~~~~~~~~
<a name="line-2207"></a>When analysing an expression, the occ_one_shots argument contains information
<a name="line-2208"></a>about how the function is being used. The length of the list indicates
<a name="line-2209"></a>how many arguments will eventually be passed to the analysed expression,
<a name="line-2210"></a>and the OneShotInfo indicates whether this application is once or multiple times.
<a name="line-2211"></a>
<a name="line-2212"></a>Example:
<a name="line-2213"></a>
<a name="line-2214"></a> Context of f                occ_one_shots when analysing f
<a name="line-2215"></a>
<a name="line-2216"></a> f 1 2                       [OneShot, OneShot]
<a name="line-2217"></a> map (f 1)                   [OneShot, NoOneShotInfo]
<a name="line-2218"></a> build f                     [OneShot, OneShot]
<a name="line-2219"></a> f 1 2 `seq` f 2 1           [NoOneShotInfo, OneShot]
<a name="line-2220"></a>
<a name="line-2221"></a>Note [Binders in case alternatives]
<a name="line-2222"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2223"></a>Consider
<a name="line-2224"></a>    case x of y { (a,b) -&gt; f y }
<a name="line-2225"></a>We treat 'a', 'b' as dead, because they don't physically occur in the
<a name="line-2226"></a>case alternative.  (Indeed, a variable is dead iff it doesn't occur in
<a name="line-2227"></a>its scope in the output of OccAnal.)  It really helps to know when
<a name="line-2228"></a>binders are unused.  See esp the call to isDeadBinder in
<a name="line-2229"></a>Simplify.mkDupableAlt
<a name="line-2230"></a>
<a name="line-2231"></a>In this example, though, the Simplifier will bring 'a' and 'b' back to
<a name="line-2232"></a>life, because it binds 'y' to (a,b) (imagine got inlined and
<a name="line-2233"></a>scrutinised y).
<a name="line-2234"></a>-}</span>
<a name="line-2235"></a>
<a name="line-2236"></a><a name="occAnalLamOrRhs"></a><span class='hs-definition'>occAnalLamOrRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-2237"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-2238"></a><span class='hs-comment'>-- Tags the returned binders with their OccInfo, but does</span>
<a name="line-2239"></a><span class='hs-comment'>-- not do any markInsideLam to the returned usage details</span>
<a name="line-2240"></a><span class='hs-definition'>occAnalLamOrRhs</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span>
<a name="line-2241"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-2242"></a>      <span class='hs-comment'>-- RHS of thunk or nullary join point</span>
<a name="line-2243"></a>
<a name="line-2244"></a><span class='hs-definition'>occAnalLamOrRhs</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-conop'>:</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-2245"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span>
<a name="line-2246"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Important: Keep the environment so that we don't inline into an RHS like</span>
<a name="line-2247"></a>    <span class='hs-comment'>--   \(@ x) -&gt; C @x (f @x)</span>
<a name="line-2248"></a>    <span class='hs-comment'>-- (see the beginning of Note [Cascading inlines]).</span>
<a name="line-2249"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnalLamOrRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span>
<a name="line-2250"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr</span><span class='hs-conop'>:</span><span class='hs-varid'>bndrs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-2251"></a>
<a name="line-2252"></a><span class='hs-definition'>occAnalLamOrRhs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>binders</span> <span class='hs-varid'>body</span>
<a name="line-2253"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-varid'>env_body</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2254"></a>    <span class='hs-keyword'>let</span>
<a name="line-2255"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_binders</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagLamBinders</span> <span class='hs-varid'>body_usage</span> <span class='hs-varid'>binders'</span>
<a name="line-2256"></a>                      <span class='hs-comment'>-- Use binders' to put one-shot info on the lambdas</span>
<a name="line-2257"></a>    <span class='hs-keyword'>in</span>
<a name="line-2258"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_binders</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2259"></a>  <span class='hs-keyword'>where</span>
<a name="line-2260"></a>    <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-varid'>binders</span>
<a name="line-2261"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>env_body</span><span class='hs-layout'>,</span> <span class='hs-varid'>binders'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oneShotGroup</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>binders</span>
<a name="line-2262"></a>
<a name="line-2263"></a><a name="occAnalAlt"></a><span class='hs-definition'>occAnalAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2264"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreAlt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>IdWithOccInfo</span><span class='hs-layout'>)</span>
<a name="line-2265"></a><span class='hs-definition'>occAnalAlt</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2266"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occAnal</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-varop'>`addInScope`</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_usage1</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2267"></a>    <span class='hs-keyword'>let</span>
<a name="line-2268"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>alt_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>tagged_bndrs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tagLamBinders</span> <span class='hs-varid'>rhs_usage1</span> <span class='hs-varid'>bndrs</span>
<a name="line-2269"></a>    <span class='hs-keyword'>in</span>                          <span class='hs-comment'>-- See Note [Binders in case alternatives]</span>
<a name="line-2270"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>alt_usg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tagged_bndrs</span> <span class='hs-varid'>rhs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2271"></a>
<a name="line-2272"></a><span class='hs-comment'>{-
<a name="line-2273"></a>************************************************************************
<a name="line-2274"></a>*                                                                      *
<a name="line-2275"></a>                    OccEnv
<a name="line-2276"></a>*                                                                      *
<a name="line-2277"></a>************************************************************************
<a name="line-2278"></a>-}</span>
<a name="line-2279"></a>
<a name="line-2280"></a><a name="OccEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2281"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span>       <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>OccEncl</span>      <span class='hs-comment'>-- Enclosing context information</span>
<a name="line-2282"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_one_shots</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>OneShots</span>     <span class='hs-comment'>-- See Note [OneShots]</span>
<a name="line-2283"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_unf_act</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>          <span class='hs-comment'>-- Which Id unfoldings are active</span>
<a name="line-2284"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_rule_act</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Activation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>  <span class='hs-comment'>-- Which rules are active</span>
<a name="line-2285"></a>             <span class='hs-comment'>-- See Note [Finding rule RHS free vars]</span>
<a name="line-2286"></a>
<a name="line-2287"></a>           <span class='hs-comment'>-- See Note [The binder-swap substitution]</span>
<a name="line-2288"></a>           <span class='hs-comment'>-- If  x :-&gt; (y, co)  is in the env,</span>
<a name="line-2289"></a>           <span class='hs-comment'>-- then please replace x by (y |&gt; mco)</span>
<a name="line-2290"></a>           <span class='hs-comment'>-- Invariant of course: idType x = exprType (y |&gt; mco)</span>
<a name="line-2291"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_env</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>IdEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>OutId</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2292"></a>                   <span class='hs-comment'>-- Domain is Global and Local Ids</span>
<a name="line-2293"></a>                   <span class='hs-comment'>-- Range is just Local Ids</span>
<a name="line-2294"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_rng</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>VarSet</span>
<a name="line-2295"></a>                   <span class='hs-comment'>-- Vars (TyVars and Ids) free in the range of occ_bs_env</span>
<a name="line-2296"></a>    <span class='hs-layout'>}</span>
<a name="line-2297"></a>
<a name="line-2298"></a>
<a name="line-2299"></a><span class='hs-comment'>-----------------------------</span>
<a name="line-2300"></a><span class='hs-comment'>-- OccEncl is used to control whether to inline into constructor arguments</span>
<a name="line-2301"></a><span class='hs-comment'>-- For example:</span>
<a name="line-2302"></a><span class='hs-comment'>--      x = (p,q)               -- Don't inline p or q</span>
<a name="line-2303"></a><span class='hs-comment'>--      y = /\a -&gt; (p a, q a)   -- Still don't inline p or q</span>
<a name="line-2304"></a><span class='hs-comment'>--      z = f (p,q)             -- Do inline p,q; it may make a rule fire</span>
<a name="line-2305"></a><span class='hs-comment'>-- So OccEncl tells enough about the context to know what to do when</span>
<a name="line-2306"></a><span class='hs-comment'>-- we encounter a constructor application or PAP.</span>
<a name="line-2307"></a><span class='hs-comment'>--</span>
<a name="line-2308"></a><span class='hs-comment'>-- OccScrut is used to set the "interesting context" field of OncOcc</span>
<a name="line-2309"></a>
<a name="line-2310"></a><a name="OccEncl"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>OccEncl</span>
<a name="line-2311"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccRhs</span>         <span class='hs-comment'>-- RHS of let(rec), albeit perhaps inside a type lambda</span>
<a name="line-2312"></a>                   <span class='hs-comment'>-- Don't inline into constructor args here</span>
<a name="line-2313"></a>
<a name="line-2314"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OccScrut</span>       <span class='hs-comment'>-- Scrutintee of a case</span>
<a name="line-2315"></a>                   <span class='hs-comment'>-- Can inline into constructor args</span>
<a name="line-2316"></a>
<a name="line-2317"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OccVanilla</span>     <span class='hs-comment'>-- Argument of function, body of lambda, etc</span>
<a name="line-2318"></a>                   <span class='hs-comment'>-- Do inline into constructor args here</span>
<a name="line-2319"></a>
<a name="line-2320"></a><a name="instance%20Outputable%20OccEncl"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>OccEncl</span> <span class='hs-keyword'>where</span>
<a name="line-2321"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>OccRhs</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"occRhs"</span>
<a name="line-2322"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>OccScrut</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"occScrut"</span>
<a name="line-2323"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>OccVanilla</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"occVanilla"</span>
<a name="line-2324"></a>
<a name="line-2325"></a><a name="OneShots"></a><span class='hs-comment'>-- See note [OneShots]</span>
<a name="line-2326"></a><a name="OneShots"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OneShots</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>
<a name="line-2327"></a>
<a name="line-2328"></a><a name="initOccEnv"></a><span class='hs-definition'>initOccEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2329"></a><span class='hs-definition'>initOccEnv</span>
<a name="line-2330"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span>
<a name="line-2331"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-2332"></a>
<a name="line-2333"></a>                 <span class='hs-comment'>-- To be conservative, we say that all</span>
<a name="line-2334"></a>                 <span class='hs-comment'>-- inlines and rules are active</span>
<a name="line-2335"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_unf_act</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2336"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_rule_act</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>\</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2337"></a>
<a name="line-2338"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-2339"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_rng</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-layout'>}</span>
<a name="line-2340"></a>
<a name="line-2341"></a><a name="noBinderSwaps"></a><span class='hs-definition'>noBinderSwaps</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2342"></a><span class='hs-definition'>noBinderSwaps</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bs_env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isEmptyVarEnv</span> <span class='hs-varid'>bs_env</span>
<a name="line-2343"></a>
<a name="line-2344"></a><a name="scrutCtxt"></a><span class='hs-definition'>scrutCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreAlt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2345"></a><span class='hs-definition'>scrutCtxt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>alts</span>
<a name="line-2346"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>interesting_alts</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccScrut</span><span class='hs-layout'>,</span>   <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span>
<a name="line-2347"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span>
<a name="line-2348"></a>  <span class='hs-keyword'>where</span>
<a name="line-2349"></a>    <span class='hs-varid'>interesting_alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>alts</span> <span class='hs-keyword'>of</span>
<a name="line-2350"></a>                         <span class='hs-conid'>[]</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2351"></a>                         <span class='hs-keyglyph'>[</span><span class='hs-varid'>alt</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDefaultAlt</span> <span class='hs-varid'>alt</span><span class='hs-layout'>)</span>
<a name="line-2352"></a>                         <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2353"></a>     <span class='hs-comment'>-- 'interesting_alts' is True if the case has at least one</span>
<a name="line-2354"></a>     <span class='hs-comment'>-- non-default alternative.  That in turn influences</span>
<a name="line-2355"></a>     <span class='hs-comment'>-- pre/postInlineUnconditionally.  Grep for "occ_int_cxt"!</span>
<a name="line-2356"></a>
<a name="line-2357"></a><a name="rhsCtxt"></a><span class='hs-definition'>rhsCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2358"></a><span class='hs-definition'>rhsCtxt</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccRhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span>
<a name="line-2359"></a>
<a name="line-2360"></a><a name="argCtxt"></a><span class='hs-definition'>argCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShots</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShots</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2361"></a><span class='hs-definition'>argCtxt</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span>
<a name="line-2362"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-2363"></a><span class='hs-definition'>argCtxt</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>one_shots</span><span class='hs-conop'>:</span><span class='hs-varid'>one_shots_s</span><span class='hs-layout'>)</span>
<a name="line-2364"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>one_shots</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>one_shots_s</span><span class='hs-layout'>)</span>
<a name="line-2365"></a>
<a name="line-2366"></a><a name="isRhsEnv"></a><span class='hs-definition'>isRhsEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2367"></a><span class='hs-definition'>isRhsEnv</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cxt</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cxt</span> <span class='hs-keyword'>of</span>
<a name="line-2368"></a>                                          <span class='hs-conid'>OccRhs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2369"></a>                                          <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2370"></a>
<a name="line-2371"></a><a name="addInScope"></a><span class='hs-definition'>addInScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2372"></a><span class='hs-comment'>-- See Note [The binder-swap substitution]</span>
<a name="line-2373"></a><span class='hs-definition'>addInScope</span> <span class='hs-varid'>env</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>swap_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_rng</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rng_vars</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-2374"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>rng_vars</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_rng</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-layout'>}</span>
<a name="line-2375"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>swap_env</span> <span class='hs-varop'>`delVarEnvList`</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>}</span>
<a name="line-2376"></a>
<a name="line-2377"></a><a name="oneShotGroup"></a><span class='hs-definition'>oneShotGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span>
<a name="line-2378"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2379"></a>                <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>
<a name="line-2380"></a>        <span class='hs-comment'>-- The result binders have one-shot-ness set that they might not have had originally.</span>
<a name="line-2381"></a>        <span class='hs-comment'>-- This happens in (build (\c n -&gt; e)).  Here the occurrence analyser</span>
<a name="line-2382"></a>        <span class='hs-comment'>-- linearity context knows that c,n are one-shot, and it records that fact in</span>
<a name="line-2383"></a>        <span class='hs-comment'>-- the binder. This is useful to guide subsequent float-in/float-out transformations</span>
<a name="line-2384"></a>
<a name="line-2385"></a><span class='hs-definition'>oneShotGroup</span> <span class='hs-varid'>env</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-2386"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>bndrs</span> <span class='hs-conid'>[]</span>
<a name="line-2387"></a>  <span class='hs-keyword'>where</span>
<a name="line-2388"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ctxt</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>rev_bndrs</span>
<a name="line-2389"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span> <span class='hs-layout'>}</span>
<a name="line-2390"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_bndrs</span> <span class='hs-layout'>)</span>
<a name="line-2391"></a>
<a name="line-2392"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rev_bndrs</span>
<a name="line-2393"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_encl</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccVanilla</span> <span class='hs-layout'>}</span>
<a name="line-2394"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_bndrs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>)</span>
<a name="line-2395"></a>
<a name="line-2396"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ctxt</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>one_shot</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ctxt'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>rev_bndrs</span>
<a name="line-2397"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ctxt'</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr'</span><span class='hs-conop'>:</span> <span class='hs-varid'>rev_bndrs</span><span class='hs-layout'>)</span>
<a name="line-2398"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ctxt</span>  <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rev_bndrs</span><span class='hs-layout'>)</span>
<a name="line-2399"></a>      <span class='hs-keyword'>where</span>
<a name="line-2400"></a>        <span class='hs-varid'>bndr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updOneShotInfo</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>one_shot</span>
<a name="line-2401"></a>               <span class='hs-comment'>-- Use updOneShotInfo, not setOneShotInfo, as pre-existing</span>
<a name="line-2402"></a>               <span class='hs-comment'>-- one-shot info might be better than what we can infer, e.g.</span>
<a name="line-2403"></a>               <span class='hs-comment'>-- due to explicit use of the magic 'oneShot' function.</span>
<a name="line-2404"></a>               <span class='hs-comment'>-- See Note [The oneShot function]</span>
<a name="line-2405"></a>
<a name="line-2406"></a>
<a name="line-2407"></a><a name="markJoinOneShots"></a><span class='hs-definition'>markJoinOneShots</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-2408"></a><span class='hs-comment'>-- Mark the lambdas of a non-recursive join point as one-shot.</span>
<a name="line-2409"></a><span class='hs-comment'>-- This is good to prevent gratuitous float-out etc</span>
<a name="line-2410"></a><span class='hs-definition'>markJoinOneShots</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndrs</span>
<a name="line-2411"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-keyword'>of</span>
<a name="line-2412"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bndrs</span>
<a name="line-2413"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>n</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>bndrs</span>
<a name="line-2414"></a> <span class='hs-keyword'>where</span>
<a name="line-2415"></a>   <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>bndrs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span>
<a name="line-2416"></a>   <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span> <span class='hs-comment'>-- This can legitimately happen.</span>
<a name="line-2417"></a>                    <span class='hs-comment'>-- e.g.    let j = case ... in j True</span>
<a name="line-2418"></a>                    <span class='hs-comment'>-- This will become an arity-1 join point after the</span>
<a name="line-2419"></a>                    <span class='hs-comment'>-- simplifier has eta-expanded it; but it may not have</span>
<a name="line-2420"></a>                    <span class='hs-comment'>-- enough lambdas /yet/. (Lint checks that JoinIds do</span>
<a name="line-2421"></a>                    <span class='hs-comment'>-- have enough lambdas.)</span>
<a name="line-2422"></a>   <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>bs</span>
<a name="line-2423"></a>     <span class='hs-keyword'>where</span>
<a name="line-2424"></a>       <span class='hs-varid'>b'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setOneShotLambda</span> <span class='hs-varid'>b</span>
<a name="line-2425"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>
<a name="line-2426"></a>
<a name="line-2427"></a><a name="addAppCtxt"></a><span class='hs-definition'>addAppCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2428"></a><span class='hs-definition'>addAppCtxt</span> <span class='hs-varid'>env</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-2429"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>replicate</span> <span class='hs-layout'>(</span><span class='hs-varid'>valArgCount</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-conid'>OneShotLam</span> <span class='hs-varop'>++</span> <span class='hs-varid'>ctxt</span> <span class='hs-layout'>}</span>
<a name="line-2430"></a>
<a name="line-2431"></a><a name="transClosureFV"></a><span class='hs-comment'>--------------------</span>
<a name="line-2432"></a><span class='hs-definition'>transClosureFV</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>VarSet</span>
<a name="line-2433"></a><span class='hs-comment'>-- If (f,g), (g,h) are in the input, then (f,h) is in the output</span>
<a name="line-2434"></a><span class='hs-comment'>--                                   as well as (f,g), (g,h)</span>
<a name="line-2435"></a><span class='hs-definition'>transClosureFV</span> <span class='hs-varid'>env</span>
<a name="line-2436"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>no_change</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-2437"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transClosureFV</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToUFM_Directly</span> <span class='hs-varid'>new_fv_list</span><span class='hs-layout'>)</span>
<a name="line-2438"></a>  <span class='hs-keyword'>where</span>
<a name="line-2439"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>no_change</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_fv_list</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>bump</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varid'>nonDetUFMToList</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-2440"></a>      <span class='hs-comment'>-- It's OK to use nonDetUFMToList here because we'll forget the</span>
<a name="line-2441"></a>      <span class='hs-comment'>-- ordering by creating a new set with listToUFM</span>
<a name="line-2442"></a>    <span class='hs-varid'>bump</span> <span class='hs-varid'>no_change</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>fvs</span><span class='hs-layout'>)</span>
<a name="line-2443"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>no_change_here</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_change</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>fvs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2444"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span>     <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>new_fvs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2445"></a>      <span class='hs-keyword'>where</span>
<a name="line-2446"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>new_fvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>no_change_here</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendFvs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fvs</span>
<a name="line-2447"></a>
<a name="line-2448"></a><a name="extendFvs_"></a><span class='hs-comment'>-------------</span>
<a name="line-2449"></a><span class='hs-definition'>extendFvs_</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-2450"></a><span class='hs-definition'>extendFvs_</span> <span class='hs-varid'>env</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fst</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendFvs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Discard the Bool flag</span>
<a name="line-2451"></a>
<a name="line-2452"></a><a name="extendFvs"></a><span class='hs-definition'>extendFvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>VarSet</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>
<a name="line-2453"></a><span class='hs-comment'>-- (extendFVs env s) returns</span>
<a name="line-2454"></a><span class='hs-comment'>--     (s `union` env(s), env(s) `subset` s)</span>
<a name="line-2455"></a><span class='hs-definition'>extendFvs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>s</span>
<a name="line-2456"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNullUFM</span> <span class='hs-varid'>env</span>
<a name="line-2457"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-2458"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2459"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>s</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>extras</span><span class='hs-layout'>,</span> <span class='hs-varid'>extras</span> <span class='hs-varop'>`subVarSet`</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-2460"></a>  <span class='hs-keyword'>where</span>
<a name="line-2461"></a>    <span class='hs-varid'>extras</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span>    <span class='hs-comment'>-- env(s)</span>
<a name="line-2462"></a>    <span class='hs-varid'>extras</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonDetStrictFoldUFM</span> <span class='hs-varid'>unionVarSet</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varop'>$</span>
<a name="line-2463"></a>      <span class='hs-comment'>-- It's OK to use nonDetStrictFoldUFM here because unionVarSet commutes</span>
<a name="line-2464"></a>             <span class='hs-varid'>intersectUFM_C</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUniqSet</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-2465"></a>
<a name="line-2466"></a><span class='hs-comment'>{-
<a name="line-2467"></a>************************************************************************
<a name="line-2468"></a>*                                                                      *
<a name="line-2469"></a>                    Binder swap
<a name="line-2470"></a>*                                                                      *
<a name="line-2471"></a>************************************************************************
<a name="line-2472"></a>
<a name="line-2473"></a>Note [Binder swap]
<a name="line-2474"></a>~~~~~~~~~~~~~~~~~~
<a name="line-2475"></a>The "binder swap" transformation swaps occurrence of the
<a name="line-2476"></a>scrutinee of a case for occurrences of the case-binder:
<a name="line-2477"></a>
<a name="line-2478"></a> (1)  case x of b { pi -&gt; ri }
<a name="line-2479"></a>         ==&gt;
<a name="line-2480"></a>      case x of b { pi -&gt; ri[b/x] }
<a name="line-2481"></a>
<a name="line-2482"></a> (2)  case (x |&gt; co) of b { pi -&gt; ri }
<a name="line-2483"></a>        ==&gt;
<a name="line-2484"></a>      case (x |&gt; co) of b { pi -&gt; ri[b |&gt; sym co/x] }
<a name="line-2485"></a>
<a name="line-2486"></a>The substitution ri[b/x] etc is done by the occurrence analyser.
<a name="line-2487"></a>See Note [The binder-swap substitution].
<a name="line-2488"></a>
<a name="line-2489"></a>There are two reasons for making this swap:
<a name="line-2490"></a>
<a name="line-2491"></a>(A) It reduces the number of occurrences of the scrutinee, x.
<a name="line-2492"></a>    That in turn might reduce its occurrences to one, so we
<a name="line-2493"></a>    can inline it and save an allocation.  E.g.
<a name="line-2494"></a>      let x = factorial y in case x of b { I# v -&gt; ...x... }
<a name="line-2495"></a>    If we replace 'x' by 'b' in the alternative we get
<a name="line-2496"></a>      let x = factorial y in case x of b { I# v -&gt; ...b... }
<a name="line-2497"></a>    and now we can inline 'x', thus
<a name="line-2498"></a>      case (factorial y) of b { I# v -&gt; ...b... }
<a name="line-2499"></a>
<a name="line-2500"></a>(B) The case-binder b has unfolding information; in the
<a name="line-2501"></a>    example above we know that b = I# v. That in turn allows
<a name="line-2502"></a>    nested cases to simplify.  Consider
<a name="line-2503"></a>       case x of b { I# v -&gt;
<a name="line-2504"></a>       ...(case x of b2 { I# v2 -&gt; rhs })...
<a name="line-2505"></a>    If we replace 'x' by 'b' in the alternative we get
<a name="line-2506"></a>       case x of b { I# v -&gt;
<a name="line-2507"></a>       ...(case b of b2 { I# v2 -&gt; rhs })...
<a name="line-2508"></a>    and now it is trivial to simplify the inner case:
<a name="line-2509"></a>       case x of b { I# v -&gt;
<a name="line-2510"></a>       ...(let b2 = b in rhs)...
<a name="line-2511"></a>
<a name="line-2512"></a>    The same can happen even if the scrutinee is a variable
<a name="line-2513"></a>    with a cast: see Note [Case of cast]
<a name="line-2514"></a>
<a name="line-2515"></a>The reason for doing these transformations /here in the occurrence
<a name="line-2516"></a>analyser/ is because it allows us to adjust the OccInfo for 'x' and
<a name="line-2517"></a>'b' as we go.
<a name="line-2518"></a>
<a name="line-2519"></a>  * Suppose the only occurrences of 'x' are the scrutinee and in the
<a name="line-2520"></a>    ri; then this transformation makes it occur just once, and hence
<a name="line-2521"></a>    get inlined right away.
<a name="line-2522"></a>
<a name="line-2523"></a>  * If instead the Simplifier replaces occurrences of x with
<a name="line-2524"></a>    occurrences of b, that will mess up b's occurrence info. That in
<a name="line-2525"></a>    turn might have consequences.
<a name="line-2526"></a>
<a name="line-2527"></a>There is a danger though.  Consider
<a name="line-2528"></a>      let v = x +# y
<a name="line-2529"></a>      in case (f v) of w -&gt; ...v...v...
<a name="line-2530"></a>And suppose that (f v) expands to just v.  Then we'd like to
<a name="line-2531"></a>use 'w' instead of 'v' in the alternative.  But it may be too
<a name="line-2532"></a>late; we may have substituted the (cheap) x+#y for v in the
<a name="line-2533"></a>same simplifier pass that reduced (f v) to v.
<a name="line-2534"></a>
<a name="line-2535"></a>I think this is just too bad.  CSE will recover some of it.
<a name="line-2536"></a>
<a name="line-2537"></a>Note [The binder-swap substitution]
<a name="line-2538"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2539"></a>The binder-swap is implemented by the occ_bs_env field of OccEnv.
<a name="line-2540"></a>There are two main pieces:
<a name="line-2541"></a>
<a name="line-2542"></a>* Given    case x |&gt; co of b { alts }
<a name="line-2543"></a>  we add [x :-&gt; (b, co)] to the occ_bs_env environment; this is
<a name="line-2544"></a>  done by addBndrSwap.
<a name="line-2545"></a>
<a name="line-2546"></a>* Then, at an occurrence of a variable, we look up in the occ_bs_env
<a name="line-2547"></a>  to perform the swap. This is done by lookupBndrSwap.
<a name="line-2548"></a>
<a name="line-2549"></a>Some tricky corners:
<a name="line-2550"></a>
<a name="line-2551"></a>(BS1) We do the substitution before gathering occurrence info. So in
<a name="line-2552"></a>      the above example, an occurrence of x turns into an occurrence
<a name="line-2553"></a>      of b, and that's what we gather in the UsageDetails.  It's as
<a name="line-2554"></a>      if the binder-swap occurred before occurrence analysis. See
<a name="line-2555"></a>      the computation of fun_uds in occAnalApp.
<a name="line-2556"></a>
<a name="line-2557"></a>(BS2) When doing a lookup in occ_bs_env, we may need to iterate,
<a name="line-2558"></a>      as you can see implemented in lookupBndrSwap.  Why?
<a name="line-2559"></a>      Consider   case x of a { 1# -&gt; e1; DEFAULT -&gt;
<a name="line-2560"></a>                 case x of b { 2# -&gt; e2; DEFAULT -&gt;
<a name="line-2561"></a>                 case x of c { 3# -&gt; e3; DEFAULT -&gt; ..x..a..b.. }}}
<a name="line-2562"></a>      At the first case addBndrSwap will extend occ_bs_env with
<a name="line-2563"></a>          [x :-&gt; a]
<a name="line-2564"></a>      At the second case we occ-anal the scrutinee 'x', which looks up
<a name="line-2565"></a>        'x in occ_bs_env, returning 'a', as it should.
<a name="line-2566"></a>      Then addBndrSwap will add [a :-&gt; b] to occ_bs_env, yielding
<a name="line-2567"></a>         occ_bs_env = [x :-&gt; a, a :-&gt; b]
<a name="line-2568"></a>      At the third case we'll again look up 'x' which returns 'a'.
<a name="line-2569"></a>      But we don't want to stop the lookup there, else we'll end up with
<a name="line-2570"></a>                 case x of a { 1# -&gt; e1; DEFAULT -&gt;
<a name="line-2571"></a>                 case a of b { 2# -&gt; e2; DEFAULT -&gt;
<a name="line-2572"></a>                 case a of c { 3# -&gt; e3; DEFAULT -&gt; ..a..b..c.. }}}
<a name="line-2573"></a>      Instead, we want iterate the lookup in addBndrSwap, to give
<a name="line-2574"></a>                 case x of a { 1# -&gt; e1; DEFAULT -&gt;
<a name="line-2575"></a>                 case a of b { 2# -&gt; e2; DEFAULT -&gt;
<a name="line-2576"></a>                 case b of c { 3# -&gt; e3; DEFAULT -&gt; ..c..c..c.. }}}
<a name="line-2577"></a>      This makes a particular difference for case-merge, which works
<a name="line-2578"></a>      only if the scrutinee is the case-binder of the immediately enclosing
<a name="line-2579"></a>      case (Note [Merge Nested Cases] in GHC.Core.Opt.Simplify.Utils
<a name="line-2580"></a>      See #19581 for the bug report that showed this up.
<a name="line-2581"></a>
<a name="line-2582"></a>(BS3) We need care when shadowing.  Suppose [x :-&gt; b] is in occ_bs_env,
<a name="line-2583"></a>      and we encounter:
<a name="line-2584"></a>         (i) \x. blah
<a name="line-2585"></a>             Here we want to delete the x-binding from occ_bs_env
<a name="line-2586"></a>
<a name="line-2587"></a>         (ii) \b. blah
<a name="line-2588"></a>              This is harder: we really want to delete all bindings that
<a name="line-2589"></a>              have 'b' free in the range.  That is a bit tiresome to implement,
<a name="line-2590"></a>              so we compromise.  We keep occ_bs_rng, which is the set of
<a name="line-2591"></a>              free vars of rng(occc_bs_env).  If a binder shadows any of these
<a name="line-2592"></a>              variables, we discard all of occ_bs_env.  Safe, if a bit
<a name="line-2593"></a>              brutal.  NB, however: the simplifer de-shadows the code, so the
<a name="line-2594"></a>              next time around this won't happen.
<a name="line-2595"></a>
<a name="line-2596"></a>      These checks are implemented in addInScope.
<a name="line-2597"></a>      (i) is needed only for Ids, but (ii) is needed for tyvars too (#22623)
<a name="line-2598"></a>      because if occ_bs_env has [x :-&gt; ...a...] where `a` is a tyvar, we
<a name="line-2599"></a>      must not replace `x` by `...a...` under /\a. ...x..., or similarly
<a name="line-2600"></a>      under a case pattern match that binds `a`.
<a name="line-2601"></a>
<a name="line-2602"></a>      An alternative would be for the occurrence analyser to do cloning as
<a name="line-2603"></a>      it goes.  In principle it could do so, but it'd make it a bit more
<a name="line-2604"></a>      complicated and there is no great benefit. The simplifer uses
<a name="line-2605"></a>      cloning to get a no-shadowing situation, the care-when-shadowing
<a name="line-2606"></a>      behaviour above isn't needed for long.
<a name="line-2607"></a>
<a name="line-2608"></a>(BS4) The domain of occ_bs_env can include GlobaIds.  Eg
<a name="line-2609"></a>         case M.foo of b { alts }
<a name="line-2610"></a>      We extend occ_bs_env with [M.foo :-&gt; b].  That's fine.
<a name="line-2611"></a>
<a name="line-2612"></a>(BS5) We have to apply the occ_bs_env substitution uniformly,
<a name="line-2613"></a>      including to (local) rules and unfoldings.
<a name="line-2614"></a>
<a name="line-2615"></a>Historical note
<a name="line-2616"></a>---------------
<a name="line-2617"></a>We used to do the binder-swap transformation by introducing
<a name="line-2618"></a>a proxy let-binding, thus;
<a name="line-2619"></a>
<a name="line-2620"></a>   case x of b { pi -&gt; ri }
<a name="line-2621"></a>      ==&gt;
<a name="line-2622"></a>   case x of b { pi -&gt; let x = b in ri }
<a name="line-2623"></a>
<a name="line-2624"></a>But that had two problems:
<a name="line-2625"></a>
<a name="line-2626"></a>1. If 'x' is an imported GlobalId, we'd end up with a GlobalId
<a name="line-2627"></a>   on the LHS of a let-binding which isn't allowed.  We worked
<a name="line-2628"></a>   around this for a while by "localising" x, but it turned
<a name="line-2629"></a>   out to be very painful #16296,
<a name="line-2630"></a>
<a name="line-2631"></a>2. In CorePrep we use the occurrence analyser to do dead-code
<a name="line-2632"></a>   elimination (see Note [Dead code in CorePrep]).  But that
<a name="line-2633"></a>   occasionally led to an unlifted let-binding
<a name="line-2634"></a>       case x of b { DEFAULT -&gt; let x::Int# = b in ... }
<a name="line-2635"></a>   which disobeys one of CorePrep's output invariants (no unlifted
<a name="line-2636"></a>   let-bindings) -- see #5433.
<a name="line-2637"></a>
<a name="line-2638"></a>Doing a substitution (via occ_bs_env) is much better.
<a name="line-2639"></a>
<a name="line-2640"></a>Note [Case of cast]
<a name="line-2641"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-2642"></a>Consider        case (x `cast` co) of b { I# -&gt;
<a name="line-2643"></a>                ... (case (x `cast` co) of {...}) ...
<a name="line-2644"></a>We'd like to eliminate the inner case.  That is the motivation for
<a name="line-2645"></a>equation (2) in Note [Binder swap].  When we get to the inner case, we
<a name="line-2646"></a>inline x, cancel the casts, and away we go.
<a name="line-2647"></a>
<a name="line-2648"></a>Note [Zap case binders in proxy bindings]
<a name="line-2649"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2650"></a>From the original
<a name="line-2651"></a>     case x of cb(dead) { p -&gt; ...x... }
<a name="line-2652"></a>we will get
<a name="line-2653"></a>     case x of cb(live) { p -&gt; ...cb... }
<a name="line-2654"></a>
<a name="line-2655"></a>Core Lint never expects to find an *occurrence* of an Id marked
<a name="line-2656"></a>as Dead, so we must zap the OccInfo on cb before making the
<a name="line-2657"></a>binding x = cb.  See #5028.
<a name="line-2658"></a>
<a name="line-2659"></a>NB: the OccInfo on /occurrences/ really doesn't matter much; the simplifier
<a name="line-2660"></a>doesn't use it. So this is only to satisfy the perhaps-over-picky Lint.
<a name="line-2661"></a>
<a name="line-2662"></a>Historical note [no-case-of-case]
<a name="line-2663"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2664"></a>We *used* to suppress the binder-swap in case expressions when
<a name="line-2665"></a>-fno-case-of-case is on.  Old remarks:
<a name="line-2666"></a>    "This happens in the first simplifier pass,
<a name="line-2667"></a>    and enhances full laziness.  Here's the bad case:
<a name="line-2668"></a>            f = \ y -&gt; ...(case x of I# v -&gt; ...(case x of ...) ... )
<a name="line-2669"></a>    If we eliminate the inner case, we trap it inside the I# v -&gt; arm,
<a name="line-2670"></a>    which might prevent some full laziness happening.  I've seen this
<a name="line-2671"></a>    in action in spectral/cichelli/Prog.hs:
<a name="line-2672"></a>             [(m,n) | m &lt;- [1..max], n &lt;- [1..max]]
<a name="line-2673"></a>    Hence the check for NoCaseOfCase."
<a name="line-2674"></a>However, now the full-laziness pass itself reverses the binder-swap, so this
<a name="line-2675"></a>check is no longer necessary.
<a name="line-2676"></a>
<a name="line-2677"></a>Historical note [Suppressing the case binder-swap]
<a name="line-2678"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2679"></a>This old note describes a problem that is also fixed by doing the
<a name="line-2680"></a>binder-swap in OccAnal:
<a name="line-2681"></a>
<a name="line-2682"></a>    There is another situation when it might make sense to suppress the
<a name="line-2683"></a>    case-expression binde-swap. If we have
<a name="line-2684"></a>
<a name="line-2685"></a>        case x of w1 { DEFAULT -&gt; case x of w2 { A -&gt; e1; B -&gt; e2 }
<a name="line-2686"></a>                       ...other cases .... }
<a name="line-2687"></a>
<a name="line-2688"></a>    We'll perform the binder-swap for the outer case, giving
<a name="line-2689"></a>
<a name="line-2690"></a>        case x of w1 { DEFAULT -&gt; case w1 of w2 { A -&gt; e1; B -&gt; e2 }
<a name="line-2691"></a>                       ...other cases .... }
<a name="line-2692"></a>
<a name="line-2693"></a>    But there is no point in doing it for the inner case, because w1 can't
<a name="line-2694"></a>    be inlined anyway.  Furthermore, doing the case-swapping involves
<a name="line-2695"></a>    zapping w2's occurrence info (see paragraphs that follow), and that
<a name="line-2696"></a>    forces us to bind w2 when doing case merging.  So we get
<a name="line-2697"></a>
<a name="line-2698"></a>        case x of w1 { A -&gt; let w2 = w1 in e1
<a name="line-2699"></a>                       B -&gt; let w2 = w1 in e2
<a name="line-2700"></a>                       ...other cases .... }
<a name="line-2701"></a>
<a name="line-2702"></a>    This is plain silly in the common case where w2 is dead.
<a name="line-2703"></a>
<a name="line-2704"></a>    Even so, I can't see a good way to implement this idea.  I tried
<a name="line-2705"></a>    not doing the binder-swap if the scrutinee was already evaluated
<a name="line-2706"></a>    but that failed big-time:
<a name="line-2707"></a>
<a name="line-2708"></a>            data T = MkT !Int
<a name="line-2709"></a>
<a name="line-2710"></a>            case v of w  { MkT x -&gt;
<a name="line-2711"></a>            case x of x1 { I# y1 -&gt;
<a name="line-2712"></a>            case x of x2 { I# y2 -&gt; ...
<a name="line-2713"></a>
<a name="line-2714"></a>    Notice that because MkT is strict, x is marked "evaluated".  But to
<a name="line-2715"></a>    eliminate the last case, we must either make sure that x (as well as
<a name="line-2716"></a>    x1) has unfolding MkT y1.  The straightforward thing to do is to do
<a name="line-2717"></a>    the binder-swap.  So this whole note is a no-op.
<a name="line-2718"></a>
<a name="line-2719"></a>It's fixed by doing the binder-swap in OccAnal because we can do the
<a name="line-2720"></a>binder-swap unconditionally and still get occurrence analysis
<a name="line-2721"></a>information right.
<a name="line-2722"></a>-}</span>
<a name="line-2723"></a>
<a name="line-2724"></a><a name="addBndrSwap"></a><span class='hs-definition'>addBndrSwap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccEnv</span>
<a name="line-2725"></a><span class='hs-comment'>-- See Note [The binder-swap substitution]</span>
<a name="line-2726"></a><span class='hs-definition'>addBndrSwap</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2727"></a>            <span class='hs-varid'>env</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>swap_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_rng</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rng_vars</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2728"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>scrut_var</span><span class='hs-layout'>,</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>get_scrut_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>stripTicksTopE</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut</span><span class='hs-layout'>)</span>
<a name="line-2729"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>scrut_var</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2730"></a>      <span class='hs-comment'>-- Consider: case x of x { ... }</span>
<a name="line-2731"></a>      <span class='hs-comment'>-- Do not add [x :-&gt; x] to occ_bs_env, else lookupBndrSwap will loop</span>
<a name="line-2732"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>swap_env</span> <span class='hs-varid'>scrut_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>case_bndr'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span>
<a name="line-2733"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>occ_bs_rng</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rng_vars</span> <span class='hs-varop'>`extendVarSet`</span> <span class='hs-varid'>case_bndr'</span>
<a name="line-2734"></a>                       <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tyCoVarsOfMCo</span> <span class='hs-varid'>mco</span> <span class='hs-layout'>}</span>
<a name="line-2735"></a>
<a name="line-2736"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2737"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-2738"></a>  <span class='hs-keyword'>where</span>
<a name="line-2739"></a>    <span class='hs-varid'>get_scrut_var</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>OutVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercion</span><span class='hs-layout'>)</span>
<a name="line-2740"></a>    <span class='hs-varid'>get_scrut_var</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-2741"></a>    <span class='hs-varid'>get_scrut_var</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [Case of cast]</span>
<a name="line-2742"></a>    <span class='hs-varid'>get_scrut_var</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-2743"></a>
<a name="line-2744"></a>    <span class='hs-varid'>case_bndr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdOccInfo</span> <span class='hs-varid'>case_bndr</span>
<a name="line-2745"></a>                 <span class='hs-comment'>-- See Note [Zap case binders in proxy bindings]</span>
<a name="line-2746"></a>
<a name="line-2747"></a><a name="lookupBndrSwap"></a><span class='hs-definition'>lookupBndrSwap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-2748"></a><span class='hs-comment'>-- See Note [The binder-swap substitution]</span>
<a name="line-2749"></a><span class='hs-comment'>-- Returns an expression of the same type as Id</span>
<a name="line-2750"></a><span class='hs-definition'>lookupBndrSwap</span> <span class='hs-varid'>env</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>OccEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_bs_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bs_env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-varid'>bndr</span>
<a name="line-2751"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>bs_env</span> <span class='hs-varid'>bndr</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-2752"></a>       <span class='hs-conid'>Nothing</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-layout'>;</span>
<a name="line-2753"></a>       <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr1</span><span class='hs-layout'>,</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2754"></a>
<a name="line-2755"></a>    <span class='hs-comment'>-- Why do we iterate here?</span>
<a name="line-2756"></a>    <span class='hs-comment'>-- See (BS2) in Note [The binder-swap substitution]</span>
<a name="line-2757"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupBndrSwap</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr1</span> <span class='hs-keyword'>of</span>
<a name="line-2758"></a>      <span class='hs-layout'>(</span><span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>add_cast</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>mco</span><span class='hs-layout'>,</span> <span class='hs-varid'>fun_id</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2759"></a>
<a name="line-2760"></a>  <span class='hs-keyword'>where</span>
<a name="line-2761"></a>    <span class='hs-varid'>add_cast</span> <span class='hs-varid'>fun</span> <span class='hs-conid'>MRefl</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fun</span>
<a name="line-2762"></a>    <span class='hs-varid'>add_cast</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-2763"></a>    <span class='hs-comment'>-- We must switch that 'co' to 'sym co';</span>
<a name="line-2764"></a>    <span class='hs-comment'>-- see the comment with occ_bs_env</span>
<a name="line-2765"></a>    <span class='hs-comment'>-- No need to test for isReflCo, because 'co' came from</span>
<a name="line-2766"></a>    <span class='hs-comment'>-- a (Cast e co) and hence is unlikely to be Refl</span>
<a name="line-2767"></a>
<a name="line-2768"></a><span class='hs-comment'>{-
<a name="line-2769"></a>************************************************************************
<a name="line-2770"></a>*                                                                      *
<a name="line-2771"></a>\subsection[OccurAnal-types]{OccEnv}
<a name="line-2772"></a>*                                                                      *
<a name="line-2773"></a>************************************************************************
<a name="line-2774"></a>
<a name="line-2775"></a>Note [UsageDetails and zapping]
<a name="line-2776"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2777"></a>On many occasions, we must modify all gathered occurrence data at once. For
<a name="line-2778"></a>instance, all occurrences underneath a (non-one-shot) lambda set the
<a name="line-2779"></a>'occ_in_lam' flag to become 'True'. We could use 'mapVarEnv' to do this, but
<a name="line-2780"></a>that takes O(n) time and we will do this often---in particular, there are many
<a name="line-2781"></a>places where tail calls are not allowed, and each of these causes all variables
<a name="line-2782"></a>to get marked with 'NoTailCallInfo'.
<a name="line-2783"></a>
<a name="line-2784"></a>Instead of relying on `mapVarEnv`, then, we carry three 'IdEnv's around along
<a name="line-2785"></a>with the 'OccInfoEnv'. Each of these extra environments is a "zapped set"
<a name="line-2786"></a>recording which variables have been zapped in some way. Zapping all occurrence
<a name="line-2787"></a>info then simply means setting the corresponding zapped set to the whole
<a name="line-2788"></a>'OccInfoEnv', a fast O(1) operation.
<a name="line-2789"></a>-}</span>
<a name="line-2790"></a>
<a name="line-2791"></a><a name="OccInfoEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OccInfoEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IdEnv</span> <span class='hs-conid'>OccInfo</span> <span class='hs-comment'>-- A finite map from ids to their usage</span>
<a name="line-2792"></a>                <span class='hs-comment'>-- INVARIANT: never IAmDead</span>
<a name="line-2793"></a>                <span class='hs-comment'>-- (Deadness is signalled by not being in the map at all)</span>
<a name="line-2794"></a>
<a name="line-2795"></a><a name="ZappedSet"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ZappedSet</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OccInfoEnv</span> <span class='hs-comment'>-- Values are ignored</span>
<a name="line-2796"></a>
<a name="line-2797"></a><a name="UsageDetails"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2798"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span>       <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>OccInfoEnv</span>
<a name="line-2799"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_many</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ZappedSet</span>   <span class='hs-comment'>-- apply 'markMany' to these</span>
<a name="line-2800"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ZappedSet</span>   <span class='hs-comment'>-- apply 'markInsideLam' to these</span>
<a name="line-2801"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_no_tail</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ZappedSet</span> <span class='hs-layout'>}</span> <span class='hs-comment'>-- apply 'markNonTail' to these</span>
<a name="line-2802"></a>  <span class='hs-comment'>-- INVARIANT: All three zapped sets are subsets of the OccInfoEnv</span>
<a name="line-2803"></a>
<a name="line-2804"></a><a name="instance%20Outputable%20UsageDetails"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyword'>where</span>
<a name="line-2805"></a>  <span class='hs-varid'>ppr</span> <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>flattenUsageDetails</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2806"></a>
<a name="line-2807"></a><span class='hs-comment'>-------------------</span>
<a name="line-2808"></a><span class='hs-comment'>-- UsageDetails API</span>
<a name="line-2809"></a>
<a name="line-2810"></a><a name="andUDs"></a><span class='hs-definition'>andUDs</span><span class='hs-layout'>,</span> <span class='hs-varid'>orUDs</span>
<a name="line-2811"></a>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2812"></a><span class='hs-definition'>andUDs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineUsageDetailsWith</span> <span class='hs-varid'>addOccInfo</span>
<a name="line-2813"></a><a name="orUDs"></a><span class='hs-definition'>orUDs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineUsageDetailsWith</span> <span class='hs-varid'>orOccInfo</span>
<a name="line-2814"></a>
<a name="line-2815"></a><a name="mkOneOcc"></a><span class='hs-definition'>mkOneOcc</span> <span class='hs-keyglyph'>::</span><span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InterestingCxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>JoinArity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2816"></a><span class='hs-definition'>mkOneOcc</span> <span class='hs-varid'>id</span> <span class='hs-varid'>int_cxt</span> <span class='hs-varid'>arity</span>
<a name="line-2817"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isLocalId</span> <span class='hs-varid'>id</span>
<a name="line-2818"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyDetails</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarEnv</span> <span class='hs-varid'>id</span> <span class='hs-varid'>occ_info</span> <span class='hs-layout'>}</span>
<a name="line-2819"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2820"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyDetails</span>
<a name="line-2821"></a>  <span class='hs-keyword'>where</span>
<a name="line-2822"></a>    <span class='hs-varid'>occ_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NotInsideLam</span>
<a name="line-2823"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>occ_n_br</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oneBranch</span>
<a name="line-2824"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt</span>
<a name="line-2825"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>occ_tail</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AlwaysTailCalled</span> <span class='hs-varid'>arity</span> <span class='hs-layout'>}</span>
<a name="line-2826"></a>
<a name="line-2827"></a><a name="addManyOccId"></a><span class='hs-definition'>addManyOccId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2828"></a><span class='hs-comment'>-- Add the non-committal (id :-&gt; noOccInfo) to the usage details</span>
<a name="line-2829"></a><span class='hs-definition'>addManyOccId</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span> <span class='hs-varid'>noOccInfo</span> <span class='hs-layout'>}</span>
<a name="line-2830"></a>
<a name="line-2831"></a><a name="addManyOcc"></a><span class='hs-comment'>-- Add several occurrences, assumed not to be tail calls</span>
<a name="line-2832"></a><span class='hs-definition'>addManyOcc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2833"></a><span class='hs-definition'>addManyOcc</span> <span class='hs-varid'>v</span> <span class='hs-varid'>u</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addManyOccId</span> <span class='hs-varid'>u</span> <span class='hs-varid'>v</span>
<a name="line-2834"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>u</span>
<a name="line-2835"></a>        <span class='hs-comment'>-- Give a non-committal binder info (i.e noOccInfo) because</span>
<a name="line-2836"></a>        <span class='hs-comment'>--   a) Many copies of the specialised thing can appear</span>
<a name="line-2837"></a>        <span class='hs-comment'>--   b) We don't want to substitute a BIG expression inside a RULE</span>
<a name="line-2838"></a>        <span class='hs-comment'>--      even if that's the only occurrence of the thing</span>
<a name="line-2839"></a>        <span class='hs-comment'>--      (Same goes for INLINE.)</span>
<a name="line-2840"></a>
<a name="line-2841"></a><a name="addManyOccs"></a><span class='hs-definition'>addManyOccs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2842"></a><span class='hs-definition'>addManyOccs</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>id_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonDetStrictFoldUniqSet</span> <span class='hs-varid'>addManyOcc</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>id_set</span>
<a name="line-2843"></a>  <span class='hs-comment'>-- It's OK to use nonDetStrictFoldUniqSet here because addManyOcc commutes</span>
<a name="line-2844"></a>
<a name="line-2845"></a><a name="delDetails"></a><span class='hs-definition'>delDetails</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2846"></a><span class='hs-definition'>delDetails</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>bndr</span>
<a name="line-2847"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-varop'>`alterUsageDetails`</span> <span class='hs-layout'>(</span><span class='hs-varop'>`delVarEnv`</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-2848"></a>
<a name="line-2849"></a><a name="delDetailsList"></a><span class='hs-definition'>delDetailsList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2850"></a><span class='hs-definition'>delDetailsList</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>bndrs</span>
<a name="line-2851"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-varop'>`alterUsageDetails`</span> <span class='hs-layout'>(</span><span class='hs-varop'>`delVarEnvList`</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-2852"></a>
<a name="line-2853"></a><a name="emptyDetails"></a><span class='hs-definition'>emptyDetails</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2854"></a><span class='hs-definition'>emptyDetails</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-2855"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_many</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-2856"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-2857"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_no_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-layout'>}</span>
<a name="line-2858"></a>
<a name="line-2859"></a><a name="isEmptyDetails"></a><span class='hs-definition'>isEmptyDetails</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2860"></a><span class='hs-definition'>isEmptyDetails</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isEmptyVarEnv</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ud_env</span>
<a name="line-2861"></a>
<a name="line-2862"></a><a name="markAllMany"></a><span class='hs-definition'>markAllMany</span><span class='hs-layout'>,</span> <span class='hs-varid'>markAllInsideLam</span><span class='hs-layout'>,</span> <span class='hs-varid'>markAllNonTail</span><span class='hs-layout'>,</span> <span class='hs-varid'>markAllManyNonTail</span>
<a name="line-2863"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2864"></a><span class='hs-definition'>markAllMany</span>          <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_z_many</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>}</span>
<a name="line-2865"></a><a name="markAllInsideLam"></a><span class='hs-definition'>markAllInsideLam</span>     <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>}</span>
<a name="line-2866"></a><a name="markAllNonTail"></a><span class='hs-definition'>markAllNonTail</span> <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_z_no_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>}</span>
<a name="line-2867"></a>
<a name="line-2868"></a><a name="markAllInsideLamIf"></a><span class='hs-definition'>markAllInsideLamIf</span><span class='hs-layout'>,</span> <span class='hs-varid'>markAllNonTailIf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2869"></a>
<a name="line-2870"></a><span class='hs-definition'>markAllInsideLamIf</span>  <span class='hs-conid'>True</span>  <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllInsideLam</span> <span class='hs-varid'>ud</span>
<a name="line-2871"></a><span class='hs-definition'>markAllInsideLamIf</span>  <span class='hs-conid'>False</span> <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span>
<a name="line-2872"></a>
<a name="line-2873"></a><a name="markAllNonTailIf"></a><span class='hs-definition'>markAllNonTailIf</span> <span class='hs-conid'>True</span>  <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllNonTail</span> <span class='hs-varid'>ud</span>
<a name="line-2874"></a><span class='hs-definition'>markAllNonTailIf</span> <span class='hs-conid'>False</span> <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span>
<a name="line-2875"></a>
<a name="line-2876"></a>
<a name="line-2877"></a><a name="markAllManyNonTail"></a><span class='hs-definition'>markAllManyNonTail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllMany</span> <span class='hs-varop'>.</span> <span class='hs-varid'>markAllNonTail</span> <span class='hs-comment'>-- effectively sets to noOccInfo</span>
<a name="line-2878"></a>
<a name="line-2879"></a><a name="markAllManyNonTailIf"></a><span class='hs-definition'>markAllManyNonTailIf</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>              <span class='hs-comment'>-- If this is true</span>
<a name="line-2880"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>      <span class='hs-comment'>-- Then do markAllManyNonTail on this</span>
<a name="line-2881"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2882"></a><span class='hs-definition'>markAllManyNonTailIf</span> <span class='hs-conid'>True</span>  <span class='hs-varid'>uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllManyNonTail</span> <span class='hs-varid'>uds</span>
<a name="line-2883"></a><span class='hs-definition'>markAllManyNonTailIf</span> <span class='hs-conid'>False</span> <span class='hs-varid'>uds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uds</span>
<a name="line-2884"></a>
<a name="line-2885"></a><a name="lookupDetails"></a><span class='hs-definition'>lookupDetails</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>
<a name="line-2886"></a><span class='hs-definition'>lookupDetails</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>id</span>
<a name="line-2887"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>id</span>  <span class='hs-comment'>-- We do not currently gather occurrence info (from types)</span>
<a name="line-2888"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>noOccInfo</span>   <span class='hs-comment'>-- for CoVars, so we must conservatively mark them as used</span>
<a name="line-2889"></a>                <span class='hs-comment'>-- See Note [DoO not mark CoVars as dead]</span>
<a name="line-2890"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2891"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span> <span class='hs-keyword'>of</span>
<a name="line-2892"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>occ</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>doZapping</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>id</span> <span class='hs-varid'>occ</span>
<a name="line-2893"></a>      <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IAmDead</span>
<a name="line-2894"></a>
<a name="line-2895"></a><a name="usedIn"></a><span class='hs-definition'>usedIn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2896"></a><a name="usedIn"></a><span class='hs-definition'>v</span> <span class='hs-varop'>`usedIn`</span> <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isExportedId</span> <span class='hs-varid'>v</span> <span class='hs-varop'>||</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`elemVarEnv`</span> <span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span>
<a name="line-2897"></a>
<a name="line-2898"></a><a name="udFreeVars"></a><span class='hs-definition'>udFreeVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-2899"></a><span class='hs-comment'>-- Find the subset of bndrs that are mentioned in uds</span>
<a name="line-2900"></a><span class='hs-definition'>udFreeVars</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>ud</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>restrictFreeVars</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span>
<a name="line-2901"></a>
<a name="line-2902"></a><a name="restrictFreeVars"></a><span class='hs-definition'>restrictFreeVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfoEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-2903"></a><span class='hs-definition'>restrictFreeVars</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>restrictUniqSetToUFM</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>fvs</span>
<a name="line-2904"></a>
<a name="line-2905"></a><span class='hs-comment'>{- Note [Do not mark CoVars as dead]
<a name="line-2906"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2907"></a>It's obviously wrong to mark CoVars as dead if they are used.
<a name="line-2908"></a>Currently we don't traverse types to gather usase info for CoVars,
<a name="line-2909"></a>so we had better treat them as having noOccInfo.
<a name="line-2910"></a>
<a name="line-2911"></a>This showed up in #15696 we had something like
<a name="line-2912"></a>  case eq_sel d of co -&gt; ...(typeError @(...co...) "urk")...
<a name="line-2913"></a>
<a name="line-2914"></a>Then 'd' was substituted by a dictionary, so the expression
<a name="line-2915"></a>simpified to
<a name="line-2916"></a>  case (Coercion &lt;blah&gt;) of co -&gt; ...(typeError @(...co...) "urk")...
<a name="line-2917"></a>
<a name="line-2918"></a>But then the "drop the case altogether" equation of rebuildCase
<a name="line-2919"></a>thought that 'co' was dead, and discarded the entire case. Urk!
<a name="line-2920"></a>
<a name="line-2921"></a>I have no idea how we managed to avoid this pitfall for so long!
<a name="line-2922"></a>-}</span>
<a name="line-2923"></a>
<a name="line-2924"></a><span class='hs-comment'>-------------------</span>
<a name="line-2925"></a><span class='hs-comment'>-- Auxiliary functions for UsageDetails implementation</span>
<a name="line-2926"></a>
<a name="line-2927"></a><a name="combineUsageDetailsWith"></a><span class='hs-definition'>combineUsageDetailsWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span><span class='hs-layout'>)</span>
<a name="line-2928"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2929"></a><span class='hs-definition'>combineUsageDetailsWith</span> <span class='hs-varid'>plus_occ_info</span> <span class='hs-varid'>ud1</span> <span class='hs-varid'>ud2</span>
<a name="line-2930"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyDetails</span> <span class='hs-varid'>ud1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud2</span>
<a name="line-2931"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyDetails</span> <span class='hs-varid'>ud2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud1</span>
<a name="line-2932"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2933"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv_C</span> <span class='hs-varid'>plus_occ_info</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud2</span><span class='hs-layout'>)</span>
<a name="line-2934"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_many</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_many</span>    <span class='hs-varid'>ud1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_many</span>    <span class='hs-varid'>ud2</span><span class='hs-layout'>)</span>
<a name="line-2935"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-varid'>ud1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-varid'>ud2</span><span class='hs-layout'>)</span>
<a name="line-2936"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_no_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_no_tail</span> <span class='hs-varid'>ud1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_no_tail</span> <span class='hs-varid'>ud2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2937"></a>
<a name="line-2938"></a><a name="doZapping"></a><span class='hs-definition'>doZapping</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>
<a name="line-2939"></a><span class='hs-definition'>doZapping</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>var</span> <span class='hs-varid'>occ</span>
<a name="line-2940"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>doZappingByUnique</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>(</span><span class='hs-varid'>varUnique</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span> <span class='hs-varid'>occ</span>
<a name="line-2941"></a>
<a name="line-2942"></a><a name="doZappingByUnique"></a><span class='hs-definition'>doZappingByUnique</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unique</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>
<a name="line-2943"></a><span class='hs-definition'>doZappingByUnique</span> <span class='hs-layout'>(</span><span class='hs-conid'>UD</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_z_many</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>many</span>
<a name="line-2944"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_lam</span>
<a name="line-2945"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_no_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_tail</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2946"></a>                  <span class='hs-varid'>uniq</span> <span class='hs-varid'>occ</span>
<a name="line-2947"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ2</span>
<a name="line-2948"></a>  <span class='hs-keyword'>where</span>
<a name="line-2949"></a>    <span class='hs-varid'>occ1</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>uniq</span> <span class='hs-varop'>`elemVarEnvByKey`</span> <span class='hs-varid'>many</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markMany</span> <span class='hs-varid'>occ</span>
<a name="line-2950"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>uniq</span> <span class='hs-varop'>`elemVarEnvByKey`</span> <span class='hs-varid'>in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markInsideLam</span> <span class='hs-varid'>occ</span>
<a name="line-2951"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span>
<a name="line-2952"></a>    <span class='hs-varid'>occ2</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>uniq</span> <span class='hs-varop'>`elemVarEnvByKey`</span> <span class='hs-varid'>no_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markNonTail</span> <span class='hs-varid'>occ1</span>
<a name="line-2953"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ1</span>
<a name="line-2954"></a>
<a name="line-2955"></a><a name="alterZappedSets"></a><span class='hs-definition'>alterZappedSets</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ZappedSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ZappedSet</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2956"></a><span class='hs-definition'>alterZappedSets</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>f</span>
<a name="line-2957"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_z_many</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_many</span>    <span class='hs-varid'>ud</span><span class='hs-layout'>)</span>
<a name="line-2958"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_in_lam</span>  <span class='hs-varid'>ud</span><span class='hs-layout'>)</span>
<a name="line-2959"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ud_z_no_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_z_no_tail</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2960"></a>
<a name="line-2961"></a><a name="alterUsageDetails"></a><span class='hs-definition'>alterUsageDetails</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>OccInfoEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfoEnv</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2962"></a><span class='hs-definition'>alterUsageDetails</span> <span class='hs-varid'>ud</span> <span class='hs-varid'>f</span>
<a name="line-2963"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-varop'>`alterZappedSets`</span> <span class='hs-varid'>f</span>
<a name="line-2964"></a>
<a name="line-2965"></a><a name="flattenUsageDetails"></a><span class='hs-definition'>flattenUsageDetails</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2966"></a><span class='hs-definition'>flattenUsageDetails</span> <span class='hs-varid'>ud</span>
<a name="line-2967"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ud</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ud_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapUFM_Directly</span> <span class='hs-layout'>(</span><span class='hs-varid'>doZappingByUnique</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ud_env</span> <span class='hs-varid'>ud</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2968"></a>      <span class='hs-varop'>`alterZappedSets`</span> <span class='hs-varid'>const</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-2969"></a>
<a name="line-2970"></a><a name="adjustRhsUsage"></a><span class='hs-comment'>-------------------</span>
<a name="line-2971"></a><span class='hs-comment'>-- See Note [Adjusting right-hand sides]</span>
<a name="line-2972"></a><span class='hs-definition'>adjustRhsUsage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RecFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span>
<a name="line-2973"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Outer lambdas, AFTER occ anal</span>
<a name="line-2974"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>   <span class='hs-comment'>-- From body of lambda</span>
<a name="line-2975"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-2976"></a><span class='hs-definition'>adjustRhsUsage</span> <span class='hs-varid'>is_rec</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>usage</span>
<a name="line-2977"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markAllInsideLamIf</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>one_shot</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2978"></a>    <span class='hs-varid'>markAllNonTailIf</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>exact_join</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2979"></a>    <span class='hs-varid'>usage</span>
<a name="line-2980"></a>  <span class='hs-keyword'>where</span>
<a name="line-2981"></a>    <span class='hs-varid'>one_shot</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-keyword'>of</span>
<a name="line-2982"></a>                 <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span>
<a name="line-2983"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRec</span> <span class='hs-varid'>is_rec</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2984"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isOneShotBndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-varid'>join_arity</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-2985"></a>                 <span class='hs-conid'>Nothing</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isOneShotBndr</span> <span class='hs-varid'>bndrs</span>
<a name="line-2986"></a>
<a name="line-2987"></a>    <span class='hs-varid'>exact_join</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exactJoin</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>bndrs</span>
<a name="line-2988"></a>
<a name="line-2989"></a><a name="exactJoin"></a><span class='hs-definition'>exactJoin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2990"></a><span class='hs-definition'>exactJoin</span> <span class='hs-conid'>Nothing</span>           <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2991"></a><span class='hs-definition'>exactJoin</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>join_arity</span>
<a name="line-2992"></a>  <span class='hs-comment'>-- Remember join_arity includes type binders</span>
<a name="line-2993"></a>
<a name="line-2994"></a><a name="IdWithOccInfo"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>IdWithOccInfo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Id</span>
<a name="line-2995"></a>
<a name="line-2996"></a><a name="tagLamBinders"></a><span class='hs-definition'>tagLamBinders</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span>          <span class='hs-comment'>-- Of scope</span>
<a name="line-2997"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>                  <span class='hs-comment'>-- Binders</span>
<a name="line-2998"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Details with binders removed</span>
<a name="line-2999"></a>                 <span class='hs-keyglyph'>[</span><span class='hs-conid'>IdWithOccInfo</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Tagged binders</span>
<a name="line-3000"></a><span class='hs-definition'>tagLamBinders</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>binders</span>
<a name="line-3001"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usage'</span> <span class='hs-varop'>`seq`</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-3002"></a>  <span class='hs-keyword'>where</span>
<a name="line-3003"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>usage'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumR</span> <span class='hs-varid'>tagLamBinder</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>binders</span>
<a name="line-3004"></a>
<a name="line-3005"></a><a name="tagLamBinder"></a><span class='hs-definition'>tagLamBinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UsageDetails</span>       <span class='hs-comment'>-- Of scope</span>
<a name="line-3006"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>                 <span class='hs-comment'>-- Binder</span>
<a name="line-3007"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- Details with binder removed</span>
<a name="line-3008"></a>                 <span class='hs-conid'>IdWithOccInfo</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Tagged binders</span>
<a name="line-3009"></a><span class='hs-comment'>-- Used for lambda and case binders</span>
<a name="line-3010"></a><span class='hs-comment'>-- It copes with the fact that lambda bindings can have a</span>
<a name="line-3011"></a><span class='hs-comment'>-- stable unfolding, used for join points</span>
<a name="line-3012"></a><span class='hs-definition'>tagLamBinder</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>bndr</span>
<a name="line-3013"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage2</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span>
<a name="line-3014"></a>  <span class='hs-keyword'>where</span>
<a name="line-3015"></a>        <span class='hs-varid'>occ</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupDetails</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>bndr</span>
<a name="line-3016"></a>        <span class='hs-varid'>bndr'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBinderOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>markNonTail</span> <span class='hs-varid'>occ</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span>
<a name="line-3017"></a>                   <span class='hs-comment'>-- Don't try to make an argument into a join point</span>
<a name="line-3018"></a>        <span class='hs-varid'>usage1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usage</span> <span class='hs-varop'>`delDetails`</span> <span class='hs-varid'>bndr</span>
<a name="line-3019"></a>        <span class='hs-varid'>usage2</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addManyOccs</span> <span class='hs-varid'>usage1</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfoldingVars</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3020"></a>                               <span class='hs-comment'>-- This is effectively the RHS of a</span>
<a name="line-3021"></a>                               <span class='hs-comment'>-- non-join-point binding, so it's okay to use</span>
<a name="line-3022"></a>                               <span class='hs-comment'>-- addManyOccsSet, which assumes no tail calls</span>
<a name="line-3023"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usage1</span>
<a name="line-3024"></a>
<a name="line-3025"></a><a name="tagNonRecBinder"></a><span class='hs-definition'>tagNonRecBinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>           <span class='hs-comment'>-- At top level?</span>
<a name="line-3026"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>           <span class='hs-comment'>-- Of scope</span>
<a name="line-3027"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBndr</span>               <span class='hs-comment'>-- Binder</span>
<a name="line-3028"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- Details with binder removed</span>
<a name="line-3029"></a>                    <span class='hs-conid'>IdWithOccInfo</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Tagged binder</span>
<a name="line-3030"></a>
<a name="line-3031"></a><span class='hs-definition'>tagNonRecBinder</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>binder</span>
<a name="line-3032"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-3033"></a>     <span class='hs-varid'>occ</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupDetails</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>binder</span>
<a name="line-3034"></a>     <span class='hs-varid'>will_be_join</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decideJoinPointHood</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>usage</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>binder</span><span class='hs-keyglyph'>]</span>
<a name="line-3035"></a>     <span class='hs-varid'>occ'</span>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>will_be_join</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- must already be marked AlwaysTailCalled</span>
<a name="line-3036"></a>                              <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>isAlwaysTailCalled</span> <span class='hs-varid'>occ</span><span class='hs-layout'>)</span> <span class='hs-varid'>occ</span>
<a name="line-3037"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>markNonTail</span> <span class='hs-varid'>occ</span>
<a name="line-3038"></a>     <span class='hs-varid'>binder'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setBinderOcc</span> <span class='hs-varid'>occ'</span> <span class='hs-varid'>binder</span>
<a name="line-3039"></a>     <span class='hs-varid'>usage'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usage</span> <span class='hs-varop'>`delDetails`</span> <span class='hs-varid'>binder</span>
<a name="line-3040"></a>   <span class='hs-keyword'>in</span>
<a name="line-3041"></a>   <span class='hs-varid'>usage'</span> <span class='hs-varop'>`seq`</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage'</span><span class='hs-layout'>,</span> <span class='hs-varid'>binder'</span><span class='hs-layout'>)</span>
<a name="line-3042"></a>
<a name="line-3043"></a><a name="tagRecBinders"></a><span class='hs-definition'>tagRecBinders</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>           <span class='hs-comment'>-- At top level?</span>
<a name="line-3044"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>           <span class='hs-comment'>-- Of body of let ONLY</span>
<a name="line-3045"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>CoreBndr</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- Binder</span>
<a name="line-3046"></a>                   <span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- RHS usage details</span>
<a name="line-3047"></a>                   <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- Lambdas in new RHS</span>
<a name="line-3048"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>UsageDetails</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- Adjusted details for whole scope,</span>
<a name="line-3049"></a>                                        <span class='hs-comment'>-- with binders removed</span>
<a name="line-3050"></a>                  <span class='hs-keyglyph'>[</span><span class='hs-conid'>IdWithOccInfo</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Tagged binders</span>
<a name="line-3051"></a><span class='hs-comment'>-- Substantially more complicated than non-recursive case. Need to adjust RHS</span>
<a name="line-3052"></a><span class='hs-comment'>-- details *before* tagging binders (because the tags depend on the RHSes).</span>
<a name="line-3053"></a><span class='hs-definition'>tagRecBinders</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>body_uds</span> <span class='hs-varid'>triples</span>
<a name="line-3054"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-3055"></a>     <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_udss</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip3</span> <span class='hs-varid'>triples</span>
<a name="line-3056"></a>
<a name="line-3057"></a>     <span class='hs-comment'>-- 1. Determine join-point-hood of whole group, as determined by</span>
<a name="line-3058"></a>     <span class='hs-comment'>--    the *unadjusted* usage details</span>
<a name="line-3059"></a>     <span class='hs-varid'>unadj_uds</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>andUDs</span> <span class='hs-varid'>body_uds</span> <span class='hs-varid'>rhs_udss</span>
<a name="line-3060"></a>     <span class='hs-varid'>will_be_joins</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decideJoinPointHood</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>unadj_uds</span> <span class='hs-varid'>bndrs</span>
<a name="line-3061"></a>
<a name="line-3062"></a>     <span class='hs-comment'>-- 2. Adjust usage details of each RHS, taking into account the</span>
<a name="line-3063"></a>     <span class='hs-comment'>--    join-point-hood decision</span>
<a name="line-3064"></a>     <span class='hs-varid'>rhs_udss'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>adjust</span> <span class='hs-varid'>triples</span>
<a name="line-3065"></a>     <span class='hs-varid'>adjust</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_uds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_bndrs</span><span class='hs-layout'>)</span>
<a name="line-3066"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adjustRhsUsage</span> <span class='hs-conid'>Recursive</span> <span class='hs-varid'>mb_join_arity</span> <span class='hs-varid'>rhs_bndrs</span> <span class='hs-varid'>rhs_uds</span>
<a name="line-3067"></a>       <span class='hs-keyword'>where</span>
<a name="line-3068"></a>         <span class='hs-comment'>-- Can't use willBeJoinId_maybe here because we haven't tagged the</span>
<a name="line-3069"></a>         <span class='hs-comment'>-- binder yet (the tag depends on these adjustments!)</span>
<a name="line-3070"></a>         <span class='hs-varid'>mb_join_arity</span>
<a name="line-3071"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>will_be_joins</span>
<a name="line-3072"></a>           <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupDetails</span> <span class='hs-varid'>unadj_uds</span> <span class='hs-varid'>bndr</span>
<a name="line-3073"></a>           <span class='hs-layout'>,</span> <span class='hs-conid'>AlwaysTailCalled</span> <span class='hs-varid'>arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-varid'>occ</span>
<a name="line-3074"></a>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>arity</span>
<a name="line-3075"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3076"></a>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>will_be_joins</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Should be AlwaysTailCalled if</span>
<a name="line-3077"></a>             <span class='hs-conid'>Nothing</span>                   <span class='hs-comment'>-- we are making join points!</span>
<a name="line-3078"></a>
<a name="line-3079"></a>     <span class='hs-comment'>-- 3. Compute final usage details from adjusted RHS details</span>
<a name="line-3080"></a>     <span class='hs-varid'>adj_uds</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>andUDs</span> <span class='hs-varid'>body_uds</span> <span class='hs-varid'>rhs_udss'</span>
<a name="line-3081"></a>
<a name="line-3082"></a>     <span class='hs-comment'>-- 4. Tag each binder with its adjusted details</span>
<a name="line-3083"></a>     <span class='hs-varid'>bndrs'</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>setBinderOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupDetails</span> <span class='hs-varid'>adj_uds</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span>
<a name="line-3084"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span> <span class='hs-keyglyph'>]</span>
<a name="line-3085"></a>
<a name="line-3086"></a>     <span class='hs-comment'>-- 5. Drop the binders from the adjusted details and return</span>
<a name="line-3087"></a>     <span class='hs-varid'>usage'</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adj_uds</span> <span class='hs-varop'>`delDetailsList`</span> <span class='hs-varid'>bndrs</span>
<a name="line-3088"></a>   <span class='hs-keyword'>in</span>
<a name="line-3089"></a>   <span class='hs-layout'>(</span><span class='hs-varid'>usage'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-3090"></a>
<a name="line-3091"></a><a name="setBinderOcc"></a><span class='hs-definition'>setBinderOcc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-3092"></a><span class='hs-definition'>setBinderOcc</span> <span class='hs-varid'>occ_info</span> <span class='hs-varid'>bndr</span>
<a name="line-3093"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span>
<a name="line-3094"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isExportedId</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isManyOccs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3095"></a>                          <span class='hs-keyword'>then</span> <span class='hs-varid'>bndr</span>
<a name="line-3096"></a>                          <span class='hs-keyword'>else</span> <span class='hs-varid'>setIdOccInfo</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>noOccInfo</span>
<a name="line-3097"></a>            <span class='hs-comment'>-- Don't use local usage info for visible-elsewhere things</span>
<a name="line-3098"></a>            <span class='hs-comment'>-- BUT *do* erase any IAmALoopBreaker annotation, because we're</span>
<a name="line-3099"></a>            <span class='hs-comment'>-- about to re-generate it and it shouldn't be "sticky"</span>
<a name="line-3100"></a>
<a name="line-3101"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdOccInfo</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>occ_info</span>
<a name="line-3102"></a>
<a name="line-3103"></a><a name="decideJoinPointHood"></a><span class='hs-comment'>-- | Decide whether some bindings should be made into join points or not.</span>
<a name="line-3104"></a><span class='hs-comment'>-- Returns `False` if they can't be join points. Note that it's an</span>
<a name="line-3105"></a><span class='hs-comment'>-- all-or-nothing decision, as if multiple binders are given, they're</span>
<a name="line-3106"></a><span class='hs-comment'>-- assumed to be mutually recursive.</span>
<a name="line-3107"></a><span class='hs-comment'>--</span>
<a name="line-3108"></a><span class='hs-comment'>-- It must, however, be a final decision. If we say "True" for 'f',</span>
<a name="line-3109"></a><span class='hs-comment'>-- and then subsequently decide /not/ make 'f' into a join point, then</span>
<a name="line-3110"></a><span class='hs-comment'>-- the decision about another binding 'g' might be invalidated if (say)</span>
<a name="line-3111"></a><span class='hs-comment'>-- 'f' tail-calls 'g'.</span>
<a name="line-3112"></a><span class='hs-comment'>--</span>
<a name="line-3113"></a><span class='hs-comment'>-- See Note [Invariants on join points] in "GHC.Core".</span>
<a name="line-3114"></a><span class='hs-definition'>decideJoinPointHood</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UsageDetails</span>
<a name="line-3115"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span>
<a name="line-3116"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-3117"></a><span class='hs-definition'>decideJoinPointHood</span> <span class='hs-conid'>TopLevel</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>
<a name="line-3118"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-3119"></a><span class='hs-definition'>decideJoinPointHood</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>bndrs</span>
<a name="line-3120"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJoinId</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-3121"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>all_ok</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"OccurAnal failed to rediscover join point(s):"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-3122"></a>                       <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span>
<a name="line-3123"></a>    <span class='hs-varid'>all_ok</span>
<a name="line-3124"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3125"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all_ok</span>
<a name="line-3126"></a>  <span class='hs-keyword'>where</span>
<a name="line-3127"></a>    <span class='hs-comment'>-- See Note [Invariants on join points]; invariants cited by number below.</span>
<a name="line-3128"></a>    <span class='hs-comment'>-- Invariant 2 is always satisfiable by the simplifier by eta expansion.</span>
<a name="line-3129"></a>    <span class='hs-varid'>all_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Invariant 3: Either all are join points or none are</span>
<a name="line-3130"></a>             <span class='hs-varid'>all</span> <span class='hs-varid'>ok</span> <span class='hs-varid'>bndrs</span>
<a name="line-3131"></a>
<a name="line-3132"></a>    <span class='hs-varid'>ok</span> <span class='hs-varid'>bndr</span>
<a name="line-3133"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-comment'>-- Invariant 1: Only tail calls, all same join arity</span>
<a name="line-3134"></a>        <span class='hs-conid'>AlwaysTailCalled</span> <span class='hs-varid'>arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupDetails</span> <span class='hs-varid'>usage</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3135"></a>
<a name="line-3136"></a>      <span class='hs-layout'>,</span> <span class='hs-comment'>-- Invariant 1 as applied to LHSes of rules</span>
<a name="line-3137"></a>        <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>ok_rule</span> <span class='hs-varid'>arity</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idCoreRules</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3138"></a>
<a name="line-3139"></a>        <span class='hs-comment'>-- Invariant 2a: stable unfoldings</span>
<a name="line-3140"></a>        <span class='hs-comment'>-- See Note [Join points and INLINE pragmas]</span>
<a name="line-3141"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>ok_unfolding</span> <span class='hs-varid'>arity</span> <span class='hs-layout'>(</span><span class='hs-varid'>realIdUnfolding</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3142"></a>
<a name="line-3143"></a>        <span class='hs-comment'>-- Invariant 4: Satisfies polymorphism rule</span>
<a name="line-3144"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isValidJoinPointType</span> <span class='hs-varid'>arity</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span>
<a name="line-3145"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-3146"></a>
<a name="line-3147"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3148"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-3149"></a>
<a name="line-3150"></a>    <span class='hs-varid'>ok_rule</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>BuiltinRule</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- only possible with plugin shenanigans</span>
<a name="line-3151"></a>    <span class='hs-varid'>ok_rule</span> <span class='hs-varid'>join_arity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3152"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>join_arity</span>
<a name="line-3153"></a>        <span class='hs-comment'>-- Invariant 1 as applied to LHSes of rules</span>
<a name="line-3154"></a>
<a name="line-3155"></a>    <span class='hs-comment'>-- ok_unfolding returns False if we should /not/ convert a non-join-id</span>
<a name="line-3156"></a>    <span class='hs-comment'>-- into a join-id, even though it is AlwaysTailCalled</span>
<a name="line-3157"></a>    <span class='hs-varid'>ok_unfolding</span> <span class='hs-varid'>join_arity</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3158"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStableSource</span> <span class='hs-varid'>src</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>join_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>joinRhsArity</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-3159"></a>    <span class='hs-varid'>ok_unfolding</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3160"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-3161"></a>    <span class='hs-varid'>ok_unfolding</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>
<a name="line-3162"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-3163"></a>
<a name="line-3164"></a><a name="willBeJoinId_maybe"></a><span class='hs-definition'>willBeJoinId_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>JoinArity</span>
<a name="line-3165"></a><span class='hs-definition'>willBeJoinId_maybe</span> <span class='hs-varid'>bndr</span>
<a name="line-3166"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-layout'>(</span><span class='hs-varid'>idOccInfo</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-3167"></a>      <span class='hs-conid'>AlwaysTailCalled</span> <span class='hs-varid'>arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>arity</span>
<a name="line-3168"></a>      <span class='hs-keyword'>_</span>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>bndr</span>
<a name="line-3169"></a>
<a name="line-3170"></a>
<a name="line-3171"></a><span class='hs-comment'>{- Note [Join points and INLINE pragmas]
<a name="line-3172"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3173"></a>Consider
<a name="line-3174"></a>   f x = let g = \x. not  -- Arity 1
<a name="line-3175"></a>             {-# INLINE g #-}
<a name="line-3176"></a>         in case x of
<a name="line-3177"></a>              A -&gt; g True True
<a name="line-3178"></a>              B -&gt; g True False
<a name="line-3179"></a>              C -&gt; blah2
<a name="line-3180"></a>
<a name="line-3181"></a>Here 'g' is always tail-called applied to 2 args, but the stable
<a name="line-3182"></a>unfolding captured by the INLINE pragma has arity 1.  If we try to
<a name="line-3183"></a>convert g to be a join point, its unfolding will still have arity 1
<a name="line-3184"></a>(since it is stable, and we don't meddle with stable unfoldings), and
<a name="line-3185"></a>Lint will complain (see Note [Invariants on join points], (2a), in
<a name="line-3186"></a>GHC.Core.  #13413.
<a name="line-3187"></a>
<a name="line-3188"></a>Moreover, since g is going to be inlined anyway, there is no benefit
<a name="line-3189"></a>from making it a join point.
<a name="line-3190"></a>
<a name="line-3191"></a>If it is recursive, and uselessly marked INLINE, this will stop us
<a name="line-3192"></a>making it a join point, which is annoying.  But occasionally
<a name="line-3193"></a>(notably in class methods; see Note [Instances and loop breakers] in
<a name="line-3194"></a>GHC.Tc.TyCl.Instance) we mark recursive things as INLINE but the recursion
<a name="line-3195"></a>unravels; so ignoring INLINE pragmas on recursive things isn't good
<a name="line-3196"></a>either.
<a name="line-3197"></a>
<a name="line-3198"></a>See Invariant 2a of Note [Invariants on join points] in GHC.Core
<a name="line-3199"></a>
<a name="line-3200"></a>
<a name="line-3201"></a>************************************************************************
<a name="line-3202"></a>*                                                                      *
<a name="line-3203"></a>\subsection{Operations over OccInfo}
<a name="line-3204"></a>*                                                                      *
<a name="line-3205"></a>************************************************************************
<a name="line-3206"></a>-}</span>
<a name="line-3207"></a>
<a name="line-3208"></a><a name="markMany"></a><span class='hs-definition'>markMany</span><span class='hs-layout'>,</span> <span class='hs-varid'>markInsideLam</span><span class='hs-layout'>,</span> <span class='hs-varid'>markNonTail</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>
<a name="line-3209"></a>
<a name="line-3210"></a><span class='hs-definition'>markMany</span> <span class='hs-conid'>IAmDead</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IAmDead</span>
<a name="line-3211"></a><span class='hs-definition'>markMany</span> <span class='hs-varid'>occ</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ManyOccs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ_tail</span> <span class='hs-varid'>occ</span> <span class='hs-layout'>}</span>
<a name="line-3212"></a>
<a name="line-3213"></a><a name="markInsideLam"></a><span class='hs-definition'>markInsideLam</span> <span class='hs-varid'>occ</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsInsideLam</span> <span class='hs-layout'>}</span>
<a name="line-3214"></a><span class='hs-definition'>markInsideLam</span> <span class='hs-varid'>occ</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span>
<a name="line-3215"></a>
<a name="line-3216"></a><a name="markNonTail"></a><span class='hs-definition'>markNonTail</span> <span class='hs-conid'>IAmDead</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IAmDead</span>
<a name="line-3217"></a><span class='hs-definition'>markNonTail</span> <span class='hs-varid'>occ</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoTailCallInfo</span> <span class='hs-layout'>}</span>
<a name="line-3218"></a>
<a name="line-3219"></a><a name="addOccInfo"></a><span class='hs-definition'>addOccInfo</span><span class='hs-layout'>,</span> <span class='hs-varid'>orOccInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OccInfo</span>
<a name="line-3220"></a>
<a name="line-3221"></a><span class='hs-definition'>addOccInfo</span> <span class='hs-varid'>a1</span> <span class='hs-varid'>a2</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadOcc</span> <span class='hs-varid'>a1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isDeadOcc</span> <span class='hs-varid'>a2</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-3222"></a>                    <span class='hs-conid'>ManyOccs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-varid'>a1</span> <span class='hs-varop'>`andTailCallInfo`</span>
<a name="line-3223"></a>                                          <span class='hs-varid'>tailCallInfo</span> <span class='hs-varid'>a2</span> <span class='hs-layout'>}</span>
<a name="line-3224"></a>                                <span class='hs-comment'>-- Both branches are at least One</span>
<a name="line-3225"></a>                                <span class='hs-comment'>-- (Argument is never IAmDead)</span>
<a name="line-3226"></a>
<a name="line-3227"></a><span class='hs-comment'>-- (orOccInfo orig new) is used</span>
<a name="line-3228"></a><span class='hs-comment'>-- when combining occurrence info from branches of a case</span>
<a name="line-3229"></a>
<a name="line-3230"></a><a name="orOccInfo"></a><span class='hs-definition'>orOccInfo</span> <span class='hs-layout'>(</span><span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_lam1</span>
<a name="line-3231"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_n_br</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nbr1</span>
<a name="line-3232"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt1</span>
<a name="line-3233"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_tail</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3234"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_lam2</span>
<a name="line-3235"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_n_br</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nbr2</span>
<a name="line-3236"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt2</span>
<a name="line-3237"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>occ_tail</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3238"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OneOcc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_n_br</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nbr1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>nbr2</span>
<a name="line-3239"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_in_lam</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_lam1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>in_lam2</span>
<a name="line-3240"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_int_cxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>int_cxt1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>int_cxt2</span>
<a name="line-3241"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>occ_tail</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tail1</span> <span class='hs-varop'>`andTailCallInfo`</span> <span class='hs-varid'>tail2</span> <span class='hs-layout'>}</span>
<a name="line-3242"></a>
<a name="line-3243"></a><span class='hs-definition'>orOccInfo</span> <span class='hs-varid'>a1</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadOcc</span> <span class='hs-varid'>a1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isDeadOcc</span> <span class='hs-varid'>a2</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-3244"></a>                  <span class='hs-conid'>ManyOccs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>occ_tail</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tailCallInfo</span> <span class='hs-varid'>a1</span> <span class='hs-varop'>`andTailCallInfo`</span>
<a name="line-3245"></a>                                        <span class='hs-varid'>tailCallInfo</span> <span class='hs-varid'>a2</span> <span class='hs-layout'>}</span>
<a name="line-3246"></a>
<a name="line-3247"></a><a name="andTailCallInfo"></a><span class='hs-definition'>andTailCallInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TailCallInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TailCallInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TailCallInfo</span>
<a name="line-3248"></a><span class='hs-definition'>andTailCallInfo</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>AlwaysTailCalled</span> <span class='hs-varid'>arity1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AlwaysTailCalled</span> <span class='hs-varid'>arity2</span><span class='hs-layout'>)</span>
<a name="line-3249"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>arity1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>arity2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span>
<a name="line-3250"></a><span class='hs-definition'>andTailCallInfo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoTailCallInfo</span>
</pre></body>
</html>
