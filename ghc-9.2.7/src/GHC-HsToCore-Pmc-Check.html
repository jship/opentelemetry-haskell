<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/HsToCore/Pmc/Check.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP               #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE DeriveFunctor     #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE GADTs             #-}</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>-- | Coverage checking step of the</span>
<a name="line-7"></a><span class='hs-comment'>-- [Lower Your Guards paper](https://dl.acm.org/doi/abs/10.1145/3408989).</span>
<a name="line-8"></a><span class='hs-comment'>--</span>
<a name="line-9"></a><span class='hs-comment'>-- Coverage check guard trees (like @'PmMatch' 'Pre'@) to get a</span>
<a name="line-10"></a><span class='hs-comment'>-- 'CheckResult', containing</span>
<a name="line-11"></a><span class='hs-comment'>--</span>
<a name="line-12"></a><span class='hs-comment'>--   1. The set of uncovered values, 'cr_uncov'</span>
<a name="line-13"></a><span class='hs-comment'>--   2. And an annotated tree variant (like @'PmMatch' 'Post'@) that captures</span>
<a name="line-14"></a><span class='hs-comment'>--      redundancy and inaccessibility information as 'RedSets' annotations</span>
<a name="line-15"></a><span class='hs-comment'>--</span>
<a name="line-16"></a><span class='hs-comment'>-- Basically the UA function from Section 5.1, which is an optimised</span>
<a name="line-17"></a><span class='hs-comment'>-- interleaving of U and A from Section 3.2 (Figure 5).</span>
<a name="line-18"></a><span class='hs-comment'>-- The Normalised Refinement Types 'Nablas' are maintained in</span>
<a name="line-19"></a><span class='hs-comment'>-- "GHC.HsToCore.Pmc.Solver".</span>
<a name="line-20"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Check</span> <span class='hs-layout'>(</span>
<a name="line-21"></a>        <span class='hs-conid'>CheckAction</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>checkMatchGroup</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkGRHSs</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkPatBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkEmptyCase</span>
<a name="line-23"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-24"></a>
<a name="line-25"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-26"></a>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span> <span class='hs-layout'>(</span> <span class='hs-varid'>hasKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>considerAccessibleIdKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>trueDataConKey</span> <span class='hs-layout'>)</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Monad</span> <span class='hs-layout'>(</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Types</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Utils</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.HsToCore.Pmc.Solver</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcType</span> <span class='hs-layout'>(</span><span class='hs-varid'>evVarPred</span><span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.OrdList</span>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Semigroup</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Semi</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-layout'>(</span> <span class='hs-conid'>NonEmpty</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>NE</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Coerce</span>
<a name="line-43"></a>
<a name="line-44"></a><a name="CheckAction"></a><span class='hs-comment'>-- | Coverage checking action. Can be composed 'leftToRight' or 'topToBottom'.</span>
<a name="line-45"></a><a name="CheckAction"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CA</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unCA</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DsM</span> <span class='hs-layout'>(</span><span class='hs-conid'>CheckResult</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-46"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Functor</span>
<a name="line-47"></a>
<a name="line-48"></a><a name="topToBottom"></a><span class='hs-comment'>-- | Composes 'CheckAction's top-to-bottom:</span>
<a name="line-49"></a><span class='hs-comment'>-- If a value falls through the resulting action, then it must fall through the</span>
<a name="line-50"></a><span class='hs-comment'>-- first action and then through the second action.</span>
<a name="line-51"></a><span class='hs-comment'>-- If a value matches the resulting action, then it either matches the</span>
<a name="line-52"></a><span class='hs-comment'>-- first action or matches the second action.</span>
<a name="line-53"></a><span class='hs-comment'>-- Basically the semantics of the LYG branching construct.</span>
<a name="line-54"></a><span class='hs-definition'>topToBottom</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>top</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ret</span><span class='hs-layout'>)</span>
<a name="line-55"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>top</span>
<a name="line-56"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>bot</span>
<a name="line-57"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>ret</span>
<a name="line-58"></a><span class='hs-definition'>topToBottom</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>CA</span> <span class='hs-varid'>top</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>CA</span> <span class='hs-varid'>bot</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CA</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>inc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-59"></a>  <span class='hs-varid'>t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>top</span> <span class='hs-varid'>inc</span>
<a name="line-60"></a>  <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bot</span> <span class='hs-layout'>(</span><span class='hs-varid'>cr_uncov</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-61"></a>  <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>cr_ret</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>cr_ret</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-62"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-varid'>b</span>
<a name="line-63"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cr_approx</span> <span class='hs-varid'>t</span> <span class='hs-conid'>Semi</span><span class='hs-varop'>.&lt;&gt;</span> <span class='hs-varid'>cr_approx</span> <span class='hs-varid'>b</span> <span class='hs-layout'>}</span>
<a name="line-64"></a>
<a name="line-65"></a>
<a name="line-66"></a><a name="leftToRight"></a><span class='hs-comment'>-- | Composes 'CheckAction's left-to-right:</span>
<a name="line-67"></a><span class='hs-comment'>-- If a value falls through the resulting action, then it either falls through the</span>
<a name="line-68"></a><span class='hs-comment'>-- first action or through the second action.</span>
<a name="line-69"></a><span class='hs-comment'>-- If a value matches the resulting action, then it must match the first action</span>
<a name="line-70"></a><span class='hs-comment'>-- and then match the second action.</span>
<a name="line-71"></a><span class='hs-comment'>-- Basically the semantics of the LYG guard construct.</span>
<a name="line-72"></a><span class='hs-definition'>leftToRight</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>RedSets</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>right</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ret</span><span class='hs-layout'>)</span>
<a name="line-73"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-conid'>RedSets</span>
<a name="line-74"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>right</span>
<a name="line-75"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>ret</span>
<a name="line-76"></a><span class='hs-definition'>leftToRight</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>CA</span> <span class='hs-varid'>left</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>CA</span> <span class='hs-varid'>right</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CA</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>inc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-77"></a>  <span class='hs-varid'>l</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>left</span> <span class='hs-varid'>inc</span>
<a name="line-78"></a>  <span class='hs-varid'>r</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>right</span> <span class='hs-layout'>(</span><span class='hs-varid'>rs_cov</span> <span class='hs-layout'>(</span><span class='hs-varid'>cr_ret</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-79"></a>  <span class='hs-varid'>limit</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>maxPmCheckModels</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-80"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-varid'>l</span> <span class='hs-conid'>Semi</span><span class='hs-varop'>.&lt;&gt;</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-varid'>r</span>
<a name="line-81"></a>  <span class='hs-comment'>-- See Note [Countering exponential blowup]</span>
<a name="line-82"></a>  <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>prec'</span><span class='hs-layout'>,</span> <span class='hs-varid'>uncov'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>throttle</span> <span class='hs-varid'>limit</span> <span class='hs-varid'>inc</span> <span class='hs-varid'>uncov</span>
<a name="line-83"></a>  <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>cr_ret</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>cr_ret</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-84"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uncov'</span>
<a name="line-85"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prec'</span> <span class='hs-conid'>Semi</span><span class='hs-varop'>.&lt;&gt;</span> <span class='hs-varid'>cr_approx</span> <span class='hs-varid'>l</span> <span class='hs-conid'>Semi</span><span class='hs-varop'>.&lt;&gt;</span> <span class='hs-varid'>cr_approx</span> <span class='hs-varid'>r</span> <span class='hs-layout'>}</span>
<a name="line-86"></a>
<a name="line-87"></a><a name="throttle"></a><span class='hs-comment'>-- | @throttle limit old new@ returns @old@ if the number of 'Nabla's in @new@</span>
<a name="line-88"></a><span class='hs-comment'>-- is exceeding the given @limit@ and the @old@ number of 'Nabla's.</span>
<a name="line-89"></a><span class='hs-comment'>-- See Note [Countering exponential blowup].</span>
<a name="line-90"></a><span class='hs-definition'>throttle</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nablas</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Precision</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nablas</span><span class='hs-layout'>)</span>
<a name="line-91"></a><span class='hs-definition'>throttle</span> <span class='hs-varid'>limit</span> <span class='hs-varid'>old</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>MkNablas</span> <span class='hs-varid'>old_ds</span><span class='hs-layout'>)</span> <span class='hs-varid'>new</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>MkNablas</span> <span class='hs-varid'>new_ds</span><span class='hs-layout'>)</span>
<a name="line-92"></a>  <span class='hs-comment'>--- | pprTrace "PmCheck:throttle" (ppr (length old_ds) &lt;+&gt; ppr (length new_ds) &lt;+&gt; ppr limit) False = undefined</span>
<a name="line-93"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-varid'>new_ds</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>max</span> <span class='hs-varid'>limit</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>old_ds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Approximate</span><span class='hs-layout'>,</span> <span class='hs-varid'>old</span><span class='hs-layout'>)</span>
<a name="line-94"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                 <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>Precise</span><span class='hs-layout'>,</span>     <span class='hs-varid'>new</span><span class='hs-layout'>)</span>
<a name="line-95"></a>
<a name="line-96"></a><a name="checkSequence"></a><span class='hs-definition'>checkSequence</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>grdtree</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-varid'>anntree</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>grdtree</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonEmpty</span> <span class='hs-varid'>anntree</span><span class='hs-layout'>)</span>
<a name="line-97"></a><span class='hs-comment'>-- The implementation is pretty similar to</span>
<a name="line-98"></a><span class='hs-comment'>-- @traverse1 :: Apply f =&gt; (a -&gt; f b) -&gt; NonEmpty a -&gt; f (NonEmpty b)@</span>
<a name="line-99"></a><span class='hs-definition'>checkSequence</span> <span class='hs-varid'>act</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span> <span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conop'>:|</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>act</span> <span class='hs-varid'>t</span>
<a name="line-100"></a><span class='hs-definition'>checkSequence</span> <span class='hs-varid'>act</span> <span class='hs-layout'>(</span><span class='hs-varid'>t1</span> <span class='hs-conop'>:|</span> <span class='hs-layout'>(</span><span class='hs-varid'>t2</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-101"></a>  <span class='hs-varid'>topToBottom</span> <span class='hs-layout'>(</span><span class='hs-conid'>NE</span><span class='hs-varop'>.&lt;|</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>act</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkSequence</span> <span class='hs-varid'>act</span> <span class='hs-layout'>(</span><span class='hs-varid'>t2</span><span class='hs-conop'>:|</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-102"></a>
<a name="line-103"></a><a name="emptyRedSets"></a><span class='hs-definition'>emptyRedSets</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RedSets</span>
<a name="line-104"></a><span class='hs-comment'>-- Semigroup instance would be misleading!</span>
<a name="line-105"></a><span class='hs-definition'>emptyRedSets</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RedSets</span> <span class='hs-varid'>mempty</span> <span class='hs-varid'>mempty</span> <span class='hs-varid'>mempty</span>
<a name="line-106"></a>
<a name="line-107"></a><a name="checkGrd"></a><span class='hs-definition'>checkGrd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmGrd</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-conid'>RedSets</span>
<a name="line-108"></a><span class='hs-definition'>checkGrd</span> <span class='hs-varid'>grd</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CA</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>inc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>grd</span> <span class='hs-keyword'>of</span>
<a name="line-109"></a>  <span class='hs-comment'>-- let x = e: Refine with x ~ e</span>
<a name="line-110"></a>  <span class='hs-conid'>PmLet</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-111"></a>    <span class='hs-varid'>matched</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiCoreCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-112"></a>    <span class='hs-varid'>tracePm</span> <span class='hs-str'>"check:Let"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'='</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-113"></a>    <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyRedSets</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rs_cov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>matched</span> <span class='hs-layout'>}</span>
<a name="line-114"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-115"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Precise</span> <span class='hs-layout'>}</span>
<a name="line-116"></a>  <span class='hs-comment'>-- Bang x _: Diverge on x ~ ⊥, refine with x ≁ ⊥</span>
<a name="line-117"></a>  <span class='hs-conid'>PmBang</span> <span class='hs-varid'>x</span> <span class='hs-varid'>mb_info</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-118"></a>    <span class='hs-varid'>div</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-119"></a>    <span class='hs-varid'>matched</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-120"></a>    <span class='hs-comment'>-- See Note [Dead bang patterns]</span>
<a name="line-121"></a>    <span class='hs-comment'>-- mb_info = Just info &lt;==&gt; PmBang originates from bang pattern in source</span>
<a name="line-122"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>bangs</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitOL</span> <span class='hs-layout'>(</span><span class='hs-varid'>div</span><span class='hs-layout'>,</span> <span class='hs-varid'>info</span><span class='hs-layout'>)</span>
<a name="line-123"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NilOL</span>
<a name="line-124"></a>    <span class='hs-varid'>tracePm</span> <span class='hs-str'>"check:Bang"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-125"></a>    <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RedSets</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rs_cov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>matched</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs_div</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>div</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs_bangs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bangs</span> <span class='hs-layout'>}</span>
<a name="line-126"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-127"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Precise</span> <span class='hs-layout'>}</span>
<a name="line-128"></a>  <span class='hs-comment'>-- See point (3) of Note [considerAccessible]</span>
<a name="line-129"></a>  <span class='hs-conid'>PmCon</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmAltConLike</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>
<a name="line-130"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>considerAccessibleIdKey</span>
<a name="line-131"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>con</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>trueDataConKey</span>
<a name="line-132"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyRedSets</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rs_cov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initNablas</span> <span class='hs-layout'>}</span>
<a name="line-133"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-134"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Precise</span> <span class='hs-layout'>}</span>
<a name="line-135"></a>  <span class='hs-comment'>-- Con: Fall through on x ≁ K and refine with x ~ K ys and type info</span>
<a name="line-136"></a>  <span class='hs-conid'>PmCon</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>dicts</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-137"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>div</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isPmAltConMatchStrict</span> <span class='hs-varid'>con</span>
<a name="line-138"></a>      <span class='hs-keyword'>then</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiBotCt</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-139"></a>      <span class='hs-keyword'>else</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>mempty</span>
<a name="line-140"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>matched</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>evVarPred</span> <span class='hs-varid'>dicts</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-141"></a>    <span class='hs-varop'>!</span><span class='hs-varid'>uncov</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotConCt</span> <span class='hs-varid'>x</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-142"></a>    <span class='hs-varid'>tracePm</span> <span class='hs-str'>"check:Con"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-143"></a>      <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>grd</span>
<a name="line-144"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inc</span>
<a name="line-145"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"div"</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-146"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"matched"</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>matched</span><span class='hs-layout'>)</span>
<a name="line-147"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"uncov"</span><span class='hs-layout'>)</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>uncov</span><span class='hs-layout'>)</span>
<a name="line-148"></a>      <span class='hs-keyglyph'>]</span>
<a name="line-149"></a>    <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyRedSets</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rs_cov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>matched</span><span class='hs-layout'>,</span> <span class='hs-varid'>rs_div</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>div</span> <span class='hs-layout'>}</span>
<a name="line-150"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uncov</span>
<a name="line-151"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Precise</span> <span class='hs-layout'>}</span>
<a name="line-152"></a>
<a name="line-153"></a><a name="checkGrds"></a><span class='hs-definition'>checkGrds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PmGrd</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-conid'>RedSets</span>
<a name="line-154"></a><span class='hs-definition'>checkGrds</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CA</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>inc</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-155"></a>  <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyRedSets</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rs_cov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>}</span>
<a name="line-156"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-157"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Precise</span> <span class='hs-layout'>}</span>
<a name="line-158"></a><span class='hs-definition'>checkGrds</span> <span class='hs-layout'>(</span><span class='hs-varid'>g</span><span class='hs-conop'>:</span><span class='hs-varid'>grds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>leftToRight</span> <span class='hs-varid'>merge</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkGrd</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkGrds</span> <span class='hs-varid'>grds</span><span class='hs-layout'>)</span>
<a name="line-159"></a>  <span class='hs-keyword'>where</span>
<a name="line-160"></a>    <span class='hs-varid'>merge</span> <span class='hs-varid'>ri_g</span> <span class='hs-varid'>ri_grds</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- This operation would /not/ form a Semigroup!</span>
<a name="line-161"></a>      <span class='hs-conid'>RedSets</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rs_cov</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rs_cov</span> <span class='hs-varid'>ri_grds</span>
<a name="line-162"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>rs_div</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rs_div</span> <span class='hs-varid'>ri_g</span>   <span class='hs-conid'>Semi</span><span class='hs-varop'>.&lt;&gt;</span> <span class='hs-varid'>rs_div</span> <span class='hs-varid'>ri_grds</span>
<a name="line-163"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>rs_bangs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rs_bangs</span> <span class='hs-varid'>ri_g</span> <span class='hs-conid'>Semi</span><span class='hs-varop'>.&lt;&gt;</span> <span class='hs-varid'>rs_bangs</span> <span class='hs-varid'>ri_grds</span> <span class='hs-layout'>}</span>
<a name="line-164"></a>
<a name="line-165"></a><a name="checkMatchGroup"></a><span class='hs-definition'>checkMatchGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmMatchGroup</span> <span class='hs-conid'>Pre</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmMatchGroup</span> <span class='hs-conid'>Post</span><span class='hs-layout'>)</span>
<a name="line-166"></a><span class='hs-definition'>checkMatchGroup</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmMatchGroup</span> <span class='hs-varid'>matches</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-167"></a>  <span class='hs-conid'>PmMatchGroup</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>checkSequence</span> <span class='hs-varid'>checkMatch</span> <span class='hs-varid'>matches</span>
<a name="line-168"></a>
<a name="line-169"></a><a name="checkMatch"></a><span class='hs-definition'>checkMatch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmMatch</span> <span class='hs-conid'>Pre</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmMatch</span> <span class='hs-conid'>Post</span><span class='hs-layout'>)</span>
<a name="line-170"></a><span class='hs-definition'>checkMatch</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmMatch</span> <span class='hs-layout'>{</span> <span class='hs-varid'>pm_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GrdVec</span> <span class='hs-varid'>grds</span><span class='hs-layout'>,</span> <span class='hs-varid'>pm_grhss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>grhss</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-171"></a>  <span class='hs-varid'>leftToRight</span> <span class='hs-conid'>PmMatch</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkGrds</span> <span class='hs-varid'>grds</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkGRHSs</span> <span class='hs-varid'>grhss</span><span class='hs-layout'>)</span>
<a name="line-172"></a>
<a name="line-173"></a><a name="checkGRHSs"></a><span class='hs-definition'>checkGRHSs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmGRHSs</span> <span class='hs-conid'>Pre</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmGRHSs</span> <span class='hs-conid'>Post</span><span class='hs-layout'>)</span>
<a name="line-174"></a><span class='hs-definition'>checkGRHSs</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmGRHSs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>pgs_lcls</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GrdVec</span> <span class='hs-varid'>lcls</span><span class='hs-layout'>,</span> <span class='hs-varid'>pgs_grhss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>grhss</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-175"></a>  <span class='hs-varid'>leftToRight</span> <span class='hs-conid'>PmGRHSs</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkGrds</span> <span class='hs-varid'>lcls</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkSequence</span> <span class='hs-varid'>checkGRHS</span> <span class='hs-varid'>grhss</span><span class='hs-layout'>)</span>
<a name="line-176"></a>
<a name="line-177"></a><a name="checkGRHS"></a><span class='hs-definition'>checkGRHS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmGRHS</span> <span class='hs-conid'>Pre</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmGRHS</span> <span class='hs-conid'>Post</span><span class='hs-layout'>)</span>
<a name="line-178"></a><span class='hs-definition'>checkGRHS</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmGRHS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>pg_grds</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GrdVec</span> <span class='hs-varid'>grds</span><span class='hs-layout'>,</span> <span class='hs-varid'>pg_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_info</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-179"></a>  <span class='hs-varid'>flip</span> <span class='hs-conid'>PmGRHS</span> <span class='hs-varid'>rhs_info</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>checkGrds</span> <span class='hs-varid'>grds</span>
<a name="line-180"></a>
<a name="line-181"></a><a name="checkEmptyCase"></a><span class='hs-definition'>checkEmptyCase</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PmEmptyCase</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-conid'>PmEmptyCase</span>
<a name="line-182"></a><span class='hs-comment'>-- See Note [Checking EmptyCase]</span>
<a name="line-183"></a><span class='hs-definition'>checkEmptyCase</span> <span class='hs-varid'>pe</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>PmEmptyCase</span> <span class='hs-layout'>{</span> <span class='hs-varid'>pe_var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>var</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CA</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>\</span><span class='hs-varid'>inc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-184"></a>  <span class='hs-varid'>unc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addPhiCtNablas</span> <span class='hs-varid'>inc</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhiNotBotCt</span> <span class='hs-varid'>var</span><span class='hs-layout'>)</span>
<a name="line-185"></a>  <span class='hs-varid'>pure</span> <span class='hs-conid'>CheckResult</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cr_ret</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pe</span><span class='hs-layout'>,</span> <span class='hs-varid'>cr_uncov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cr_approx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span> <span class='hs-layout'>}</span>
<a name="line-186"></a>
<a name="line-187"></a><a name="checkPatBind"></a><span class='hs-definition'>checkPatBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmPatBind</span> <span class='hs-conid'>Pre</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheckAction</span> <span class='hs-layout'>(</span><span class='hs-conid'>PmPatBind</span> <span class='hs-conid'>Post</span><span class='hs-layout'>)</span>
<a name="line-188"></a><span class='hs-definition'>checkPatBind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coerce</span> <span class='hs-varid'>checkGRHS</span>
<a name="line-189"></a>
<a name="line-190"></a><span class='hs-comment'>{- Note [Checking EmptyCase]
<a name="line-191"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-192"></a>-XEmptyCase is useful for matching on empty data types like 'Void'. For example,
<a name="line-193"></a>the following is a complete match:
<a name="line-194"></a>
<a name="line-195"></a>    f :: Void -&gt; ()
<a name="line-196"></a>    f x = case x of {}
<a name="line-197"></a>
<a name="line-198"></a>Really, -XEmptyCase is the only way to write a program that at the same time is
<a name="line-199"></a>safe (@f _ = error "boom"@ is not because of ⊥), doesn't trigger a warning
<a name="line-200"></a>(@f !_ = error "inaccessible" has inaccessible RHS) and doesn't turn an
<a name="line-201"></a>exception into divergence (@f x = f x@).
<a name="line-202"></a>
<a name="line-203"></a>Semantically, unlike every other case expression, -XEmptyCase is strict in its
<a name="line-204"></a>match var x, which rules out ⊥ as an inhabitant. So we add x ≁ ⊥ to the
<a name="line-205"></a>initial Nabla and check if there are any values left to match on.
<a name="line-206"></a>
<a name="line-207"></a>Note [Dead bang patterns]
<a name="line-208"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-209"></a>Consider
<a name="line-210"></a>
<a name="line-211"></a>  f :: Bool -&gt; Int
<a name="line-212"></a>  f True = 1
<a name="line-213"></a>  f !x   = 2
<a name="line-214"></a>
<a name="line-215"></a>Whenever we fall through to the second equation, we will already have evaluated
<a name="line-216"></a>the argument. Thus, the bang pattern serves no purpose and should be warned
<a name="line-217"></a>about. We call this kind of bang patterns "dead". Dead bangs are the ones
<a name="line-218"></a>that under no circumstances can force a thunk that wasn't already forced.
<a name="line-219"></a>Dead bangs are a form of redundant bangs; see below.
<a name="line-220"></a>
<a name="line-221"></a>We can detect dead bang patterns by checking whether @x ~ ⊥@ is satisfiable
<a name="line-222"></a>where the PmBang appears in 'checkGrd'. If not, then clearly the bang is
<a name="line-223"></a>dead. So for a source bang, we add the refined Nabla and the source info to
<a name="line-224"></a>the 'RedSet's 'rs_bangs'. When collecting stuff to warn, we test that Nabla for
<a name="line-225"></a>inhabitants. If it's empty, we'll warn that it's redundant.
<a name="line-226"></a>
<a name="line-227"></a>Note that we don't want to warn for a dead bang that appears on a redundant
<a name="line-228"></a>clause. That is because in that case, we recommend to delete the clause wholly,
<a name="line-229"></a>including its leading pattern match.
<a name="line-230"></a>
<a name="line-231"></a>Dead bang patterns are redundant. But there are bang patterns which are
<a name="line-232"></a>redundant that aren't dead, for example
<a name="line-233"></a>
<a name="line-234"></a>  f !() = 0
<a name="line-235"></a>
<a name="line-236"></a>the bang still forces the match variable, before we attempt to match on (). But
<a name="line-237"></a>it is redundant with the forcing done by the () match. We currently don't
<a name="line-238"></a>detect redundant bangs that aren't dead.
<a name="line-239"></a>
<a name="line-240"></a>Note [Countering exponential blowup]
<a name="line-241"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-242"></a>Precise pattern match exhaustiveness checking is necessarily exponential in
<a name="line-243"></a>the size of some input programs. We implement a counter-measure in the form of
<a name="line-244"></a>the -fmax-pmcheck-models flag, limiting the number of Nablas we check against
<a name="line-245"></a>each pattern by a constant.
<a name="line-246"></a>
<a name="line-247"></a>How do we do that? Consider
<a name="line-248"></a>
<a name="line-249"></a>  f True True = ()
<a name="line-250"></a>  f True True = ()
<a name="line-251"></a>
<a name="line-252"></a>And imagine we set our limit to 1 for the sake of the example. The first clause
<a name="line-253"></a>will be checked against the initial Nabla, {}. Doing so will produce an
<a name="line-254"></a>Uncovered set of size 2, containing the models {x≁True} and {x~True,y≁True}.
<a name="line-255"></a>Also we find the first clause to cover the model {x~True,y~True}.
<a name="line-256"></a>
<a name="line-257"></a>But the Uncovered set we get out of the match is too huge! We somehow have to
<a name="line-258"></a>ensure not to make things worse as they are already, so we continue checking
<a name="line-259"></a>with a singleton Uncovered set of the initial Nabla {}. Why is this
<a name="line-260"></a>sound (wrt. the notion in GADTs Meet Their Match)? Well, it basically amounts
<a name="line-261"></a>to forgetting that we matched against the first clause. The values represented
<a name="line-262"></a>by {} are a superset of those represented by its two refinements {x≁True} and
<a name="line-263"></a>{x~True,y≁True}.
<a name="line-264"></a>
<a name="line-265"></a>This forgetfulness becomes very apparent in the example above: By continuing
<a name="line-266"></a>with {} we don't detect the second clause as redundant, as it again covers the
<a name="line-267"></a>same non-empty subset of {}. So we don't flag everything as redundant anymore,
<a name="line-268"></a>but still will never flag something as redundant that isn't.
<a name="line-269"></a>
<a name="line-270"></a>For exhaustivity, the converse applies: We will report @f@ as non-exhaustive
<a name="line-271"></a>and report @f _ _@ as missing, which is a superset of the actual missing
<a name="line-272"></a>matches. But soundness means we will never fail to report a missing match.
<a name="line-273"></a>
<a name="line-274"></a>This mechanism is implemented in 'throttle'.
<a name="line-275"></a>
<a name="line-276"></a>Guards are an extreme example in this regard, with #11195 being a particularly
<a name="line-277"></a>dreadful example: Since their RHS are often pretty much unique, we split on a
<a name="line-278"></a>variable (the one representing the RHS) that doesn't occur anywhere else in the
<a name="line-279"></a>program, so we don't actually get useful information out of that split!
<a name="line-280"></a>
<a name="line-281"></a>Note [considerAccessible]
<a name="line-282"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-283"></a>Consider (T18610)
<a name="line-284"></a>
<a name="line-285"></a>  f :: Bool -&gt; Int
<a name="line-286"></a>  f x = case (x, x) of
<a name="line-287"></a>    (True,  True)  -&gt; 1
<a name="line-288"></a>    (False, False) -&gt; 2
<a name="line-289"></a>    (True,  False) -&gt; 3 -- Warning: Redundant
<a name="line-290"></a>
<a name="line-291"></a>The third case is detected as redundant. But it may be the intent of the
<a name="line-292"></a>programmer to keep the dead code, in order for it not to bitrot or to support
<a name="line-293"></a>debugging scenarios. But there is no way to communicate that to the
<a name="line-294"></a>pattern-match checker! The only way is to deactivate pattern-match checking
<a name="line-295"></a>whole-sale, which is quite annoying. Hence, we define in "GHC.Exts":
<a name="line-296"></a>
<a name="line-297"></a>  considerAccessible = True
<a name="line-298"></a>
<a name="line-299"></a>'considerAccessible' is treated specially by the pattern-match checker in that a
<a name="line-300"></a>guard with it as the scrutinee expression will keep its parent clause alive:
<a name="line-301"></a>
<a name="line-302"></a>  g :: Bool -&gt; Int
<a name="line-303"></a>  g x = case (x, x) of
<a name="line-304"></a>    (True,  True)  -&gt; 1
<a name="line-305"></a>    (False, False) -&gt; 2
<a name="line-306"></a>    (True,  False) | GHC.Exts.considerAccessible -&gt; 3 -- No warning
<a name="line-307"></a>
<a name="line-308"></a>The key bits of the implementation are:
<a name="line-309"></a>
<a name="line-310"></a>  1. Its definition is recognised as known-key (see "GHC.Builtin.Names").
<a name="line-311"></a>  2. After "GHC.HsToCore.Pmc.Desugar", the guard will end up as a 'PmCon', where
<a name="line-312"></a>     the match var is the known-key 'considerAccessible' and the constructor
<a name="line-313"></a>     against which it matches is 'True'.
<a name="line-314"></a>  3. We recognise the 'PmCon' in 'GHC.HsToCore.Check.checkGrd' and inflate the
<a name="line-315"></a>     incoming set of values for all guards downstream to the unconstrained
<a name="line-316"></a>     'initNablas' set, e.g. /all/ values.
<a name="line-317"></a>     (The set of values that falls through that particular guard is empty, as
<a name="line-318"></a>     matching 'considerAccessible' against 'True' can't fail.)
<a name="line-319"></a>
<a name="line-320"></a>Note that 'considerAccessible' breaks the invariant that incoming sets of values
<a name="line-321"></a>reaching syntactic children are subsets of that of the syntactic ancestor:
<a name="line-322"></a>A whole match, like that of the third clause of the example, might have no
<a name="line-323"></a>incoming value, but its single RHS has incoming values because of (3).
<a name="line-324"></a>
<a name="line-325"></a>That means the 'is_covered' flag computed in 'GHC.HsToCore.Pmc.cirbsMatch'
<a name="line-326"></a>is irrelevant and should not be used to flag all children as redundant (which is
<a name="line-327"></a>what we used to do).
<a name="line-328"></a>
<a name="line-329"></a>We achieve great benefits with a very simple implementation.
<a name="line-330"></a>There are caveats, though:
<a name="line-331"></a>
<a name="line-332"></a>  (A) Putting potentially failing guards /after/ the
<a name="line-333"></a>      'considerAccessible' guard might lead to weird check results, e.g.,
<a name="line-334"></a>
<a name="line-335"></a>        h :: Bool -&gt; Int
<a name="line-336"></a>        h x = case (x, x) of
<a name="line-337"></a>          (True,  True)  -&gt; 1
<a name="line-338"></a>          (False, False) -&gt; 2
<a name="line-339"></a>          (True,  False) | GHC.Exts.considerAccessible, False &lt;- x -&gt; 3
<a name="line-340"></a>          -- Warning: Not matched: (_, _)
<a name="line-341"></a>
<a name="line-342"></a>      That *is* fixable, although we would pay with a much more complicated
<a name="line-343"></a>      implementation.
<a name="line-344"></a>  (B) If the programmer puts a 'considerAccessible' marker on an accessible
<a name="line-345"></a>      clause, the checker doesn't warn about it. E.g.,
<a name="line-346"></a>
<a name="line-347"></a>        f :: Bool -&gt; Int
<a name="line-348"></a>        f True | considerAccessible = 0
<a name="line-349"></a>        f False = 1
<a name="line-350"></a>
<a name="line-351"></a>      will not emit any warning whatsoever. We could implement code that warns
<a name="line-352"></a>      here, but it wouldn't be as simple as it is now.
<a name="line-353"></a>-}</span>
</pre></body>
</html>
