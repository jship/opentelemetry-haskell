<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681085029"><span id="local-6989586621681085030"></span></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE LambdaCase #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-11"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-orphans #-}</span><span> </span><span class="hs-comment">-- Outputable</span><span>
</span><span id="line-14"></span><span>
</span><span id="line-15"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[PatSyntax]{Abstract Haskell syntax---patterns}
-}</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">GHC.Hs.Pat</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-23"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier">Pat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier">LPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-24"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier">EpAnnSumPat</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier">ConPatTc</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier">CoPat</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#ListPatTc"><span class="hs-identifier">ListPatTc</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier">ConLikeP</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier">HsConPatDetails</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier">hsConPatArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier">HsRecFields</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier">HsRecField'</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField%27"><span class="hs-identifier">LHsRecField'</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier">HsRecField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecField"><span class="hs-identifier">LHsRecField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier">HsRecUpdField</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier">LHsRecUpdField</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-34"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFields"><span class="hs-identifier">hsRecFields</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier">hsRecFieldSel</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier">hsRecFieldId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldsArgs"><span class="hs-identifier">hsRecFieldsArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-35"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldId"><span class="hs-identifier">hsRecUpdFieldId</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier">hsRecUpdFieldOcc</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldRdr"><span class="hs-identifier">hsRecUpdFieldRdr</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>
</span><span id="line-37"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier">mkPrefixConPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier">mkCharLitPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier">mkNilPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-38"></span><span>
</span><span id="line-39"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier">isSimplePat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-40"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier">looksLazyPatBind</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-41"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier">isBangedLPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-42"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier">patNeedsParens</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier">parenthesizePat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-43"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier">isIrrefutableHsPat</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-44"></span><span>
</span><span id="line-45"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier">collectEvVarsPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier">collectEvVarsPats</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier">pprParendLPat</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier">pprConArgs</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-48"></span><span>        </span><span class="annot"><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier">pprLPat</span></a></span><span>
</span><span id="line-49"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-50"></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-52"></span><span>
</span><span id="line-53"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-54"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier">HsExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier">SyntaxExpr</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html"><span class="hs-identifier">GHC.Hs.Expr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Expr.html#pprLExpr"><span class="hs-identifier">pprLExpr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Expr.html#pprSplice"><span class="hs-identifier">pprSplice</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-comment">-- friends:</span><span>
</span><span id="line-59"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Binds.html"><span class="hs-identifier">GHC.Hs.Binds</span></a></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Lit.html"><span class="hs-identifier">GHC.Hs.Lit</span></a></span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-62"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html"><span class="hs-identifier">GHC.Parser.Annotation</span></a></span><span>
</span><span id="line-63"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html"><span class="hs-identifier">GHC.Hs.Extension</span></a></span><span>
</span><span id="line-64"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Hs.Type.html"><span class="hs-identifier">GHC.Hs.Type</span></a></span><span>
</span><span id="line-65"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></a></span><span>
</span><span id="line-66"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span>
</span><span id="line-67"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span>
</span><span id="line-68"></span><span class="hs-comment">-- others:</span><span>
</span><span id="line-69"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Ppr.html"><span class="hs-identifier">GHC.Core.Ppr</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="hs-comment">{- instance OutputableBndr TyVar -}</span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-70"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Builtin.Types.html"><span class="hs-identifier">GHC.Builtin.Types</span></a></span><span>
</span><span id="line-71"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.html"><span class="hs-identifier">GHC.Types.Var</span></a></span><span>
</span><span id="line-72"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html"><span class="hs-identifier">GHC.Types.Name.Reader</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier">RdrName</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-73"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html"><span class="hs-identifier">GHC.Core.ConLike</span></a></span><span>
</span><span id="line-74"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html"><span class="hs-identifier">GHC.Core.DataCon</span></a></span><span>
</span><span id="line-75"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.TyCon.html"><span class="hs-identifier">GHC.Core.TyCon</span></a></span><span>
</span><span id="line-76"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html"><span class="hs-identifier">GHC.Utils.Outputable</span></a></span><span>
</span><span id="line-77"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-78"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span>
</span><span id="line-79"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span> </span><span class="hs-comment">-- collect ev vars from pats</span><span>
</span><span id="line-80"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Maybe.html"><span class="hs-identifier">GHC.Data.Maybe</span></a></span><span>
</span><span id="line-81"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.html"><span class="hs-identifier">GHC.Types.Name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier">Name</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-82"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Driver.Session.html"><span class="hs-identifier">GHC.Driver.Session</span></a></span><span>
</span><span id="line-83"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../ghc-boot-9.2.7/src/GHC-LanguageExtensions.html#"><span class="hs-identifier">GHC.LanguageExtensions</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">LangExt</span></span><span>
</span><span id="line-84"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#"><span class="hs-identifier">Data.Data</span></a></span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span class="hs-keyword">data</span><span> </span><span id="ListPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ListPatTc"><span class="hs-identifier hs-var">ListPatTc</span></a></span></span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ListPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ListPatTc"><span class="hs-identifier hs-var">ListPatTc</span></a></span></span><span>
</span><span id="line-89"></span><span>      </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>                             </span><span class="hs-comment">-- The type of the elements</span><span>
</span><span id="line-90"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- For rebindable syntax</span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-93"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-94"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XWildPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XWildPat"><span class="hs-identifier hs-var">XWildPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XVarPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarPat"><span class="hs-identifier hs-var">XVarPat</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- For '~'</span><span>
</span><span id="line-99"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-100"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLazyPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLazyPat"><span class="hs-identifier hs-var">XLazyPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-101"></span><span>
</span><span id="line-102"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- For '@'</span><span>
</span><span id="line-103"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-104"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XAsPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAsPat"><span class="hs-identifier hs-var">XAsPat</span></a></span></span><span>   </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-105"></span><span>
</span><span id="line-106"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XParPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParPat"><span class="hs-identifier hs-var">XParPat</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#AnnParen"><span class="hs-identifier hs-type">AnnParen</span></a></span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- For '!'</span><span>
</span><span id="line-109"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-110"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XBangPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBangPat"><span class="hs-identifier hs-var">XBangPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-111"></span><span>
</span><span id="line-112"></span><span class="hs-comment">-- Note: XListPat cannot be extended when using GHC 8.0.2 as the bootstrap</span><span>
</span><span id="line-113"></span><span class="hs-comment">-- compiler, as it triggers https://gitlab.haskell.org/ghc/ghc/issues/14396 for</span><span>
</span><span id="line-114"></span><span class="hs-comment">-- `SyntaxExpr`</span><span>
</span><span id="line-115"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#AnnList"><span class="hs-identifier hs-type">AnnList</span></a></span><span>
</span><span id="line-116"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-117"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XListPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XListPat"><span class="hs-identifier hs-var">XListPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ListPatTc"><span class="hs-identifier hs-type">ListPatTc</span></a></span><span>
</span><span id="line-118"></span><span>
</span><span id="line-119"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-120"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-121"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XTuplePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTuplePat"><span class="hs-identifier hs-var">XTuplePat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-122"></span><span>
</span><span id="line-123"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-type">EpAnnSumPat</span></a></span><span>
</span><span id="line-124"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-125"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSumPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSumPat"><span class="hs-identifier hs-var">XSumPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-128"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-129"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XConPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConPat"><span class="hs-identifier hs-var">XConPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-130"></span><span>
</span><span id="line-131"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-132"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-133"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XViewPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XViewPat"><span class="hs-identifier hs-var">XViewPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSplicePat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSplicePat"><span class="hs-identifier hs-var">XSplicePat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-136"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XLitPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLitPat"><span class="hs-identifier hs-var">XLitPat</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-137"></span><span>
</span><span id="line-138"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-139"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPat"><span class="hs-identifier hs-var">XNPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span> </span><span class="hs-comment">-- Of the &quot;+&quot;</span><span>
</span><span id="line-143"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-144"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XNPlusKPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNPlusKPat"><span class="hs-identifier hs-var">XNPlusKPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-147"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtField"><span class="hs-identifier hs-type">NoExtField</span></a></span><span>
</span><span id="line-148"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XSigPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSigPat"><span class="hs-identifier hs-var">XSigPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-149"></span><span>
</span><span id="line-150"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtCon"><span class="hs-identifier hs-type">NoExtCon</span></a></span><span>
</span><span id="line-151"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoExtCon"><span class="hs-identifier hs-type">NoExtCon</span></a></span><span>
</span><span id="line-152"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XXPat"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPat"><span class="hs-identifier hs-var">XXPat</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span>
</span><span id="line-153"></span><span>  </span><span class="hs-comment">-- After typechecking, we add one extra constructor: CoPat</span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-type">GhcPs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span><span> </span><span class="hs-comment">-- IdP GhcPs</span><span>
</span><span id="line-156"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-type">GhcRn</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>    </span><span class="hs-comment">-- IdP GhcRn</span><span>
</span><span id="line-157"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ConLikeP"><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-var">ConLikeP</span></a></span></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span>
</span><span id="line-158"></span><span>
</span><span id="line-159"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="XHsRecField"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsRecField"><span class="hs-identifier hs-var">XHsRecField</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#EpAnn"><span class="hs-identifier hs-type">EpAnn</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-160"></span><span>
</span><span id="line-161"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-162"></span><span>
</span><span id="line-163"></span><span class="hs-comment">-- API Annotations types</span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-keyword">data</span><span> </span><span id="EpAnnSumPat"><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="EpAnnSumPat"><span class="annot"><a href="GHC.Hs.Pat.html#EpAnnSumPat"><span class="hs-identifier hs-var">EpAnnSumPat</span></a></span></span><span>
</span><span id="line-166"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="sumPatParens"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [AddEpAnn]
</span><a href="GHC.Hs.Pat.html#sumPatParens"><span class="hs-identifier hs-var hs-var">sumPatParens</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#AddEpAnn"><span class="hs-identifier hs-type">AddEpAnn</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-167"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="sumPatVbarsBefore"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [EpaLocation]
</span><a href="GHC.Hs.Pat.html#sumPatVbarsBefore"><span class="hs-identifier hs-var hs-var">sumPatVbarsBefore</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-168"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="sumPatVbarsAfter"><span class="annot"><span class="annottext">EpAnnSumPat -&gt; [EpaLocation]
</span><a href="GHC.Hs.Pat.html#sumPatVbarsAfter"><span class="hs-identifier hs-var hs-var">sumPatVbarsAfter</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Parser.Annotation.html#EpaLocation"><span class="hs-identifier hs-type">EpaLocation</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-169"></span><span>      </span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681084947"><span id="local-6989586621681084949"><span id="local-6989586621681084951"><span id="local-6989586621681084953"><span id="local-6989586621681084955"><span id="local-6989586621681084957"><span id="local-6989586621681084959"><span id="local-6989586621681084961"><span id="local-6989586621681084963"><span id="local-6989586621681084965"><span id="local-6989586621681084967"><span id="local-6989586621681084969"><span id="local-6989586621681084976"><span id="local-6989586621681084984"><span class="annot"><span class="annottext">Typeable EpAnnSumPat
EpAnnSumPat -&gt; DataType
EpAnnSumPat -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; EpAnnSumPat -&gt; m EpAnnSumPat
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; EpAnnSumPat -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; EpAnnSumPat -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; EpAnnSumPat -&gt; EpAnnSumPat
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c EpAnnSumPat)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c EpAnnSumPat)
dataTypeOf :: EpAnnSumPat -&gt; DataType
$cdataTypeOf :: EpAnnSumPat -&gt; DataType
toConstr :: EpAnnSumPat -&gt; Constr
$ctoConstr :: EpAnnSumPat -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c EpAnnSumPat
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; EpAnnSumPat -&gt; c EpAnnSumPat
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-170"></span><span>
</span><span id="line-171"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span class="hs-comment">-- | This is the extension field for ConPat, added after typechecking</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- It adds quite a few extra fields, to support elaboration of pattern matching.</span><span>
</span><span id="line-175"></span><span class="hs-keyword">data</span><span> </span><span id="ConPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-var">ConPatTc</span></a></span></span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ConPatTc"><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-var">ConPatTc</span></a></span></span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | The universal arg types  1-1 with the universal</span><span>
</span><span id="line-178"></span><span>      </span><span class="hs-comment">-- tyvars of the constructor/pattern synonym</span><span>
</span><span id="line-179"></span><span>      </span><span class="hs-comment">-- Use (conLikeResTy pat_con cpt_arg_tys) to get</span><span>
</span><span id="line-180"></span><span>      </span><span class="hs-comment">-- the type of the pattern</span><span>
</span><span id="line-181"></span><span>      </span><span id="cpt_arg_tys"><span class="annot"><span class="annottext">ConPatTc -&gt; [Type]
</span><a href="GHC.Hs.Pat.html#cpt_arg_tys"><span class="hs-identifier hs-var hs-var">cpt_arg_tys</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-182"></span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Existentially bound type variables</span><span>
</span><span id="line-184"></span><span>      </span><span class="hs-comment">-- in correctly-scoped order e.g. [k:*  x:k]</span><span>
</span><span id="line-185"></span><span>      </span><span id="cpt_tvs"><span class="annot"><span class="annottext">ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var hs-var">cpt_tvs</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Ditto *coercion variables* and *dictionaries*</span><span>
</span><span id="line-188"></span><span>      </span><span class="hs-comment">-- One reason for putting coercion variable here  I think</span><span>
</span><span id="line-189"></span><span>      </span><span class="hs-comment">--      is to ensure their kinds are zonked</span><span>
</span><span id="line-190"></span><span>      </span><span id="cpt_dicts"><span class="annot"><span class="annottext">ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var hs-var">cpt_dicts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-191"></span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Bindings involving those dictionaries</span><span>
</span><span id="line-193"></span><span>      </span><span id="cpt_binds"><span class="annot"><span class="annottext">ConPatTc -&gt; TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var hs-var">cpt_binds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#TcEvBinds"><span class="hs-identifier hs-type">TcEvBinds</span></a></span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- ^ Extra wrapper to pass to the matcher</span><span>
</span><span id="line-196"></span><span>      </span><span class="hs-comment">-- Only relevant for pattern-synonyms;</span><span>
</span><span id="line-197"></span><span>      </span><span class="hs-comment">--   ignored for data cons</span><span>
</span><span id="line-198"></span><span>      </span><span id="cpt_wrap"><span class="annot"><span class="annottext">ConPatTc -&gt; HsWrapper
</span><a href="GHC.Hs.Pat.html#cpt_wrap"><span class="hs-identifier hs-var hs-var">cpt_wrap</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-199"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- | Coercion Pattern (translation only)</span><span>
</span><span id="line-202"></span><span class="hs-comment">--</span><span>
</span><span id="line-203"></span><span class="hs-comment">-- During desugaring a (CoPat co pat) turns into a cast with 'co' on the</span><span>
</span><span id="line-204"></span><span class="hs-comment">-- scrutinee, followed by a match on 'pat'.</span><span>
</span><span id="line-205"></span><span class="hs-keyword">data</span><span> </span><span id="CoPat"><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-var">CoPat</span></a></span></span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="CoPat"><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-var">CoPat</span></a></span></span><span>
</span><span id="line-207"></span><span>    </span><span class="hs-special">{</span><span> </span><span class="hs-comment">-- | Coercion Pattern</span><span>
</span><span id="line-208"></span><span>      </span><span class="hs-comment">-- If co :: t1 ~ t2, p :: t2,</span><span>
</span><span id="line-209"></span><span>      </span><span class="hs-comment">-- then (CoPat co p) :: t1</span><span>
</span><span id="line-210"></span><span>      </span><span id="co_cpt_wrap"><span class="annot"><span class="annottext">CoPat -&gt; HsWrapper
</span><a href="GHC.Hs.Pat.html#co_cpt_wrap"><span class="hs-identifier hs-var hs-var">co_cpt_wrap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-211"></span><span>
</span><span id="line-212"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Why not LPat?  Ans: existing locn will do</span><span>
</span><span id="line-213"></span><span>      </span><span id="co_pat_inner"><span class="annot"><span class="annottext">CoPat -&gt; Pat GhcTc
</span><a href="GHC.Hs.Pat.html#co_pat_inner"><span class="hs-identifier hs-var hs-var">co_pat_inner</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- | Type of whole pattern, t1</span><span>
</span><span id="line-216"></span><span>      </span><span id="co_pat_ty"><span class="annot"><span class="annottext">CoPat -&gt; Type
</span><a href="GHC.Hs.Pat.html#co_pat_ty"><span class="hs-identifier hs-var hs-var">co_pat_ty</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>
</span><span id="line-217"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-218"></span><span>
</span><span id="line-219"></span><span id="local-6989586621681085283"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier hs-type">hsRecFieldId</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085283"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span></span><span>
</span><span id="line-220"></span><span id="hsRecFieldId"><span class="annot"><span class="annottext">hsRecFieldId :: forall arg. HsRecField GhcTc arg -&gt; Located TyVar
</span><a href="GHC.Hs.Pat.html#hsRecFieldId"><span class="hs-identifier hs-var hs-var">hsRecFieldId</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall pass arg. HsRecField pass arg -&gt; Located (XCFieldOcc pass)
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldSel"><span class="hs-identifier hs-var">hsRecFieldSel</span></a></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span id="local-6989586621681085277"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldRdr"><span class="hs-identifier hs-type">hsRecUpdFieldRdr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecUpdField"><span class="hs-identifier hs-type">HsRecUpdField</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085277"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Name.Reader.html#RdrName"><span class="hs-identifier hs-type">RdrName</span></a></span></span><span>
</span><span id="line-223"></span><span id="hsRecUpdFieldRdr"><span class="annot"><span class="annottext">hsRecUpdFieldRdr :: forall (p :: Pass). HsRecUpdField (GhcPass p) -&gt; Located RdrName
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldRdr"><span class="hs-identifier hs-var hs-var">hsRecUpdFieldRdr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). AmbiguousFieldOcc (GhcPass p) -&gt; RdrName
</span><a href="GHC.Hs.Type.html#rdrNameAmbiguousFieldOcc"><span class="hs-identifier hs-var">rdrNameAmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall id arg. HsRecField' id arg -&gt; Located id
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldLbl"><span class="hs-identifier hs-var">hsRecFieldLbl</span></a></span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span id="local-6989586621681085257"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldId"><span class="hs-identifier hs-type">hsRecUpdFieldId</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier hs-type">HsRecField'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-type">AmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681085257"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span></span><span>
</span><span id="line-226"></span><span id="hsRecUpdFieldId"><span class="annot"><span class="annottext">hsRecUpdFieldId :: forall arg.
HsRecField' (AmbiguousFieldOcc GhcTc) arg -&gt; Located TyVar
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldId"><span class="hs-identifier hs-var hs-var">hsRecUpdFieldId</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">forall pass. FieldOcc pass -&gt; XCFieldOcc pass
</span><a href="Language.Haskell.Syntax.Type.html#extFieldOcc"><span class="hs-identifier hs-var">extFieldOcc</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall arg.
HsRecField' (AmbiguousFieldOcc GhcTc) arg -&gt; LFieldOcc GhcTc
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier hs-var">hsRecUpdFieldOcc</span></a></span><span>
</span><span id="line-227"></span><span>
</span><span id="line-228"></span><span id="local-6989586621681085253"><span class="annot"><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier hs-type">hsRecUpdFieldOcc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier hs-type">HsRecField'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-type">AmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681085253"><span class="hs-identifier hs-type">arg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LFieldOcc"><span class="hs-identifier hs-type">LFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span></span><span>
</span><span id="line-229"></span><span id="hsRecUpdFieldOcc"><span class="annot"><span class="annottext">hsRecUpdFieldOcc :: forall arg.
HsRecField' (AmbiguousFieldOcc GhcTc) arg -&gt; LFieldOcc GhcTc
</span><a href="GHC.Hs.Pat.html#hsRecUpdFieldOcc"><span class="hs-identifier hs-var hs-var">hsRecUpdFieldOcc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#fmap"><span class="hs-identifier hs-var">fmap</span></a></span><span> </span><span class="annot"><span class="annottext">AmbiguousFieldOcc GhcTc -&gt; FieldOcc GhcTc
</span><a href="GHC.Hs.Type.html#unambiguousFieldOcc"><span class="hs-identifier hs-var">unambiguousFieldOcc</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall id arg. HsRecField' id arg -&gt; Located id
</span><a href="Language.Haskell.Syntax.Pat.html#hsRecFieldLbl"><span class="hs-identifier hs-var">hsRecFieldLbl</span></a></span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span>
</span><span id="line-232"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
*              Printing patterns
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-239"></span><span>
</span><span id="line-240"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681085245"><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085245"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085245"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-241"></span><span>    </span><span id="local-6989586621681084917"><span class="annot"><span class="annottext">ppr :: Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span id="local-6989586621681085244"><span class="annot"><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier hs-type">pprLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085244"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085244"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-244"></span><span id="pprLPat"><span class="annot"><span class="annottext">pprLPat :: forall (p :: Pass). OutputableBndrId p =&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprLPat"><span class="hs-identifier hs-var hs-var">pprLPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084911"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084911"><span class="hs-identifier hs-var">e</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084911"><span class="hs-identifier hs-var">e</span></a></span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span class="hs-comment">-- | Print with type info if -dppr-debug is on</span><span>
</span><span id="line-247"></span><span id="local-6989586621681085240"><span class="annot"><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-type">pprPatBndr</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085240"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681085240"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-248"></span><span id="pprPatBndr"><span class="annot"><span class="annottext">pprPatBndr :: forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var hs-var">pprPatBndr</span></a></span></span><span> </span><span id="local-6989586621681084906"><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621681084906"><span class="hs-identifier hs-var">var</span></a></span></span><span>
</span><span id="line-249"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#getPprDebug"><span class="hs-identifier hs-var">getPprDebug</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-250"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. OutputableBndr a =&gt; BindingSite -&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprBndr"><span class="hs-identifier hs-var">pprBndr</span></a></span><span> </span><span class="annot"><span class="annottext">BindingSite
</span><a href="GHC.Utils.Outputable.html#LambdaBind"><span class="hs-identifier hs-var">LambdaBind</span></a></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621681084906"><span class="hs-identifier hs-var">var</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Could pass the site to pprPat</span><span>
</span><span id="line-251"></span><span>                                              </span><span class="hs-comment">-- but is it worth it?</span><span>
</span><span id="line-252"></span><span>      </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">name
</span><a href="#local-6989586621681084906"><span class="hs-identifier hs-var">var</span></a></span><span>
</span><span id="line-253"></span><span>
</span><span id="line-254"></span><span id="local-6989586621681085232"><span class="annot"><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-type">pprParendLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085232"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-255"></span><span>              </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085232"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-256"></span><span id="pprParendLPat"><span class="annot"><span class="annottext">pprParendLPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var hs-var">pprParendLPat</span></a></span></span><span> </span><span id="local-6989586621681084898"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084898"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var">pprParendPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084898"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-257"></span><span>
</span><span id="line-258"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-type">pprParendPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681085229"><span class="annot"><a href="#local-6989586621681085229"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085229"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-259"></span><span>             </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span>
</span><span id="line-260"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085229"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-261"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-262"></span><span id="pprParendPat"><span class="annot"><span class="annottext">pprParendPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var hs-var">pprParendPat</span></a></span></span><span> </span><span id="local-6989586621681084889"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084889"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621681084888"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084888"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (SDocContext -&gt; a) -&gt; (a -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sdocOption"><span class="hs-identifier hs-var">sdocOption</span></a></span><span> </span><span class="annot"><span class="annottext">SDocContext -&gt; Bool
</span><a href="GHC.Utils.Outputable.html#sdocPrintTypecheckerElaboration"><span class="hs-identifier hs-var">sdocPrintTypecheckerElaboration</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span> </span><span id="local-6989586621681084885"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084885"><span class="hs-identifier hs-var">print_tc_elab</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-263"></span><span>    </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084884"><span class="hs-identifier hs-var">need_parens</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084885"><span class="hs-identifier hs-var">print_tc_elab</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084888"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-264"></span><span>    </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084888"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-265"></span><span>    </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084888"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-266"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-267"></span><span>    </span><span id="local-6989586621681084884"><span class="annot"><span class="annottext">need_parens :: Bool -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084884"><span class="hs-identifier hs-var hs-var">need_parens</span></a></span></span><span> </span><span id="local-6989586621681084883"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084883"><span class="hs-identifier hs-var">print_tc_elab</span></a></span></span><span> </span><span id="local-6989586621681084882"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084882"><span class="hs-identifier hs-var">pat</span></a></span></span><span>
</span><span id="line-268"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681085229"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-269"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681084877"><span class="annot"><span class="annottext">XXPat GhcTc
</span><a href="#local-6989586621681084877"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084882"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-270"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">XXPat GhcTc
</span><a href="#local-6989586621681084877"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-271"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084883"><span class="hs-identifier hs-var">print_tc_elab</span></a></span><span>
</span><span id="line-272"></span><span>
</span><span id="line-273"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>
</span><span id="line-274"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var">patNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084889"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084882"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-275"></span><span>      </span><span class="hs-comment">-- For a CoPat we need parens if we are going to show it, which</span><span>
</span><span id="line-276"></span><span>      </span><span class="hs-comment">-- we do if -fprint-typechecker-elaboration is on (c.f. pprHsWrapper)</span><span>
</span><span id="line-277"></span><span>      </span><span class="hs-comment">-- But otherwise the CoPat is discarded, so it</span><span>
</span><span id="line-278"></span><span>      </span><span class="hs-comment">-- is the pattern inside that matters.  Sigh.</span><span>
</span><span id="line-279"></span><span>
</span><span id="line-280"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-type">pprPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681084876"><span class="annot"><a href="#local-6989586621681084876"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084876"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084876"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-281"></span><span id="pprPat"><span class="annot"><span class="annottext">pprPat :: forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var hs-var">pprPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="annot"><span class="annottext">XVarPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084828"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084828"><span class="hs-identifier hs-var">lvar</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var">pprPatBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084828"><span class="hs-identifier hs-var">lvar</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-282"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="annot"><span class="annottext">XWildPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'_'</span></span><span>
</span><span id="line-283"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084824"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084824"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'~'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084824"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-284"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084820"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084820"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'!'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084820"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-285"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084818"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084818"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621681084817"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084817"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084818"><span class="hs-identifier hs-var">name</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span class="hs-special">,</span><span>
</span><span id="line-286"></span><span>                                        </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084817"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-287"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084814"><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><a href="#local-6989586621681084814"><span class="hs-identifier hs-var">expr</span></a></span></span><span> </span><span id="local-6989586621681084813"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084813"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
LHsExpr (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprLExpr"><span class="hs-identifier hs-var">pprLExpr</span></a></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><a href="#local-6989586621681084814"><span class="hs-identifier hs-var">expr</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot; -&gt; &quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084813"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-288"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084810"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084810"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#parens"><span class="hs-identifier hs-var">parens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084810"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084808"><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621681084808"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621681084808"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-290"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084806"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084806"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (SyntaxExpr (GhcPass p))
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>  </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084806"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-291"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084805"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084805"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'-'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084805"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-292"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPlusKPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084803"><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084803"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621681084802"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084802"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsOverLit (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681084801"><span class="hs-identifier hs-var">ppr_n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'+'</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084802"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-293"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681084801"><span class="annot"><span class="annottext">ppr_n :: SDoc
</span><a href="#local-6989586621681084801"><span class="hs-identifier hs-var hs-var">ppr_n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681084876"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-294"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084803"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-295"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084803"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-296"></span><span>                  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><a href="#local-6989586621681084803"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-297"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="annot"><span class="annottext">XSplicePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084788"><span class="annot"><span class="annottext">HsSplice (GhcPass p)
</span><a href="#local-6989586621681084788"><span class="hs-identifier hs-var">splice</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
HsSplice (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Expr.html#pprSplice"><span class="hs-identifier hs-var">pprSplice</span></a></span><span> </span><span class="annot"><span class="annottext">HsSplice (GhcPass p)
</span><a href="#local-6989586621681084788"><span class="hs-identifier hs-var">splice</span></a></span><span>
</span><span id="line-298"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084786"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084786"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621681084785"><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><a href="#local-6989586621681084785"><span class="hs-identifier hs-var">ty</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084786"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="GHC.Utils.Outputable.html#dcolon"><span class="hs-identifier hs-var">dcolon</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><a href="#local-6989586621681084785"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-299"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084781"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084781"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#brackets"><span class="hs-identifier hs-var">brackets</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#interpp%27SP"><span class="hs-identifier hs-var">interpp'SP</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084781"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-300"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084777"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084777"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span id="local-6989586621681084776"><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621681084776"><span class="hs-identifier hs-var">bx</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span>    </span><span class="hs-comment">-- Special-case unary boxed tuples so that they are pretty-printed as</span><span>
</span><span id="line-302"></span><span>    </span><span class="hs-comment">-- `Solo x`, not `(x)`</span><span>
</span><span id="line-303"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">[</span><span id="local-6989586621681084775"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084775"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084777"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="GHC.Types.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621681084776"><span class="hs-identifier hs-var">bx</span></a></span><span>
</span><span id="line-305"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Boxity -&gt; Int -&gt; String
</span><a href="GHC.Builtin.Types.html#mkTupleStr"><span class="hs-identifier hs-var">mkTupleStr</span></a></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="GHC.Types.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">1</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084775"><span class="hs-identifier hs-var">pat</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-306"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TupleSort -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Types.Basic.html#tupleParens"><span class="hs-identifier hs-var">tupleParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Boxity -&gt; TupleSort
</span><a href="GHC.Types.Basic.html#boxityTupleSort"><span class="hs-identifier hs-var">boxityTupleSort</span></a></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="#local-6989586621681084776"><span class="hs-identifier hs-var">bx</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (a -&gt; SDoc) -&gt; [a] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprWithCommas"><span class="hs-identifier hs-var">pprWithCommas</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084777"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSumPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084768"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084768"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span id="local-6989586621681084767"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681084767"><span class="hs-identifier hs-var">alt</span></a></span></span><span> </span><span id="local-6989586621681084766"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681084766"><span class="hs-identifier hs-var">arity</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Types.Basic.html#sumParens"><span class="hs-identifier hs-var">sumParens</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. (a -&gt; SDoc) -&gt; a -&gt; Int -&gt; Int -&gt; SDoc
</span><a href="GHC.Types.Basic.html#pprAlternative"><span class="hs-identifier hs-var">pprAlternative</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084768"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681084767"><span class="hs-identifier hs-var">alt</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681084766"><span class="hs-identifier hs-var">arity</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-309"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084761"><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084761"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-310"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084759"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084759"><span class="hs-identifier hs-var">details</span></a></span></span><span>
</span><span id="line-311"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084757"><span class="annot"><span class="annottext">XConPat (GhcPass p)
</span><a href="#local-6989586621681084757"><span class="hs-identifier hs-var">ext</span></a></span></span><span>
</span><span id="line-312"></span><span>               </span><span class="hs-special">}</span><span>
</span><span id="line-313"></span><span>       </span><span class="hs-special">)</span><span>
</span><span id="line-314"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681084876"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-315"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084761"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084759"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-316"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084761"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084759"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-317"></span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. (SDocContext -&gt; a) -&gt; (a -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sdocOption"><span class="hs-identifier hs-var">sdocOption</span></a></span><span> </span><span class="annot"><span class="annottext">SDocContext -&gt; Bool
</span><a href="GHC.Utils.Outputable.html#sdocPrintTypecheckerElaboration"><span class="hs-identifier hs-var">sdocPrintTypecheckerElaboration</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-318"></span><span>        </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084761"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084759"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-319"></span><span>        </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-320"></span><span>          </span><span class="hs-comment">-- Tiresome; in 'GHC.Tc.Gen.Bind.tcRhs' we print out a typechecked Pat in an</span><span>
</span><span id="line-321"></span><span>          </span><span class="hs-comment">-- error message, and we want to make sure it prints nicely</span><span>
</span><span id="line-322"></span><span>          </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084761"><span class="hs-identifier hs-var">con</span></a></span><span>
</span><span id="line-323"></span><span>            </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#braces"><span class="hs-identifier hs-var">braces</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hsep"><span class="hs-identifier hs-var">hsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPatBndr"><span class="hs-identifier hs-var">pprPatBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681084714"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. [a] -&gt; [a] -&gt; [a]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%2B%2B"><span class="hs-operator hs-var">++</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681084713"><span class="hs-identifier hs-var">dicts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-324"></span><span>                           </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">TcEvBinds
</span><a href="#local-6989586621681084712"><span class="hs-identifier hs-var">binds</span></a></span><span> </span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-325"></span><span>            </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084759"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-326"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_tvs :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var">cpt_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084714"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681084714"><span class="hs-identifier hs-var">tvs</span></a></span></span><span>
</span><span id="line-327"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084713"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681084713"><span class="hs-identifier hs-var">dicts</span></a></span></span><span>
</span><span id="line-328"></span><span>                       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_binds :: ConPatTc -&gt; TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var">cpt_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084712"><span class="annot"><span class="annottext">TcEvBinds
</span><a href="#local-6989586621681084712"><span class="hs-identifier hs-var">binds</span></a></span></span><span>
</span><span id="line-329"></span><span>                       </span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XConPat (GhcPass p)
</span><a href="#local-6989586621681084757"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-330"></span><span>
</span><span id="line-331"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681084711"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681084711"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681084876"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 811
</span><span>  </span><span class="hs-identifier">GhcPs</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">noExtCon</span><span> </span><span class="hs-identifier">ext</span><span>
</span><span id="line-334"></span><span>  </span><span class="hs-identifier">GhcRn</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">noExtCon</span><span> </span><span class="hs-identifier">ext</span><span class="hs-cpp">
#endif
</span><span>  </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">HsWrapper -&gt; (Bool -&gt; SDoc) -&gt; SDoc
</span><a href="GHC.Tc.Types.Evidence.html#pprHsWrapper"><span class="hs-identifier hs-var">pprHsWrapper</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><a href="#local-6989586621681084705"><span class="hs-identifier hs-var">co</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621681084704"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084704"><span class="hs-identifier hs-var">parens</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-337"></span><span>      </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084704"><span class="hs-identifier hs-var">parens</span></a></span><span>
</span><span id="line-338"></span><span>      </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendPat"><span class="hs-identifier hs-var">pprParendPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084703"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-339"></span><span>      </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). OutputableBndrId p =&gt; Pat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprPat"><span class="hs-identifier hs-var">pprPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084703"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-340"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span id="local-6989586621681084705"><span class="annot"><span class="annottext">HsWrapper
</span><a href="#local-6989586621681084705"><span class="hs-identifier hs-var">co</span></a></span></span><span> </span><span id="local-6989586621681084703"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084703"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681084711"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span id="local-6989586621681085156"><span id="local-6989586621681085157"><span class="annot"><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-type">pprUserCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085157"><span class="hs-identifier hs-type">con</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085156"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-343"></span><span>                     </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-type">Anno</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#IdGhcP"><span class="hs-identifier hs-type">IdGhcP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085156"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-344"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="#local-6989586621681085157"><span class="hs-identifier hs-type">con</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085156"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span></span><span>
</span><span id="line-345"></span><span id="pprUserCon"><span class="annot"><span class="annottext">pprUserCon :: forall con (p :: Pass).
(OutputableBndr con, OutputableBndrId p,
 Outputable (Anno (IdGhcP p))) =&gt;
con -&gt; HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var hs-var">pprUserCon</span></a></span></span><span> </span><span id="local-6989586621681084690"><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681084690"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621681084688"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084688"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621681084687"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084687"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084688"><span class="hs-identifier hs-var">p1</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprInfixOcc"><span class="hs-identifier hs-var">pprInfixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681084690"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084687"><span class="hs-identifier hs-var">p2</span></a></span><span>
</span><span id="line-346"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprUserCon"><span class="hs-identifier hs-var">pprUserCon</span></a></span><span> </span><span id="local-6989586621681084685"><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681084685"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621681084684"><span class="annot"><span class="annottext">HsConDetails
  (HsPatSigType (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
</span><a href="#local-6989586621681084684"><span class="hs-identifier hs-var">details</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall name. OutputableBndr name =&gt; name -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var">pprPrefixOcc</span></a></span><span> </span><span class="annot"><span class="annottext">con
</span><a href="#local-6989586621681084685"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConDetails
  (HsPatSigType (NoGhcTc (GhcPass p)))
  (LPat (GhcPass p))
  (HsRecFields (GhcPass p) (LPat (GhcPass p)))
</span><a href="#local-6989586621681084684"><span class="hs-identifier hs-var">details</span></a></span><span>
</span><span id="line-347"></span><span>
</span><span id="line-348"></span><span id="local-6989586621681085151"><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-type">pprConArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085151"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-349"></span><span>                     </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-type">Anno</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#IdGhcP"><span class="hs-identifier hs-type">IdGhcP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085151"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-350"></span><span>           </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsConPatDetails"><span class="hs-identifier hs-type">HsConPatDetails</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085151"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-351"></span><span id="pprConArgs"><span class="annot"><span class="annottext">pprConArgs :: forall (p :: Pass).
(OutputableBndrId p, Outputable (Anno (IdGhcP p))) =&gt;
HsConPatDetails (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var hs-var">pprConArgs</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span id="local-6989586621681084654"><span class="annot"><span class="annottext">[HsPatSigType (NoGhcTc (GhcPass p))]
</span><a href="#local-6989586621681084654"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621681084653"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084653"><span class="hs-identifier hs-var">pats</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; [a] -&gt; SDoc
</span><a href="#local-6989586621681084651"><span class="hs-identifier hs-var">pprTyArgs</span></a></span><span> </span><span class="annot"><span class="annottext">[HsPatSigType (NoGhcTc (GhcPass p))]
</span><a href="#local-6989586621681084654"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084653"><span class="hs-identifier hs-var">pats</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-352"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621681084651"><span class="annot"><span class="annottext">pprTyArgs :: [a] -&gt; SDoc
</span><a href="#local-6989586621681084651"><span class="hs-identifier hs-var hs-var">pprTyArgs</span></a></span></span><span> </span><span id="local-6989586621681084648"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681084648"><span class="hs-identifier hs-var">tyargs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#fsep"><span class="hs-identifier hs-var">fsep</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621681084647"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681084647"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Char -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#char"><span class="hs-identifier hs-var">char</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'@'</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%3E"><span class="hs-operator hs-var">&lt;&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621681084647"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681084648"><span class="hs-identifier hs-var">tyargs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-353"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span id="local-6989586621681084646"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084646"><span class="hs-identifier hs-var">p1</span></a></span></span><span> </span><span id="local-6989586621681084645"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084645"><span class="hs-identifier hs-var">p2</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084646"><span class="hs-identifier hs-var">p1</span></a></span><span>
</span><span id="line-354"></span><span>                                     </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; SDoc
</span><a href="GHC.Hs.Pat.html#pprParendLPat"><span class="hs-identifier hs-var">pprParendLPat</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084645"><span class="hs-identifier hs-var">p2</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-355"></span><span class="annot"><a href="GHC.Hs.Pat.html#pprConArgs"><span class="hs-identifier hs-var">pprConArgs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span id="local-6989586621681084643"><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (LPat (GhcPass p))
</span><a href="#local-6989586621681084643"><span class="hs-identifier hs-var">rpats</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">HsRecFields (GhcPass p) (LPat (GhcPass p))
</span><a href="#local-6989586621681084643"><span class="hs-identifier hs-var">rpats</span></a></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
*              Building patterns
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-364"></span><span>
</span><span id="line-365"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-type">mkPrefixConPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#DataCon"><span class="hs-identifier hs-type">DataCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-366"></span><span>                  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-367"></span><span class="hs-comment">-- Make a vanilla Prefix constructor pattern</span><span>
</span><span id="line-368"></span><span id="mkPrefixConPat"><span class="annot"><span class="annottext">mkPrefixConPat :: DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var hs-var">mkPrefixConPat</span></a></span></span><span> </span><span id="local-6989586621681084642"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681084642"><span class="hs-identifier hs-var">dc</span></a></span></span><span> </span><span id="local-6989586621681084641"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681084641"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span id="local-6989586621681084640"><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681084640"><span class="hs-identifier hs-var">tys</span></a></span></span><span>
</span><span id="line-369"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a an. a -&gt; LocatedAn an a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: XRec GhcTc (ConLikeP GhcTc)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a an. a -&gt; LocatedAn an a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; ConLike
</span><a href="GHC.Core.ConLike.html#RealDataCon"><span class="hs-identifier hs-var">RealDataCon</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681084642"><span class="hs-identifier hs-var">dc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-370"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: HsConPatDetails GhcTc
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall tyarg arg rec.
[tyarg] -&gt; [arg] -&gt; HsConDetails tyarg arg rec
</span><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-var">PrefixCon</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681084641"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-371"></span><span>                    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: XConPat GhcTc
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-372"></span><span>                      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_tvs :: [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_tvs"><span class="hs-identifier hs-var">cpt_tvs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-373"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-374"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_binds :: TcEvBinds
</span><a href="GHC.Hs.Pat.html#cpt_binds"><span class="hs-identifier hs-var">cpt_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TcEvBinds
</span><a href="GHC.Tc.Types.Evidence.html#emptyTcEvBinds"><span class="hs-identifier hs-var">emptyTcEvBinds</span></a></span><span>
</span><span id="line-375"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_arg_tys :: [Type]
</span><a href="GHC.Hs.Pat.html#cpt_arg_tys"><span class="hs-identifier hs-var">cpt_arg_tys</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Type]
</span><a href="#local-6989586621681084640"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-376"></span><span>                      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">cpt_wrap :: HsWrapper
</span><a href="GHC.Hs.Pat.html#cpt_wrap"><span class="hs-identifier hs-var">cpt_wrap</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><a href="GHC.Tc.Types.Evidence.html#idHsWrapper"><span class="hs-identifier hs-var">idHsWrapper</span></a></span><span>
</span><span id="line-377"></span><span>                      </span><span class="hs-special">}</span><span>
</span><span id="line-378"></span><span>                    </span><span class="hs-special">}</span><span>
</span><span id="line-379"></span><span>
</span><span id="line-380"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier hs-type">mkNilPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-381"></span><span id="mkNilPat"><span class="annot"><span class="annottext">mkNilPat :: Type -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkNilPat"><span class="hs-identifier hs-var hs-var">mkNilPat</span></a></span></span><span> </span><span id="local-6989586621681084635"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681084635"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var">mkPrefixConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="GHC.Builtin.Types.html#nilDataCon"><span class="hs-identifier hs-var">nilDataCon</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621681084635"><span class="hs-identifier hs-var">ty</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-382"></span><span>
</span><span id="line-383"></span><span class="annot"><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier hs-type">mkCharLitPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span>
</span><span id="line-384"></span><span id="mkCharLitPat"><span class="annot"><span class="annottext">mkCharLitPat :: SourceText -&gt; Char -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkCharLitPat"><span class="hs-identifier hs-var hs-var">mkCharLitPat</span></a></span></span><span> </span><span id="local-6989586621681084633"><span class="annot"><span class="annottext">SourceText
</span><a href="#local-6989586621681084633"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span id="local-6989586621681084632"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621681084632"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataCon -&gt; [LPat GhcTc] -&gt; [Type] -&gt; LPat GhcTc
</span><a href="GHC.Hs.Pat.html#mkPrefixConPat"><span class="hs-identifier hs-var">mkPrefixConPat</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="GHC.Builtin.Types.html#charDataCon"><span class="hs-identifier hs-var">charDataCon</span></a></span><span>
</span><span id="line-385"></span><span>                          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall a an. a -&gt; LocatedAn an a
</span><a href="GHC.Parser.Annotation.html#noLocA"><span class="hs-identifier hs-var">noLocA</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. XLitPat p -&gt; HsLit p -&gt; Pat p
</span><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-var">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">NoExtField
</span><a href="Language.Haskell.Syntax.Extension.html#noExtField"><span class="hs-identifier hs-var">noExtField</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall x. XHsCharPrim x -&gt; Char -&gt; HsLit x
</span><a href="Language.Haskell.Syntax.Lit.html#HsCharPrim"><span class="hs-identifier hs-var">HsCharPrim</span></a></span><span> </span><span class="annot"><span class="annottext">SourceText
</span><a href="#local-6989586621681084633"><span class="hs-identifier hs-var">src</span></a></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621681084632"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-386"></span><span>
</span><span id="line-387"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
* Predicates for checking things about pattern-lists in EquationInfo   *
*                                                                      *
************************************************************************

\subsection[Pat-list-predicates]{Look for interesting things in patterns}

Unlike in the Wadler chapter, where patterns are either ``variables''
or ``constructors,'' here we distinguish between:
\begin{description}
\item[unfailable:]
Patterns that cannot fail to match: variables, wildcards, and lazy
patterns.

These are the irrefutable patterns; the two other categories
are refutable patterns.

\item[constructor:]
A non-literal constructor pattern (see next category).

\item[literal patterns:]
At least the numeric ones may be overloaded.
\end{description}

A pattern is in {\em exactly one} of the above three categories; `as'
patterns are treated specially, of course.

The 1.3 report defines what ``irrefutable'' and ``failure-free'' patterns are.
-}</span><span>
</span><span id="line-418"></span><span>
</span><span id="line-419"></span><span id="local-6989586621681085126"><span class="annot"><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-type">isBangedLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085126"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-420"></span><span id="isBangedLPat"><span class="annot"><span class="annottext">isBangedLPat :: forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-var hs-var">isBangedLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span id="local-6989586621681085124"><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-type">isBangedPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085124"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-423"></span><span id="isBangedPat"><span class="annot"><span class="annottext">isBangedPat :: forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var hs-var">isBangedPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084627"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084627"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isBangedLPat"><span class="hs-identifier hs-var">isBangedLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084627"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-424"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-425"></span><span class="annot"><a href="GHC.Hs.Pat.html#isBangedPat"><span class="hs-identifier hs-var">isBangedPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-426"></span><span>
</span><span id="line-427"></span><span id="local-6989586621681085122"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-type">looksLazyPatBind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBind"><span class="hs-identifier hs-type">HsBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085122"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-428"></span><span class="hs-comment">-- Returns True of anything *except*</span><span>
</span><span id="line-429"></span><span class="hs-comment">--     a StrictHsBind (as above) or</span><span>
</span><span id="line-430"></span><span class="hs-comment">--     a VarPat</span><span>
</span><span id="line-431"></span><span class="hs-comment">-- In particular, returns True of a pattern binding with a compound pattern, like (I# x)</span><span>
</span><span id="line-432"></span><span class="hs-comment">-- Looks through AbsBinds</span><span>
</span><span id="line-433"></span><span id="looksLazyPatBind"><span class="annot"><span class="annottext">looksLazyPatBind :: forall (p :: Pass). HsBind (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var hs-var">looksLazyPatBind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatBind"><span class="hs-identifier hs-type">PatBind</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_lhs :: forall idL idR. HsBindLR idL idR -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Binds.html#pat_lhs"><span class="hs-identifier hs-var">pat_lhs</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084624"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084624"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084624"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-435"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#AbsBinds"><span class="hs-identifier hs-type">AbsBinds</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">abs_binds :: forall idL idR. HsBindLR idL idR -&gt; LHsBinds idL
</span><a href="Language.Haskell.Syntax.Binds.html#abs_binds"><span class="hs-identifier hs-var">abs_binds</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084620"><span class="annot"><span class="annottext">LHsBinds (GhcPass p)
</span><a href="#local-6989586621681084620"><span class="hs-identifier hs-var">binds</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-436"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. (a -&gt; Bool) -&gt; Bag a -&gt; Bool
</span><a href="GHC.Data.Bag.html#anyBag"><span class="hs-identifier hs-var">anyBag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (p :: Pass). HsBind (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">LHsBinds (GhcPass p)
</span><a href="#local-6989586621681084620"><span class="hs-identifier hs-var">binds</span></a></span><span>
</span><span id="line-437"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPatBind"><span class="hs-identifier hs-var">looksLazyPatBind</span></a></span><span> </span><span class="annot"><span class="annottext">HsBindLR (GhcPass p) (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-439"></span><span>
</span><span id="line-440"></span><span id="local-6989586621681084618"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-type">looksLazyLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084618"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-441"></span><span id="looksLazyLPat"><span class="annot"><span class="annottext">looksLazyLPat :: forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var hs-var">looksLazyLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-442"></span><span>
</span><span id="line-443"></span><span id="local-6989586621681084616"><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-type">looksLazyPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084616"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-444"></span><span id="looksLazyPat"><span class="annot"><span class="annottext">looksLazyPat :: forall (p :: Pass). Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var hs-var">looksLazyPat</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084615"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084615"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084615"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-445"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084614"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084614"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#looksLazyLPat"><span class="hs-identifier hs-var">looksLazyLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084614"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-446"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-447"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-448"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-449"></span><span class="annot"><a href="GHC.Hs.Pat.html#looksLazyPat"><span class="hs-identifier hs-var">looksLazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-450"></span><span>
</span><span id="line-451"></span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-type">isIrrefutableHsPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681085109"><span class="annot"><a href="#local-6989586621681085109"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085109"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-452"></span><span>                   </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Driver.Session.html#DynFlags"><span class="hs-identifier hs-type">DynFlags</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085109"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-453"></span><span class="hs-comment">-- (isIrrefutableHsPat p) is true if matching against p cannot fail,</span><span>
</span><span id="line-454"></span><span class="hs-comment">-- in the sense of falling through to the next pattern.</span><span>
</span><span id="line-455"></span><span class="hs-comment">--      (NB: this is not quite the same as the (silly) defn</span><span>
</span><span id="line-456"></span><span class="hs-comment">--      in 3.17.2 of the Haskell 98 report.)</span><span>
</span><span id="line-457"></span><span class="hs-comment">--</span><span>
</span><span id="line-458"></span><span class="hs-comment">-- WARNING: isIrrefutableHsPat returns False if it's in doubt.</span><span>
</span><span id="line-459"></span><span class="hs-comment">-- Specifically on a ConPatIn, which is what it sees for a</span><span>
</span><span id="line-460"></span><span class="hs-comment">-- (LPat Name) in the renamer, it doesn't know the size of the</span><span>
</span><span id="line-461"></span><span class="hs-comment">-- constructor family, so it returns False.  Result: only</span><span>
</span><span id="line-462"></span><span class="hs-comment">-- tuple patterns are considered irrefutable at the renamer stage.</span><span>
</span><span id="line-463"></span><span class="hs-comment">--</span><span>
</span><span id="line-464"></span><span class="hs-comment">-- But if it returns True, the pattern is definitely irrefutable</span><span>
</span><span id="line-465"></span><span id="isIrrefutableHsPat"><span class="annot"><span class="annottext">isIrrefutableHsPat :: forall (p :: Pass).
OutputableBndrId p =&gt;
DynFlags -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat"><span class="hs-identifier hs-var hs-var">isIrrefutableHsPat</span></a></span></span><span> </span><span id="local-6989586621681084611"><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621681084611"><span class="hs-identifier hs-var">dflags</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-466"></span><span>    </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-var">isIrrefutableHsPat'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Extension -&gt; DynFlags -&gt; Bool
</span><a href="GHC.Driver.Session.html#xopt"><span class="hs-identifier hs-var">xopt</span></a></span><span> </span><span class="annot"><span class="annottext">Extension
</span><span class="hs-identifier hs-var">LangExt.Strict</span></span><span> </span><span class="annot"><span class="annottext">DynFlags
</span><a href="#local-6989586621681084611"><span class="hs-identifier hs-var">dflags</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-467"></span><span>
</span><span id="line-468"></span><span class="hs-comment">{-
Note [-XStrict and irrefutability]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
When -XStrict is enabled the rules for irrefutability are slightly modified.
Specifically, the pattern in a program like

    do ~(Just hi) &lt;- expr

cannot be considered irrefutable. The ~ here merely disables the bang that
-XStrict would usually apply, rendering the program equivalent to the following
without -XStrict

    do Just hi &lt;- expr

To achieve make this pattern irrefutable with -XStrict the user would rather
need to write

    do ~(~(Just hi)) &lt;- expr

Failing to account for this resulted in #19027. To fix this isIrrefutableHsPat
takes care to check for two the irrefutability of the inner pattern when it
encounters a LazyPat and -XStrict is enabled.

See also Note [decideBangHood] in GHC.HsToCore.Utils.
-}</span><span>
</span><span id="line-493"></span><span>
</span><span id="line-494"></span><span class="annot"><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-type">isIrrefutableHsPat'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681085106"><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#OutputableBndrId"><span class="hs-identifier hs-type">OutputableBndrId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-495"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-comment">-- ^ Are we in a @-XStrict@ context?</span><span>
</span><span id="line-496"></span><span>                            </span><span class="hs-comment">-- See Note [-XStrict and irrefutability]</span><span>
</span><span id="line-497"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-498"></span><span id="isIrrefutableHsPat%27"><span class="annot"><span class="annottext">isIrrefutableHsPat' :: forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-var hs-var">isIrrefutableHsPat'</span></a></span></span><span> </span><span id="local-6989586621681084600"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084600"><span class="hs-identifier hs-var">is_strict</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span>
</span><span id="line-499"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-500"></span><span>    </span><span class="annot"><a href="#local-6989586621681084599"><span class="hs-identifier hs-type">goL</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-501"></span><span>    </span><span id="local-6989586621681084599"><span class="annot"><span class="annottext">goL :: LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var hs-var">goL</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-502"></span><span>
</span><span id="line-503"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-504"></span><span>    </span><span id="local-6989586621681084598"><span class="annot"><span class="annottext">go :: Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084598"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-505"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-506"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084597"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084597"><span class="hs-identifier hs-var">p'</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-507"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681084600"><span class="hs-identifier hs-var">is_strict</span></a></span><span>
</span><span id="line-508"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass).
OutputableBndrId p =&gt;
Bool -&gt; LPat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#isIrrefutableHsPat%27"><span class="hs-identifier hs-var">isIrrefutableHsPat'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084597"><span class="hs-identifier hs-var">p'</span></a></span><span>
</span><span id="line-509"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-510"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084596"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084596"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084596"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-511"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084595"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084595"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084595"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-512"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084594"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084594"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084594"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-513"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="annot"><span class="annottext">XViewPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084593"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084593"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084593"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-514"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084592"><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084592"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass p))
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084592"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-515"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084591"><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084591"><span class="hs-identifier hs-var">pats</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#all"><span class="hs-identifier hs-var">all</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat (GhcPass p)]
</span><a href="#local-6989586621681084591"><span class="hs-identifier hs-var">pats</span></a></span><span>
</span><span id="line-516"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-517"></span><span>                    </span><span class="hs-comment">-- See Note [Unboxed sum patterns aren't irrefutable]</span><span>
</span><span id="line-518"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-519"></span><span>
</span><span id="line-520"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span>
</span><span id="line-521"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_con :: forall p. Pat p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con"><span class="hs-identifier hs-var">pat_con</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084589"><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084589"><span class="hs-identifier hs-var">con</span></a></span></span><span>
</span><span id="line-522"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084588"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084588"><span class="hs-identifier hs-var">details</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-523"></span><span>                           </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-524"></span><span>       </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcPs"><span class="hs-identifier hs-var">GhcPs</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- Conservative</span><span>
</span><span id="line-525"></span><span>       </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcRn"><span class="hs-identifier hs-var">GhcRn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- Conservative</span><span>
</span><span id="line-526"></span><span>       </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (ConLikeP (GhcPass p))
</span><a href="#local-6989586621681084589"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-527"></span><span>         </span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnN
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.ConLike.html#PatSynCon"><span class="hs-identifier hs-type">PatSynCon</span></a></span><span> </span><span id="local-6989586621681084581"><span class="annot"><span class="annottext">PatSyn
</span><a href="#local-6989586621681084581"><span class="hs-identifier hs-var">_pat</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- Conservative</span><span>
</span><span id="line-528"></span><span>         </span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnN
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Core.ConLike.html#RealDataCon"><span class="hs-identifier hs-type">RealDataCon</span></a></span><span> </span><span id="local-6989586621681084580"><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681084580"><span class="hs-identifier hs-var">con</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-529"></span><span>           </span><span class="annot"><span class="annottext">forall a. Maybe a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Maybe.html#isJust"><span class="hs-identifier hs-var">isJust</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyCon -&gt; Maybe DataCon
</span><a href="GHC.Core.TyCon.html#tyConSingleDataCon_maybe"><span class="hs-identifier hs-var">tyConSingleDataCon_maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DataCon -&gt; TyCon
</span><a href="GHC.Core.DataCon.html#dataConTyCon"><span class="hs-identifier hs-var">dataConTyCon</span></a></span><span> </span><span class="annot"><span class="annottext">DataCon
</span><a href="#local-6989586621681084580"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-530"></span><span>           </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#all"><span class="hs-identifier hs-var">all</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084599"><span class="hs-identifier hs-var">goL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084588"><span class="hs-identifier hs-var">details</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-531"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-532"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-533"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-534"></span><span>
</span><span id="line-535"></span><span>    </span><span class="hs-comment">-- We conservatively assume that no TH splices are irrefutable</span><span>
</span><span id="line-536"></span><span>    </span><span class="hs-comment">-- since we cannot know until the splice is evaluated.</span><span>
</span><span id="line-537"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-538"></span><span>
</span><span id="line-539"></span><span>    </span><span class="annot"><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681084575"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681084575"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681085106"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 811
</span><span>      </span><span class="hs-identifier">GhcPs</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">noExtCon</span><span> </span><span class="hs-identifier">ext</span><span>
</span><span id="line-542"></span><span>      </span><span class="hs-identifier">GhcRn</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">noExtCon</span><span> </span><span class="hs-identifier">ext</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084598"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084573"><span class="hs-identifier hs-var">pat</span></a></span><span>
</span><span id="line-545"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084573"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084573"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681084575"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-546"></span><span>
</span><span id="line-547"></span><span class="hs-comment">-- | Is the pattern any of combination of:</span><span>
</span><span id="line-548"></span><span class="hs-comment">--</span><span>
</span><span id="line-549"></span><span class="hs-comment">-- - (pat)</span><span>
</span><span id="line-550"></span><span class="hs-comment">-- - pat :: Type</span><span>
</span><span id="line-551"></span><span class="hs-comment">-- - ~pat</span><span>
</span><span id="line-552"></span><span class="hs-comment">-- - !pat</span><span>
</span><span id="line-553"></span><span class="hs-comment">-- - x (variable)</span><span>
</span><span id="line-554"></span><span id="local-6989586621681085097"><span class="annot"><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-type">isSimplePat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085097"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085097"><span class="hs-identifier hs-type">x</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span>
</span><span id="line-555"></span><span id="isSimplePat"><span class="annot"><span class="annottext">isSimplePat :: forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var hs-var">isSimplePat</span></a></span></span><span> </span><span id="local-6989586621681084572"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084572"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084572"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-556"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">XParPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084571"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084571"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084571"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-557"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSigPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084570"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084570"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc (GhcPass x))
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084570"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-558"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084569"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084569"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084569"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-559"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084568"><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084568"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall (x :: Pass). LPat (GhcPass x) -&gt; Maybe (IdP (GhcPass x))
</span><a href="GHC.Hs.Pat.html#isSimplePat"><span class="hs-identifier hs-var">isSimplePat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass x)
</span><a href="#local-6989586621681084568"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-560"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="annot"><span class="annottext">XVarPat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084567"><span class="annot"><span class="annottext">LIdP (GhcPass x)
</span><a href="#local-6989586621681084567"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. a -&gt; Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-var">Just</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP (GhcPass x)
</span><a href="#local-6989586621681084567"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-561"></span><span>  </span><span class="annot"><span class="annottext">Pat (GhcPass x)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-562"></span><span>
</span><span id="line-563"></span><span>
</span><span id="line-564"></span><span class="hs-comment">{- Note [Unboxed sum patterns aren't irrefutable]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlike unboxed tuples, unboxed sums are *not* irrefutable when used as
patterns. A simple example that demonstrates this is from #14228:

  pattern Just' x = (# x | #)
  pattern Nothing' = (# | () #)

  foo x = case x of
    Nothing' -&gt; putStrLn &quot;nothing&quot;
    Just'    -&gt; putStrLn &quot;just&quot;

In foo, the pattern Nothing' (that is, (# x | #)) is certainly not irrefutable,
as does not match an unboxed sum value of the same arity&#8212;namely, (# | y #)
(covered by Just'). In fact, no unboxed sum pattern is irrefutable, since the
minimum unboxed sum arity is 2.

Failing to mark unboxed sum patterns as non-irrefutable would cause the Just'
case in foo to be unreachable, as GHC would mistakenly believe that Nothing'
is the only thing that could possibly be matched!
-}</span><span>
</span><span id="line-585"></span><span>
</span><span id="line-586"></span><span class="hs-comment">-- | @'patNeedsParens' p pat@ returns 'True' if the pattern @pat@ needs</span><span>
</span><span id="line-587"></span><span class="hs-comment">-- parentheses under precedence @p@.</span><span>
</span><span id="line-588"></span><span class="annot"><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-type">patNeedsParens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681085214"><span class="annot"><a href="#local-6989586621681085214"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085214"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085214"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-589"></span><span id="patNeedsParens"><span class="annot"><span class="annottext">patNeedsParens :: forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var hs-var">patNeedsParens</span></a></span></span><span> </span><span id="local-6989586621681084560"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-590"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-591"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085214"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-592"></span><span>    </span><span id="local-6989586621681084559"><span class="annot"><span class="annottext">go :: Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084559"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPlusKPat"><span class="hs-identifier hs-type">NPlusKPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#opPrec"><span class="hs-identifier hs-var">opPrec</span></a></span><span>
</span><span id="line-593"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SplicePat"><span class="hs-identifier hs-type">SplicePat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-594"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084556"><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084556"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-595"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall t a b. PprPrec -&gt; HsConDetails t a b -&gt; Bool
</span><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-var">conPatNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails (GhcPass p)
</span><a href="#local-6989586621681084556"><span class="hs-identifier hs-var">ds</span></a></span><span>
</span><span id="line-596"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#sigPrec"><span class="hs-identifier hs-var">sigPrec</span></a></span><span>
</span><span id="line-597"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ViewPat"><span class="hs-identifier hs-type">ViewPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-598"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span id="local-6989586621681084553"><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681084553"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; GhcPass p
</span><a href="GHC.Hs.Extension.html#ghcPass"><span class="hs-identifier hs-var">ghcPass</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681085214"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &lt; 901
</span><span>      </span><span class="hs-identifier">GhcPs</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">noExtCon</span><span> </span><span class="hs-identifier">ext</span><span>
</span><span id="line-601"></span><span>      </span><span class="hs-identifier">GhcRn</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">noExtCon</span><span> </span><span class="hs-identifier">ext</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">GhcPass p
</span><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-var">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p) -&gt; Bool
</span><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084551"><span class="hs-identifier hs-var">inner</span></a></span><span>
</span><span id="line-604"></span><span>        </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084551"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084551"><span class="hs-identifier hs-var">inner</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">XXPat (GhcPass p)
</span><a href="#local-6989586621681084553"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-605"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#WildPat"><span class="hs-identifier hs-type">WildPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-606"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#VarPat"><span class="hs-identifier hs-type">VarPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-607"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-608"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-609"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-610"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-611"></span><span>    </span><span class="hs-comment">-- Special-case unary boxed tuple applications so that they are</span><span>
</span><span id="line-612"></span><span>    </span><span class="hs-comment">-- parenthesized as `Identity (Solo x)`, not `Identity Solo x` (#18612)</span><span>
</span><span id="line-613"></span><span>    </span><span class="hs-comment">-- See Note [One-tuples] in GHC.Builtin.Types</span><span>
</span><span id="line-614"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Boxity
</span><a href="GHC.Types.Basic.html#Boxed"><span class="hs-identifier hs-var">Boxed</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-615"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span>
</span><span id="line-616"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-617"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-618"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-619"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LitPat"><span class="hs-identifier hs-type">LitPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLitPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084550"><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621681084550"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall x. PprPrec -&gt; HsLit x -&gt; Bool
</span><a href="Language.Haskell.Syntax.Lit.html#hsLitNeedsParens"><span class="hs-identifier hs-var">hsLitNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">HsLit (GhcPass p)
</span><a href="#local-6989586621681084550"><span class="hs-identifier hs-var">l</span></a></span><span>
</span><span id="line-620"></span><span>    </span><span class="annot"><a href="#local-6989586621681084559"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#NPat"><span class="hs-identifier hs-type">NPat</span></a></span><span> </span><span class="annot"><span class="annottext">XNPat (GhcPass p)
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084548"><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084548"><span class="hs-identifier hs-var">lol</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe (SyntaxExpr (GhcPass p))
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">SyntaxExpr (GhcPass p)
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall x. PprPrec -&gt; HsOverLit x -&gt; Bool
</span><a href="Language.Haskell.Syntax.Lit.html#hsOverLitNeedsParens"><span class="hs-identifier hs-var">hsOverLitNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084560"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span> </span><span class="annot"><span class="annottext">XRec (GhcPass p) (HsOverLit (GhcPass p))
</span><a href="#local-6989586621681084548"><span class="hs-identifier hs-var">lol</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-621"></span><span>
</span><span id="line-622"></span><span class="hs-comment">-- | @'conPatNeedsParens' p cp@ returns 'True' if the constructor patterns @cp@</span><span>
</span><span id="line-623"></span><span class="hs-comment">-- needs parentheses under precedence @p@.</span><span>
</span><span id="line-624"></span><span id="local-6989586621681085090"><span id="local-6989586621681085091"><span id="local-6989586621681085092"><span class="annot"><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-type">conPatNeedsParens</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085092"><span class="hs-identifier hs-type">t</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085091"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085090"><span class="hs-identifier hs-type">b</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span></span><span>
</span><span id="line-625"></span><span id="conPatNeedsParens"><span class="annot"><span class="annottext">conPatNeedsParens :: forall t a b. PprPrec -&gt; HsConDetails t a b -&gt; Bool
</span><a href="GHC.Hs.Pat.html#conPatNeedsParens"><span class="hs-identifier hs-var hs-var">conPatNeedsParens</span></a></span></span><span> </span><span id="local-6989586621681084542"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084542"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsConDetails t a b -&gt; Bool
</span><a href="#local-6989586621681084541"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-626"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-627"></span><span>    </span><span id="local-6989586621681084541"><span class="annot"><span class="annottext">go :: HsConDetails t a b -&gt; Bool
</span><a href="#local-6989586621681084541"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#PrefixCon"><span class="hs-identifier hs-type">PrefixCon</span></a></span><span> </span><span id="local-6989586621681084540"><span class="annot"><span class="annottext">[t]
</span><a href="#local-6989586621681084540"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621681084539"><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681084539"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084542"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#appPrec"><span class="hs-identifier hs-var">appPrec</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[a]
</span><a href="#local-6989586621681084539"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">||</span></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[t]
</span><a href="#local-6989586621681084540"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-628"></span><span>    </span><span class="annot"><a href="#local-6989586621681084541"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#InfixCon"><span class="hs-identifier hs-type">InfixCon</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084542"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="GHC.Types.Basic.html#opPrec"><span class="hs-identifier hs-var">opPrec</span></a></span><span> </span><span class="hs-comment">-- type args should be empty in this case</span><span>
</span><span id="line-629"></span><span>    </span><span class="annot"><a href="#local-6989586621681084541"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#RecCon"><span class="hs-identifier hs-type">RecCon</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-630"></span><span>
</span><span id="line-631"></span><span class="hs-comment">-- | @'parenthesizePat' p pat@ checks if @'patNeedsParens' p pat@ is true, and</span><span>
</span><span id="line-632"></span><span class="hs-comment">-- if so, surrounds @pat@ with a 'ParPat'. Otherwise, it simply returns @pat@.</span><span>
</span><span id="line-633"></span><span id="local-6989586621681085082"><span class="annot"><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier hs-type">parenthesizePat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#IsPass"><span class="hs-identifier hs-type">IsPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085082"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-634"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#PprPrec"><span class="hs-identifier hs-type">PprPrec</span></a></span><span>
</span><span id="line-635"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085082"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-636"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681085082"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span>
</span><span id="line-637"></span><span id="parenthesizePat"><span class="annot"><span class="annottext">parenthesizePat :: forall (p :: Pass).
IsPass p =&gt;
PprPrec -&gt; LPat (GhcPass p) -&gt; LPat (GhcPass p)
</span><a href="GHC.Hs.Pat.html#parenthesizePat"><span class="hs-identifier hs-var hs-var">parenthesizePat</span></a></span></span><span> </span><span id="local-6989586621681084533"><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084533"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621681084532"><span class="annot"><span class="annottext">lpat :: LPat (GhcPass p)
</span><a href="#local-6989586621681084532"><span class="hs-identifier hs-var">lpat</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-type">L</span></a></span><span> </span><span id="local-6989586621681084531"><span class="annot"><span class="annottext">SrcSpanAnnA
</span><a href="#local-6989586621681084531"><span class="hs-identifier hs-var">loc</span></a></span></span><span> </span><span id="local-6989586621681084530"><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084530"><span class="hs-identifier hs-var">pat</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-638"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall (p :: Pass). IsPass p =&gt; PprPrec -&gt; Pat (GhcPass p) -&gt; Bool
</span><a href="GHC.Hs.Pat.html#patNeedsParens"><span class="hs-identifier hs-var">patNeedsParens</span></a></span><span> </span><span class="annot"><span class="annottext">PprPrec
</span><a href="#local-6989586621681084533"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Pat (GhcPass p)
</span><a href="#local-6989586621681084530"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall l e. l -&gt; e -&gt; GenLocated l e
</span><a href="GHC.Types.SrcLoc.html#L"><span class="hs-identifier hs-var">L</span></a></span><span> </span><span class="annot"><span class="annottext">SrcSpanAnnA
</span><a href="#local-6989586621681084531"><span class="hs-identifier hs-var">loc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. XParPat p -&gt; LPat p -&gt; Pat p
</span><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-var">ParPat</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. EpAnn a
</span><a href="GHC.Parser.Annotation.html#noAnn"><span class="hs-identifier hs-var">noAnn</span></a></span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084532"><span class="hs-identifier hs-var">lpat</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-639"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LPat (GhcPass p)
</span><a href="#local-6989586621681084532"><span class="hs-identifier hs-var">lpat</span></a></span><span>
</span><span id="line-640"></span><span>
</span><span id="line-641"></span><span class="hs-comment">{-
% Collect all EvVars from all constructor patterns
-}</span><span>
</span><span id="line-644"></span><span>
</span><span id="line-645"></span><span class="hs-comment">-- May need to add more cases</span><span>
</span><span id="line-646"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier hs-type">collectEvVarsPats</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-647"></span><span id="collectEvVarsPats"><span class="annot"><span class="annottext">collectEvVarsPats :: [Pat GhcTc] -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPats"><span class="hs-identifier hs-var hs-var">collectEvVarsPats</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span>
</span><span id="line-648"></span><span>
</span><span id="line-649"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-type">collectEvVarsLPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-650"></span><span id="collectEvVarsLPat"><span class="annot"><span class="annottext">collectEvVarsLPat :: LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var hs-var">collectEvVarsLPat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span>
</span><span id="line-651"></span><span>
</span><span id="line-652"></span><span class="annot"><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-type">collectEvVarsPat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span>
</span><span id="line-653"></span><span id="collectEvVarsPat"><span class="annot"><span class="annottext">collectEvVarsPat :: Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var hs-var">collectEvVarsPat</span></a></span></span><span> </span><span id="local-6989586621681084526"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084526"><span class="hs-identifier hs-var">pat</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-654"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084526"><span class="hs-identifier hs-var">pat</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-655"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LazyPat"><span class="hs-identifier hs-type">LazyPat</span></a></span><span> </span><span class="annot"><span class="annottext">XLazyPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084525"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084525"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084525"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-656"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#AsPat"><span class="hs-identifier hs-type">AsPat</span></a></span><span> </span><span class="annot"><span class="annottext">XAsPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084524"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084524"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084524"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-657"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ParPat"><span class="hs-identifier hs-type">ParPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XParPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084523"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084523"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084523"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-658"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#BangPat"><span class="hs-identifier hs-type">BangPat</span></a></span><span> </span><span class="annot"><span class="annottext">XBangPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084522"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084522"><span class="hs-identifier hs-var">p</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084522"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-659"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ListPat"><span class="hs-identifier hs-type">ListPat</span></a></span><span> </span><span class="annot"><span class="annottext">XListPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084521"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681084521"><span class="hs-identifier hs-var">ps</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681084521"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-660"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#TuplePat"><span class="hs-identifier hs-type">TuplePat</span></a></span><span> </span><span class="annot"><span class="annottext">XTuplePat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084520"><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681084520"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span class="annot"><span class="annottext">Boxity
</span><span class="hs-identifier">_</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">[LPat GhcTc]
</span><a href="#local-6989586621681084520"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-661"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SumPat"><span class="hs-identifier hs-type">SumPat</span></a></span><span> </span><span class="annot"><span class="annottext">XSumPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084519"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084519"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-identifier">_</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084519"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-662"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConPat"><span class="hs-identifier hs-type">ConPat</span></a></span><span>
</span><span id="line-663"></span><span>      </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">pat_args :: forall p. Pat p -&gt; HsConPatDetails p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_args"><span class="hs-identifier hs-var">pat_args</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084518"><span class="annot"><span class="annottext">HsConPatDetails GhcTc
</span><a href="#local-6989586621681084518"><span class="hs-identifier hs-var">args</span></a></span></span><span>
</span><span id="line-664"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pat_con_ext :: forall p. Pat p -&gt; XConPat p
</span><a href="Language.Haskell.Syntax.Pat.html#pat_con_ext"><span class="hs-identifier hs-var">pat_con_ext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Hs.Pat.html#ConPatTc"><span class="hs-identifier hs-type">ConPatTc</span></a></span><span>
</span><span id="line-665"></span><span>        </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">cpt_dicts :: ConPatTc -&gt; [TyVar]
</span><a href="GHC.Hs.Pat.html#cpt_dicts"><span class="hs-identifier hs-var">cpt_dicts</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681084517"><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681084517"><span class="hs-identifier hs-var">dicts</span></a></span></span><span>
</span><span id="line-666"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-667"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-668"></span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a -&gt; Bag a -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionBags"><span class="hs-identifier hs-var">unionBags</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. [a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#listToBag"><span class="hs-identifier hs-var">listToBag</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVar]
</span><a href="#local-6989586621681084517"><span class="hs-identifier hs-var">dicts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-669"></span><span>                                   </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. [Bag a] -&gt; Bag a
</span><a href="GHC.Data.Bag.html#unionManyBags"><span class="hs-identifier hs-var">unionManyBags</span></a></span><span>
</span><span id="line-670"></span><span>                                   </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span>
</span><span id="line-671"></span><span>                                   </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. UnXRec p =&gt; HsConPatDetails p -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Pat.html#hsConPatArgs"><span class="hs-identifier hs-var">hsConPatArgs</span></a></span><span> </span><span class="annot"><span class="annottext">HsConPatDetails GhcTc
</span><a href="#local-6989586621681084518"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-672"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#SigPat"><span class="hs-identifier hs-type">SigPat</span></a></span><span>  </span><span class="annot"><span class="annottext">XSigPat GhcTc
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084514"><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084514"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsPatSigType (NoGhcTc GhcTc)
</span><span class="hs-identifier">_</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">LPat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsLPat"><span class="hs-identifier hs-var">collectEvVarsLPat</span></a></span><span> </span><span class="annot"><span class="annottext">LPat GhcTc
</span><a href="#local-6989586621681084514"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-673"></span><span>    </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#XPat"><span class="hs-identifier hs-type">XPat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Pat.html#CoPat"><span class="hs-identifier hs-type">CoPat</span></a></span><span> </span><span class="annot"><span class="annottext">HsWrapper
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681084513"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084513"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Pat GhcTc -&gt; Bag TyVar
</span><a href="GHC.Hs.Pat.html#collectEvVarsPat"><span class="hs-identifier hs-var">collectEvVarsPat</span></a></span><span>  </span><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084513"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-674"></span><span>    </span><span id="local-6989586621681084512"><span class="annot"><span class="annottext">Pat GhcTc
</span><a href="#local-6989586621681084512"><span class="hs-identifier hs-var">_other_pat</span></a></span></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Bag a
</span><a href="GHC.Data.Bag.html#emptyBag"><span class="hs-identifier hs-var">emptyBag</span></a></span><span>
</span><span id="line-675"></span><span>
</span><span id="line-676"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Anno instances}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-683"></span><span>
</span><span id="line-684"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681084510"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084510"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-685"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681084509"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084509"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span>
</span><span id="line-686"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnN"><span class="hs-identifier hs-type">SrcSpanAnnN</span></a></span><span>
</span><span id="line-687"></span><span>
</span><span id="line-688"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681084507"><span id="local-6989586621681084508"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier hs-type">HsRecField'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084508"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084507"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-689"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681084506"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier hs-type">HsRecField'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084506"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#LocatedA"><span class="hs-identifier hs-type">LocatedA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084506"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-690"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681084503"><span id="local-6989586621681084504"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField"><span class="hs-identifier hs-type">HsRecField</span></a></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Hs.Extension.html#GhcPass"><span class="hs-identifier hs-type">GhcPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084504"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681084503"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-691"></span><span>
</span><span id="line-692"></span><span class="hs-comment">-- type instance Anno (HsRecUpdField p) = SrcSpanAnnA</span><span>
</span><span id="line-693"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span id="local-6989586621681084502"><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier hs-type">HsRecField'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-type">AmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084502"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Parser.Annotation.html#LocatedA"><span class="hs-identifier hs-type">LocatedA</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681084502"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">)</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-694"></span><span>
</span><span id="line-695"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="Anno"><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#Anno"><span class="hs-identifier hs-var">Anno</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-type">AmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="GHC.Hs.Extension.html#GhcTc"><span class="hs-identifier hs-type">GhcTc</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Parser.Annotation.html#SrcSpanAnnA"><span class="hs-identifier hs-type">SrcSpanAnnA</span></a></span><span>
</span><span id="line-696"></span></pre></body></html>