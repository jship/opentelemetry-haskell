<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Tc/Validity.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP           #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-record-updates #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns   #-}</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>{-
<a name="line-7"></a>(c) The University of Glasgow 2006
<a name="line-8"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-9"></a>-}</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Tc.Validity</span> <span class='hs-layout'>(</span>
<a name="line-12"></a>  <span class='hs-conid'>Rank</span><span class='hs-layout'>,</span> <span class='hs-conid'>UserTypeCtxt</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidType</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidMonoType</span><span class='hs-layout'>,</span>
<a name="line-13"></a>  <span class='hs-varid'>checkValidTheta</span><span class='hs-layout'>,</span>
<a name="line-14"></a>  <span class='hs-varid'>checkValidInstance</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidInstHead</span><span class='hs-layout'>,</span> <span class='hs-varid'>validDerivPred</span><span class='hs-layout'>,</span>
<a name="line-15"></a>  <span class='hs-varid'>checkTySynRhs</span><span class='hs-layout'>,</span>
<a name="line-16"></a>  <span class='hs-varid'>checkValidCoAxiom</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidCoAxBranch</span><span class='hs-layout'>,</span>
<a name="line-17"></a>  <span class='hs-varid'>checkValidTyFamEqn</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkValidAssocTyFamDeflt</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkConsistentFamInst</span><span class='hs-layout'>,</span>
<a name="line-18"></a>  <span class='hs-varid'>badATErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>arityErr</span><span class='hs-layout'>,</span>
<a name="line-19"></a>  <span class='hs-varid'>checkTyConTelescope</span><span class='hs-layout'>,</span>
<a name="line-20"></a>  <span class='hs-varid'>allDistinctTyVars</span>
<a name="line-21"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-24"></a>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-26"></a>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-comment'>-- friends:</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Unify</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>tcSubTypeAmbiguity</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver</span>         <span class='hs-layout'>(</span> <span class='hs-varid'>simplifyAmbiguityCheck</span> <span class='hs-layout'>)</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Instance.Class</span> <span class='hs-layout'>(</span> <span class='hs-varid'>matchGlobalInst</span><span class='hs-layout'>,</span> <span class='hs-conid'>ClsInstResult</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>InstanceWhat</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AssocInstInfo</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.FVs</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Ppr</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcType</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-varid'>sizeType</span><span class='hs-layout'>,</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types</span> <span class='hs-layout'>(</span> <span class='hs-varid'>heqTyConName</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqTyConName</span><span class='hs-layout'>,</span> <span class='hs-varid'>coercibleTyConName</span><span class='hs-layout'>,</span> <span class='hs-varid'>manyDataConTy</span> <span class='hs-layout'>)</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unify</span> <span class='hs-layout'>(</span> <span class='hs-varid'>tcMatchTyX_BM</span><span class='hs-layout'>,</span> <span class='hs-conid'>BindFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion.Axiom</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Class</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Predicate</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Origin</span>
<a name="line-47"></a>
<a name="line-48"></a><span class='hs-comment'>-- others:</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Iface.Type</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>pprIfaceType</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprIfaceTypeApp</span> <span class='hs-layout'>)</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.CoreToIface</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>toIfaceTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>toIfaceTcArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>toIfaceType</span> <span class='hs-layout'>)</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Hs</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Monad</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Env</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>tcInitTidyEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcInitOpenTidyEnv</span> <span class='hs-layout'>)</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Instance.FunDeps</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>
<a name="line-56"></a>   <span class='hs-layout'>(</span> <span class='hs-varid'>isDominatedBy</span><span class='hs-layout'>,</span> <span class='hs-varid'>injectiveBranches</span><span class='hs-layout'>,</span> <span class='hs-conid'>InjectivityCheckResult</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Instance.Family</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>     <span class='hs-layout'>(</span> <span class='hs-conid'>VarBndr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyVar</span> <span class='hs-layout'>)</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.FV</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Error</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.List.SetOps</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Outputable</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Uniques</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>mkAlphaTyVarUnique</span> <span class='hs-layout'>)</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Bag</span>      <span class='hs-layout'>(</span> <span class='hs-varid'>emptyBag</span> <span class='hs-layout'>)</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.LanguageExtensions</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>LangExt</span>
<a name="line-73"></a>
<a name="line-74"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>
<a name="line-75"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Foldable</span>
<a name="line-76"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Function</span>
<a name="line-77"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>        <span class='hs-layout'>(</span> <span class='hs-layout'>(</span><span class='hs-varop'>\\</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>nub</span> <span class='hs-layout'>)</span>
<a name="line-78"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>NE</span>
<a name="line-79"></a>
<a name="line-80"></a><span class='hs-comment'>{-
<a name="line-81"></a>************************************************************************
<a name="line-82"></a>*                                                                      *
<a name="line-83"></a>          Checking for ambiguity
<a name="line-84"></a>*                                                                      *
<a name="line-85"></a>************************************************************************
<a name="line-86"></a>
<a name="line-87"></a>Note [The ambiguity check for type signatures]
<a name="line-88"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-89"></a>checkAmbiguity is a check on *user-supplied type signatures*.  It is
<a name="line-90"></a>*purely* there to report functions that cannot possibly be called.  So for
<a name="line-91"></a>example we want to reject:
<a name="line-92"></a>   f :: C a =&gt; Int
<a name="line-93"></a>The idea is there can be no legal calls to 'f' because every call will
<a name="line-94"></a>give rise to an ambiguous constraint.  We could soundly omit the
<a name="line-95"></a>ambiguity check on type signatures entirely, at the expense of
<a name="line-96"></a>delaying ambiguity errors to call sites.  Indeed, the flag
<a name="line-97"></a>-XAllowAmbiguousTypes switches off the ambiguity check.
<a name="line-98"></a>
<a name="line-99"></a>What about things like this:
<a name="line-100"></a>   class D a b | a -&gt; b where ..
<a name="line-101"></a>   h :: D Int b =&gt; Int
<a name="line-102"></a>The Int may well fix 'b' at the call site, so that signature should
<a name="line-103"></a>not be rejected.  Moreover, using *visible* fundeps is too
<a name="line-104"></a>conservative.  Consider
<a name="line-105"></a>   class X a b where ...
<a name="line-106"></a>   class D a b | a -&gt; b where ...
<a name="line-107"></a>   instance D a b =&gt; X [a] b where...
<a name="line-108"></a>   h :: X a b =&gt; a -&gt; a
<a name="line-109"></a>Here h's type looks ambiguous in 'b', but here's a legal call:
<a name="line-110"></a>   ...(h [True])...
<a name="line-111"></a>That gives rise to a (X [Bool] beta) constraint, and using the
<a name="line-112"></a>instance means we need (D Bool beta) and that fixes 'beta' via D's
<a name="line-113"></a>fundep!
<a name="line-114"></a>
<a name="line-115"></a>Behind all these special cases there is a simple guiding principle.
<a name="line-116"></a>Consider
<a name="line-117"></a>
<a name="line-118"></a>  f :: &lt;type&gt;
<a name="line-119"></a>  f = ...blah...
<a name="line-120"></a>
<a name="line-121"></a>  g :: &lt;type&gt;
<a name="line-122"></a>  g = f
<a name="line-123"></a>
<a name="line-124"></a>You would think that the definition of g would surely typecheck!
<a name="line-125"></a>After all f has exactly the same type, and g=f. But in fact f's type
<a name="line-126"></a>is instantiated and the instantiated constraints are solved against
<a name="line-127"></a>the originals, so in the case of an ambiguous type it won't work.
<a name="line-128"></a>Consider our earlier example f :: C a =&gt; Int.  Then in g's definition,
<a name="line-129"></a>we'll instantiate to (C alpha) and try to deduce (C alpha) from (C a),
<a name="line-130"></a>and fail.
<a name="line-131"></a>
<a name="line-132"></a>So in fact we use this as our *definition* of ambiguity.  We use a
<a name="line-133"></a>very similar test for *inferred* types, to ensure that they are
<a name="line-134"></a>unambiguous. See Note [Impedance matching] in GHC.Tc.Gen.Bind.
<a name="line-135"></a>
<a name="line-136"></a>This test is very conveniently implemented by calling
<a name="line-137"></a>    tcSubType &lt;type&gt; &lt;type&gt;
<a name="line-138"></a>This neatly takes account of the functional dependency stuff above,
<a name="line-139"></a>and implicit parameter (see Note [Implicit parameters and ambiguity]).
<a name="line-140"></a>And this is what checkAmbiguity does.
<a name="line-141"></a>
<a name="line-142"></a>Note [The squishiness of the ambiguity check]
<a name="line-143"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-144"></a>What about this?
<a name="line-145"></a>   g :: C [a] =&gt; Int
<a name="line-146"></a>Is every call to 'g' ambiguous?  After all, we might have
<a name="line-147"></a>   instance C [a] where ...
<a name="line-148"></a>at the call site.  So maybe that type is ok!  Indeed even f's
<a name="line-149"></a>quintessentially ambiguous type might, just possibly be callable:
<a name="line-150"></a>with -XFlexibleInstances we could have
<a name="line-151"></a>  instance C a where ...
<a name="line-152"></a>and now a call could be legal after all!  Well, we'll reject this
<a name="line-153"></a>unless the instance is available *here*.
<a name="line-154"></a>
<a name="line-155"></a>But even that's not quite right. Even a function with an utterly-ambiguous
<a name="line-156"></a>type like f :: Eq a =&gt; Int -&gt; Int
<a name="line-157"></a>is still callable if you are prepared to use visible type application,
<a name="line-158"></a>thus (f @Bool x).
<a name="line-159"></a>
<a name="line-160"></a>In short, the ambiguity check is a good-faith attempt to say "you are likely
<a name="line-161"></a>to have trouble if your function has this type"; it is NOT the case that
<a name="line-162"></a>"you can't call this function without giving a type error".
<a name="line-163"></a>
<a name="line-164"></a>See also Note [Ambiguity check and deep subsumption] in GHC.Tc.Utils.Unify.
<a name="line-165"></a>
<a name="line-166"></a>Note [When to call checkAmbiguity]
<a name="line-167"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-168"></a>We call checkAmbiguity
<a name="line-169"></a>   (a) on user-specified type signatures
<a name="line-170"></a>   (b) in checkValidType
<a name="line-171"></a>
<a name="line-172"></a>Conncerning (b), you might wonder about nested foralls.  What about
<a name="line-173"></a>    f :: forall b. (forall a. Eq a =&gt; b) -&gt; b
<a name="line-174"></a>The nested forall is ambiguous.  Originally we called checkAmbiguity
<a name="line-175"></a>in the forall case of check_type, but that had two bad consequences:
<a name="line-176"></a>  * We got two error messages about (Eq b) in a nested forall like this:
<a name="line-177"></a>       g :: forall a. Eq a =&gt; forall b. Eq b =&gt; a -&gt; a
<a name="line-178"></a>  * If we try to check for ambiguity of a nested forall like
<a name="line-179"></a>    (forall a. Eq a =&gt; b), the implication constraint doesn't bind
<a name="line-180"></a>    all the skolems, which results in "No skolem info" in error
<a name="line-181"></a>    messages (see #10432).
<a name="line-182"></a>
<a name="line-183"></a>To avoid this, we call checkAmbiguity once, at the top, in checkValidType.
<a name="line-184"></a>(I'm still a bit worried about unbound skolems when the type mentions
<a name="line-185"></a>in-scope type variables.)
<a name="line-186"></a>
<a name="line-187"></a>In fact, because of the co/contra-variance implemented in tcSubType,
<a name="line-188"></a>this *does* catch function f above. too.
<a name="line-189"></a>
<a name="line-190"></a>Concerning (a) the ambiguity check is only used for *user* types, not
<a name="line-191"></a>for types coming from interface files.  The latter can legitimately
<a name="line-192"></a>have ambiguous types. Example
<a name="line-193"></a>
<a name="line-194"></a>   class S a where s :: a -&gt; (Int,Int)
<a name="line-195"></a>   instance S Char where s _ = (1,1)
<a name="line-196"></a>   f:: S a =&gt; [a] -&gt; Int -&gt; (Int,Int)
<a name="line-197"></a>   f (_::[a]) x = (a*x,b)
<a name="line-198"></a>        where (a,b) = s (undefined::a)
<a name="line-199"></a>
<a name="line-200"></a>Here the worker for f gets the type
<a name="line-201"></a>        fw :: forall a. S a =&gt; Int -&gt; (# Int, Int #)
<a name="line-202"></a>
<a name="line-203"></a>
<a name="line-204"></a>Note [Implicit parameters and ambiguity]
<a name="line-205"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-206"></a>Only a *class* predicate can give rise to ambiguity
<a name="line-207"></a>An *implicit parameter* cannot.  For example:
<a name="line-208"></a>        foo :: (?x :: [a]) =&gt; Int
<a name="line-209"></a>        foo = length ?x
<a name="line-210"></a>is fine.  The call site will supply a particular 'x'
<a name="line-211"></a>
<a name="line-212"></a>Furthermore, the type variables fixed by an implicit parameter
<a name="line-213"></a>propagate to the others.  E.g.
<a name="line-214"></a>        foo :: (Show a, ?x::[a]) =&gt; Int
<a name="line-215"></a>        foo = show (?x++?x)
<a name="line-216"></a>The type of foo looks ambiguous.  But it isn't, because at a call site
<a name="line-217"></a>we might have
<a name="line-218"></a>        let ?x = 5::Int in foo
<a name="line-219"></a>and all is well.  In effect, implicit parameters are, well, parameters,
<a name="line-220"></a>so we can take their type variables into account as part of the
<a name="line-221"></a>"tau-tvs" stuff.  This is done in the function 'GHC.Tc.Instance.FunDeps.grow'.
<a name="line-222"></a>-}</span>
<a name="line-223"></a>
<a name="line-224"></a><a name="checkAmbiguity"></a><span class='hs-definition'>checkAmbiguity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-225"></a><span class='hs-definition'>checkAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-226"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>wantAmbiguityCheck</span> <span class='hs-varid'>ctxt</span>
<a name="line-227"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"Ambiguity check for"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-228"></a>         <span class='hs-comment'>-- Solve the constraints eagerly because an ambiguous type</span>
<a name="line-229"></a>         <span class='hs-comment'>-- can cause a cascade of further errors.  Since the free</span>
<a name="line-230"></a>         <span class='hs-comment'>-- tyvars are skolemised, we can safely use tcSimplifyTop</span>
<a name="line-231"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>allow_ambiguous</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.AllowAmbiguousTypes</span>
<a name="line-232"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-sel'>_wrap</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_msg</span> <span class='hs-varid'>allow_ambiguous</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-233"></a>                            <span class='hs-varid'>captureConstraints</span> <span class='hs-varop'>$</span>
<a name="line-234"></a>                            <span class='hs-varid'>tcSubTypeAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>ty</span>
<a name="line-235"></a>                            <span class='hs-comment'>-- See Note [Ambiguity check and deep subsumption]</span>
<a name="line-236"></a>                            <span class='hs-comment'>-- in GHC.Tc.Utils.Unify</span>
<a name="line-237"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplifyAmbiguityCheck</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>wanted</span>
<a name="line-238"></a>
<a name="line-239"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"Done ambiguity check for"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-240"></a>
<a name="line-241"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-242"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-243"></a> <span class='hs-keyword'>where</span>
<a name="line-244"></a>   <span class='hs-varid'>mk_msg</span> <span class='hs-varid'>allow_ambiguous</span>
<a name="line-245"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"In the ambiguity check for"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what</span>
<a name="line-246"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>ppUnless</span> <span class='hs-varid'>allow_ambiguous</span> <span class='hs-varid'>ambig_msg</span> <span class='hs-keyglyph'>]</span>
<a name="line-247"></a>   <span class='hs-varid'>ambig_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"To defer the ambiguity check to use sites, enable AllowAmbiguousTypes"</span>
<a name="line-248"></a>   <span class='hs-varid'>what</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isSigMaybe</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-249"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprUserTypeCtxt</span> <span class='hs-varid'>ctxt</span>
<a name="line-250"></a>
<a name="line-251"></a><a name="wantAmbiguityCheck"></a><span class='hs-definition'>wantAmbiguityCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-252"></a><span class='hs-definition'>wantAmbiguityCheck</span> <span class='hs-varid'>ctxt</span>
<a name="line-253"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>  <span class='hs-comment'>-- See Note [When we don't check for ambiguity]</span>
<a name="line-254"></a>      <span class='hs-conid'>GhciCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-255"></a>      <span class='hs-conid'>TySynCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-256"></a>      <span class='hs-conid'>TypeAppCtxt</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-257"></a>      <span class='hs-conid'>StandaloneKindSigCtxt</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-258"></a>      <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-259"></a>
<a name="line-260"></a><a name="checkUserTypeError"></a><span class='hs-definition'>checkUserTypeError</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-261"></a><span class='hs-comment'>-- Check to see if the type signature mentions "TypeError blah"</span>
<a name="line-262"></a><span class='hs-comment'>-- anywhere in it, and fail if so.</span>
<a name="line-263"></a><span class='hs-comment'>--</span>
<a name="line-264"></a><span class='hs-comment'>-- Very unsatisfactorily (#11144) we need to tidy the type</span>
<a name="line-265"></a><span class='hs-comment'>-- because it may have come from an /inferred/ signature, not a</span>
<a name="line-266"></a><span class='hs-comment'>-- user-supplied one.  This is really only a half-baked fix;</span>
<a name="line-267"></a><span class='hs-comment'>-- the other errors in checkValidType don't do tidying, and so</span>
<a name="line-268"></a><span class='hs-comment'>-- may give bad error messages when given an inferred type.</span>
<a name="line-269"></a><span class='hs-definition'>checkUserTypeError</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check</span>
<a name="line-270"></a>  <span class='hs-keyword'>where</span>
<a name="line-271"></a>  <span class='hs-varid'>check</span> <span class='hs-varid'>ty</span>
<a name="line-272"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>msg</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>userTypeError_maybe</span> <span class='hs-varid'>ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fail_with</span> <span class='hs-varid'>msg</span>
<a name="line-273"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-varid'>check</span> <span class='hs-varid'>ts</span>
<a name="line-274"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>t1</span><span class='hs-layout'>,</span><span class='hs-varid'>t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitAppTy_maybe</span> <span class='hs-varid'>ty</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>&gt;&gt;</span> <span class='hs-varid'>check</span> <span class='hs-varid'>t2</span>
<a name="line-275"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>t1</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check</span> <span class='hs-varid'>t1</span>
<a name="line-276"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-277"></a>
<a name="line-278"></a>  <span class='hs-varid'>fail_with</span> <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>env0</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInitTidyEnv</span>
<a name="line-279"></a>                     <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tidy_msg</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidyOpenType</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>msg</span>
<a name="line-280"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>failWithTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprUserTypeErrorTy</span> <span class='hs-varid'>tidy_msg</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-281"></a>
<a name="line-282"></a>
<a name="line-283"></a><span class='hs-comment'>{- Note [When we don't check for ambiguity]
<a name="line-284"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-285"></a>In a few places we do not want to check a user-specified type for ambiguity
<a name="line-286"></a>
<a name="line-287"></a>* GhciCtxt: Allow ambiguous types in GHCi's :kind command
<a name="line-288"></a>  E.g.   type family T a :: *  -- T :: forall k. k -&gt; *
<a name="line-289"></a>  Then :k T should work in GHCi, not complain that
<a name="line-290"></a>  (T k) is ambiguous!
<a name="line-291"></a>
<a name="line-292"></a>* TySynCtxt: type T a b = C a b =&gt; blah
<a name="line-293"></a>  It may be that when we /use/ T, we'll give an 'a' or 'b' that somehow
<a name="line-294"></a>  cure the ambiguity.  So we defer the ambiguity check to the use site.
<a name="line-295"></a>
<a name="line-296"></a>  There is also an implementation reason (#11608).  In the RHS of
<a name="line-297"></a>  a type synonym we don't (currently) instantiate 'a' and 'b' with
<a name="line-298"></a>  TcTyVars before calling checkValidType, so we get assertion failures
<a name="line-299"></a>  from doing an ambiguity check on a type with TyVars in it.  Fixing this
<a name="line-300"></a>  would not be hard, but let's wait till there's a reason.
<a name="line-301"></a>
<a name="line-302"></a>* TypeAppCtxt: visible type application
<a name="line-303"></a>     f @ty
<a name="line-304"></a>  No need to check ty for ambiguity
<a name="line-305"></a>
<a name="line-306"></a>* StandaloneKindSigCtxt: type T :: ksig
<a name="line-307"></a>  Kinds need a different ambiguity check than types, and the currently
<a name="line-308"></a>  implemented check is only good for types. See #14419, in particular
<a name="line-309"></a>  https://gitlab.haskell.org/ghc/ghc/issues/14419#note_160844
<a name="line-310"></a>
<a name="line-311"></a>************************************************************************
<a name="line-312"></a>*                                                                      *
<a name="line-313"></a>          Checking validity of a user-defined type
<a name="line-314"></a>*                                                                      *
<a name="line-315"></a>************************************************************************
<a name="line-316"></a>
<a name="line-317"></a>When dealing with a user-written type, we first translate it from an HsType
<a name="line-318"></a>to a Type, performing kind checking, and then check various things that should
<a name="line-319"></a>be true about it.  We don't want to perform these checks at the same time
<a name="line-320"></a>as the initial translation because (a) they are unnecessary for interface-file
<a name="line-321"></a>types and (b) when checking a mutually recursive group of type and class decls,
<a name="line-322"></a>we can't "look" at the tycons/classes yet.  Also, the checks are rather
<a name="line-323"></a>diverse, and used to really mess up the other code.
<a name="line-324"></a>
<a name="line-325"></a>One thing we check for is 'rank'.
<a name="line-326"></a>
<a name="line-327"></a>        Rank 0:         monotypes (no foralls)
<a name="line-328"></a>        Rank 1:         foralls at the front only, Rank 0 inside
<a name="line-329"></a>        Rank 2:         foralls at the front, Rank 1 on left of fn arrow,
<a name="line-330"></a>
<a name="line-331"></a>        basic ::= tyvar | T basic ... basic
<a name="line-332"></a>
<a name="line-333"></a>        r2  ::= forall tvs. cxt =&gt; r2a
<a name="line-334"></a>        r2a ::= r1 -&gt; r2a | basic
<a name="line-335"></a>        r1  ::= forall tvs. cxt =&gt; r0
<a name="line-336"></a>        r0  ::= r0 -&gt; r0 | basic
<a name="line-337"></a>
<a name="line-338"></a>Another thing is to check that type synonyms are saturated.
<a name="line-339"></a>This might not necessarily show up in kind checking.
<a name="line-340"></a>        type A i = i
<a name="line-341"></a>        data T k = MkT (k Int)
<a name="line-342"></a>        f :: T A        -- BAD!
<a name="line-343"></a>-}</span>
<a name="line-344"></a>
<a name="line-345"></a><a name="checkValidType"></a><span class='hs-definition'>checkValidType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-346"></a><span class='hs-comment'>-- Checks that a user-written type is valid for the given context</span>
<a name="line-347"></a><span class='hs-comment'>-- Assumes argument is fully zonked</span>
<a name="line-348"></a><span class='hs-comment'>-- Not used for instance decls; checkValidInstance instead</span>
<a name="line-349"></a><span class='hs-definition'>checkValidType</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-350"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkValidType"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"::"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-351"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rankn_flag</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.RankNTypes</span>
<a name="line-352"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>impred_flag</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.ImpredicativeTypes</span>
<a name="line-353"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>gen_rank</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span>
<a name="line-354"></a>             <span class='hs-varid'>gen_rank</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>rankn_flag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-355"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span>
<a name="line-356"></a>
<a name="line-357"></a>             <span class='hs-varid'>rank1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gen_rank</span> <span class='hs-varid'>r1</span>
<a name="line-358"></a>             <span class='hs-varid'>rank0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gen_rank</span> <span class='hs-varid'>r0</span>
<a name="line-359"></a>
<a name="line-360"></a>             <span class='hs-varid'>r0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rankZeroMonoType</span>
<a name="line-361"></a>             <span class='hs-varid'>r1</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LimitedRank</span> <span class='hs-conid'>True</span> <span class='hs-varid'>r0</span>
<a name="line-362"></a>
<a name="line-363"></a>             <span class='hs-varid'>rank</span>
<a name="line-364"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-365"></a>                 <span class='hs-conid'>DefaultDeclCtxt</span><span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MustBeMonoType</span>
<a name="line-366"></a>                 <span class='hs-conid'>PatSigCtxt</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank0</span>
<a name="line-367"></a>                 <span class='hs-conid'>RuleSigCtxt</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-368"></a>                 <span class='hs-conid'>TySynCtxt</span> <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank0</span>
<a name="line-369"></a>
<a name="line-370"></a>                 <span class='hs-conid'>ExprSigCtxt</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-371"></a>                 <span class='hs-conid'>KindSigCtxt</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-372"></a>                 <span class='hs-conid'>StandaloneKindSigCtxt</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-373"></a>                 <span class='hs-conid'>TypeAppCtxt</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>impred_flag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-374"></a>                             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyConArgMonoType</span>
<a name="line-375"></a>                    <span class='hs-comment'>-- Normally, ImpredicativeTypes is handled in check_arg_type,</span>
<a name="line-376"></a>                    <span class='hs-comment'>-- but visible type applications don't go through there.</span>
<a name="line-377"></a>                    <span class='hs-comment'>-- So we do this check here.</span>
<a name="line-378"></a>
<a name="line-379"></a>                 <span class='hs-conid'>FunSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-380"></a>                 <span class='hs-conid'>InfSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span> <span class='hs-comment'>-- Inferred types should obey the</span>
<a name="line-381"></a>                                         <span class='hs-comment'>-- same rules as declared ones</span>
<a name="line-382"></a>
<a name="line-383"></a>                 <span class='hs-conid'>ConArgCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span> <span class='hs-comment'>-- We are given the type of the entire</span>
<a name="line-384"></a>                                         <span class='hs-comment'>-- constructor, hence rank 1</span>
<a name="line-385"></a>                 <span class='hs-conid'>PatSynCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-386"></a>
<a name="line-387"></a>                 <span class='hs-conid'>ForSigCtxt</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-388"></a>                 <span class='hs-conid'>SpecInstCtxt</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-389"></a>                 <span class='hs-conid'>GhciCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-390"></a>
<a name="line-391"></a>                 <span class='hs-conid'>TyVarBndrKindCtxt</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank0</span>
<a name="line-392"></a>                 <span class='hs-conid'>DataKindCtxt</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-393"></a>                 <span class='hs-conid'>TySynKindCtxt</span> <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-394"></a>                 <span class='hs-conid'>TyFamResKindCtxt</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rank1</span>
<a name="line-395"></a>
<a name="line-396"></a>                 <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"checkValidType"</span>
<a name="line-397"></a>                                          <span class='hs-comment'>-- Can't happen; not used for *user* sigs</span>
<a name="line-398"></a>
<a name="line-399"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInitOpenTidyEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfTypeList</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-400"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initialExpandMode</span>
<a name="line-401"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ve</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span>
<a name="line-402"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span> <span class='hs-layout'>}</span>
<a name="line-403"></a>
<a name="line-404"></a>       <span class='hs-comment'>-- Check the internal validity of the type itself</span>
<a name="line-405"></a>       <span class='hs-comment'>-- Fail if bad things happen, else we misleading</span>
<a name="line-406"></a>       <span class='hs-comment'>-- (and more complicated) errors in checkAmbiguity</span>
<a name="line-407"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkNoErrs</span> <span class='hs-varop'>$</span>
<a name="line-408"></a>         <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty</span>
<a name="line-409"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>checkUserTypeError</span> <span class='hs-varid'>ty</span>
<a name="line-410"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"done ct"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-411"></a>
<a name="line-412"></a>       <span class='hs-comment'>-- Check for ambiguous types.  See Note [When to call checkAmbiguity]</span>
<a name="line-413"></a>       <span class='hs-comment'>-- NB: this will happen even for monotypes, but that should be cheap;</span>
<a name="line-414"></a>       <span class='hs-comment'>--     and there may be nested foralls for the subtype test to examine</span>
<a name="line-415"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-416"></a>
<a name="line-417"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkValidType done"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"::"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-418"></a>
<a name="line-419"></a><a name="checkValidMonoType"></a><span class='hs-definition'>checkValidMonoType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-420"></a><span class='hs-comment'>-- Assumes argument is fully zonked</span>
<a name="line-421"></a><span class='hs-definition'>checkValidMonoType</span> <span class='hs-varid'>ty</span>
<a name="line-422"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInitOpenTidyEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfTypeList</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-423"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initialExpandMode</span>
<a name="line-424"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ve</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SigmaCtxt</span>
<a name="line-425"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MustBeMonoType</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span> <span class='hs-layout'>}</span>
<a name="line-426"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-427"></a>
<a name="line-428"></a><a name="checkTySynRhs"></a><span class='hs-definition'>checkTySynRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-429"></a><span class='hs-definition'>checkTySynRhs</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-430"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tcReturnsConstraintKind</span> <span class='hs-varid'>actual_kind</span>
<a name="line-431"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ck</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.ConstraintKinds</span>
<a name="line-432"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>ck</span>
<a name="line-433"></a>         <span class='hs-keyword'>then</span>  <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcIsConstraintKind</span> <span class='hs-varid'>actual_kind</span><span class='hs-layout'>)</span>
<a name="line-434"></a>                    <span class='hs-layout'>(</span><span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-435"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initialExpandMode</span>
<a name="line-436"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>check_pred_ty</span> <span class='hs-varid'>emptyTidyEnv</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>expand</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-437"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>addErrTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>constraintSynErr</span> <span class='hs-varid'>emptyTidyEnv</span> <span class='hs-varid'>actual_kind</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-438"></a>
<a name="line-439"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-440"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-441"></a>  <span class='hs-keyword'>where</span>
<a name="line-442"></a>    <span class='hs-varid'>actual_kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>ty</span>
<a name="line-443"></a>
<a name="line-444"></a><span class='hs-comment'>{-
<a name="line-445"></a>Note [Higher rank types]
<a name="line-446"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-447"></a>Technically
<a name="line-448"></a>            Int -&gt; forall a. a-&gt;a
<a name="line-449"></a>is still a rank-1 type, but it's not Haskell 98 (#5957).  So the
<a name="line-450"></a>validity checker allow a forall after an arrow only if we allow it
<a name="line-451"></a>before -- that is, with Rank2Types or RankNTypes
<a name="line-452"></a>-}</span>
<a name="line-453"></a>
<a name="line-454"></a><a name="Rank"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArbitraryRank</span>         <span class='hs-comment'>-- Any rank ok</span>
<a name="line-455"></a>
<a name="line-456"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LimitedRank</span>   <span class='hs-comment'>-- Note [Higher rank types]</span>
<a name="line-457"></a>                 <span class='hs-conid'>Bool</span>     <span class='hs-comment'>-- Forall ok at top</span>
<a name="line-458"></a>                 <span class='hs-conid'>Rank</span>     <span class='hs-comment'>-- Use for function arguments</span>
<a name="line-459"></a>
<a name="line-460"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MonoType</span> <span class='hs-conid'>SDoc</span>   <span class='hs-comment'>-- Monotype, with a suggestion of how it could be a polytype</span>
<a name="line-461"></a>
<a name="line-462"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MustBeMonoType</span>  <span class='hs-comment'>-- Monotype regardless of flags</span>
<a name="line-463"></a>
<a name="line-464"></a><a name="instance%20Outputable%20Rank"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Rank</span> <span class='hs-keyword'>where</span>
<a name="line-465"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>ArbitraryRank</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ArbitraryRank"</span>
<a name="line-466"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>LimitedRank</span> <span class='hs-varid'>top_forall_ok</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-467"></a>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"LimitedRank"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>top_forall_ok</span>
<a name="line-468"></a>                                          <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-469"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>MonoType</span> <span class='hs-varid'>msg</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"MonoType"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>msg</span>
<a name="line-470"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>MustBeMonoType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"MustBeMonoType"</span>
<a name="line-471"></a>
<a name="line-472"></a><a name="rankZeroMonoType"></a><span class='hs-definition'>rankZeroMonoType</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyConArgMonoType</span><span class='hs-layout'>,</span> <span class='hs-varid'>synArgMonoType</span><span class='hs-layout'>,</span> <span class='hs-varid'>constraintMonoType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span>
<a name="line-473"></a><span class='hs-definition'>rankZeroMonoType</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps you intended to use RankNTypes"</span><span class='hs-layout'>)</span>
<a name="line-474"></a><a name="tyConArgMonoType"></a><span class='hs-definition'>tyConArgMonoType</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps you intended to use ImpredicativeTypes"</span><span class='hs-layout'>)</span>
<a name="line-475"></a><a name="synArgMonoType"></a><span class='hs-definition'>synArgMonoType</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps you intended to use LiberalTypeSynonyms"</span><span class='hs-layout'>)</span>
<a name="line-476"></a><a name="constraintMonoType"></a><span class='hs-definition'>constraintMonoType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MonoType</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"A constraint must be a monotype"</span>
<a name="line-477"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps you intended to use QuantifiedConstraints"</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-478"></a>
<a name="line-479"></a><a name="funArgResRank"></a><span class='hs-definition'>funArgResRank</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rank</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rank</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- Function argument and result</span>
<a name="line-480"></a><span class='hs-definition'>funArgResRank</span> <span class='hs-layout'>(</span><span class='hs-conid'>LimitedRank</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_rank</span><span class='hs-layout'>,</span> <span class='hs-conid'>LimitedRank</span> <span class='hs-layout'>(</span><span class='hs-varid'>forAllAllowed</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>)</span>
<a name="line-481"></a><span class='hs-definition'>funArgResRank</span> <span class='hs-varid'>other_rank</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>other_rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>other_rank</span><span class='hs-layout'>)</span>
<a name="line-482"></a>
<a name="line-483"></a><a name="forAllAllowed"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-484"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-conid'>ArbitraryRank</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-485"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-layout'>(</span><span class='hs-conid'>LimitedRank</span> <span class='hs-varid'>forall_ok</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forall_ok</span>
<a name="line-486"></a><span class='hs-definition'>forAllAllowed</span> <span class='hs-keyword'>_</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-487"></a>
<a name="line-488"></a><a name="TypeOrKindCtxt"></a><span class='hs-comment'>-- | Indicates whether a 'UserTypeCtxt' represents type-level contexts,</span>
<a name="line-489"></a><a name="TypeOrKindCtxt"></a><span class='hs-comment'>-- kind-level contexts, or both.</span>
<a name="line-490"></a><a name="TypeOrKindCtxt"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TypeOrKindCtxt</span>
<a name="line-491"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-492"></a>    <span class='hs-comment'>-- ^ A 'UserTypeCtxt' that only represents type-level positions.</span>
<a name="line-493"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-494"></a>    <span class='hs-comment'>-- ^ A 'UserTypeCtxt' that only represents kind-level positions.</span>
<a name="line-495"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BothTypeAndKindCtxt</span>
<a name="line-496"></a>    <span class='hs-comment'>-- ^ A 'UserTypeCtxt' that can represent both type- and kind-level positions.</span>
<a name="line-497"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Eq</span>
<a name="line-498"></a>
<a name="line-499"></a><a name="instance%20Outputable%20TypeOrKindCtxt"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>TypeOrKindCtxt</span> <span class='hs-keyword'>where</span>
<a name="line-500"></a>  <span class='hs-varid'>ppr</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-501"></a>    <span class='hs-conid'>OnlyTypeCtxt</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"OnlyTypeCtxt"</span>
<a name="line-502"></a>    <span class='hs-conid'>OnlyKindCtxt</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"OnlyKindCtxt"</span>
<a name="line-503"></a>    <span class='hs-conid'>BothTypeAndKindCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"BothTypeAndKindCtxt"</span>
<a name="line-504"></a>
<a name="line-505"></a><a name="typeOrKindCtxt"></a><span class='hs-comment'>-- | Determine whether a 'UserTypeCtxt' can represent type-level contexts,</span>
<a name="line-506"></a><span class='hs-comment'>-- kind-level contexts, or both.</span>
<a name="line-507"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TypeOrKindCtxt</span>
<a name="line-508"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-509"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>InfSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-510"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ExprSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-511"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TypeAppCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-512"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>PatSynCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-513"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>PatSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-514"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>RuleSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-515"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-516"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DefaultDeclCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-517"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstDeclCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-518"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecInstCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-519"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-520"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassSCCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-521"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>SigmaCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-522"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataTyCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-523"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DerivClauseCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-524"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConArgCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyTypeCtxt</span>
<a name="line-525"></a>  <span class='hs-comment'>-- Although data constructors can be promoted with DataKinds, we always</span>
<a name="line-526"></a>  <span class='hs-comment'>-- validity-check them as though they are the types of terms. We may need</span>
<a name="line-527"></a>  <span class='hs-comment'>-- to revisit this decision if we ever allow visible dependent quantification</span>
<a name="line-528"></a>  <span class='hs-comment'>-- in the types of data constructors.</span>
<a name="line-529"></a>
<a name="line-530"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>KindSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-531"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>StandaloneKindSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-532"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarBndrKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-533"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-534"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySynKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-535"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyFamResKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OnlyKindCtxt</span>
<a name="line-536"></a>
<a name="line-537"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySynCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BothTypeAndKindCtxt</span>
<a name="line-538"></a>  <span class='hs-comment'>-- Type synonyms can have types and kinds on their RHSs</span>
<a name="line-539"></a><span class='hs-definition'>typeOrKindCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>GhciCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BothTypeAndKindCtxt</span>
<a name="line-540"></a>  <span class='hs-comment'>-- GHCi's :kind command accepts both types and kinds</span>
<a name="line-541"></a>
<a name="line-542"></a><a name="typeLevelUserTypeCtxt"></a><span class='hs-comment'>-- | Returns 'True' if the supplied 'UserTypeCtxt' is unambiguously not the</span>
<a name="line-543"></a><span class='hs-comment'>-- context for a kind of a type.</span>
<a name="line-544"></a><span class='hs-comment'>-- If the 'UserTypeCtxt' can refer to both types and kinds, this function</span>
<a name="line-545"></a><span class='hs-comment'>-- conservatively returns 'True'.</span>
<a name="line-546"></a><span class='hs-comment'>--</span>
<a name="line-547"></a><span class='hs-comment'>-- An example of something that is unambiguously the kind of a type is the</span>
<a name="line-548"></a><span class='hs-comment'>-- @Show a =&gt; a -&gt; a@ in @type Foo :: Show a =&gt; a -&gt; a@. On the other hand, the</span>
<a name="line-549"></a><span class='hs-comment'>-- same type in @foo :: Show a =&gt; a -&gt; a@ is unambiguously the type of a term,</span>
<a name="line-550"></a><span class='hs-comment'>-- not the kind of a type, so it is permitted.</span>
<a name="line-551"></a><span class='hs-definition'>typeLevelUserTypeCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-552"></a><span class='hs-definition'>typeLevelUserTypeCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>typeOrKindCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-553"></a>  <span class='hs-conid'>OnlyTypeCtxt</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-554"></a>  <span class='hs-conid'>OnlyKindCtxt</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-555"></a>  <span class='hs-conid'>BothTypeAndKindCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-556"></a>
<a name="line-557"></a><a name="allConstraintsAllowed"></a><span class='hs-comment'>-- | Returns 'True' if the supplied 'UserTypeCtxt' is unambiguously not the</span>
<a name="line-558"></a><span class='hs-comment'>-- context for a kind of a type, where the arbitrary use of constraints is</span>
<a name="line-559"></a><span class='hs-comment'>-- currently disallowed.</span>
<a name="line-560"></a><span class='hs-comment'>-- (See @Note [Constraints in kinds]@ in "GHC.Core.TyCo.Rep".)</span>
<a name="line-561"></a><span class='hs-definition'>allConstraintsAllowed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-562"></a><span class='hs-definition'>allConstraintsAllowed</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeLevelUserTypeCtxt</span>
<a name="line-563"></a>
<a name="line-564"></a><a name="linearityAllowed"></a><span class='hs-comment'>-- | Returns 'True' if the supplied 'UserTypeCtxt' is unambiguously not the</span>
<a name="line-565"></a><span class='hs-comment'>-- context for a kind of a type, where all function arrows currently</span>
<a name="line-566"></a><span class='hs-comment'>-- must be unrestricted.</span>
<a name="line-567"></a><span class='hs-definition'>linearityAllowed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-568"></a><span class='hs-definition'>linearityAllowed</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeLevelUserTypeCtxt</span>
<a name="line-569"></a>
<a name="line-570"></a><a name="vdqAllowed"></a><span class='hs-comment'>-- | Returns 'True' if the supplied 'UserTypeCtxt' is unambiguously not the</span>
<a name="line-571"></a><span class='hs-comment'>-- context for the type of a term, where visible, dependent quantification is</span>
<a name="line-572"></a><span class='hs-comment'>-- currently disallowed. If the 'UserTypeCtxt' can refer to both types and</span>
<a name="line-573"></a><span class='hs-comment'>-- kinds, this function conservatively returns 'True'.</span>
<a name="line-574"></a><span class='hs-comment'>--</span>
<a name="line-575"></a><span class='hs-comment'>-- An example of something that is unambiguously the type of a term is the</span>
<a name="line-576"></a><span class='hs-comment'>-- @forall a -&gt; a -&gt; a@ in @foo :: forall a -&gt; a -&gt; a@. On the other hand, the</span>
<a name="line-577"></a><span class='hs-comment'>-- same type in @type family Foo :: forall a -&gt; a -&gt; a@ is unambiguously the</span>
<a name="line-578"></a><span class='hs-comment'>-- kind of a type, not the type of a term, so it is permitted.</span>
<a name="line-579"></a><span class='hs-comment'>--</span>
<a name="line-580"></a><span class='hs-comment'>-- For more examples, see</span>
<a name="line-581"></a><span class='hs-comment'>-- @testsuite/tests/dependent/should_compile/T16326_Compile*.hs@ (for places</span>
<a name="line-582"></a><span class='hs-comment'>-- where VDQ is permitted) and</span>
<a name="line-583"></a><span class='hs-comment'>-- @testsuite/tests/dependent/should_fail/T16326_Fail*.hs@ (for places where</span>
<a name="line-584"></a><span class='hs-comment'>-- VDQ is disallowed).</span>
<a name="line-585"></a><span class='hs-definition'>vdqAllowed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-586"></a><span class='hs-definition'>vdqAllowed</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>typeOrKindCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-587"></a>  <span class='hs-conid'>OnlyTypeCtxt</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-588"></a>  <span class='hs-conid'>OnlyKindCtxt</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-589"></a>  <span class='hs-conid'>BothTypeAndKindCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-590"></a>
<a name="line-591"></a><span class='hs-comment'>{-
<a name="line-592"></a>Note [Correctness and performance of type synonym validity checking]
<a name="line-593"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-594"></a>Consider the type A arg1 arg2, where A is a type synonym. How should we check
<a name="line-595"></a>this type for validity? We have three distinct choices, corresponding to the
<a name="line-596"></a>three constructors of ExpandMode:
<a name="line-597"></a>
<a name="line-598"></a>1. Expand the application of A, and check the resulting type (`Expand`).
<a name="line-599"></a>2. Don't expand the application of A. Only check the arguments (`NoExpand`).
<a name="line-600"></a>3. Check the arguments *and* check the expanded type (`Both`).
<a name="line-601"></a>
<a name="line-602"></a>It's tempting to think that we could always just pick choice (3), but this
<a name="line-603"></a>results in serious performance issues when checking a type like in the
<a name="line-604"></a>signature for `f` below:
<a name="line-605"></a>
<a name="line-606"></a>  type S = ...
<a name="line-607"></a>  f :: S (S (S (S (S (S ....(S Int)...))))
<a name="line-608"></a>
<a name="line-609"></a>When checking the type of `f`, we'll check the outer `S` application with and
<a name="line-610"></a>without expansion, and in *each* of those checks, we'll check the next `S`
<a name="line-611"></a>application with and without expansion... the result is exponential blowup! So
<a name="line-612"></a>clearly we don't want to use `Both` 100% of the time.
<a name="line-613"></a>
<a name="line-614"></a>On the other hand, neither is it correct to use exclusively `Expand` or
<a name="line-615"></a>exclusively `NoExpand` 100% of the time:
<a name="line-616"></a>
<a name="line-617"></a>* If one always expands, then one can miss erroneous programs like the one in
<a name="line-618"></a>  the `tcfail129` test case:
<a name="line-619"></a>
<a name="line-620"></a>    type Foo a = String -&gt; Maybe a
<a name="line-621"></a>    type Bar m = m Int
<a name="line-622"></a>    blah = undefined :: Bar Foo
<a name="line-623"></a>
<a name="line-624"></a>  If we expand `Bar Foo` immediately, we'll miss the fact that the `Foo` type
<a name="line-625"></a>  synonyms is unsaturated.
<a name="line-626"></a>* If one never expands and only checks the arguments, then one can miss
<a name="line-627"></a>  erroneous programs like the one in #16059:
<a name="line-628"></a>
<a name="line-629"></a>    type Foo b = Eq b =&gt; b
<a name="line-630"></a>    f :: forall b (a :: Foo b). Int
<a name="line-631"></a>
<a name="line-632"></a>  The kind of `a` contains a constraint, which is illegal, but this will only
<a name="line-633"></a>  be caught if `Foo b` is expanded.
<a name="line-634"></a>
<a name="line-635"></a>Therefore, it's impossible to have these validity checks be simultaneously
<a name="line-636"></a>correct and performant if one sticks exclusively to a single `ExpandMode`. In
<a name="line-637"></a>that case, the solution is to vary the `ExpandMode`s! In more detail:
<a name="line-638"></a>
<a name="line-639"></a>1. When we start validity checking, we start with `Expand` if
<a name="line-640"></a>   LiberalTypeSynonyms is enabled (see Note [Liberal type synonyms] for why we
<a name="line-641"></a>   do this), and we start with `Both` otherwise. The `initialExpandMode`
<a name="line-642"></a>   function is responsible for this.
<a name="line-643"></a>2. When expanding an application of a type synonym (in `check_syn_tc_app`), we
<a name="line-644"></a>   determine which things to check based on the current `ExpandMode` argument.
<a name="line-645"></a>   Importantly, if the current mode is `Both`, then we check the arguments in
<a name="line-646"></a>   `NoExpand` mode and check the expanded type in `Both` mode.
<a name="line-647"></a>
<a name="line-648"></a>   Switching to `NoExpand` when checking the arguments is vital to avoid
<a name="line-649"></a>   exponential blowup. One consequence of this choice is that if you have
<a name="line-650"></a>   the following type synonym in one module (with RankNTypes enabled):
<a name="line-651"></a>
<a name="line-652"></a>     {-# LANGUAGE RankNTypes #-}
<a name="line-653"></a>     module A where
<a name="line-654"></a>     type A = forall a. a
<a name="line-655"></a>
<a name="line-656"></a>   And you define the following in a separate module *without* RankNTypes
<a name="line-657"></a>   enabled:
<a name="line-658"></a>
<a name="line-659"></a>     module B where
<a name="line-660"></a>
<a name="line-661"></a>     import A
<a name="line-662"></a>
<a name="line-663"></a>     type Const a b = a
<a name="line-664"></a>     f :: Const Int A -&gt; Int
<a name="line-665"></a>
<a name="line-666"></a>   Then `f` will be accepted, even though `A` (which is technically a rank-n
<a name="line-667"></a>   type) appears in its type. We view this as an acceptable compromise, since
<a name="line-668"></a>   `A` never appears in the type of `f` post-expansion. If `A` _did_ appear in
<a name="line-669"></a>   a type post-expansion, such as in the following variant:
<a name="line-670"></a>
<a name="line-671"></a>     g :: Const A A -&gt; Int
<a name="line-672"></a>
<a name="line-673"></a>   Then that would be rejected unless RankNTypes were enabled.
<a name="line-674"></a>-}</span>
<a name="line-675"></a>
<a name="line-676"></a><a name="ExpandMode"></a><span class='hs-comment'>-- | When validity-checking an application of a type synonym, should we</span>
<a name="line-677"></a><a name="ExpandMode"></a><span class='hs-comment'>-- check the arguments, check the expanded type, or both?</span>
<a name="line-678"></a><a name="ExpandMode"></a><span class='hs-comment'>-- See Note [Correctness and performance of type synonym validity checking]</span>
<a name="line-679"></a><a name="ExpandMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ExpandMode</span>
<a name="line-680"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expand</span>   <span class='hs-comment'>-- ^ Only check the expanded type.</span>
<a name="line-681"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NoExpand</span> <span class='hs-comment'>-- ^ Only check the arguments.</span>
<a name="line-682"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Both</span>     <span class='hs-comment'>-- ^ Check both the arguments and the expanded type.</span>
<a name="line-683"></a>
<a name="line-684"></a><a name="instance%20Outputable%20ExpandMode"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ExpandMode</span> <span class='hs-keyword'>where</span>
<a name="line-685"></a>  <span class='hs-varid'>ppr</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>of</span>
<a name="line-686"></a>                   <span class='hs-conid'>Expand</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"Expand"</span>
<a name="line-687"></a>                   <span class='hs-conid'>NoExpand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"NoExpand"</span>
<a name="line-688"></a>                   <span class='hs-conid'>Both</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-str'>"Both"</span>
<a name="line-689"></a>
<a name="line-690"></a><a name="initialExpandMode"></a><span class='hs-comment'>-- | If @LiberalTypeSynonyms@ is enabled, we start in 'Expand' mode for the</span>
<a name="line-691"></a><span class='hs-comment'>-- reasons explained in @Note [Liberal type synonyms]@. Otherwise, we start</span>
<a name="line-692"></a><span class='hs-comment'>-- in 'Both' mode.</span>
<a name="line-693"></a><span class='hs-definition'>initialExpandMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>ExpandMode</span>
<a name="line-694"></a><span class='hs-definition'>initialExpandMode</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-695"></a>  <span class='hs-varid'>liberal_flag</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.LiberalTypeSynonyms</span>
<a name="line-696"></a>  <span class='hs-varid'>pure</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>liberal_flag</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>Expand</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Both</span>
<a name="line-697"></a>
<a name="line-698"></a><a name="ValidityEnv"></a><span class='hs-comment'>-- | Information about a type being validity-checked.</span>
<a name="line-699"></a><a name="ValidityEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ValidityEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValidityEnv</span>
<a name="line-700"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span>
<a name="line-701"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span>
<a name="line-702"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rank</span>
<a name="line-703"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExpandMode</span> <span class='hs-layout'>}</span>
<a name="line-704"></a>
<a name="line-705"></a><a name="instance%20Outputable%20ValidityEnv"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ValidityEnv</span> <span class='hs-keyword'>where</span>
<a name="line-706"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span>
<a name="line-707"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-708"></a>    <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"ValidityEnv"</span><span class='hs-layout'>)</span>
<a name="line-709"></a>       <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ve_tidy_env"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>env</span>
<a name="line-710"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ve_ctxt"</span>     <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprUserTypeCtxt</span> <span class='hs-varid'>ctxt</span>
<a name="line-711"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ve_rank"</span>     <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rank</span>
<a name="line-712"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ve_expand"</span>   <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-713"></a>
<a name="line-714"></a><a name="check_type"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-715"></a><span class='hs-definition'>check_type</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValidityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-716"></a><span class='hs-comment'>-- The args say what the *type context* requires, independent</span>
<a name="line-717"></a><span class='hs-comment'>-- of *flag* settings.  You test the flag settings at usage sites.</span>
<a name="line-718"></a><span class='hs-comment'>--</span>
<a name="line-719"></a><span class='hs-comment'>-- Rank is allowed rank for function args</span>
<a name="line-720"></a><span class='hs-comment'>-- Rank 0 means no for-alls anywhere</span>
<a name="line-721"></a>
<a name="line-722"></a><span class='hs-definition'>check_type</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-723"></a>
<a name="line-724"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-725"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty1</span>
<a name="line-726"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_arg_type</span> <span class='hs-conid'>False</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span>
<a name="line-727"></a>
<a name="line-728"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-729"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeSynonymTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-730"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_syn_tc_app</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-731"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnboxedTupleTyCon</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_ubx_tuple</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span>
<a name="line-732"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_arg_type</span> <span class='hs-conid'>False</span> <span class='hs-varid'>ve</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-733"></a>
<a name="line-734"></a><span class='hs-definition'>check_type</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-735"></a>
<a name="line-736"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>ty</span>
<a name="line-737"></a>
<a name="line-738"></a><span class='hs-comment'>-- Check for rank-n types, such as (forall x. x -&gt; x) or (Show x =&gt; x).</span>
<a name="line-739"></a><span class='hs-comment'>--</span>
<a name="line-740"></a><span class='hs-comment'>-- Critically, this case must come *after* the case for TyConApp.</span>
<a name="line-741"></a><span class='hs-comment'>-- See Note [Liberal type synonyms].</span>
<a name="line-742"></a><span class='hs-definition'>check_type</span> <span class='hs-varid'>ve</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span>
<a name="line-743"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-744"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>tvbs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-745"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"check_type"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rank</span><span class='hs-layout'>)</span>
<a name="line-746"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>forAllAllowed</span> <span class='hs-varid'>rank</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>forAllTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-747"></a>                <span class='hs-comment'>-- Reject e.g. (Maybe (?x::Int =&gt; Int)),</span>
<a name="line-748"></a>                <span class='hs-comment'>-- with a decent error message</span>
<a name="line-749"></a>
<a name="line-750"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkConstraintsOK</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>ty</span>
<a name="line-751"></a>                <span class='hs-comment'>-- Reject forall (a :: Eq b =&gt; b). blah</span>
<a name="line-752"></a>                <span class='hs-comment'>-- In a kind signature we don't allow constraints</span>
<a name="line-753"></a>
<a name="line-754"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInvisibleArgFlag</span> <span class='hs-varop'>.</span> <span class='hs-varid'>binderArgFlag</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvbs</span>
<a name="line-755"></a>                         <span class='hs-varop'>||</span> <span class='hs-varid'>vdqAllowed</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span>
<a name="line-756"></a>                   <span class='hs-layout'>(</span><span class='hs-varid'>illegalVDQTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-757"></a>                <span class='hs-comment'>-- Reject visible, dependent quantification in the type of a</span>
<a name="line-758"></a>                <span class='hs-comment'>-- term (e.g., `f :: forall a -&gt; a -&gt; Maybe a`)</span>
<a name="line-759"></a>
<a name="line-760"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_valid_theta</span> <span class='hs-varid'>env'</span> <span class='hs-conid'>SigmaCtxt</span> <span class='hs-varid'>expand</span> <span class='hs-varid'>theta</span>
<a name="line-761"></a>                <span class='hs-comment'>-- Allow     type T = ?x::Int =&gt; Int -&gt; Int</span>
<a name="line-762"></a>                <span class='hs-comment'>-- but not   type T = ?x::Int</span>
<a name="line-763"></a>
<a name="line-764"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>tau</span>
<a name="line-765"></a>                <span class='hs-comment'>-- Allow foralls to right of arrow</span>
<a name="line-766"></a>
<a name="line-767"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkEscapingKind</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>tvbs'</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tau</span> <span class='hs-layout'>}</span>
<a name="line-768"></a>  <span class='hs-keyword'>where</span>
<a name="line-769"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvbs</span><span class='hs-layout'>,</span> <span class='hs-varid'>phi</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTyVarBinders</span> <span class='hs-varid'>ty</span>
<a name="line-770"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitPhiTy</span> <span class='hs-varid'>phi</span>
<a name="line-771"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tvbs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidyTyCoVarBinders</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvbs</span>
<a name="line-772"></a>
<a name="line-773"></a><span class='hs-definition'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span>
<a name="line-774"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-775"></a>           <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span>
<a name="line-776"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>failIfTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>linearityAllowed</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isManyDataConTy</span> <span class='hs-varid'>mult</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-777"></a>                     <span class='hs-layout'>(</span><span class='hs-varid'>linearFunKindErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-778"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_rank</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_ty</span>
<a name="line-779"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res_rank</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>res_ty</span> <span class='hs-layout'>}</span>
<a name="line-780"></a>  <span class='hs-keyword'>where</span>
<a name="line-781"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>arg_rank</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_rank</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funArgResRank</span> <span class='hs-varid'>rank</span>
<a name="line-782"></a>
<a name="line-783"></a><span class='hs-definition'>check_type</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"check_type"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-784"></a>
<a name="line-785"></a><a name="check_syn_tc_app"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-786"></a><span class='hs-definition'>check_syn_tc_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValidityEnv</span>
<a name="line-787"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-788"></a><span class='hs-comment'>-- Used for type synonyms and type synonym families,</span>
<a name="line-789"></a><span class='hs-comment'>-- which must be saturated,</span>
<a name="line-790"></a><span class='hs-comment'>-- but not data families, which need not be saturated</span>
<a name="line-791"></a><span class='hs-definition'>check_syn_tc_app</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-792"></a>                 <span class='hs-varid'>ty</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-793"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>tc_arity</span>   <span class='hs-comment'>-- Saturated</span>
<a name="line-794"></a>       <span class='hs-comment'>-- Check that the synonym has enough args</span>
<a name="line-795"></a>       <span class='hs-comment'>-- This applies equally to open and closed synonyms</span>
<a name="line-796"></a>       <span class='hs-comment'>-- It's OK to have an *over-applied* type synonym</span>
<a name="line-797"></a>       <span class='hs-comment'>--      data Tree a b = ...</span>
<a name="line-798"></a>       <span class='hs-comment'>--      type Foo a = Tree [a]</span>
<a name="line-799"></a>       <span class='hs-comment'>--      f :: Foo a b -&gt; ...</span>
<a name="line-800"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>expand</span> <span class='hs-keyword'>of</span>
<a name="line-801"></a>      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-802"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_args_only</span> <span class='hs-varid'>expand</span>
<a name="line-803"></a>      <span class='hs-comment'>-- See Note [Correctness and performance of type synonym validity</span>
<a name="line-804"></a>      <span class='hs-comment'>--           checking]</span>
<a name="line-805"></a>      <span class='hs-conid'>Expand</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_expansion_only</span> <span class='hs-varid'>expand</span>
<a name="line-806"></a>      <span class='hs-conid'>NoExpand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_args_only</span> <span class='hs-varid'>expand</span>
<a name="line-807"></a>      <span class='hs-conid'>Both</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_args_only</span> <span class='hs-conid'>NoExpand</span> <span class='hs-varop'>*&gt;</span> <span class='hs-varid'>check_expansion_only</span> <span class='hs-conid'>Both</span>
<a name="line-808"></a>
<a name="line-809"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GhciCtxt</span> <span class='hs-conid'>True</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctxt</span>  <span class='hs-comment'>-- Accept outermost under-saturated type synonym or</span>
<a name="line-810"></a>                           <span class='hs-comment'>-- type family constructors in GHCi :kind commands.</span>
<a name="line-811"></a>                           <span class='hs-comment'>-- See Note [Unsaturated type synonyms in GHCi]</span>
<a name="line-812"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_args_only</span> <span class='hs-varid'>expand</span>
<a name="line-813"></a>
<a name="line-814"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-815"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArityErr</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-816"></a>  <span class='hs-keyword'>where</span>
<a name="line-817"></a>    <span class='hs-varid'>tc_arity</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span>
<a name="line-818"></a>
<a name="line-819"></a>    <span class='hs-varid'>check_arg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExpandMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-820"></a>    <span class='hs-varid'>check_arg</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>=</span>
<a name="line-821"></a>      <span class='hs-varid'>check_arg_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeSynonymTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-822"></a>
<a name="line-823"></a>    <span class='hs-varid'>check_args_only</span><span class='hs-layout'>,</span> <span class='hs-varid'>check_expansion_only</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExpandMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-824"></a>    <span class='hs-varid'>check_args_only</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_arg</span> <span class='hs-varid'>expand</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-825"></a>
<a name="line-826"></a>    <span class='hs-varid'>check_expansion_only</span> <span class='hs-varid'>expand</span>
<a name="line-827"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isTypeSynonymTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>)</span>
<a name="line-828"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-829"></a>         <span class='hs-conid'>Just</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>err_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"In the expansion of type synonym"</span>
<a name="line-830"></a>                                    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-831"></a>                     <span class='hs-keyword'>in</span> <span class='hs-varid'>addErrCtxt</span> <span class='hs-varid'>err_ctxt</span> <span class='hs-varop'>$</span>
<a name="line-832"></a>                        <span class='hs-varid'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_expand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty'</span>
<a name="line-833"></a>         <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"check_syn_tc_app"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-834"></a>
<a name="line-835"></a><span class='hs-comment'>{-
<a name="line-836"></a>Note [Unsaturated type synonyms in GHCi]
<a name="line-837"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-838"></a>Generally speaking, GHC disallows unsaturated uses of type synonyms or type
<a name="line-839"></a>families. For instance, if one defines `type Const a b = a`, then GHC will not
<a name="line-840"></a>permit using `Const` unless it is applied to (at least) two arguments. There is
<a name="line-841"></a>an exception to this rule, however: GHCi's :kind command. For instance, it
<a name="line-842"></a>is quite common to look up the kind of a type constructor like so:
<a name="line-843"></a>
<a name="line-844"></a>  λ&gt; :kind Const
<a name="line-845"></a>  Const :: j -&gt; k -&gt; j
<a name="line-846"></a>  λ&gt; :kind Const Int
<a name="line-847"></a>  Const Int :: k -&gt; Type
<a name="line-848"></a>
<a name="line-849"></a>Strictly speaking, the two uses of `Const` above are unsaturated, but this
<a name="line-850"></a>is an extremely benign (and useful) example of unsaturation, so we allow it
<a name="line-851"></a>here as a special case.
<a name="line-852"></a>
<a name="line-853"></a>That being said, we do not allow unsaturation carte blanche in GHCi. Otherwise,
<a name="line-854"></a>this GHCi interaction would be possible:
<a name="line-855"></a>
<a name="line-856"></a>  λ&gt; newtype Fix f = MkFix (f (Fix f))
<a name="line-857"></a>  λ&gt; type Id a = a
<a name="line-858"></a>  λ&gt; :kind Fix Id
<a name="line-859"></a>  Fix Id :: Type
<a name="line-860"></a>
<a name="line-861"></a>This is rather dodgy, so we move to disallow this. We only permit unsaturated
<a name="line-862"></a>synonyms in GHCi if they are *top-level*—that is, if the synonym is the
<a name="line-863"></a>outermost type being applied. This allows `Const` and `Const Int` in the
<a name="line-864"></a>first example, but not `Fix Id` in the second example, as `Id` is not the
<a name="line-865"></a>outermost type being applied (`Fix` is).
<a name="line-866"></a>
<a name="line-867"></a>We track this outermost property in the GhciCtxt constructor of UserTypeCtxt.
<a name="line-868"></a>A field of True in GhciCtxt indicates that we're in an outermost position. Any
<a name="line-869"></a>time we invoke `check_arg` to check the validity of an argument, we switch the
<a name="line-870"></a>field to False.
<a name="line-871"></a>-}</span>
<a name="line-872"></a>
<a name="line-873"></a><a name="check_ubx_tuple"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-874"></a><span class='hs-definition'>check_ubx_tuple</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValidityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-875"></a><span class='hs-definition'>check_ubx_tuple</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span>
<a name="line-876"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>ub_tuples_allowed</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.UnboxedTuples</span>
<a name="line-877"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>checkTcM</span> <span class='hs-varid'>ub_tuples_allowed</span> <span class='hs-layout'>(</span><span class='hs-varid'>ubxArgTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-878"></a>
<a name="line-879"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>impred</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.ImpredicativeTypes</span>
<a name="line-880"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rank'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>impred</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>ArbitraryRank</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>tyConArgMonoType</span>
<a name="line-881"></a>                <span class='hs-comment'>-- c.f. check_arg_type</span>
<a name="line-882"></a>                <span class='hs-comment'>-- However, args are allowed to be unlifted, or</span>
<a name="line-883"></a>                <span class='hs-comment'>-- more unboxed tuples, so can't use check_arg_ty</span>
<a name="line-884"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank'</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span>
<a name="line-885"></a>
<a name="line-886"></a><a name="check_arg_type"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-887"></a><span class='hs-definition'>check_arg_type</span>
<a name="line-888"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-comment'>-- ^ Is this the argument to a type synonym?</span>
<a name="line-889"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ValidityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-890"></a><span class='hs-comment'>-- The sort of type that can instantiate a type variable,</span>
<a name="line-891"></a><span class='hs-comment'>-- or be the argument of a type constructor.</span>
<a name="line-892"></a><span class='hs-comment'>-- Not an unboxed tuple, but now *can* be a forall (since impredicativity)</span>
<a name="line-893"></a><span class='hs-comment'>-- Other unboxed types are very occasionally allowed as type</span>
<a name="line-894"></a><span class='hs-comment'>-- arguments depending on the kind of the type constructor</span>
<a name="line-895"></a><span class='hs-comment'>--</span>
<a name="line-896"></a><span class='hs-comment'>-- For example, we want to reject things like:</span>
<a name="line-897"></a><span class='hs-comment'>--</span>
<a name="line-898"></a><span class='hs-comment'>--      instance Ord a =&gt; Ord (forall s. T s a)</span>
<a name="line-899"></a><span class='hs-comment'>-- and</span>
<a name="line-900"></a><span class='hs-comment'>--      g :: T s (forall b.b)</span>
<a name="line-901"></a><span class='hs-comment'>--</span>
<a name="line-902"></a><span class='hs-comment'>-- NB: unboxed tuples can have polymorphic or unboxed args.</span>
<a name="line-903"></a><span class='hs-comment'>--     This happens in the workers for functions returning</span>
<a name="line-904"></a><span class='hs-comment'>--     product types with polymorphic components.</span>
<a name="line-905"></a><span class='hs-comment'>--     But not in user code.</span>
<a name="line-906"></a><span class='hs-comment'>-- Anyway, they are dealt with by a special case in check_tau_type</span>
<a name="line-907"></a>
<a name="line-908"></a><span class='hs-definition'>check_arg_type</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-909"></a>
<a name="line-910"></a><span class='hs-definition'>check_arg_type</span> <span class='hs-varid'>type_syn</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-911"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>impred</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.ImpredicativeTypes</span>
<a name="line-912"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rank'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rank</span> <span class='hs-keyword'>of</span>          <span class='hs-comment'>-- Predictive =&gt; must be monotype</span>
<a name="line-913"></a>                        <span class='hs-comment'>-- Rank-n arguments to type synonyms are OK, provided</span>
<a name="line-914"></a>                        <span class='hs-comment'>-- that LiberalTypeSynonyms is enabled.</span>
<a name="line-915"></a>                        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>type_syn</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>synArgMonoType</span>
<a name="line-916"></a>                        <span class='hs-conid'>MustBeMonoType</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MustBeMonoType</span>  <span class='hs-comment'>-- Monotype, regardless</span>
<a name="line-917"></a>                        <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>impred</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-918"></a>                               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyConArgMonoType</span>
<a name="line-919"></a>                        <span class='hs-comment'>-- Make sure that MustBeMonoType is propagated,</span>
<a name="line-920"></a>                        <span class='hs-comment'>-- so that we don't suggest -XImpredicativeTypes in</span>
<a name="line-921"></a>                        <span class='hs-comment'>--    (Ord (forall a.a)) =&gt; a -&gt; a</span>
<a name="line-922"></a>                        <span class='hs-comment'>-- and so that if it Must be a monotype, we check that it is!</span>
<a name="line-923"></a>              <span class='hs-varid'>ctxt'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span>
<a name="line-924"></a>              <span class='hs-varid'>ctxt'</span>
<a name="line-925"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GhciCtxt</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GhciCtxt</span> <span class='hs-conid'>False</span>
<a name="line-926"></a>                    <span class='hs-comment'>-- When checking an argument, set the field of GhciCtxt to</span>
<a name="line-927"></a>                    <span class='hs-comment'>-- False to indicate that we are no longer in an outermost</span>
<a name="line-928"></a>                    <span class='hs-comment'>-- position (and thus unsaturated synonyms are no longer</span>
<a name="line-929"></a>                    <span class='hs-comment'>-- allowed).</span>
<a name="line-930"></a>                    <span class='hs-comment'>-- See Note [Unsaturated type synonyms in GHCi]</span>
<a name="line-931"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt</span>
<a name="line-932"></a>
<a name="line-933"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_type</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve</span><span class='hs-layout'>{</span><span class='hs-varid'>ve_ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctxt'</span><span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank'</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-934"></a>
<a name="line-935"></a><a name="forAllTyErr"></a><span class='hs-comment'>----------------------------------------</span>
<a name="line-936"></a><span class='hs-definition'>forAllTyErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Rank</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-937"></a><span class='hs-definition'>forAllTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rank</span> <span class='hs-varid'>ty</span>
<a name="line-938"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-939"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-varid'>herald</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-940"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>suggestion</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>
<a name="line-941"></a>  <span class='hs-keyword'>where</span>
<a name="line-942"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-sel'>_rho</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTyVars</span> <span class='hs-varid'>ty</span>
<a name="line-943"></a>    <span class='hs-varid'>herald</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal qualified type:"</span>
<a name="line-944"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal polymorphic type:"</span>
<a name="line-945"></a>    <span class='hs-varid'>suggestion</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>rank</span> <span class='hs-keyword'>of</span>
<a name="line-946"></a>                   <span class='hs-conid'>LimitedRank</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps you intended to use RankNTypes"</span>
<a name="line-947"></a>                   <span class='hs-conid'>MonoType</span> <span class='hs-varid'>d</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>d</span>
<a name="line-948"></a>                   <span class='hs-keyword'>_</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Outputable.empty</span> <span class='hs-comment'>-- Polytype is always illegal</span>
<a name="line-949"></a>
<a name="line-950"></a><a name="checkEscapingKind"></a><span class='hs-comment'>-- | Reject type variables that would escape their escape through a kind.</span>
<a name="line-951"></a><span class='hs-comment'>-- See @Note [Type variables escaping through kinds]@.</span>
<a name="line-952"></a><span class='hs-definition'>checkEscapingKind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVarBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-953"></a><span class='hs-definition'>checkEscapingKind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvbs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tau</span> <span class='hs-keyglyph'>=</span>
<a name="line-954"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>occCheckExpand</span> <span class='hs-layout'>(</span><span class='hs-varid'>binderVars</span> <span class='hs-varid'>tvbs</span><span class='hs-layout'>)</span> <span class='hs-varid'>phi_kind</span> <span class='hs-keyword'>of</span>
<a name="line-955"></a>    <span class='hs-comment'>-- Ensure that none of the tvs occur in the kind of the forall</span>
<a name="line-956"></a>    <span class='hs-comment'>-- /after/ expanding type synonyms.</span>
<a name="line-957"></a>    <span class='hs-comment'>-- See Note [Phantom type variables in kinds] in GHC.Core.Type</span>
<a name="line-958"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>failWithTcM</span> <span class='hs-varop'>$</span> <span class='hs-varid'>forAllEscapeErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvbs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tau</span> <span class='hs-varid'>tau_kind</span>
<a name="line-959"></a>    <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-960"></a>  <span class='hs-keyword'>where</span>
<a name="line-961"></a>    <span class='hs-varid'>tau_kind</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>tau</span>
<a name="line-962"></a>    <span class='hs-varid'>phi_kind</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tau_kind</span>
<a name="line-963"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftedTypeKind</span>
<a name="line-964"></a>        <span class='hs-comment'>-- If there are any constraints, the kind is *. (#11405)</span>
<a name="line-965"></a>
<a name="line-966"></a><a name="forAllEscapeErr"></a><span class='hs-definition'>forAllEscapeErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVarBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Kind</span>
<a name="line-967"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-968"></a><span class='hs-definition'>forAllEscapeErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tvbs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tau</span> <span class='hs-varid'>tau_kind</span>
<a name="line-969"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-970"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Quantified type's kind mentions quantified type variable"</span><span class='hs-layout'>)</span>
<a name="line-971"></a>                <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"type:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSigmaTy</span> <span class='hs-varid'>tvbs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-972"></a>                <span class='hs-comment'>-- NB: Don't tidy this type since the tvbs were already tidied</span>
<a name="line-973"></a>                <span class='hs-comment'>-- previously, and re-tidying them will make the names of type</span>
<a name="line-974"></a>                <span class='hs-comment'>-- variables different from tau_kind.</span>
<a name="line-975"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"where the body of the forall has this kind:"</span><span class='hs-layout'>)</span>
<a name="line-976"></a>                <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tau_kind</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>
<a name="line-977"></a>
<a name="line-978"></a><span class='hs-comment'>{-
<a name="line-979"></a>Note [Type variables escaping through kinds]
<a name="line-980"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-981"></a>Consider:
<a name="line-982"></a>
<a name="line-983"></a>  type family T (r :: RuntimeRep) :: TYPE r
<a name="line-984"></a>  foo :: forall r. T r
<a name="line-985"></a>
<a name="line-986"></a>Something smells funny about the type of `foo`. If you spell out the kind
<a name="line-987"></a>explicitly, it becomes clearer from where the smell originates:
<a name="line-988"></a>
<a name="line-989"></a>  foo :: ((forall r. T r) :: TYPE r)
<a name="line-990"></a>
<a name="line-991"></a>The type variable `r` appears in the result kind, which escapes the scope of
<a name="line-992"></a>its binding site! This is not desirable, so we establish a validity check
<a name="line-993"></a>(`checkEscapingKind`) to catch any type variables that might escape through
<a name="line-994"></a>kinds in this way.
<a name="line-995"></a>-}</span>
<a name="line-996"></a>
<a name="line-997"></a><a name="ubxArgTyErr"></a><span class='hs-definition'>ubxArgTyErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-998"></a><span class='hs-definition'>ubxArgTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-999"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal unboxed tuple type as function argument:"</span>
<a name="line-1000"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>]</span>
<a name="line-1001"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps you intended to use UnboxedTuples"</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>
<a name="line-1002"></a>
<a name="line-1003"></a><a name="checkConstraintsOK"></a><span class='hs-definition'>checkConstraintsOK</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValidityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1004"></a><span class='hs-definition'>checkConstraintsOK</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>ty</span>
<a name="line-1005"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1006"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>allConstraintsAllowed</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve_ctxt</span> <span class='hs-varid'>ve</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1007"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1008"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- We are in a kind, where we allow only equality predicates</span>
<a name="line-1009"></a>    <span class='hs-comment'>-- See Note [Constraints in kinds] in GHC.Core.TyCo.Rep, and #16263</span>
<a name="line-1010"></a>    <span class='hs-varid'>checkTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>isEqPred</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1011"></a>    <span class='hs-varid'>constraintTyErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ve_tidy_env</span> <span class='hs-varid'>ve</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-1012"></a>
<a name="line-1013"></a><a name="constraintTyErr"></a><span class='hs-definition'>constraintTyErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1014"></a><span class='hs-definition'>constraintTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1015"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal constraint in a kind:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1016"></a>
<a name="line-1017"></a><a name="illegalVDQTyErr"></a><span class='hs-comment'>-- | Reject a use of visible, dependent quantification in the type of a term.</span>
<a name="line-1018"></a><span class='hs-definition'>illegalVDQTyErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1019"></a><span class='hs-definition'>illegalVDQTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span>
<a name="line-1020"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>vcat</span>
<a name="line-1021"></a>  <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal visible, dependent quantification"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-1022"></a>          <span class='hs-varid'>text</span> <span class='hs-str'>"in the type of a term:"</span><span class='hs-layout'>)</span>
<a name="line-1023"></a>       <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1024"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"(GHC does not yet support this)"</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>
<a name="line-1025"></a>
<a name="line-1026"></a><a name="linearFunKindErr"></a><span class='hs-comment'>-- | Reject uses of linear function arrows in kinds.</span>
<a name="line-1027"></a><span class='hs-definition'>linearFunKindErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1028"></a><span class='hs-definition'>linearFunKindErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span>
<a name="line-1029"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal linear function in a kind:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1030"></a>
<a name="line-1031"></a><span class='hs-comment'>{-
<a name="line-1032"></a>Note [Liberal type synonyms]
<a name="line-1033"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1034"></a>If -XLiberalTypeSynonyms is on, expand closed type synonyms *before*
<a name="line-1035"></a>doing validity checking.  This allows us to instantiate a synonym defn
<a name="line-1036"></a>with a for-all type, or with a partially-applied type synonym.
<a name="line-1037"></a>        e.g.   type T a b = a
<a name="line-1038"></a>               type S m   = m ()
<a name="line-1039"></a>               f :: S (T Int)
<a name="line-1040"></a>Here, T is partially applied, so it's illegal in H98.  But if you
<a name="line-1041"></a>expand S first, then T we get just
<a name="line-1042"></a>               f :: Int
<a name="line-1043"></a>which is fine.
<a name="line-1044"></a>
<a name="line-1045"></a>IMPORTANT: suppose T is a type synonym.  Then we must do validity
<a name="line-1046"></a>checking on an application (T ty1 ty2)
<a name="line-1047"></a>
<a name="line-1048"></a>        *either* before expansion (i.e. check ty1, ty2)
<a name="line-1049"></a>        *or* after expansion (i.e. expand T ty1 ty2, and then check)
<a name="line-1050"></a>        BUT NOT BOTH
<a name="line-1051"></a>
<a name="line-1052"></a>If we do both, we get exponential behaviour!!
<a name="line-1053"></a>
<a name="line-1054"></a>  data TIACons1 i r c = c i ::: r c
<a name="line-1055"></a>  type TIACons2 t x = TIACons1 t (TIACons1 t x)
<a name="line-1056"></a>  type TIACons3 t x = TIACons2 t (TIACons1 t x)
<a name="line-1057"></a>  type TIACons4 t x = TIACons2 t (TIACons2 t x)
<a name="line-1058"></a>  type TIACons7 t x = TIACons4 t (TIACons3 t x)
<a name="line-1059"></a>
<a name="line-1060"></a>The order in which you do validity checking is also somewhat delicate. Consider
<a name="line-1061"></a>the `check_type` function, which drives the validity checking for unsaturated
<a name="line-1062"></a>uses of type synonyms. There is a special case for rank-n types, such as
<a name="line-1063"></a>(forall x. x -&gt; x) or (Show x =&gt; x), since those require at least one language
<a name="line-1064"></a>extension to use. It used to be the case that this case came before every other
<a name="line-1065"></a>case, but this can lead to bugs. Imagine you have this scenario (from #15954):
<a name="line-1066"></a>
<a name="line-1067"></a>  type A a = Int
<a name="line-1068"></a>  type B (a :: Type -&gt; Type) = forall x. x -&gt; x
<a name="line-1069"></a>  type C = B A
<a name="line-1070"></a>
<a name="line-1071"></a>If the rank-n case came first, then in the process of checking for `forall`s
<a name="line-1072"></a>or contexts, we would expand away `B A` to `forall x. x -&gt; x`. This is because
<a name="line-1073"></a>the functions that split apart `forall`s/contexts
<a name="line-1074"></a>(tcSplitForAllTyVarBinders/tcSplitPhiTy) expand type synonyms! If `B A` is expanded
<a name="line-1075"></a>away to `forall x. x -&gt; x` before the actually validity checks occur, we will
<a name="line-1076"></a>have completely obfuscated the fact that we had an unsaturated application of
<a name="line-1077"></a>the `A` type synonym.
<a name="line-1078"></a>
<a name="line-1079"></a>We have since learned from our mistakes and now put this rank-n case /after/
<a name="line-1080"></a>the case for TyConApp, which ensures that an unsaturated `A` TyConApp will be
<a name="line-1081"></a>caught properly. But be careful! We can't make the rank-n case /last/ either,
<a name="line-1082"></a>as the FunTy case must came after the rank-n case. Otherwise, something like
<a name="line-1083"></a>(Eq a =&gt; Int) would be treated as a function type (FunTy), which just
<a name="line-1084"></a>wouldn't do.
<a name="line-1085"></a>
<a name="line-1086"></a>************************************************************************
<a name="line-1087"></a>*                                                                      *
<a name="line-1088"></a>\subsection{Checking a theta or source type}
<a name="line-1089"></a>*                                                                      *
<a name="line-1090"></a>************************************************************************
<a name="line-1091"></a>
<a name="line-1092"></a>Note [Implicit parameters in instance decls]
<a name="line-1093"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1094"></a>Implicit parameters _only_ allowed in type signatures; not in instance
<a name="line-1095"></a>decls, superclasses etc. The reason for not allowing implicit params in
<a name="line-1096"></a>instances is a bit subtle.  If we allowed
<a name="line-1097"></a>  instance (?x::Int, Eq a) =&gt; Foo [a] where ...
<a name="line-1098"></a>then when we saw
<a name="line-1099"></a>     (e :: (?x::Int) =&gt; t)
<a name="line-1100"></a>it would be unclear how to discharge all the potential uses of the ?x
<a name="line-1101"></a>in e.  For example, a constraint Foo [Int] might come out of e, and
<a name="line-1102"></a>applying the instance decl would show up two uses of ?x.  #8912.
<a name="line-1103"></a>-}</span>
<a name="line-1104"></a>
<a name="line-1105"></a><a name="checkValidTheta"></a><span class='hs-definition'>checkValidTheta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1106"></a><span class='hs-comment'>-- Assumes argument is fully zonked</span>
<a name="line-1107"></a><span class='hs-definition'>checkValidTheta</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span>
<a name="line-1108"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addErrCtxtM</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkThetaCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1109"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInitOpenTidyEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfTypesList</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-1110"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initialExpandMode</span>
<a name="line-1111"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_valid_theta</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>expand</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>}</span>
<a name="line-1112"></a>
<a name="line-1113"></a><a name="check_valid_theta"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1114"></a><span class='hs-definition'>check_valid_theta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExpandMode</span>
<a name="line-1115"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1116"></a><span class='hs-definition'>check_valid_theta</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-1117"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1118"></a><span class='hs-definition'>check_valid_theta</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>expand</span> <span class='hs-varid'>theta</span>
<a name="line-1119"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1120"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>warnTcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reason</span> <span class='hs-conid'>Opt_WarnDuplicateConstraints</span><span class='hs-layout'>)</span>
<a name="line-1121"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>wopt</span> <span class='hs-conid'>Opt_WarnDuplicateConstraints</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>notNull</span> <span class='hs-varid'>dups</span><span class='hs-layout'>)</span>
<a name="line-1122"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>dupPredWarn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dups</span><span class='hs-layout'>)</span>
<a name="line-1123"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"check_valid_theta"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-1124"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_pred_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>expand</span><span class='hs-layout'>)</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>}</span>
<a name="line-1125"></a>  <span class='hs-keyword'>where</span>
<a name="line-1126"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>dups</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>removeDups</span> <span class='hs-varid'>nonDetCmpType</span> <span class='hs-varid'>theta</span>
<a name="line-1127"></a>    <span class='hs-comment'>-- It's OK to use nonDetCmpType because dups only appears in the</span>
<a name="line-1128"></a>    <span class='hs-comment'>-- warning</span>
<a name="line-1129"></a>
<a name="line-1130"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1131"></a><span class='hs-comment'>{- Note [Validity checking for constraints]
<a name="line-1132"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1133"></a>We look through constraint synonyms so that we can see the underlying
<a name="line-1134"></a>constraint(s).  For example
<a name="line-1135"></a>   type Foo = ?x::Int
<a name="line-1136"></a>   instance Foo =&gt; C T
<a name="line-1137"></a>We should reject the instance because it has an implicit parameter in
<a name="line-1138"></a>the context.
<a name="line-1139"></a>
<a name="line-1140"></a>But we record, in 'under_syn', whether we have looked under a synonym
<a name="line-1141"></a>to avoid requiring language extensions at the use site.  Main example
<a name="line-1142"></a>(#9838):
<a name="line-1143"></a>
<a name="line-1144"></a>   {-# LANGUAGE ConstraintKinds #-}
<a name="line-1145"></a>   module A where
<a name="line-1146"></a>      type EqShow a = (Eq a, Show a)
<a name="line-1147"></a>
<a name="line-1148"></a>   module B where
<a name="line-1149"></a>      import A
<a name="line-1150"></a>      foo :: EqShow a =&gt; a -&gt; String
<a name="line-1151"></a>
<a name="line-1152"></a>We don't want to require ConstraintKinds in module B.
<a name="line-1153"></a>-}</span>
<a name="line-1154"></a>
<a name="line-1155"></a><a name="check_pred_ty"></a><span class='hs-definition'>check_pred_ty</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExpandMode</span>
<a name="line-1156"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1157"></a><span class='hs-comment'>-- Check the validity of a predicate in a signature</span>
<a name="line-1158"></a><span class='hs-comment'>-- See Note [Validity checking for constraints]</span>
<a name="line-1159"></a><span class='hs-definition'>check_pred_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>expand</span> <span class='hs-varid'>pred</span>
<a name="line-1160"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>check_type</span> <span class='hs-varid'>ve</span> <span class='hs-varid'>pred</span>
<a name="line-1161"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_pred_help</span> <span class='hs-conid'>False</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-layout'>}</span>
<a name="line-1162"></a>  <span class='hs-keyword'>where</span>
<a name="line-1163"></a>    <span class='hs-varid'>rank</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.QuantifiedConstraints</span> <span class='hs-varid'>dflags</span>
<a name="line-1164"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ArbitraryRank</span>
<a name="line-1165"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1166"></a>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>constraintMonoType</span>
<a name="line-1167"></a>
<a name="line-1168"></a>    <span class='hs-varid'>ve</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValidityEnv</span>
<a name="line-1169"></a>    <span class='hs-varid'>ve</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ValidityEnv</span><span class='hs-layout'>{</span> <span class='hs-varid'>ve_tidy_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1170"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>ve_ctxt</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SigmaCtxt</span>
<a name="line-1171"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>ve_rank</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rank</span>
<a name="line-1172"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>ve_expand</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expand</span> <span class='hs-layout'>}</span>
<a name="line-1173"></a>
<a name="line-1174"></a><a name="check_pred_help"></a><span class='hs-definition'>check_pred_help</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- True &lt;=&gt; under a type synonym</span>
<a name="line-1175"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TidyEnv</span>
<a name="line-1176"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span>
<a name="line-1177"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1178"></a><span class='hs-definition'>check_pred_help</span> <span class='hs-varid'>under_syn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span>
<a name="line-1179"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>pred'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>pred</span>  <span class='hs-comment'>-- Switch on under_syn when going under a</span>
<a name="line-1180"></a>                                 <span class='hs-comment'>-- synonym (#9838, yuk)</span>
<a name="line-1181"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_pred_help</span> <span class='hs-conid'>True</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred'</span>
<a name="line-1182"></a>
<a name="line-1183"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- A bit like classifyPredType, but not the same</span>
<a name="line-1184"></a>               <span class='hs-comment'>-- E.g. we treat (~) like (~#); and we look inside tuples</span>
<a name="line-1185"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-1186"></a>      <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1187"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCTupleClass</span> <span class='hs-varid'>cls</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_tuple_pred</span> <span class='hs-varid'>under_syn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tys</span>
<a name="line-1188"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_class_pred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1189"></a>
<a name="line-1190"></a>      <span class='hs-conid'>EqPred</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"check_pred_help"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1191"></a>              <span class='hs-comment'>-- EqPreds, such as (t1 ~ #t2) or (t1 ~R# t2), don't even have kind Constraint</span>
<a name="line-1192"></a>              <span class='hs-comment'>-- and should never appear before the '=&gt;' of a type.  Thus</span>
<a name="line-1193"></a>              <span class='hs-comment'>--     f :: (a ~# b) =&gt; blah</span>
<a name="line-1194"></a>              <span class='hs-comment'>-- is wrong.  For user written signatures, it'll be rejected by kind-checking</span>
<a name="line-1195"></a>              <span class='hs-comment'>-- well before we get to validity checking.  For inferred types we are careful</span>
<a name="line-1196"></a>              <span class='hs-comment'>-- to box such constraints in GHC.Tc.Utils.TcType.pickQuantifiablePreds, as described</span>
<a name="line-1197"></a>              <span class='hs-comment'>-- in Note [Lift equality constraints when quantifying] in GHC.Tc.Utils.TcType</span>
<a name="line-1198"></a>
<a name="line-1199"></a>      <span class='hs-conid'>ForAllPred</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>head</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_quant_pred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>head</span>
<a name="line-1200"></a>      <span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_irred_pred</span> <span class='hs-varid'>under_syn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>pred</span>
<a name="line-1201"></a>
<a name="line-1202"></a><a name="check_eq_pred"></a><span class='hs-definition'>check_eq_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1203"></a><span class='hs-definition'>check_eq_pred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>pred</span>
<a name="line-1204"></a>  <span class='hs-keyglyph'>=</span>         <span class='hs-comment'>-- Equational constraints are valid in all contexts if type</span>
<a name="line-1205"></a>            <span class='hs-comment'>-- families are permitted</span>
<a name="line-1206"></a>    <span class='hs-varid'>checkTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.TypeFamilies</span> <span class='hs-varid'>dflags</span>
<a name="line-1207"></a>              <span class='hs-varop'>||</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.GADTs</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1208"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>eqPredTyErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1209"></a>
<a name="line-1210"></a><a name="check_quant_pred"></a><span class='hs-definition'>check_quant_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span>
<a name="line-1211"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1212"></a><span class='hs-definition'>check_quant_pred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>head_pred</span>
<a name="line-1213"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addErrCtxt</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"In the quantified constraint"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1214"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Check the instance head</span>
<a name="line-1215"></a>         <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>head_pred</span> <span class='hs-keyword'>of</span>
<a name="line-1216"></a>                                 <span class='hs-comment'>-- SigmaCtxt tells checkValidInstHead that</span>
<a name="line-1217"></a>                                 <span class='hs-comment'>-- this is the head of a quantified constraint</span>
<a name="line-1218"></a>            <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkValidInstHead</span> <span class='hs-conid'>SigmaCtxt</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1219"></a>                                    <span class='hs-layout'>;</span> <span class='hs-varid'>check_pred_help</span> <span class='hs-conid'>False</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>head_pred</span> <span class='hs-layout'>}</span>
<a name="line-1220"></a>                               <span class='hs-comment'>-- need check_pred_help to do extra pred-only validity</span>
<a name="line-1221"></a>                               <span class='hs-comment'>-- checks, such as for (~). Otherwise, we get #17563</span>
<a name="line-1222"></a>                               <span class='hs-comment'>-- NB: checks for the context are covered by the check_type</span>
<a name="line-1223"></a>                               <span class='hs-comment'>-- in check_pred_ty</span>
<a name="line-1224"></a>            <span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>hasTyVarHead</span> <span class='hs-varid'>head_pred</span>
<a name="line-1225"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1226"></a>            <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>failWithTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>badQuantHeadErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1227"></a>
<a name="line-1228"></a>         <span class='hs-comment'>-- Check for termination</span>
<a name="line-1229"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.UndecidableInstances</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1230"></a>         <span class='hs-varid'>checkInstTermination</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>head_pred</span>
<a name="line-1231"></a>    <span class='hs-layout'>}</span>
<a name="line-1232"></a>
<a name="line-1233"></a><a name="check_tuple_pred"></a><span class='hs-definition'>check_tuple_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1234"></a><span class='hs-definition'>check_tuple_pred</span> <span class='hs-varid'>under_syn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>ts</span>
<a name="line-1235"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- See Note [ConstraintKinds in predicates]</span>
<a name="line-1236"></a>         <span class='hs-varid'>checkTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>under_syn</span> <span class='hs-varop'>||</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.ConstraintKinds</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1237"></a>                  <span class='hs-layout'>(</span><span class='hs-varid'>predTupleErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1238"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check_pred_help</span> <span class='hs-varid'>under_syn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span> <span class='hs-layout'>}</span>
<a name="line-1239"></a>    <span class='hs-comment'>-- This case will not normally be executed because without</span>
<a name="line-1240"></a>    <span class='hs-comment'>-- -XConstraintKinds tuple types are only kind-checked as *</span>
<a name="line-1241"></a>
<a name="line-1242"></a><a name="check_irred_pred"></a><span class='hs-definition'>check_irred_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1243"></a><span class='hs-definition'>check_irred_pred</span> <span class='hs-varid'>under_syn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>pred</span>
<a name="line-1244"></a>    <span class='hs-comment'>-- The predicate looks like (X t1 t2) or (x t1 t2) :: Constraint</span>
<a name="line-1245"></a>    <span class='hs-comment'>-- where X is a type function</span>
<a name="line-1246"></a>  <span class='hs-keyglyph'>=</span>      <span class='hs-comment'>-- If it looks like (x t1 t2), require ConstraintKinds</span>
<a name="line-1247"></a>         <span class='hs-comment'>--   see Note [ConstraintKinds in predicates]</span>
<a name="line-1248"></a>         <span class='hs-comment'>-- But (X t1 t2) is always ok because we just require ConstraintKinds</span>
<a name="line-1249"></a>         <span class='hs-comment'>-- at the definition site (#9838)</span>
<a name="line-1250"></a>    <span class='hs-varid'>failIfTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>under_syn</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.ConstraintKinds</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1251"></a>                            <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>hasTyVarHead</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1252"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>predIrredErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1253"></a>
<a name="line-1254"></a><span class='hs-comment'>{- Note [ConstraintKinds in predicates]
<a name="line-1255"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1256"></a>Don't check for -XConstraintKinds under a type synonym, because that
<a name="line-1257"></a>was done at the type synonym definition site; see #9838
<a name="line-1258"></a>e.g.   module A where
<a name="line-1259"></a>          type C a = (Eq a, Ix a)   -- Needs -XConstraintKinds
<a name="line-1260"></a>       module B where
<a name="line-1261"></a>          import A
<a name="line-1262"></a>          f :: C a =&gt; a -&gt; a        -- Does *not* need -XConstraintKinds
<a name="line-1263"></a>-}</span>
<a name="line-1264"></a>
<a name="line-1265"></a><a name="check_class_pred"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1266"></a><span class='hs-definition'>check_class_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span>
<a name="line-1267"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1268"></a><span class='hs-definition'>check_class_pred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1269"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEqPredClass</span> <span class='hs-varid'>cls</span>    <span class='hs-comment'>-- (~) and (~~) are classified as classes,</span>
<a name="line-1270"></a>                         <span class='hs-comment'>-- but here we want to treat them as equalities</span>
<a name="line-1271"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_eq_pred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>pred</span>
<a name="line-1272"></a>
<a name="line-1273"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIPClass</span> <span class='hs-varid'>cls</span>
<a name="line-1274"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>check_arity</span>
<a name="line-1275"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>okIPCtxt</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>badIPPred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1276"></a>
<a name="line-1277"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-comment'>-- Includes Coercible</span>
<a name="line-1278"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>check_arity</span>
<a name="line-1279"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkSimplifiableClassConstraint</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1280"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTcM</span> <span class='hs-varid'>arg_tys_ok</span> <span class='hs-layout'>(</span><span class='hs-varid'>predTyVarErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1281"></a>  <span class='hs-keyword'>where</span>
<a name="line-1282"></a>    <span class='hs-varid'>check_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>classArity</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span>
<a name="line-1283"></a>                          <span class='hs-layout'>(</span><span class='hs-varid'>tyConArityErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1284"></a>
<a name="line-1285"></a>    <span class='hs-comment'>-- Check the arguments of a class constraint</span>
<a name="line-1286"></a>    <span class='hs-varid'>flexible_contexts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.FlexibleContexts</span>     <span class='hs-varid'>dflags</span>
<a name="line-1287"></a>    <span class='hs-varid'>arg_tys_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1288"></a>        <span class='hs-conid'>SpecInstCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>    <span class='hs-comment'>-- {-# SPECIALISE instance Eq (T Int) #-} is fine</span>
<a name="line-1289"></a>        <span class='hs-conid'>InstDeclCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>checkValidClsArgs</span> <span class='hs-varid'>flexible_contexts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1290"></a>                                <span class='hs-comment'>-- Further checks on head and theta</span>
<a name="line-1291"></a>                                <span class='hs-comment'>-- in checkInstTermination</span>
<a name="line-1292"></a>        <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>checkValidClsArgs</span> <span class='hs-varid'>flexible_contexts</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1293"></a>
<a name="line-1294"></a><a name="checkSimplifiableClassConstraint"></a><span class='hs-definition'>checkSimplifiableClassConstraint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span>
<a name="line-1295"></a>                                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1296"></a><span class='hs-comment'>-- See Note [Simplifiable given constraints]</span>
<a name="line-1297"></a><span class='hs-definition'>checkSimplifiableClassConstraint</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1298"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>wopt</span> <span class='hs-conid'>Opt_WarnSimplifiableClassConstraints</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1299"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1300"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.MonoLocalBinds</span> <span class='hs-varid'>dflags</span>
<a name="line-1301"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1302"></a>
<a name="line-1303"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DataTyCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctxt</span>   <span class='hs-comment'>-- Don't do this check for the "stupid theta"</span>
<a name="line-1304"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>               <span class='hs-comment'>-- of a data type declaration</span>
<a name="line-1305"></a>
<a name="line-1306"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>coercibleTyConKey</span>
<a name="line-1307"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>   <span class='hs-comment'>-- Oddly, we treat (Coercible t1 t2) as unconditionally OK</span>
<a name="line-1308"></a>                <span class='hs-comment'>-- matchGlobalInst will reply "yes" because we can reduce</span>
<a name="line-1309"></a>                <span class='hs-comment'>-- (Coercible a b) to (a ~R# b)</span>
<a name="line-1310"></a>
<a name="line-1311"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1312"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchGlobalInst</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>False</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1313"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>result</span> <span class='hs-keyword'>of</span>
<a name="line-1314"></a>           <span class='hs-conid'>OneInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cir_what</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>what</span> <span class='hs-layout'>}</span>
<a name="line-1315"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addWarnTc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reason</span> <span class='hs-conid'>Opt_WarnSimplifiableClassConstraints</span><span class='hs-layout'>)</span>
<a name="line-1316"></a>                                   <span class='hs-layout'>(</span><span class='hs-varid'>simplifiable_constraint_warn</span> <span class='hs-varid'>what</span><span class='hs-layout'>)</span>
<a name="line-1317"></a>           <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-1318"></a>  <span class='hs-keyword'>where</span>
<a name="line-1319"></a>    <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1320"></a>
<a name="line-1321"></a>    <span class='hs-varid'>simplifiable_constraint_warn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstanceWhat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1322"></a>    <span class='hs-varid'>simplifiable_constraint_warn</span> <span class='hs-varid'>what</span>
<a name="line-1323"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"The constraint"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tidyType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1324"></a>                    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"matches"</span><span class='hs-layout'>)</span>
<a name="line-1325"></a>                 <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>what</span><span class='hs-layout'>)</span>
<a name="line-1326"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"This makes type inference for inner bindings fragile;"</span><span class='hs-layout'>)</span>
<a name="line-1327"></a>                 <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"either use MonoLocalBinds, or simplify it using the instance"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1328"></a>
<a name="line-1329"></a><span class='hs-comment'>{- Note [Simplifiable given constraints]
<a name="line-1330"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1331"></a>A type signature like
<a name="line-1332"></a>   f :: Eq [(a,b)] =&gt; a -&gt; b
<a name="line-1333"></a>is very fragile, for reasons described at length in GHC.Tc.Solver.Interact
<a name="line-1334"></a>Note [Instance and Given overlap].  As that Note discusses, for the
<a name="line-1335"></a>most part the clever stuff in GHC.Tc.Solver.Interact means that we don't use a
<a name="line-1336"></a>top-level instance if a local Given might fire, so there is no
<a name="line-1337"></a>fragility. But if we /infer/ the type of a local let-binding, things
<a name="line-1338"></a>can go wrong (#11948 is an example, discussed in the Note).
<a name="line-1339"></a>
<a name="line-1340"></a>So this warning is switched on only if we have NoMonoLocalBinds; in
<a name="line-1341"></a>that case the warning discourages users from writing simplifiable
<a name="line-1342"></a>class constraints.
<a name="line-1343"></a>
<a name="line-1344"></a>The warning only fires if the constraint in the signature
<a name="line-1345"></a>matches the top-level instances in only one way, and with no
<a name="line-1346"></a>unifiers -- that is, under the same circumstances that
<a name="line-1347"></a>GHC.Tc.Solver.Interact.matchInstEnv fires an interaction with the top
<a name="line-1348"></a>level instances.  For example (#13526), consider
<a name="line-1349"></a>
<a name="line-1350"></a>  instance {-# OVERLAPPABLE #-} Eq (T a) where ...
<a name="line-1351"></a>  instance                   Eq (T Char) where ..
<a name="line-1352"></a>  f :: Eq (T a) =&gt; ...
<a name="line-1353"></a>
<a name="line-1354"></a>We don't want to complain about this, even though the context
<a name="line-1355"></a>(Eq (T a)) matches an instance, because the user may be
<a name="line-1356"></a>deliberately deferring the choice so that the Eq (T Char)
<a name="line-1357"></a>has a chance to fire when 'f' is called.  And the fragility
<a name="line-1358"></a>only matters when there's a risk that the instance might
<a name="line-1359"></a>fire instead of the local 'given'; and there is no such
<a name="line-1360"></a>risk in this case.  Just use the same rules as for instance
<a name="line-1361"></a>firing!
<a name="line-1362"></a>-}</span>
<a name="line-1363"></a>
<a name="line-1364"></a><a name="okIPCtxt"></a><span class='hs-comment'>-------------------------</span>
<a name="line-1365"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1366"></a>  <span class='hs-comment'>-- See Note [Implicit parameters in instance decls]</span>
<a name="line-1367"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1368"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>InfSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1369"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>ExprSigCtxt</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1370"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>TypeAppCtxt</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1371"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>PatSigCtxt</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1372"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>GenSigCtxt</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1373"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConArgCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1374"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- ??</span>
<a name="line-1375"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>GhciCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1376"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>SigmaCtxt</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1377"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataTyCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1378"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>PatSynCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1379"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySynCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- e.g.   type Blah = ?x::Int</span>
<a name="line-1380"></a>                                         <span class='hs-comment'>-- #11466</span>
<a name="line-1381"></a>
<a name="line-1382"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>KindSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1383"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>StandaloneKindSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1384"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassSCCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1385"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstDeclCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1386"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>SpecInstCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1387"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>RuleSigCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1388"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>DefaultDeclCtxt</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1389"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-conid'>DerivClauseCtxt</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1390"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarBndrKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1391"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1392"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TySynKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1393"></a><span class='hs-definition'>okIPCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyFamResKindCtxt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1394"></a>
<a name="line-1395"></a><span class='hs-comment'>{-
<a name="line-1396"></a>Note [Kind polymorphic type classes]
<a name="line-1397"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1398"></a>MultiParam check:
<a name="line-1399"></a>
<a name="line-1400"></a>    class C f where...   -- C :: forall k. k -&gt; Constraint
<a name="line-1401"></a>    instance C Maybe where...
<a name="line-1402"></a>
<a name="line-1403"></a>  The dictionary gets type [C * Maybe] even if it's not a MultiParam
<a name="line-1404"></a>  type class.
<a name="line-1405"></a>
<a name="line-1406"></a>Flexibility check:
<a name="line-1407"></a>
<a name="line-1408"></a>    class C f where...   -- C :: forall k. k -&gt; Constraint
<a name="line-1409"></a>    data D a = D a
<a name="line-1410"></a>    instance C D where
<a name="line-1411"></a>
<a name="line-1412"></a>  The dictionary gets type [C * (D *)]. IA0_TODO it should be
<a name="line-1413"></a>  generalized actually.
<a name="line-1414"></a>-}</span>
<a name="line-1415"></a>
<a name="line-1416"></a><a name="checkThetaCtxt"></a><span class='hs-definition'>checkThetaCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1417"></a><span class='hs-definition'>checkThetaCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>env</span>
<a name="line-1418"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1419"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"In the context:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprTheta</span> <span class='hs-layout'>(</span><span class='hs-varid'>tidyTypes</span> <span class='hs-varid'>env</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-1420"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"While checking"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprUserTypeCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>
<a name="line-1421"></a>
<a name="line-1422"></a><a name="eqPredTyErr"></a><span class='hs-definition'>eqPredTyErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>predTupleErr</span><span class='hs-layout'>,</span> <span class='hs-varid'>predIrredErr</span><span class='hs-layout'>,</span>
<a name="line-1423"></a>   <span class='hs-varid'>badQuantHeadErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1424"></a><a name="badQuantHeadErr"></a><span class='hs-definition'>badQuantHeadErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span>
<a name="line-1425"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1426"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Quantified predicate must have a class or type variable head:"</span><span class='hs-layout'>)</span>
<a name="line-1427"></a>         <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1428"></a><span class='hs-definition'>eqPredTyErr</span>  <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span>
<a name="line-1429"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1430"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal equational constraint"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>$$</span>
<a name="line-1431"></a>      <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Use GADTs or TypeFamilies to permit this"</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1432"></a><a name="predTupleErr"></a><span class='hs-definition'>predTupleErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span>
<a name="line-1433"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1434"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal tuple constraint:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1435"></a>         <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-varid'>constraintKindsMsg</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1436"></a><a name="predIrredErr"></a><span class='hs-definition'>predIrredErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span>
<a name="line-1437"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1438"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal constraint:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1439"></a>         <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-varid'>constraintKindsMsg</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1440"></a>
<a name="line-1441"></a><a name="predTyVarErr"></a><span class='hs-definition'>predTyVarErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1442"></a><span class='hs-definition'>predTyVarErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span>
<a name="line-1443"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span>
<a name="line-1444"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Non type-variable argument"</span><span class='hs-layout'>)</span>
<a name="line-1445"></a>                <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"in the constraint:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1446"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Use FlexibleContexts to permit this"</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1447"></a>
<a name="line-1448"></a><a name="badIPPred"></a><span class='hs-definition'>badIPPred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1449"></a><span class='hs-definition'>badIPPred</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span>
<a name="line-1450"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1451"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal implicit parameter"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1452"></a>
<a name="line-1453"></a><a name="constraintSynErr"></a><span class='hs-definition'>constraintSynErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1454"></a><span class='hs-definition'>constraintSynErr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>kind</span>
<a name="line-1455"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1456"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal constraint synonym of kind:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>kind</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1457"></a>         <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-varid'>constraintKindsMsg</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1458"></a>
<a name="line-1459"></a><a name="dupPredWarn"></a><span class='hs-definition'>dupPredWarn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NE.NonEmpty</span> <span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TidyEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>SDoc</span><span class='hs-layout'>)</span>
<a name="line-1460"></a><span class='hs-definition'>dupPredWarn</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dups</span>
<a name="line-1461"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>env</span>
<a name="line-1462"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Duplicate constraint"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>plural</span> <span class='hs-varid'>primaryDups</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>":"</span>
<a name="line-1463"></a>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprWithCommas</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr_tidy</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>primaryDups</span> <span class='hs-layout'>)</span>
<a name="line-1464"></a>  <span class='hs-keyword'>where</span>
<a name="line-1465"></a>    <span class='hs-varid'>primaryDups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-conid'>NE.head</span> <span class='hs-varid'>dups</span>
<a name="line-1466"></a>
<a name="line-1467"></a><a name="tyConArityErr"></a><span class='hs-definition'>tyConArityErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1468"></a><span class='hs-comment'>-- For type-constructor arity errors, be careful to report</span>
<a name="line-1469"></a><span class='hs-comment'>-- the number of /visible/ arguments required and supplied,</span>
<a name="line-1470"></a><span class='hs-comment'>-- ignoring the /invisible/ arguments, which the user does not see.</span>
<a name="line-1471"></a><span class='hs-comment'>-- (e.g. #10516)</span>
<a name="line-1472"></a><span class='hs-definition'>tyConArityErr</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tks</span>
<a name="line-1473"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConFlavour</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1474"></a>             <span class='hs-varid'>tc_type_arity</span> <span class='hs-varid'>tc_type_args</span>
<a name="line-1475"></a>  <span class='hs-keyword'>where</span>
<a name="line-1476"></a>    <span class='hs-varid'>vis_tks</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tks</span>
<a name="line-1477"></a>
<a name="line-1478"></a>    <span class='hs-comment'>-- tc_type_arity = number of *type* args expected</span>
<a name="line-1479"></a>    <span class='hs-comment'>-- tc_type_args  = number of *type* args encountered</span>
<a name="line-1480"></a>    <span class='hs-varid'>tc_type_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isVisibleTyConBinder</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConBinders</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1481"></a>    <span class='hs-varid'>tc_type_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>vis_tks</span>
<a name="line-1482"></a>
<a name="line-1483"></a><a name="arityErr"></a><span class='hs-definition'>arityErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1484"></a><span class='hs-definition'>arityErr</span> <span class='hs-varid'>what</span> <span class='hs-varid'>name</span> <span class='hs-varid'>n</span> <span class='hs-varid'>m</span>
<a name="line-1485"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"The"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what</span><span class='hs-layout'>,</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"should have"</span><span class='hs-layout'>,</span>
<a name="line-1486"></a>           <span class='hs-varid'>n_arguments</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"but has been given"</span><span class='hs-layout'>,</span>
<a name="line-1487"></a>           <span class='hs-keyword'>if</span> <span class='hs-varid'>m</span><span class='hs-varop'>==</span><span class='hs-num'>0</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>text</span> <span class='hs-str'>"none"</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>int</span> <span class='hs-varid'>m</span><span class='hs-keyglyph'>]</span>
<a name="line-1488"></a>    <span class='hs-keyword'>where</span>
<a name="line-1489"></a>        <span class='hs-varid'>n_arguments</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"no arguments"</span>
<a name="line-1490"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"1 argument"</span>
<a name="line-1491"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>True</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>int</span> <span class='hs-varid'>n</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"arguments"</span><span class='hs-keyglyph'>]</span>
<a name="line-1492"></a>
<a name="line-1493"></a><span class='hs-comment'>{-
<a name="line-1494"></a>************************************************************************
<a name="line-1495"></a>*                                                                      *
<a name="line-1496"></a>\subsection{Checking for a decent instance head type}
<a name="line-1497"></a>*                                                                      *
<a name="line-1498"></a>************************************************************************
<a name="line-1499"></a>
<a name="line-1500"></a>@checkValidInstHead@ checks the type {\em and} its syntactic constraints:
<a name="line-1501"></a>it must normally look like: @instance Foo (Tycon a b c ...) ...@
<a name="line-1502"></a>
<a name="line-1503"></a>The exceptions to this syntactic checking: (1)~if the @GlasgowExts@
<a name="line-1504"></a>flag is on, or (2)~the instance is imported (they must have been
<a name="line-1505"></a>compiled elsewhere). In these cases, we let them go through anyway.
<a name="line-1506"></a>
<a name="line-1507"></a>We can also have instances for functions: @instance Foo (a -&gt; b) ...@.
<a name="line-1508"></a>-}</span>
<a name="line-1509"></a>
<a name="line-1510"></a><a name="checkValidInstHead"></a><span class='hs-definition'>checkValidInstHead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1511"></a><span class='hs-definition'>checkValidInstHead</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span>
<a name="line-1512"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1513"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>is_boot</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcIsHsBootOrSig</span>
<a name="line-1514"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>is_sig</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcIsHsig</span>
<a name="line-1515"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_special_inst_head</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>is_sig</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span>
<a name="line-1516"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidTypePats</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-varid'>cls_args</span>
<a name="line-1517"></a>       <span class='hs-layout'>}</span>
<a name="line-1518"></a>
<a name="line-1519"></a><span class='hs-comment'>{-
<a name="line-1520"></a>
<a name="line-1521"></a>Note [Instances of built-in classes in signature files]
<a name="line-1522"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1523"></a>
<a name="line-1524"></a>User defined instances for KnownNat, KnownSymbol and Typeable are
<a name="line-1525"></a>disallowed -- they are generated when needed by GHC itself on-the-fly.
<a name="line-1526"></a>
<a name="line-1527"></a>However, if they occur in a Backpack signature file, they have an
<a name="line-1528"></a>entirely different meaning. Suppose in M.hsig we see
<a name="line-1529"></a>
<a name="line-1530"></a>  signature M where
<a name="line-1531"></a>    data T :: Nat
<a name="line-1532"></a>    instance KnownNat T
<a name="line-1533"></a>
<a name="line-1534"></a>That says that any module satisfying M.hsig must provide a KnownNat
<a name="line-1535"></a>instance for T.  We absolultely need that instance when compiling a
<a name="line-1536"></a>module that imports M.hsig: see #15379 and
<a name="line-1537"></a>Note [Fabricating Evidence for Literals in Backpack] in GHC.Tc.Instance.Class.
<a name="line-1538"></a>
<a name="line-1539"></a>Hence, checkValidInstHead accepts a user-written instance declaration
<a name="line-1540"></a>in hsig files, where `is_sig` is True.
<a name="line-1541"></a>
<a name="line-1542"></a>-}</span>
<a name="line-1543"></a>
<a name="line-1544"></a><a name="check_special_inst_head"></a><span class='hs-definition'>check_special_inst_head</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1545"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1546"></a><span class='hs-comment'>-- Wow!  There are a surprising number of ad-hoc special cases here.</span>
<a name="line-1547"></a><span class='hs-definition'>check_special_inst_head</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>is_boot</span> <span class='hs-varid'>is_sig</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span>
<a name="line-1548"></a>
<a name="line-1549"></a>  <span class='hs-comment'>-- If not in an hs-boot file, abstract classes cannot have instances</span>
<a name="line-1550"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isAbstractClass</span> <span class='hs-varid'>clas</span>
<a name="line-1551"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>is_boot</span>
<a name="line-1552"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varid'>abstract_class_msg</span>
<a name="line-1553"></a>
<a name="line-1554"></a>  <span class='hs-comment'>-- For Typeable, don't complain about instances for</span>
<a name="line-1555"></a>  <span class='hs-comment'>-- standalone deriving; they are no-ops, and we warn about</span>
<a name="line-1556"></a>  <span class='hs-comment'>-- it in GHC.Tc.Deriv.deriveStandalone.</span>
<a name="line-1557"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>clas_nm</span> <span class='hs-varop'>==</span> <span class='hs-varid'>typeableClassName</span>
<a name="line-1558"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>is_sig</span>
<a name="line-1559"></a>    <span class='hs-comment'>-- Note [Instances of built-in classes in signature files]</span>
<a name="line-1560"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hand_written_bindings</span>
<a name="line-1561"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varid'>rejected_class_msg</span>
<a name="line-1562"></a>
<a name="line-1563"></a>  <span class='hs-comment'>-- Handwritten instances of KnownNat/KnownSymbol class</span>
<a name="line-1564"></a>  <span class='hs-comment'>-- are always forbidden (#12837)</span>
<a name="line-1565"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>clas_nm</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>knownNatClassName</span><span class='hs-layout'>,</span> <span class='hs-varid'>knownSymbolClassName</span> <span class='hs-keyglyph'>]</span>
<a name="line-1566"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>is_sig</span>
<a name="line-1567"></a>    <span class='hs-comment'>-- Note [Instances of built-in classes in signature files]</span>
<a name="line-1568"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hand_written_bindings</span>
<a name="line-1569"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varid'>rejected_class_msg</span>
<a name="line-1570"></a>
<a name="line-1571"></a>  <span class='hs-comment'>-- For the most part we don't allow</span>
<a name="line-1572"></a>  <span class='hs-comment'>-- instances for (~), (~~), or Coercible;</span>
<a name="line-1573"></a>  <span class='hs-comment'>-- but we DO want to allow them in quantified constraints:</span>
<a name="line-1574"></a>  <span class='hs-comment'>--   f :: (forall a b. Coercible a b =&gt; Coercible (m a) (m b)) =&gt; ...m...</span>
<a name="line-1575"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>clas_nm</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>heqTyConName</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqTyConName</span><span class='hs-layout'>,</span> <span class='hs-varid'>coercibleTyConName</span> <span class='hs-keyglyph'>]</span>
<a name="line-1576"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>quantified_constraint</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varid'>rejected_class_msg</span>
<a name="line-1578"></a>
<a name="line-1579"></a>  <span class='hs-comment'>-- Check for hand-written Generic instances (disallowed in Safe Haskell)</span>
<a name="line-1580"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>clas_nm</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>genericClassNames</span>
<a name="line-1581"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>hand_written_bindings</span>
<a name="line-1582"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>failIfTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>safeLanguageOn</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>gen_inst_err</span>
<a name="line-1583"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>safeInferOn</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>recordUnsafeInfer</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1584"></a>
<a name="line-1585"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>clas_nm</span> <span class='hs-varop'>==</span> <span class='hs-varid'>hasFieldClassName</span>
<a name="line-1586"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkHasFieldInst</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span>
<a name="line-1587"></a>
<a name="line-1588"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCTupleClass</span> <span class='hs-varid'>clas</span>
<a name="line-1589"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varid'>tuple_class_msg</span>
<a name="line-1590"></a>
<a name="line-1591"></a>  <span class='hs-comment'>-- Check language restrictions on the args to the class</span>
<a name="line-1592"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>check_h98_arg_shape</span>
<a name="line-1593"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_ty_args_msg</span>
<a name="line-1594"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>cls_args</span> <span class='hs-varid'>msg</span><span class='hs-layout'>)</span>
<a name="line-1595"></a>
<a name="line-1596"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1597"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-1598"></a>  <span class='hs-keyword'>where</span>
<a name="line-1599"></a>    <span class='hs-varid'>clas_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getName</span> <span class='hs-varid'>clas</span>
<a name="line-1600"></a>    <span class='hs-varid'>ty_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-varid'>cls_args</span>
<a name="line-1601"></a>
<a name="line-1602"></a>    <span class='hs-varid'>hand_written_bindings</span>
<a name="line-1603"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1604"></a>            <span class='hs-conid'>InstDeclCtxt</span> <span class='hs-varid'>stand_alone</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-varid'>stand_alone</span>
<a name="line-1605"></a>            <span class='hs-conid'>SpecInstCtxt</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1606"></a>            <span class='hs-conid'>DerivClauseCtxt</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1607"></a>            <span class='hs-keyword'>_</span>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1608"></a>
<a name="line-1609"></a>    <span class='hs-varid'>check_h98_arg_shape</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1610"></a>                            <span class='hs-conid'>SpecInstCtxt</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1611"></a>                            <span class='hs-conid'>DerivClauseCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1612"></a>                            <span class='hs-conid'>SigmaCtxt</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1613"></a>                            <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1614"></a>        <span class='hs-comment'>-- SigmaCtxt: once we are in quantified-constraint land, we</span>
<a name="line-1615"></a>        <span class='hs-comment'>-- aren't so picky about enforcing H98-language restrictions</span>
<a name="line-1616"></a>        <span class='hs-comment'>-- E.g. we want to allow a head like Coercible (m a) (m b)</span>
<a name="line-1617"></a>
<a name="line-1618"></a>
<a name="line-1619"></a>    <span class='hs-comment'>-- When we are looking at the head of a quantified constraint,</span>
<a name="line-1620"></a>    <span class='hs-comment'>-- check_quant_pred sets ctxt to SigmaCtxt</span>
<a name="line-1621"></a>    <span class='hs-varid'>quantified_constraint</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1622"></a>                              <span class='hs-conid'>SigmaCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1623"></a>                              <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1624"></a>
<a name="line-1625"></a>    <span class='hs-varid'>head_type_synonym_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span>
<a name="line-1626"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"All instance types must be of the form (T t1 ... tn)"</span> <span class='hs-varop'>$$</span>
<a name="line-1627"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"where T is not a synonym."</span> <span class='hs-varop'>$$</span>
<a name="line-1628"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Use TypeSynonymInstances if you want to disable this."</span><span class='hs-layout'>)</span>
<a name="line-1629"></a>
<a name="line-1630"></a>    <span class='hs-varid'>head_type_args_tyvars_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span>
<a name="line-1631"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"All instance types must be of the form (T a1 ... an)"</span><span class='hs-layout'>,</span>
<a name="line-1632"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"where a1 ... an are *distinct type variables*,"</span><span class='hs-layout'>,</span>
<a name="line-1633"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"and each type variable appears at most once in the instance head."</span><span class='hs-layout'>,</span>
<a name="line-1634"></a>                <span class='hs-varid'>text</span> <span class='hs-str'>"Use FlexibleInstances if you want to disable this."</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1635"></a>
<a name="line-1636"></a>    <span class='hs-varid'>head_one_type_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-varop'>$</span>
<a name="line-1637"></a>                        <span class='hs-varid'>text</span> <span class='hs-str'>"Only one type can be given in an instance head."</span> <span class='hs-varop'>$$</span>
<a name="line-1638"></a>                        <span class='hs-varid'>text</span> <span class='hs-str'>"Use MultiParamTypeClasses if you want to allow more, or zero."</span>
<a name="line-1639"></a>
<a name="line-1640"></a>    <span class='hs-varid'>rejected_class_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Class"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>clas_nm</span><span class='hs-layout'>)</span>
<a name="line-1641"></a>                         <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"does not support user-specified instances"</span>
<a name="line-1642"></a>    <span class='hs-varid'>tuple_class_msg</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"You can't specify an instance for a tuple constraint"</span>
<a name="line-1643"></a>
<a name="line-1644"></a>    <span class='hs-varid'>gen_inst_err</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rejected_class_msg</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"(in Safe Haskell)"</span><span class='hs-layout'>)</span>
<a name="line-1645"></a>
<a name="line-1646"></a>    <span class='hs-varid'>abstract_class_msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Cannot define instance for abstract class"</span>
<a name="line-1647"></a>                         <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>clas_nm</span><span class='hs-layout'>)</span>
<a name="line-1648"></a>
<a name="line-1649"></a>    <span class='hs-varid'>mb_ty_args_msg</span>
<a name="line-1650"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.TypeSynonymInstances</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1651"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>tcInstHeadTyNotSynonym</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span>
<a name="line-1652"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>head_type_synonym_msg</span>
<a name="line-1653"></a>
<a name="line-1654"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.FlexibleInstances</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1655"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>tcInstHeadTyAppAllTyVars</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span>
<a name="line-1656"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>head_type_args_tyvars_msg</span>
<a name="line-1657"></a>
<a name="line-1658"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>length</span> <span class='hs-varid'>ty_args</span> <span class='hs-varop'>/=</span> <span class='hs-num'>1</span>
<a name="line-1659"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.MultiParamTypeClasses</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span>
<a name="line-1660"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>xopt</span> <span class='hs-conid'>LangExt.NullaryTypeClasses</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>ty_args</span><span class='hs-layout'>)</span>
<a name="line-1661"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>head_one_type_msg</span>
<a name="line-1662"></a>
<a name="line-1663"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1664"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1665"></a>
<a name="line-1666"></a><a name="tcInstHeadTyNotSynonym"></a><span class='hs-definition'>tcInstHeadTyNotSynonym</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1667"></a><span class='hs-comment'>-- Used in Haskell-98 mode, for the argument types of an instance head</span>
<a name="line-1668"></a><span class='hs-comment'>-- These must not be type synonyms, but everywhere else type synonyms</span>
<a name="line-1669"></a><span class='hs-comment'>-- are transparent, so we need a special function here</span>
<a name="line-1670"></a><span class='hs-definition'>tcInstHeadTyNotSynonym</span> <span class='hs-varid'>ty</span>
<a name="line-1671"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>  <span class='hs-comment'>-- Do not use splitTyConApp,</span>
<a name="line-1672"></a>                <span class='hs-comment'>-- because that expands synonyms!</span>
<a name="line-1673"></a>        <span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeSynonymTyCon</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>unrestrictedFunTyCon</span>
<a name="line-1674"></a>                <span class='hs-comment'>-- Allow (-&gt;), e.g. instance Category (-&gt;),</span>
<a name="line-1675"></a>                <span class='hs-comment'>-- even though it's a type synonym for FUN 'Many</span>
<a name="line-1676"></a>        <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1677"></a>
<a name="line-1678"></a><a name="tcInstHeadTyAppAllTyVars"></a><span class='hs-definition'>tcInstHeadTyAppAllTyVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1679"></a><span class='hs-comment'>-- Used in Haskell-98 mode, for the argument types of an instance head</span>
<a name="line-1680"></a><span class='hs-comment'>-- These must be a constructor applied to type variable arguments</span>
<a name="line-1681"></a><span class='hs-comment'>-- or a type-level literal.</span>
<a name="line-1682"></a><span class='hs-comment'>-- But we allow</span>
<a name="line-1683"></a><span class='hs-comment'>-- 1) kind instantiations</span>
<a name="line-1684"></a><span class='hs-comment'>-- 2) the type (-&gt;) = FUN 'Many, even though it's not in this form.</span>
<a name="line-1685"></a><span class='hs-definition'>tcInstHeadTyAppAllTyVars</span> <span class='hs-varid'>ty</span>
<a name="line-1686"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSplitTyConApp_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropCasts</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1687"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tys'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>  <span class='hs-comment'>-- avoid kinds</span>
<a name="line-1688"></a>        <span class='hs-varid'>tys''</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>funTyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys_h</span><span class='hs-conop'>:</span><span class='hs-varid'>tys_t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys_h</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>manyDataConTy</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys_t</span>
<a name="line-1689"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys'</span>
<a name="line-1690"></a>    <span class='hs-keyword'>in</span> <span class='hs-varid'>ok</span> <span class='hs-varid'>tys''</span>
<a name="line-1691"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LitTy</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- accept type literals (#13833)</span>
<a name="line-1692"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1693"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1694"></a>  <span class='hs-keyword'>where</span>
<a name="line-1695"></a>        <span class='hs-comment'>-- Check that all the types are type variables,</span>
<a name="line-1696"></a>        <span class='hs-comment'>-- and that each is distinct</span>
<a name="line-1697"></a>    <span class='hs-varid'>ok</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>hasNoDups</span> <span class='hs-varid'>tvs</span>
<a name="line-1698"></a>           <span class='hs-keyword'>where</span>
<a name="line-1699"></a>             <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapMaybe</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>tys</span>
<a name="line-1700"></a>
<a name="line-1701"></a><a name="dropCasts"></a><span class='hs-definition'>dropCasts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1702"></a><span class='hs-comment'>-- See Note [Casts during validity checking]</span>
<a name="line-1703"></a><span class='hs-comment'>-- This function can turn a well-kinded type into an ill-kinded</span>
<a name="line-1704"></a><span class='hs-comment'>-- one, so I've kept it local to this module</span>
<a name="line-1705"></a><span class='hs-comment'>-- To consider: drop only HoleCo casts</span>
<a name="line-1706"></a><span class='hs-definition'>dropCasts</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropCasts</span> <span class='hs-varid'>ty</span>
<a name="line-1707"></a><span class='hs-definition'>dropCasts</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropCasts</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropCasts</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-1708"></a><span class='hs-definition'>dropCasts</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ft_mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropCasts</span> <span class='hs-varid'>w</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropCasts</span> <span class='hs-varid'>t1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropCasts</span> <span class='hs-varid'>t2</span> <span class='hs-layout'>}</span>
<a name="line-1709"></a><span class='hs-definition'>dropCasts</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>dropCasts</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1710"></a><span class='hs-definition'>dropCasts</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>b</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropCastsB</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropCasts</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1711"></a><span class='hs-definition'>dropCasts</span> <span class='hs-varid'>ty</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>  <span class='hs-comment'>-- LitTy, TyVarTy, CoercionTy</span>
<a name="line-1712"></a>
<a name="line-1713"></a><a name="dropCastsB"></a><span class='hs-definition'>dropCastsB</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarBinder</span>
<a name="line-1714"></a><span class='hs-definition'>dropCastsB</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span>   <span class='hs-comment'>-- Don't bother in the kind of a forall</span>
<a name="line-1715"></a>
<a name="line-1716"></a><a name="instTypeErr"></a><span class='hs-definition'>instTypeErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1717"></a><span class='hs-definition'>instTypeErr</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>msg</span>
<a name="line-1718"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal instance declaration for"</span><span class='hs-layout'>)</span>
<a name="line-1719"></a>             <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1720"></a>       <span class='hs-num'>2</span> <span class='hs-varid'>msg</span>
<a name="line-1721"></a>
<a name="line-1722"></a><a name="checkHasFieldInst"></a><span class='hs-comment'>-- | See Note [Validity checking of HasField instances]</span>
<a name="line-1723"></a><span class='hs-definition'>checkHasFieldInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1724"></a><span class='hs-definition'>checkHasFieldInst</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span><span class='hs-keyglyph'>@</span><span class='hs-keyglyph'>[</span><span class='hs-sel'>_k_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>x_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>r_ty</span><span class='hs-layout'>,</span> <span class='hs-sel'>_a_ty</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>=</span>
<a name="line-1725"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>r_ty</span> <span class='hs-keyword'>of</span>
<a name="line-1726"></a>    <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>whoops</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Record data type must be specified"</span><span class='hs-layout'>)</span>
<a name="line-1727"></a>    <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-1728"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-1729"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>whoops</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Record data type may not be a data family"</span><span class='hs-layout'>)</span>
<a name="line-1730"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isStrLitTy</span> <span class='hs-varid'>x_ty</span> <span class='hs-keyword'>of</span>
<a name="line-1731"></a>       <span class='hs-conid'>Just</span> <span class='hs-varid'>lbl</span>
<a name="line-1732"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupTyConFieldLabel</span> <span class='hs-varid'>lbl</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1733"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>whoops</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"already has a field"</span>
<a name="line-1734"></a>                                       <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>lbl</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1735"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1736"></a>       <span class='hs-conid'>Nothing</span>
<a name="line-1737"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConFieldLabels</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1738"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>whoops</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"has fields"</span><span class='hs-layout'>)</span>
<a name="line-1739"></a>  <span class='hs-keyword'>where</span>
<a name="line-1740"></a>    <span class='hs-varid'>whoops</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addErrTc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1741"></a><span class='hs-definition'>checkHasFieldInst</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"checkHasFieldInst"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1742"></a>
<a name="line-1743"></a><span class='hs-comment'>{- Note [Casts during validity checking]
<a name="line-1744"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1745"></a>Consider the (bogus)
<a name="line-1746"></a>     instance Eq Char#
<a name="line-1747"></a>We elaborate to  'Eq (Char# |&gt; UnivCo(hole))'  where the hole is an
<a name="line-1748"></a>insoluble equality constraint for * ~ #.  We'll report the insoluble
<a name="line-1749"></a>constraint separately, but we don't want to *also* complain that Eq is
<a name="line-1750"></a>not applied to a type constructor.  So we look gaily look through
<a name="line-1751"></a>CastTys here.
<a name="line-1752"></a>
<a name="line-1753"></a>Another example:  Eq (Either a).  Then we actually get a cast in
<a name="line-1754"></a>the middle:
<a name="line-1755"></a>   Eq ((Either |&gt; g) a)
<a name="line-1756"></a>
<a name="line-1757"></a>
<a name="line-1758"></a>Note [Validity checking of HasField instances]
<a name="line-1759"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1760"></a>The HasField class has magic constraint solving behaviour (see Note
<a name="line-1761"></a>[HasField instances] in GHC.Tc.Solver.Interact).  However, we permit users to
<a name="line-1762"></a>declare their own instances, provided they do not clash with the
<a name="line-1763"></a>built-in behaviour.  In particular, we forbid:
<a name="line-1764"></a>
<a name="line-1765"></a>  1. `HasField _ r _` where r is a variable
<a name="line-1766"></a>
<a name="line-1767"></a>  2. `HasField _ (T ...) _` if T is a data family
<a name="line-1768"></a>     (because it might have fields introduced later)
<a name="line-1769"></a>
<a name="line-1770"></a>  3. `HasField x (T ...) _` where x is a variable,
<a name="line-1771"></a>      if T has any fields at all
<a name="line-1772"></a>
<a name="line-1773"></a>  4. `HasField "foo" (T ...) _` if T has a "foo" field
<a name="line-1774"></a>
<a name="line-1775"></a>The usual functional dependency checks also apply.
<a name="line-1776"></a>
<a name="line-1777"></a>
<a name="line-1778"></a>Note [Valid 'deriving' predicate]
<a name="line-1779"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1780"></a>validDerivPred checks for OK 'deriving' context.  See Note [Exotic
<a name="line-1781"></a>derived instance contexts] in GHC.Tc.Deriv.  However the predicate is
<a name="line-1782"></a>here because it uses sizeTypes, fvTypes.
<a name="line-1783"></a>
<a name="line-1784"></a>It checks for three things
<a name="line-1785"></a>
<a name="line-1786"></a>  * No repeated variables (hasNoDups fvs)
<a name="line-1787"></a>
<a name="line-1788"></a>  * No type constructors.  This is done by comparing
<a name="line-1789"></a>        sizeTypes tys == length (fvTypes tys)
<a name="line-1790"></a>    sizeTypes counts variables and constructors; fvTypes returns variables.
<a name="line-1791"></a>    So if they are the same, there must be no constructors.  But there
<a name="line-1792"></a>    might be applications thus (f (g x)).
<a name="line-1793"></a>
<a name="line-1794"></a>    Note that tys only includes the visible arguments of the class type
<a name="line-1795"></a>    constructor. Including the non-visible arguments can cause the following,
<a name="line-1796"></a>    perfectly valid instance to be rejected:
<a name="line-1797"></a>       class Category (cat :: k -&gt; k -&gt; *) where ...
<a name="line-1798"></a>       newtype T (c :: * -&gt; * -&gt; *) a b = MkT (c a b)
<a name="line-1799"></a>       instance Category c =&gt; Category (T c) where ...
<a name="line-1800"></a>    since the first argument to Category is a non-visible *, which sizeTypes
<a name="line-1801"></a>    would count as a constructor! See #11833.
<a name="line-1802"></a>
<a name="line-1803"></a>  * Also check for a bizarre corner case, when the derived instance decl
<a name="line-1804"></a>    would look like
<a name="line-1805"></a>       instance C a b =&gt; D (T a) where ...
<a name="line-1806"></a>    Note that 'b' isn't a parameter of T.  This gives rise to all sorts of
<a name="line-1807"></a>    problems; in particular, it's hard to compare solutions for equality
<a name="line-1808"></a>    when finding the fixpoint, and that means the inferContext loop does
<a name="line-1809"></a>    not converge.  See #5287.
<a name="line-1810"></a>
<a name="line-1811"></a>Note [Equality class instances]
<a name="line-1812"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1813"></a>We can't have users writing instances for the equality classes. But we
<a name="line-1814"></a>still need to be able to write instances for them ourselves. So we allow
<a name="line-1815"></a>instances only in the defining module.
<a name="line-1816"></a>
<a name="line-1817"></a>-}</span>
<a name="line-1818"></a>
<a name="line-1819"></a><a name="validDerivPred"></a><span class='hs-definition'>validDerivPred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1820"></a><span class='hs-comment'>-- See Note [Valid 'deriving' predicate]</span>
<a name="line-1821"></a><span class='hs-definition'>validDerivPred</span> <span class='hs-varid'>tv_set</span> <span class='hs-varid'>pred</span>
<a name="line-1822"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-1823"></a>       <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>typeableClassKey</span>
<a name="line-1824"></a>                <span class='hs-comment'>-- Typeable constraints are bigger than they appear due</span>
<a name="line-1825"></a>                <span class='hs-comment'>-- to kind polymorphism, but that's OK</span>
<a name="line-1826"></a>                       <span class='hs-varop'>||</span> <span class='hs-varid'>check_tys</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1827"></a>       <span class='hs-conid'>EqPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- reject equality constraints</span>
<a name="line-1828"></a>       <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- Non-class predicates are ok</span>
<a name="line-1829"></a>  <span class='hs-keyword'>where</span>
<a name="line-1830"></a>    <span class='hs-varid'>check_tys</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1831"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hasNoDups</span> <span class='hs-varid'>fvs</span>
<a name="line-1832"></a>                   <span class='hs-comment'>-- use sizePred to ignore implicit args</span>
<a name="line-1833"></a>                <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>lengthIs</span> <span class='hs-varid'>fvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizePred</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1834"></a>                <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tv_set</span><span class='hs-layout'>)</span> <span class='hs-varid'>fvs</span>
<a name="line-1835"></a>      <span class='hs-keyword'>where</span> <span class='hs-varid'>tys'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1836"></a>            <span class='hs-varid'>fvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>tys'</span>
<a name="line-1837"></a>
<a name="line-1838"></a><span class='hs-comment'>{-
<a name="line-1839"></a>************************************************************************
<a name="line-1840"></a>*                                                                      *
<a name="line-1841"></a>\subsection{Checking instance for termination}
<a name="line-1842"></a>*                                                                      *
<a name="line-1843"></a>************************************************************************
<a name="line-1844"></a>-}</span>
<a name="line-1845"></a>
<a name="line-1846"></a><span class='hs-comment'>{- Note [Instances and constraint synonyms]
<a name="line-1847"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1848"></a>Currently, we don't allow instances for constraint synonyms at all.
<a name="line-1849"></a>Consider these (#13267):
<a name="line-1850"></a>  type C1 a = Show (a -&gt; Bool)
<a name="line-1851"></a>  instance C1 Int where    -- I1
<a name="line-1852"></a>    show _ = "ur"
<a name="line-1853"></a>
<a name="line-1854"></a>This elicits "show is not a (visible) method of class C1", which isn't
<a name="line-1855"></a>a great message. But it comes from the renamer, so it's hard to improve.
<a name="line-1856"></a>
<a name="line-1857"></a>This needs a bit more care:
<a name="line-1858"></a>  type C2 a = (Show a, Show Int)
<a name="line-1859"></a>  instance C2 Int           -- I2
<a name="line-1860"></a>
<a name="line-1861"></a>If we use (splitTyConApp_maybe tau) in checkValidInstance to decompose
<a name="line-1862"></a>the instance head, we'll expand the synonym on fly, and it'll look like
<a name="line-1863"></a>  instance (%,%) (Show Int, Show Int)
<a name="line-1864"></a>and we /really/ don't want that.  So we carefully do /not/ expand
<a name="line-1865"></a>synonyms, by matching on TyConApp directly.
<a name="line-1866"></a>-}</span>
<a name="line-1867"></a>
<a name="line-1868"></a><a name="checkValidInstance"></a><span class='hs-definition'>checkValidInstance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UserTypeCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LHsSigType</span> <span class='hs-conid'>GhcRn</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1869"></a><span class='hs-definition'>checkValidInstance</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>hs_type</span> <span class='hs-varid'>ty</span>
<a name="line-1870"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>is_tc_app</span>
<a name="line-1871"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Instance head is not headed by a class:"</span><span class='hs-layout'>)</span>
<a name="line-1872"></a>                   <span class='hs-num'>2</span> <span class='hs-layout'>(</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1873"></a>
<a name="line-1874"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNothing</span> <span class='hs-varid'>mb_cls</span>
<a name="line-1875"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal instance for a"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConFlavour</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-1876"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"A class instance must be for a class"</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1877"></a>
<a name="line-1878"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>arity_ok</span>
<a name="line-1879"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Arity mis-match in instance head"</span><span class='hs-layout'>)</span>
<a name="line-1880"></a>
<a name="line-1881"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1882"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>setSrcSpanA</span> <span class='hs-varid'>head_loc</span> <span class='hs-varop'>$</span>
<a name="line-1883"></a>          <span class='hs-varid'>checkValidInstHead</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span>
<a name="line-1884"></a>
<a name="line-1885"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkValidInstance {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1886"></a>
<a name="line-1887"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>env0</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInitTidyEnv</span>
<a name="line-1888"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>expand</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>initialExpandMode</span>
<a name="line-1889"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>check_valid_theta</span> <span class='hs-varid'>env0</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>expand</span> <span class='hs-varid'>theta</span>
<a name="line-1890"></a>
<a name="line-1891"></a>        <span class='hs-comment'>-- The Termination and Coverate Conditions</span>
<a name="line-1892"></a>        <span class='hs-comment'>-- Check that instance inference will terminate (if we care)</span>
<a name="line-1893"></a>        <span class='hs-comment'>-- For Haskell 98 this will already have been done by checkValidTheta,</span>
<a name="line-1894"></a>        <span class='hs-comment'>-- but as we may be using other extensions we need to check.</span>
<a name="line-1895"></a>        <span class='hs-comment'>--</span>
<a name="line-1896"></a>        <span class='hs-comment'>-- Note that the Termination Condition is *more conservative* than</span>
<a name="line-1897"></a>        <span class='hs-comment'>-- the checkAmbiguity test we do on other type signatures</span>
<a name="line-1898"></a>        <span class='hs-comment'>--   e.g.  Bar a =&gt; Bar Int is ambiguous, but it also fails</span>
<a name="line-1899"></a>        <span class='hs-comment'>--   the termination condition, because 'a' appears more often</span>
<a name="line-1900"></a>        <span class='hs-comment'>--   in the constraint than in the head</span>
<a name="line-1901"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.UndecidableInstances</span>
<a name="line-1902"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>undecidable_ok</span>
<a name="line-1903"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>checkAmbiguity</span> <span class='hs-varid'>ctxt</span> <span class='hs-varid'>ty</span>
<a name="line-1904"></a>          <span class='hs-keyword'>else</span> <span class='hs-varid'>checkInstTermination</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tau</span>
<a name="line-1905"></a>
<a name="line-1906"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"cvi 2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1907"></a>
<a name="line-1908"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkInstCoverage</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1909"></a>            <span class='hs-conid'>IsValid</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>   <span class='hs-comment'>-- Check succeeded</span>
<a name="line-1910"></a>            <span class='hs-conid'>NotValid</span> <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>instTypeErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varid'>msg</span><span class='hs-layout'>)</span>
<a name="line-1911"></a>
<a name="line-1912"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End checkValidInstance }"</span> <span class='hs-varid'>empty</span>
<a name="line-1913"></a>
<a name="line-1914"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-1915"></a>  <span class='hs-keyword'>where</span>
<a name="line-1916"></a>    <span class='hs-layout'>(</span><span class='hs-sel'>_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>tau</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitSigmaTy</span> <span class='hs-varid'>ty</span>
<a name="line-1917"></a>    <span class='hs-varid'>is_tc_app</span>            <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tau</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>TyConApp</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span><span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-1918"></a>    <span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>inst_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tau</span>   <span class='hs-comment'>-- See Note [Instances and constraint synonyms]</span>
<a name="line-1919"></a>    <span class='hs-varid'>mb_cls</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConClass_maybe</span> <span class='hs-varid'>tc</span>
<a name="line-1920"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>clas</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mb_cls</span>
<a name="line-1921"></a>    <span class='hs-varid'>arity_ok</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inst_tys</span> <span class='hs-varop'>`lengthIs`</span> <span class='hs-varid'>classArity</span> <span class='hs-varid'>clas</span>
<a name="line-1922"></a>
<a name="line-1923"></a>        <span class='hs-comment'>-- The location of the "head" of the instance</span>
<a name="line-1924"></a>    <span class='hs-varid'>head_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getLoc</span> <span class='hs-layout'>(</span><span class='hs-varid'>getLHsInstDeclHead</span> <span class='hs-varid'>hs_type</span><span class='hs-layout'>)</span>
<a name="line-1925"></a>
<a name="line-1926"></a><span class='hs-comment'>{-
<a name="line-1927"></a>Note [Paterson conditions]
<a name="line-1928"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1929"></a>Termination test: the so-called "Paterson conditions" (see Section 5 of
<a name="line-1930"></a>"Understanding functional dependencies via Constraint Handling Rules,
<a name="line-1931"></a>JFP Jan 2007).
<a name="line-1932"></a>
<a name="line-1933"></a>We check that each assertion in the context satisfies:
<a name="line-1934"></a> (1) no variable has more occurrences in the assertion than in the head, and
<a name="line-1935"></a> (2) the assertion has fewer constructors and variables (taken together
<a name="line-1936"></a>     and counting repetitions) than the head.
<a name="line-1937"></a>This is only needed with -fglasgow-exts, as Haskell 98 restrictions
<a name="line-1938"></a>(which have already been checked) guarantee termination.
<a name="line-1939"></a>
<a name="line-1940"></a>The underlying idea is that
<a name="line-1941"></a>
<a name="line-1942"></a>    for any ground substitution, each assertion in the
<a name="line-1943"></a>    context has fewer type constructors than the head.
<a name="line-1944"></a>-}</span>
<a name="line-1945"></a>
<a name="line-1946"></a><a name="checkInstTermination"></a><span class='hs-definition'>checkInstTermination</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcPredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1947"></a><span class='hs-comment'>-- See Note [Paterson conditions]</span>
<a name="line-1948"></a><span class='hs-definition'>checkInstTermination</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>head_pred</span>
<a name="line-1949"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>check_preds</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>theta</span>
<a name="line-1950"></a>  <span class='hs-keyword'>where</span>
<a name="line-1951"></a>   <span class='hs-varid'>head_fvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>head_pred</span>
<a name="line-1952"></a>   <span class='hs-varid'>head_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>head_pred</span>
<a name="line-1953"></a>
<a name="line-1954"></a>   <span class='hs-varid'>check_preds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1955"></a>   <span class='hs-varid'>check_preds</span> <span class='hs-varid'>foralld_tvs</span> <span class='hs-varid'>preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>check</span> <span class='hs-varid'>foralld_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>preds</span>
<a name="line-1956"></a>
<a name="line-1957"></a>   <span class='hs-varid'>check</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1958"></a>   <span class='hs-varid'>check</span> <span class='hs-varid'>foralld_tvs</span> <span class='hs-varid'>pred</span>
<a name="line-1959"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-1960"></a>         <span class='hs-conid'>EqPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>  <span class='hs-comment'>-- See #4200.</span>
<a name="line-1961"></a>         <span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check2</span> <span class='hs-varid'>foralld_tvs</span> <span class='hs-varid'>pred</span> <span class='hs-layout'>(</span><span class='hs-varid'>sizeType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1962"></a>         <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1963"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTerminatingClass</span> <span class='hs-varid'>cls</span>
<a name="line-1964"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1965"></a>
<a name="line-1966"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCTupleClass</span> <span class='hs-varid'>cls</span>  <span class='hs-comment'>-- Look inside tuple predicates; #8359</span>
<a name="line-1967"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_preds</span> <span class='hs-varid'>foralld_tvs</span> <span class='hs-varid'>tys</span>
<a name="line-1968"></a>
<a name="line-1969"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-comment'>-- Other ClassPreds</span>
<a name="line-1970"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check2</span> <span class='hs-varid'>foralld_tvs</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>bogus_size</span>
<a name="line-1971"></a>           <span class='hs-keyword'>where</span>
<a name="line-1972"></a>              <span class='hs-varid'>bogus_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1973"></a>                               <span class='hs-comment'>-- See Note [Invisible arguments and termination]</span>
<a name="line-1974"></a>
<a name="line-1975"></a>         <span class='hs-conid'>ForAllPred</span> <span class='hs-varid'>tvs</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>head_pred'</span>
<a name="line-1976"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check</span> <span class='hs-layout'>(</span><span class='hs-varid'>foralld_tvs</span> <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>head_pred'</span>
<a name="line-1977"></a>              <span class='hs-comment'>-- Termination of the quantified predicate itself is checked</span>
<a name="line-1978"></a>              <span class='hs-comment'>-- when the predicates are individually checked for validity</span>
<a name="line-1979"></a>
<a name="line-1980"></a>   <span class='hs-varid'>check2</span> <span class='hs-varid'>foralld_tvs</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>pred_size</span>
<a name="line-1981"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>noMoreMsg</span> <span class='hs-varid'>bad_tvs</span> <span class='hs-varid'>what</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>head_pred</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1982"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyFamFree</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>nestedMsg</span> <span class='hs-varid'>what</span><span class='hs-layout'>)</span>
<a name="line-1983"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pred_size</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>head_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>failWithTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>smallerMsg</span> <span class='hs-varid'>what</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>head_pred</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1984"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1985"></a>     <span class='hs-comment'>-- isTyFamFree: see Note [Type families in instance contexts]</span>
<a name="line-1986"></a>     <span class='hs-keyword'>where</span>
<a name="line-1987"></a>        <span class='hs-varid'>what</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"constraint"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1988"></a>        <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>foralld_tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvType</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1989"></a>                  <span class='hs-varop'>\\</span> <span class='hs-varid'>head_fvs</span>
<a name="line-1990"></a>
<a name="line-1991"></a><a name="smallerMsg"></a><span class='hs-definition'>smallerMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1992"></a><span class='hs-definition'>smallerMsg</span> <span class='hs-varid'>what</span> <span class='hs-varid'>inst_head</span>
<a name="line-1993"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"The"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what</span><span class='hs-layout'>)</span>
<a name="line-1994"></a>              <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"is no smaller than"</span>
<a name="line-1995"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"the instance head"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-varid'>inst_head</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1996"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span> <span class='hs-keyglyph'>]</span>
<a name="line-1997"></a>
<a name="line-1998"></a><a name="noMoreMsg"></a><span class='hs-definition'>noMoreMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1999"></a><span class='hs-definition'>noMoreMsg</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>what</span> <span class='hs-varid'>inst_head</span>
<a name="line-2000"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Variable"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>plural</span> <span class='hs-varid'>tvs1</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprWithCommas</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tvs1</span><span class='hs-layout'>)</span>
<a name="line-2001"></a>                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>occurs</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"more often"</span><span class='hs-layout'>)</span>
<a name="line-2002"></a>              <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"in the"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what</span>
<a name="line-2003"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"than in the instance head"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-varid'>inst_head</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2004"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span> <span class='hs-keyglyph'>]</span>
<a name="line-2005"></a>  <span class='hs-keyword'>where</span>
<a name="line-2006"></a>   <span class='hs-varid'>tvs1</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nub</span> <span class='hs-varid'>tvs</span>
<a name="line-2007"></a>   <span class='hs-varid'>occurs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isSingleton</span> <span class='hs-varid'>tvs1</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>text</span> <span class='hs-str'>"occurs"</span>
<a name="line-2008"></a>                               <span class='hs-keyword'>else</span> <span class='hs-varid'>text</span> <span class='hs-str'>"occur"</span>
<a name="line-2009"></a>
<a name="line-2010"></a><a name="undecidableMsg"></a><span class='hs-definition'>undecidableMsg</span><span class='hs-layout'>,</span> <span class='hs-varid'>constraintKindsMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span>
<a name="line-2011"></a><span class='hs-definition'>undecidableMsg</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Use UndecidableInstances to permit this"</span>
<a name="line-2012"></a><a name="constraintKindsMsg"></a><span class='hs-definition'>constraintKindsMsg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Use ConstraintKinds to permit this"</span>
<a name="line-2013"></a>
<a name="line-2014"></a><span class='hs-comment'>{- Note [Type families in instance contexts]
<a name="line-2015"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2016"></a>Are these OK?
<a name="line-2017"></a>  type family F a
<a name="line-2018"></a>  instance F a    =&gt; C (Maybe [a]) where ...
<a name="line-2019"></a>  instance C (F a) =&gt; C [[[a]]]     where ...
<a name="line-2020"></a>
<a name="line-2021"></a>No: the type family in the instance head might blow up to an
<a name="line-2022"></a>arbitrarily large type, depending on how 'a' is instantiated.
<a name="line-2023"></a>So we require UndecidableInstances if we have a type family
<a name="line-2024"></a>in the instance head.  #15172.
<a name="line-2025"></a>
<a name="line-2026"></a>Note [Invisible arguments and termination]
<a name="line-2027"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2028"></a>When checking the ​Paterson conditions for termination an instance
<a name="line-2029"></a>declaration, we check for the number of "constructors and variables"
<a name="line-2030"></a>in the instance head and constraints. Question: Do we look at
<a name="line-2031"></a>
<a name="line-2032"></a> * All the arguments, visible or invisible?
<a name="line-2033"></a> * Just the visible arguments?
<a name="line-2034"></a>
<a name="line-2035"></a>I think both will ensure termination, provided we are consistent.
<a name="line-2036"></a>Currently we are /not/ consistent, which is really a bug.  It's
<a name="line-2037"></a>described in #15177, which contains a number of examples.
<a name="line-2038"></a>The suspicious bits are the calls to filterOutInvisibleTypes.
<a name="line-2039"></a>-}</span>
<a name="line-2040"></a>
<a name="line-2041"></a>
<a name="line-2042"></a><span class='hs-comment'>{-
<a name="line-2043"></a>************************************************************************
<a name="line-2044"></a>*                                                                      *
<a name="line-2045"></a>        Checking type instance well-formedness and termination
<a name="line-2046"></a>*                                                                      *
<a name="line-2047"></a>************************************************************************
<a name="line-2048"></a>-}</span>
<a name="line-2049"></a>
<a name="line-2050"></a><a name="checkValidCoAxiom"></a><span class='hs-definition'>checkValidCoAxiom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoAxiom</span> <span class='hs-conid'>Branched</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2051"></a><span class='hs-definition'>checkValidCoAxiom</span> <span class='hs-varid'>ax</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co_ax_tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_ax_branches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>branches</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2052"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkValidCoAxBranch</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>branch_list</span>
<a name="line-2053"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>foldlM_</span> <span class='hs-varid'>check_branch_compat</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>branch_list</span> <span class='hs-layout'>}</span>
<a name="line-2054"></a>  <span class='hs-keyword'>where</span>
<a name="line-2055"></a>    <span class='hs-varid'>branch_list</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromBranches</span> <span class='hs-varid'>branches</span>
<a name="line-2056"></a>    <span class='hs-varid'>injectivity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConInjectivityInfo</span> <span class='hs-varid'>fam_tc</span>
<a name="line-2057"></a>
<a name="line-2058"></a>    <span class='hs-varid'>check_branch_compat</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- previous branches in reverse order</span>
<a name="line-2059"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span>      <span class='hs-comment'>-- current branch</span>
<a name="line-2060"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span><span class='hs-comment'>-- current branch : previous branches</span>
<a name="line-2061"></a>    <span class='hs-comment'>-- Check for</span>
<a name="line-2062"></a>    <span class='hs-comment'>--   (a) this branch is dominated by previous ones</span>
<a name="line-2063"></a>    <span class='hs-comment'>--   (b) failure of injectivity</span>
<a name="line-2064"></a>    <span class='hs-varid'>check_branch_compat</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span>
<a name="line-2065"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>cur_branch</span> <span class='hs-varop'>`isDominatedBy`</span> <span class='hs-varid'>prev_branches</span>
<a name="line-2066"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>addWarnAt</span> <span class='hs-conid'>NoReason</span> <span class='hs-layout'>(</span><span class='hs-varid'>coAxBranchSpan</span> <span class='hs-varid'>cur_branch</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2067"></a>             <span class='hs-varid'>inaccessibleCoAxBranch</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>cur_branch</span>
<a name="line-2068"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>prev_branches</span> <span class='hs-layout'>}</span>
<a name="line-2069"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2070"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>check_injectivity</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span>
<a name="line-2071"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>cur_branch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>prev_branches</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2072"></a>
<a name="line-2073"></a>     <span class='hs-comment'>-- Injectivity check: check whether a new (CoAxBranch) can extend</span>
<a name="line-2074"></a>     <span class='hs-comment'>-- already checked equations without violating injectivity</span>
<a name="line-2075"></a>     <span class='hs-comment'>-- annotation supplied by the user.</span>
<a name="line-2076"></a>     <span class='hs-comment'>-- See Note [Verifying injectivity annotation] in GHC.Core.FamInstEnv</span>
<a name="line-2077"></a>    <span class='hs-varid'>check_injectivity</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span>
<a name="line-2078"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Injective</span> <span class='hs-varid'>inj</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>injectivity</span>
<a name="line-2079"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-2080"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>conflicts</span> <span class='hs-keyglyph'>=</span>
<a name="line-2081"></a>                     <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-varid'>gather_conflicts</span> <span class='hs-varid'>inj</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span><span class='hs-layout'>)</span>
<a name="line-2082"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span> <span class='hs-varid'>prev_branches</span>
<a name="line-2083"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>reportConflictingInjectivityErrs</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>conflicts</span> <span class='hs-varid'>cur_branch</span>
<a name="line-2084"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>reportInjectivityErrors</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ax</span> <span class='hs-varid'>cur_branch</span> <span class='hs-varid'>inj</span> <span class='hs-layout'>}</span>
<a name="line-2085"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2086"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-2087"></a>
<a name="line-2088"></a>    <span class='hs-varid'>gather_conflicts</span> <span class='hs-varid'>inj</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>cur_branch</span> <span class='hs-layout'>(</span><span class='hs-varid'>acc</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>branch</span>
<a name="line-2089"></a>               <span class='hs-comment'>-- n is 0-based index of branch in prev_branches</span>
<a name="line-2090"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>injectiveBranches</span> <span class='hs-varid'>inj</span> <span class='hs-varid'>cur_branch</span> <span class='hs-varid'>branch</span> <span class='hs-keyword'>of</span>
<a name="line-2091"></a>           <span class='hs-comment'>-- Case 1B2 in Note [Verifying injectivity annotation] in GHC.Core.FamInstEnv</span>
<a name="line-2092"></a>          <span class='hs-conid'>InjectivityUnified</span> <span class='hs-varid'>ax1</span> <span class='hs-varid'>ax2</span>
<a name="line-2093"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ax1</span> <span class='hs-varop'>`isDominatedBy`</span> <span class='hs-layout'>(</span><span class='hs-varid'>replace_br</span> <span class='hs-varid'>prev_branches</span> <span class='hs-varid'>n</span> <span class='hs-varid'>ax2</span><span class='hs-layout'>)</span>
<a name="line-2094"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>acc</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-2095"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2096"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>branch</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-2097"></a>          <span class='hs-conid'>InjectivityAccepted</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>acc</span><span class='hs-layout'>,</span> <span class='hs-varid'>n</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-2098"></a>
<a name="line-2099"></a>    <span class='hs-comment'>-- Replace n-th element in the list. Assumes 0-based indexing.</span>
<a name="line-2100"></a>    <span class='hs-varid'>replace_br</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoAxBranch</span><span class='hs-keyglyph'>]</span>
<a name="line-2101"></a>    <span class='hs-varid'>replace_br</span> <span class='hs-varid'>brs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>br</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>take</span> <span class='hs-varid'>n</span> <span class='hs-varid'>brs</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>br</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>++</span> <span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>brs</span>
<a name="line-2102"></a>
<a name="line-2103"></a>
<a name="line-2104"></a><a name="checkValidCoAxBranch"></a><span class='hs-comment'>-- Check that a "type instance" is well-formed (which includes decidability</span>
<a name="line-2105"></a><span class='hs-comment'>-- unless -XUndecidableInstances is given).</span>
<a name="line-2106"></a><span class='hs-comment'>--</span>
<a name="line-2107"></a><span class='hs-definition'>checkValidCoAxBranch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2108"></a><span class='hs-definition'>checkValidCoAxBranch</span> <span class='hs-varid'>fam_tc</span>
<a name="line-2109"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>CoAxBranch</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cab_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cab_cvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cvs</span>
<a name="line-2110"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>cab_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typats</span>
<a name="line-2111"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>cab_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cab_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2112"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setSrcSpan</span> <span class='hs-varid'>loc</span> <span class='hs-varop'>$</span>
<a name="line-2113"></a>    <span class='hs-varid'>checkValidTyFamEqn</span> <span class='hs-varid'>fam_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-varop'>++</span><span class='hs-varid'>cvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>typats</span> <span class='hs-varid'>rhs</span>
<a name="line-2114"></a>
<a name="line-2115"></a><a name="checkValidTyFamEqn"></a><span class='hs-comment'>-- | Do validity checks on a type family equation, including consistency</span>
<a name="line-2116"></a><span class='hs-comment'>-- with any enclosing class instance head, termination, and lack of</span>
<a name="line-2117"></a><span class='hs-comment'>-- polytypes.</span>
<a name="line-2118"></a><span class='hs-definition'>checkValidTyFamEqn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>   <span class='hs-comment'>-- ^ of the type family</span>
<a name="line-2119"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- ^ Bound variables in the equation</span>
<a name="line-2120"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ^ Type patterns</span>
<a name="line-2121"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- ^ Rhs</span>
<a name="line-2122"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2123"></a><span class='hs-definition'>checkValidTyFamEqn</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>qvs</span> <span class='hs-varid'>typats</span> <span class='hs-varid'>rhs</span>
<a name="line-2124"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>checkValidTypePats</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>typats</span>
<a name="line-2125"></a>
<a name="line-2126"></a>         <span class='hs-comment'>-- Check for things used on the right but not bound on the left</span>
<a name="line-2127"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkFamPatBinders</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>qvs</span> <span class='hs-varid'>typats</span> <span class='hs-varid'>rhs</span>
<a name="line-2128"></a>
<a name="line-2129"></a>         <span class='hs-comment'>-- Check for oversaturated visible kind arguments in a type family</span>
<a name="line-2130"></a>         <span class='hs-comment'>-- equation.</span>
<a name="line-2131"></a>         <span class='hs-comment'>-- See Note [Oversaturated type family equations]</span>
<a name="line-2132"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2133"></a>           <span class='hs-keyword'>case</span> <span class='hs-varid'>drop</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>typats</span> <span class='hs-keyword'>of</span>
<a name="line-2134"></a>             <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-2135"></a>             <span class='hs-varid'>spec_arg</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2136"></a>               <span class='hs-varid'>addErr</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal oversaturated visible kind argument:"</span>
<a name="line-2137"></a>                    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>char</span> <span class='hs-chr'>'@'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>pprParendType</span> <span class='hs-varid'>spec_arg</span><span class='hs-layout'>)</span>
<a name="line-2138"></a>
<a name="line-2139"></a>         <span class='hs-comment'>-- The argument patterns, and RHS, are all boxed tau types</span>
<a name="line-2140"></a>         <span class='hs-comment'>-- E.g  Reject type family F (a :: k1) :: k2</span>
<a name="line-2141"></a>         <span class='hs-comment'>--             type instance F (forall a. a-&gt;a) = ...</span>
<a name="line-2142"></a>         <span class='hs-comment'>--             type instance F Int#             = ...</span>
<a name="line-2143"></a>         <span class='hs-comment'>--             type instance F Int              = forall a. a-&gt;a</span>
<a name="line-2144"></a>         <span class='hs-comment'>--             type instance F Int              = Int#</span>
<a name="line-2145"></a>         <span class='hs-comment'>-- See #9357</span>
<a name="line-2146"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>rhs</span>
<a name="line-2147"></a>
<a name="line-2148"></a>         <span class='hs-comment'>-- We have a decidable instance unless otherwise permitted</span>
<a name="line-2149"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.UndecidableInstances</span>
<a name="line-2150"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkVTFE"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTyFamInsts</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2151"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-varid'>undecidable_ok</span> <span class='hs-varop'>$</span>
<a name="line-2152"></a>         <span class='hs-varid'>mapM_</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkFamInstRhs</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>typats</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTyFamInsts</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2153"></a>
<a name="line-2154"></a><a name="checkValidAssocTyFamDeflt"></a><span class='hs-comment'>-- | Checks that an associated type family default:</span>
<a name="line-2155"></a><span class='hs-comment'>--</span>
<a name="line-2156"></a><span class='hs-comment'>-- 1. Only consists of arguments that are bare type variables, and</span>
<a name="line-2157"></a><span class='hs-comment'>--</span>
<a name="line-2158"></a><span class='hs-comment'>-- 2. Has a distinct type variable in each argument.</span>
<a name="line-2159"></a><span class='hs-comment'>--</span>
<a name="line-2160"></a><span class='hs-comment'>-- See @Note [Type-checking default assoc decls]@ in "GHC.Tc.TyCl".</span>
<a name="line-2161"></a><span class='hs-definition'>checkValidAssocTyFamDeflt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>  <span class='hs-comment'>-- ^ of the type family</span>
<a name="line-2162"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ Type patterns</span>
<a name="line-2163"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2164"></a><span class='hs-definition'>checkValidAssocTyFamDeflt</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats</span> <span class='hs-keyglyph'>=</span>
<a name="line-2165"></a>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cpt_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWithM</span> <span class='hs-varid'>extract_tv</span> <span class='hs-varid'>pats</span> <span class='hs-varid'>pats_vis</span>
<a name="line-2166"></a>     <span class='hs-layout'>;</span> <span class='hs-varid'>check_all_distinct_tvs</span> <span class='hs-varop'>$</span> <span class='hs-varid'>zip</span> <span class='hs-varid'>cpt_tvs</span> <span class='hs-varid'>pats_vis</span> <span class='hs-layout'>}</span>
<a name="line-2167"></a>  <span class='hs-keyword'>where</span>
<a name="line-2168"></a>    <span class='hs-varid'>pats_vis</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgFlag</span><span class='hs-keyglyph'>]</span>
<a name="line-2169"></a>    <span class='hs-varid'>pats_vis</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConArgFlags</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats</span>
<a name="line-2170"></a>
<a name="line-2171"></a>    <span class='hs-comment'>-- Checks that a pattern on the LHS of a default is a type</span>
<a name="line-2172"></a>    <span class='hs-comment'>-- variable. If so, return the underlying type variable, and if</span>
<a name="line-2173"></a>    <span class='hs-comment'>-- not, throw an error.</span>
<a name="line-2174"></a>    <span class='hs-comment'>-- See Note [Type-checking default assoc decls]</span>
<a name="line-2175"></a>    <span class='hs-varid'>extract_tv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- The particular type pattern from which to extract</span>
<a name="line-2176"></a>                          <span class='hs-comment'>-- its underlying type variable</span>
<a name="line-2177"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgFlag</span> <span class='hs-comment'>-- The visibility of the type pattern</span>
<a name="line-2178"></a>                          <span class='hs-comment'>-- (only used for error message purposes)</span>
<a name="line-2179"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>TyVar</span>
<a name="line-2180"></a>    <span class='hs-varid'>extract_tv</span> <span class='hs-varid'>pat</span> <span class='hs-varid'>pat_vis</span> <span class='hs-keyglyph'>=</span>
<a name="line-2181"></a>      <span class='hs-keyword'>case</span> <span class='hs-varid'>getTyVar_maybe</span> <span class='hs-varid'>pat</span> <span class='hs-keyword'>of</span>
<a name="line-2182"></a>        <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>tv</span>
<a name="line-2183"></a>        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varop'>$</span>
<a name="line-2184"></a>          <span class='hs-varid'>pprWithExplicitKindsWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInvisibleArgFlag</span> <span class='hs-varid'>pat_vis</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2185"></a>          <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal argument"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pat</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"in:"</span><span class='hs-layout'>)</span>
<a name="line-2186"></a>             <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr_eqn</span><span class='hs-layout'>,</span> <span class='hs-varid'>suggestion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2187"></a>
<a name="line-2188"></a>    <span class='hs-comment'>-- Checks that no type variables in an associated default declaration are</span>
<a name="line-2189"></a>    <span class='hs-comment'>-- duplicated. If that is the case, throw an error.</span>
<a name="line-2190"></a>    <span class='hs-comment'>-- See Note [Type-checking default assoc decls]</span>
<a name="line-2191"></a>    <span class='hs-varid'>check_all_distinct_tvs</span> <span class='hs-keyglyph'>::</span>
<a name="line-2192"></a>         <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>ArgFlag</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- The type variable arguments in the associated</span>
<a name="line-2193"></a>                            <span class='hs-comment'>-- default declaration, along with their respective</span>
<a name="line-2194"></a>                            <span class='hs-comment'>-- visibilities (the latter are only used for error</span>
<a name="line-2195"></a>                            <span class='hs-comment'>-- message purposes)</span>
<a name="line-2196"></a>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2197"></a>    <span class='hs-varid'>check_all_distinct_tvs</span> <span class='hs-varid'>cpt_tvs_vis</span> <span class='hs-keyglyph'>=</span>
<a name="line-2198"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>dups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDupsEq</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>==</span><span class='hs-layout'>)</span> <span class='hs-varop'>`on`</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>cpt_tvs_vis</span> <span class='hs-keyword'>in</span>
<a name="line-2199"></a>      <span class='hs-varid'>traverse_</span>
<a name="line-2200"></a>        <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>d</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>pat_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>pat_vis</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NE.head</span> <span class='hs-varid'>d</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varop'>$</span>
<a name="line-2201"></a>               <span class='hs-varid'>pprWithExplicitKindsWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInvisibleArgFlag</span> <span class='hs-varid'>pat_vis</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2202"></a>               <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal duplicate variable"</span>
<a name="line-2203"></a>                       <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pat_tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"in:"</span><span class='hs-layout'>)</span>
<a name="line-2204"></a>                  <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr_eqn</span><span class='hs-layout'>,</span> <span class='hs-varid'>suggestion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2205"></a>        <span class='hs-varid'>dups</span>
<a name="line-2206"></a>
<a name="line-2207"></a>    <span class='hs-varid'>ppr_eqn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span>
<a name="line-2208"></a>    <span class='hs-varid'>ppr_eqn</span> <span class='hs-keyglyph'>=</span>
<a name="line-2209"></a>      <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"type"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-2210"></a>                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"..."</span><span class='hs-layout'>)</span>
<a name="line-2211"></a>
<a name="line-2212"></a>    <span class='hs-varid'>suggestion</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span>
<a name="line-2213"></a>    <span class='hs-varid'>suggestion</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"The arguments to"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-2214"></a>             <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"must all be distinct type variables"</span>
<a name="line-2215"></a>
<a name="line-2216"></a><a name="checkFamInstRhs"></a><span class='hs-comment'>-- Make sure that each type family application is</span>
<a name="line-2217"></a><span class='hs-comment'>--   (1) strictly smaller than the lhs,</span>
<a name="line-2218"></a><span class='hs-comment'>--   (2) mentions no type variable more often than the lhs, and</span>
<a name="line-2219"></a><span class='hs-comment'>--   (3) does not contain any further type family instances.</span>
<a name="line-2220"></a><span class='hs-comment'>--</span>
<a name="line-2221"></a><span class='hs-definition'>checkFamInstRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- LHS</span>
<a name="line-2222"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- type family calls in RHS</span>
<a name="line-2223"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>SDoc</span><span class='hs-keyglyph'>]</span>
<a name="line-2224"></a><span class='hs-definition'>checkFamInstRhs</span> <span class='hs-varid'>lhs_tc</span> <span class='hs-varid'>lhs_tys</span> <span class='hs-varid'>famInsts</span>
<a name="line-2225"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapMaybe</span> <span class='hs-varid'>check</span> <span class='hs-varid'>famInsts</span>
<a name="line-2226"></a>  <span class='hs-keyword'>where</span>
<a name="line-2227"></a>   <span class='hs-varid'>lhs_size</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTyConAppArgs</span> <span class='hs-varid'>lhs_tc</span> <span class='hs-varid'>lhs_tys</span>
<a name="line-2228"></a>   <span class='hs-varid'>inst_head</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>lhs_tc</span> <span class='hs-varid'>lhs_tys</span><span class='hs-layout'>)</span>
<a name="line-2229"></a>   <span class='hs-varid'>lhs_fvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>lhs_tys</span>
<a name="line-2230"></a>   <span class='hs-varid'>check</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-2231"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>isTyFamFree</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>nestedMsg</span> <span class='hs-varid'>what</span><span class='hs-layout'>)</span>
<a name="line-2232"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>noMoreMsg</span> <span class='hs-varid'>bad_tvs</span> <span class='hs-varid'>what</span> <span class='hs-varid'>inst_head</span><span class='hs-layout'>)</span>
<a name="line-2233"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lhs_size</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>fam_app_size</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>smallerMsg</span> <span class='hs-varid'>what</span> <span class='hs-varid'>inst_head</span><span class='hs-layout'>)</span>
<a name="line-2234"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-2235"></a>      <span class='hs-keyword'>where</span>
<a name="line-2236"></a>        <span class='hs-varid'>what</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"type family application"</span>
<a name="line-2237"></a>               <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2238"></a>        <span class='hs-varid'>fam_app_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTyConAppArgs</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-2239"></a>        <span class='hs-varid'>bad_tvs</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>lhs_fvs</span>
<a name="line-2240"></a>                       <span class='hs-comment'>-- The (\\) is list difference; e.g.</span>
<a name="line-2241"></a>                       <span class='hs-comment'>--   [a,b,a,a] \\ [a,a] = [b,a]</span>
<a name="line-2242"></a>                       <span class='hs-comment'>-- So we are counting repetitions</span>
<a name="line-2243"></a>
<a name="line-2244"></a><a name="checkFamPatBinders"></a><span class='hs-comment'>-----------------</span>
<a name="line-2245"></a><span class='hs-definition'>checkFamPatBinders</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>
<a name="line-2246"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Bound on LHS of family instance</span>
<a name="line-2247"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- LHS patterns</span>
<a name="line-2248"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>        <span class='hs-comment'>-- RHS</span>
<a name="line-2249"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2250"></a><span class='hs-definition'>checkFamPatBinders</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>qtvs</span> <span class='hs-varid'>pats</span> <span class='hs-varid'>rhs</span>
<a name="line-2251"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkFamPatBinders"</span> <span class='hs-varop'>$</span>
<a name="line-2252"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>debugPprType</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-2253"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-2254"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"qtvs:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span>
<a name="line-2255"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"rhs_tvs:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvVarSet</span> <span class='hs-varid'>rhs_fvs</span><span class='hs-layout'>)</span>
<a name="line-2256"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"cpt_tvs:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cpt_tvs</span>
<a name="line-2257"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"inj_cpt_tvs:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inj_cpt_tvs</span> <span class='hs-keyglyph'>]</span>
<a name="line-2258"></a>
<a name="line-2259"></a>         <span class='hs-comment'>-- Check for implicitly-bound tyvars, mentioned on the</span>
<a name="line-2260"></a>         <span class='hs-comment'>-- RHS but not bound on the LHS</span>
<a name="line-2261"></a>         <span class='hs-comment'>--    data T            = MkT (forall (a::k). blah)</span>
<a name="line-2262"></a>         <span class='hs-comment'>--    data family D Int = MkD (forall (a::k). blah)</span>
<a name="line-2263"></a>         <span class='hs-comment'>-- In both cases, 'k' is not bound on the LHS, but is used on the RHS</span>
<a name="line-2264"></a>         <span class='hs-comment'>-- We catch the former in kcDeclHeader, and the latter right here</span>
<a name="line-2265"></a>         <span class='hs-comment'>-- See Note [Check type-family instance binders]</span>
<a name="line-2266"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_tvs</span> <span class='hs-varid'>bad_rhs_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"mentioned in the RHS"</span><span class='hs-layout'>)</span>
<a name="line-2267"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"bound on the LHS of"</span><span class='hs-layout'>)</span>
<a name="line-2268"></a>
<a name="line-2269"></a>         <span class='hs-comment'>-- Check for explicitly forall'd variable that is not bound on LHS</span>
<a name="line-2270"></a>         <span class='hs-comment'>--    data instance forall a.  T Int = MkT Int</span>
<a name="line-2271"></a>         <span class='hs-comment'>-- See Note [Unused explicitly bound variables in a family pattern]</span>
<a name="line-2272"></a>         <span class='hs-comment'>-- See Note [Check type-family instance binders]</span>
<a name="line-2273"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_tvs</span> <span class='hs-varid'>bad_qtvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"bound by a forall"</span><span class='hs-layout'>)</span>
<a name="line-2274"></a>                            <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"used in"</span><span class='hs-layout'>)</span>
<a name="line-2275"></a>       <span class='hs-layout'>}</span>
<a name="line-2276"></a>  <span class='hs-keyword'>where</span>
<a name="line-2277"></a>    <span class='hs-varid'>cpt_tvs</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>pats</span>
<a name="line-2278"></a>    <span class='hs-varid'>inj_cpt_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvVarSet</span> <span class='hs-varop'>$</span> <span class='hs-varid'>injectiveVarsOfTypes</span> <span class='hs-conid'>False</span> <span class='hs-varid'>pats</span>
<a name="line-2279"></a>      <span class='hs-comment'>-- The type variables that are in injective positions.</span>
<a name="line-2280"></a>      <span class='hs-comment'>-- See Note [Dodgy binding sites in type family instances]</span>
<a name="line-2281"></a>      <span class='hs-comment'>-- NB: The False above is irrelevant, as we never have type families in</span>
<a name="line-2282"></a>      <span class='hs-comment'>-- patterns.</span>
<a name="line-2283"></a>      <span class='hs-comment'>--</span>
<a name="line-2284"></a>      <span class='hs-comment'>-- NB: It's OK to use the nondeterministic `fvVarSet` function here,</span>
<a name="line-2285"></a>      <span class='hs-comment'>-- since the order of `inj_cpt_tvs` is never revealed in an error</span>
<a name="line-2286"></a>      <span class='hs-comment'>-- message.</span>
<a name="line-2287"></a>    <span class='hs-varid'>rhs_fvs</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoFVsOfType</span> <span class='hs-varid'>rhs</span>
<a name="line-2288"></a>    <span class='hs-varid'>used_tvs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cpt_tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>fvVarSet</span> <span class='hs-varid'>rhs_fvs</span>
<a name="line-2289"></a>    <span class='hs-varid'>bad_qtvs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>used_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>qtvs</span>
<a name="line-2290"></a>                  <span class='hs-comment'>-- Bound but not used at all</span>
<a name="line-2291"></a>    <span class='hs-varid'>bad_rhs_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>inj_cpt_tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvVarList</span> <span class='hs-varid'>rhs_fvs</span><span class='hs-layout'>)</span>
<a name="line-2292"></a>                  <span class='hs-comment'>-- Used on RHS but not bound on LHS</span>
<a name="line-2293"></a>    <span class='hs-varid'>dodgy_tvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cpt_tvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>inj_cpt_tvs</span>
<a name="line-2294"></a>
<a name="line-2295"></a>    <span class='hs-varid'>check_tvs</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>what</span> <span class='hs-varid'>what2</span>
<a name="line-2296"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>addErrAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>getSrcSpan</span> <span class='hs-layout'>(</span><span class='hs-varid'>head</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2297"></a>        <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Type variable"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>plural</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprQuotedList</span> <span class='hs-varid'>tvs</span>
<a name="line-2298"></a>              <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>isOrAre</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span><span class='hs-layout'>)</span>
<a name="line-2299"></a>           <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"but not"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what2</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"the family instance"</span>
<a name="line-2300"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>mk_extra</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2301"></a>
<a name="line-2302"></a>    <span class='hs-comment'>-- mk_extra: #7536: give a decent error message for</span>
<a name="line-2303"></a>    <span class='hs-comment'>--         type T a = Int</span>
<a name="line-2304"></a>    <span class='hs-comment'>--         type instance F (T a) = a</span>
<a name="line-2305"></a>    <span class='hs-varid'>mk_extra</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>dodgy_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2306"></a>                   <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"The real LHS (expanding synonyms) is:"</span><span class='hs-layout'>)</span>
<a name="line-2307"></a>                      <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprTypeApp</span> <span class='hs-varid'>fam_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>expandTypeSynonyms</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2308"></a>
<a name="line-2309"></a>
<a name="line-2310"></a><a name="checkValidTypePats"></a><span class='hs-comment'>-- | Checks that a list of type patterns is valid in a matching (LHS)</span>
<a name="line-2311"></a><span class='hs-comment'>-- position of a class instances or type/data family instance.</span>
<a name="line-2312"></a><span class='hs-comment'>--</span>
<a name="line-2313"></a><span class='hs-comment'>-- Specifically:</span>
<a name="line-2314"></a><span class='hs-comment'>--    * All monotypes</span>
<a name="line-2315"></a><span class='hs-comment'>--    * No type-family applications</span>
<a name="line-2316"></a><span class='hs-definition'>checkValidTypePats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2317"></a><span class='hs-definition'>checkValidTypePats</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>pat_ty_args</span>
<a name="line-2318"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Check that each of pat_ty_args is a monotype.</span>
<a name="line-2319"></a>         <span class='hs-comment'>-- One could imagine generalising to allow</span>
<a name="line-2320"></a>         <span class='hs-comment'>--      instance C (forall a. a-&gt;a)</span>
<a name="line-2321"></a>         <span class='hs-comment'>-- but we don't know what all the consequences might be.</span>
<a name="line-2322"></a>         <span class='hs-varid'>traverse_</span> <span class='hs-varid'>checkValidMonoType</span> <span class='hs-varid'>pat_ty_args</span>
<a name="line-2323"></a>
<a name="line-2324"></a>       <span class='hs-comment'>-- Ensure that no type family applications occur a type pattern</span>
<a name="line-2325"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcTyConAppTyFamInstsAndVis</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>pat_ty_args</span> <span class='hs-keyword'>of</span>
<a name="line-2326"></a>            <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-conid'>()</span>
<a name="line-2327"></a>            <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>tf_is_invis_arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>tf_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tf_args</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>failWithTc</span> <span class='hs-varop'>$</span>
<a name="line-2328"></a>               <span class='hs-varid'>ty_fam_inst_illegal_err</span> <span class='hs-varid'>tf_is_invis_arg</span>
<a name="line-2329"></a>                                       <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tf_tc</span> <span class='hs-varid'>tf_args</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2330"></a>  <span class='hs-keyword'>where</span>
<a name="line-2331"></a>    <span class='hs-varid'>inst_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>pat_ty_args</span>
<a name="line-2332"></a>
<a name="line-2333"></a>    <span class='hs-varid'>ty_fam_inst_illegal_err</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2334"></a>    <span class='hs-varid'>ty_fam_inst_illegal_err</span> <span class='hs-varid'>invis_arg</span> <span class='hs-varid'>ty</span>
<a name="line-2335"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprWithExplicitKindsWhen</span> <span class='hs-varid'>invis_arg</span> <span class='hs-varop'>$</span>
<a name="line-2336"></a>        <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Illegal type synonym family application"</span>
<a name="line-2337"></a>                <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"in instance"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>colon</span><span class='hs-layout'>)</span>
<a name="line-2338"></a>           <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_ty</span><span class='hs-layout'>)</span>
<a name="line-2339"></a>
<a name="line-2340"></a><span class='hs-comment'>-- Error messages</span>
<a name="line-2341"></a>
<a name="line-2342"></a><a name="inaccessibleCoAxBranch"></a><span class='hs-definition'>inaccessibleCoAxBranch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2343"></a><span class='hs-definition'>inaccessibleCoAxBranch</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>cur_branch</span>
<a name="line-2344"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Type family instance equation is overlapped:"</span> <span class='hs-varop'>$$</span>
<a name="line-2345"></a>    <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCoAxBranchUser</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>cur_branch</span><span class='hs-layout'>)</span>
<a name="line-2346"></a>
<a name="line-2347"></a><a name="nestedMsg"></a><span class='hs-definition'>nestedMsg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2348"></a><span class='hs-definition'>nestedMsg</span> <span class='hs-varid'>what</span>
<a name="line-2349"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Illegal nested"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>what</span>
<a name="line-2350"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>undecidableMsg</span> <span class='hs-keyglyph'>]</span>
<a name="line-2351"></a>
<a name="line-2352"></a><a name="badATErr"></a><span class='hs-definition'>badATErr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2353"></a><span class='hs-definition'>badATErr</span> <span class='hs-varid'>clas</span> <span class='hs-varid'>op</span>
<a name="line-2354"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Class"</span><span class='hs-layout'>,</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-2355"></a>          <span class='hs-varid'>text</span> <span class='hs-str'>"does not have an associated type"</span><span class='hs-layout'>,</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2356"></a>
<a name="line-2357"></a>
<a name="line-2358"></a><a name="checkConsistentFamInst"></a><span class='hs-comment'>-------------------------</span>
<a name="line-2359"></a><span class='hs-definition'>checkConsistentFamInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AssocInstInfo</span>
<a name="line-2360"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span>     <span class='hs-comment'>-- ^ Family tycon</span>
<a name="line-2361"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoAxBranch</span>
<a name="line-2362"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2363"></a><span class='hs-comment'>-- See Note [Checking consistent instantiation]</span>
<a name="line-2364"></a>
<a name="line-2365"></a><span class='hs-definition'>checkConsistentFamInst</span> <span class='hs-conid'>NotAssociated</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>
<a name="line-2366"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-2367"></a>
<a name="line-2368"></a><span class='hs-definition'>checkConsistentFamInst</span> <span class='hs-layout'>(</span><span class='hs-conid'>InClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ai_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>clas</span>
<a name="line-2369"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ai_tyvars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inst_tvs</span>
<a name="line-2370"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ai_inst_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mini_env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2371"></a>                       <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>branch</span>
<a name="line-2372"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"checkConsistentFamInst"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inst_tvs</span>
<a name="line-2373"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_triples</span>
<a name="line-2374"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mini_env</span>
<a name="line-2375"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ax_tvs</span>
<a name="line-2376"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ax_arg_tys</span>
<a name="line-2377"></a>                                                <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_triples</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2378"></a>       <span class='hs-comment'>-- Check that the associated type indeed comes from this class</span>
<a name="line-2379"></a>       <span class='hs-comment'>-- See [Mismatched class methods and associated type families]</span>
<a name="line-2380"></a>       <span class='hs-comment'>-- in TcInstDecls.</span>
<a name="line-2381"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkTc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tyConAssoc_maybe</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-2382"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>badATErr</span> <span class='hs-layout'>(</span><span class='hs-varid'>className</span> <span class='hs-varid'>clas</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2383"></a>
<a name="line-2384"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>check_match</span> <span class='hs-varid'>arg_triples</span>
<a name="line-2385"></a>       <span class='hs-layout'>}</span>
<a name="line-2386"></a>  <span class='hs-keyword'>where</span>
<a name="line-2387"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>ax_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ax_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>etaExpandCoAxBranch</span> <span class='hs-varid'>branch</span>
<a name="line-2388"></a>
<a name="line-2389"></a>    <span class='hs-varid'>arg_triples</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>ArgFlag</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2390"></a>    <span class='hs-varid'>arg_triples</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls_arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>at_arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span>
<a name="line-2391"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>fam_tc_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>vis</span><span class='hs-layout'>,</span> <span class='hs-varid'>at_arg_ty</span><span class='hs-layout'>)</span>
<a name="line-2392"></a>                       <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip3</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span>
<a name="line-2393"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>tyConArgFlags</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varid'>ax_arg_tys</span><span class='hs-layout'>)</span>
<a name="line-2394"></a>                               <span class='hs-varid'>ax_arg_tys</span>
<a name="line-2395"></a>                  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cls_arg_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>mini_env</span> <span class='hs-varid'>fam_tc_tv</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>]</span>
<a name="line-2396"></a>
<a name="line-2397"></a>    <span class='hs-varid'>pp_wrong_at_arg</span> <span class='hs-varid'>vis</span>
<a name="line-2398"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprWithExplicitKindsWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInvisibleArgFlag</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2399"></a>        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Type indexes must match class instance head"</span>
<a name="line-2400"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Expected:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pp_expected_ty</span>
<a name="line-2401"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"  Actual:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pp_actual_ty</span> <span class='hs-keyglyph'>]</span>
<a name="line-2402"></a>
<a name="line-2403"></a>    <span class='hs-comment'>-- Fiddling around to arrange that wildcards unconditionally print as "_"</span>
<a name="line-2404"></a>    <span class='hs-comment'>-- We only need to print the LHS, not the RHS at all</span>
<a name="line-2405"></a>    <span class='hs-comment'>-- See Note [Printing conflicts with class header]</span>
<a name="line-2406"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tidy_env1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidyVarBndrs</span> <span class='hs-varid'>emptyTidyEnv</span> <span class='hs-varid'>inst_tvs</span>
<a name="line-2407"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tidy_env2</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidyCoAxBndrsForUser</span> <span class='hs-varid'>tidy_env1</span> <span class='hs-layout'>(</span><span class='hs-varid'>ax_tvs</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>inst_tvs</span><span class='hs-layout'>)</span>
<a name="line-2408"></a>
<a name="line-2409"></a>    <span class='hs-varid'>pp_expected_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprIfaceTypeApp</span> <span class='hs-varid'>topPrec</span> <span class='hs-layout'>(</span><span class='hs-varid'>toIfaceTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2410"></a>                     <span class='hs-varid'>toIfaceTcArgs</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varop'>$</span>
<a name="line-2411"></a>                     <span class='hs-keyglyph'>[</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>mini_env</span> <span class='hs-varid'>at_tv</span> <span class='hs-keyword'>of</span>
<a name="line-2412"></a>                         <span class='hs-conid'>Just</span> <span class='hs-varid'>cls_arg_ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tidyType</span> <span class='hs-varid'>tidy_env2</span> <span class='hs-varid'>cls_arg_ty</span>
<a name="line-2413"></a>                         <span class='hs-conid'>Nothing</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mk_wildcard</span> <span class='hs-varid'>at_tv</span>
<a name="line-2414"></a>                     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>at_tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConTyVars</span> <span class='hs-varid'>fam_tc</span> <span class='hs-keyglyph'>]</span>
<a name="line-2415"></a>
<a name="line-2416"></a>    <span class='hs-varid'>pp_actual_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprIfaceTypeApp</span> <span class='hs-varid'>topPrec</span> <span class='hs-layout'>(</span><span class='hs-varid'>toIfaceTyCon</span> <span class='hs-varid'>fam_tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2417"></a>                   <span class='hs-varid'>toIfaceTcArgs</span> <span class='hs-varid'>fam_tc</span> <span class='hs-varop'>$</span>
<a name="line-2418"></a>                   <span class='hs-varid'>tidyTypes</span> <span class='hs-varid'>tidy_env2</span> <span class='hs-varid'>ax_arg_tys</span>
<a name="line-2419"></a>
<a name="line-2420"></a>    <span class='hs-varid'>mk_wildcard</span> <span class='hs-varid'>at_tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVar</span> <span class='hs-varid'>tv_name</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>at_tv</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2421"></a>    <span class='hs-varid'>tv_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInternalName</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkAlphaTyVarUnique</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarOcc</span> <span class='hs-str'>"_"</span><span class='hs-layout'>)</span> <span class='hs-varid'>noSrcSpan</span>
<a name="line-2422"></a>
<a name="line-2423"></a>    <span class='hs-comment'>-- For check_match, bind_me, see</span>
<a name="line-2424"></a>    <span class='hs-comment'>-- Note [Matching in the consistent-instantiation check]</span>
<a name="line-2425"></a>    <span class='hs-varid'>check_match</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span><span class='hs-conid'>ArgFlag</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2426"></a>    <span class='hs-varid'>check_match</span> <span class='hs-varid'>triples</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>emptyTCvSubst</span> <span class='hs-varid'>emptyTCvSubst</span> <span class='hs-varid'>triples</span>
<a name="line-2427"></a>
<a name="line-2428"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-2429"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>lr_subst</span> <span class='hs-varid'>rl_subst</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>ty1</span><span class='hs-layout'>,</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span><span class='hs-varid'>vis</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>triples</span><span class='hs-layout'>)</span>
<a name="line-2430"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>lr_subst1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcMatchTyX_BM</span> <span class='hs-varid'>bind_me</span> <span class='hs-varid'>lr_subst</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-2431"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rl_subst1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcMatchTyX_BM</span> <span class='hs-varid'>bind_me</span> <span class='hs-varid'>rl_subst</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ty1</span>
<a name="line-2432"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>lr_subst1</span> <span class='hs-varid'>rl_subst1</span> <span class='hs-varid'>triples</span>
<a name="line-2433"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2434"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addErrTc</span> <span class='hs-layout'>(</span><span class='hs-varid'>pp_wrong_at_arg</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span>
<a name="line-2435"></a>
<a name="line-2436"></a>    <span class='hs-comment'>-- The /scoped/ type variables from the class-instance header</span>
<a name="line-2437"></a>    <span class='hs-comment'>-- should not be alpha-renamed.  Inferred ones can be.</span>
<a name="line-2438"></a>    <span class='hs-varid'>no_bind_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>inst_tvs</span>
<a name="line-2439"></a>    <span class='hs-varid'>bind_me</span> <span class='hs-varid'>tv</span> <span class='hs-sel'>_ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>no_bind_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Apart</span>
<a name="line-2440"></a>                   <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BindMe</span>
<a name="line-2441"></a>
<a name="line-2442"></a>
<a name="line-2443"></a><span class='hs-comment'>{- Note [Check type-family instance binders]
<a name="line-2444"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2445"></a>In a type family instance, we require (of course), type variables
<a name="line-2446"></a>used on the RHS are matched on the LHS. This is checked by
<a name="line-2447"></a>checkFamPatBinders.  Here is an interesting example:
<a name="line-2448"></a>
<a name="line-2449"></a>    type family   T :: k
<a name="line-2450"></a>    type instance T = (Nothing :: Maybe a)
<a name="line-2451"></a>
<a name="line-2452"></a>Upon a cursory glance, it may appear that the kind variable `a` is unbound
<a name="line-2453"></a>since there are no (visible) LHS patterns in `T`. However, there is an
<a name="line-2454"></a>*invisible* pattern due to the return kind, so inside of GHC, the instance
<a name="line-2455"></a>looks closer to this:
<a name="line-2456"></a>
<a name="line-2457"></a>    type family T @k :: k
<a name="line-2458"></a>    type instance T @(Maybe a) = (Nothing :: Maybe a)
<a name="line-2459"></a>
<a name="line-2460"></a>Here, we can see that `a` really is bound by a LHS type pattern, so `a` is in
<a name="line-2461"></a>fact not unbound. Contrast that with this example (#13985)
<a name="line-2462"></a>
<a name="line-2463"></a>    type instance T = Proxy (Nothing :: Maybe a)
<a name="line-2464"></a>
<a name="line-2465"></a>This would looks like this inside of GHC:
<a name="line-2466"></a>
<a name="line-2467"></a>    type instance T @(*) = Proxy (Nothing :: Maybe a)
<a name="line-2468"></a>
<a name="line-2469"></a>So this time, `a` is neither bound by a visible nor invisible type pattern on
<a name="line-2470"></a>the LHS, so `a` would be reported as not in scope.
<a name="line-2471"></a>
<a name="line-2472"></a>Finally, here's one more brain-teaser (from #9574). In the example below:
<a name="line-2473"></a>
<a name="line-2474"></a>    class Funct f where
<a name="line-2475"></a>      type Codomain f :: *
<a name="line-2476"></a>    instance Funct ('KProxy :: KProxy o) where
<a name="line-2477"></a>      type Codomain 'KProxy = NatTr (Proxy :: o -&gt; *)
<a name="line-2478"></a>
<a name="line-2479"></a>As it turns out, `o` is in scope in this example. That is because `o` is
<a name="line-2480"></a>bound by the kind signature of the LHS type pattern 'KProxy. To make this more
<a name="line-2481"></a>obvious, one can also write the instance like so:
<a name="line-2482"></a>
<a name="line-2483"></a>    instance Funct ('KProxy :: KProxy o) where
<a name="line-2484"></a>      type Codomain ('KProxy :: KProxy o) = NatTr (Proxy :: o -&gt; *)
<a name="line-2485"></a>
<a name="line-2486"></a>Note [Dodgy binding sites in type family instances]
<a name="line-2487"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2488"></a>Consider the following example (from #7536):
<a name="line-2489"></a>
<a name="line-2490"></a>  type T a = Int
<a name="line-2491"></a>  type instance F (T a) = a
<a name="line-2492"></a>
<a name="line-2493"></a>This `F` instance is extremely fishy, since the RHS, `a`, purports to be
<a name="line-2494"></a>"bound" by the LHS pattern `T a`. "Bound" has scare quotes around it because
<a name="line-2495"></a>`T a` expands to `Int`, which doesn't mention at all, so it's as if one had
<a name="line-2496"></a>actually written:
<a name="line-2497"></a>
<a name="line-2498"></a>  type instance F Int = a
<a name="line-2499"></a>
<a name="line-2500"></a>That is clearly bogus, so to reject this, we check that every type variable
<a name="line-2501"></a>that is mentioned on the RHS is /actually/ bound on the LHS. In other words,
<a name="line-2502"></a>we need to do something slightly more sophisticated that just compute the free
<a name="line-2503"></a>variables of the LHS patterns.
<a name="line-2504"></a>
<a name="line-2505"></a>It's tempting to just expand all type synonyms on the LHS and then compute
<a name="line-2506"></a>their free variables, but even that isn't sophisticated enough. After all,
<a name="line-2507"></a>an impish user could write the following (#17008):
<a name="line-2508"></a>
<a name="line-2509"></a>  type family ConstType (a :: Type) :: Type where
<a name="line-2510"></a>    ConstType _ = Type
<a name="line-2511"></a>
<a name="line-2512"></a>  type family F (x :: ConstType a) :: Type where
<a name="line-2513"></a>    F (x :: ConstType a) = a
<a name="line-2514"></a>
<a name="line-2515"></a>Just like in the previous example, the `a` on the RHS isn't actually bound
<a name="line-2516"></a>on the LHS, but this time a type family is responsible for the deception, not
<a name="line-2517"></a>a type synonym.
<a name="line-2518"></a>
<a name="line-2519"></a>We avoid both issues by requiring that all RHS type variables are mentioned
<a name="line-2520"></a>in injective positions on the left-hand side (by way of
<a name="line-2521"></a>`injectiveVarsOfTypes`). For instance, the `a` in `T a` is not in an injective
<a name="line-2522"></a>position, as `T` is not an injective type constructor, so we do not count that.
<a name="line-2523"></a>Similarly for the `a` in `ConstType a`.
<a name="line-2524"></a>
<a name="line-2525"></a>Note [Matching in the consistent-instantiation check]
<a name="line-2526"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2527"></a>Matching the class-instance header to family-instance tyvars is
<a name="line-2528"></a>tricker than it sounds.  Consider (#13972)
<a name="line-2529"></a>    class C (a :: k) where
<a name="line-2530"></a>      type T k :: Type
<a name="line-2531"></a>    instance C Left where
<a name="line-2532"></a>      type T (a -&gt; Either a b) = Int
<a name="line-2533"></a>
<a name="line-2534"></a>Here there are no lexically-scoped variables from (C Left).
<a name="line-2535"></a>Yet the real class-instance header is   C @(p -&gt; Either @p @q)) (Left @p @q)
<a name="line-2536"></a>while the type-family instance is       T (a -&gt; Either @a @b)
<a name="line-2537"></a>So we allow alpha-renaming of variables that don't come
<a name="line-2538"></a>from the class-instance header.
<a name="line-2539"></a>
<a name="line-2540"></a>We track the lexically-scoped type variables from the
<a name="line-2541"></a>class-instance header in ai_tyvars.
<a name="line-2542"></a>
<a name="line-2543"></a>Here's another example (#14045a)
<a name="line-2544"></a>    class C (a :: k) where
<a name="line-2545"></a>      data S (a :: k)
<a name="line-2546"></a>    instance C (z :: Bool) where
<a name="line-2547"></a>      data S :: Bool -&gt; Type where
<a name="line-2548"></a>
<a name="line-2549"></a>Again, there is no lexical connection, but we will get
<a name="line-2550"></a>   class-instance header:   C @Bool (z::Bool)
<a name="line-2551"></a>   family instance          S @Bool (a::Bool)
<a name="line-2552"></a>
<a name="line-2553"></a>When looking for mis-matches, we check left-to-right,
<a name="line-2554"></a>kinds first.  If we look at types first, we'll fail to
<a name="line-2555"></a>suggest -fprint-explicit-kinds for a mis-match with
<a name="line-2556"></a>      T @k    vs    T @Type
<a name="line-2557"></a>somewhere deep inside the type
<a name="line-2558"></a>
<a name="line-2559"></a>Note [Checking consistent instantiation]
<a name="line-2560"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2561"></a>See #11450 for background discussion on this check.
<a name="line-2562"></a>
<a name="line-2563"></a>  class C a b where
<a name="line-2564"></a>    type T a x b
<a name="line-2565"></a>
<a name="line-2566"></a>With this class decl, if we have an instance decl
<a name="line-2567"></a>  instance C ty1 ty2 where ...
<a name="line-2568"></a>then the type instance must look like
<a name="line-2569"></a>     type T ty1 v ty2 = ...
<a name="line-2570"></a>with exactly 'ty1' for 'a', 'ty2' for 'b', and some type 'v' for 'x'.
<a name="line-2571"></a>For example:
<a name="line-2572"></a>
<a name="line-2573"></a>  instance C [p] Int
<a name="line-2574"></a>    type T [p] y Int = (p,y,y)
<a name="line-2575"></a>
<a name="line-2576"></a>Note that
<a name="line-2577"></a>
<a name="line-2578"></a>* We used to allow completely different bound variables in the
<a name="line-2579"></a>  associated type instance; e.g.
<a name="line-2580"></a>    instance C [p] Int
<a name="line-2581"></a>      type T [q] y Int = ...
<a name="line-2582"></a>  But from GHC 8.2 onwards, we don't.  It's much simpler this way.
<a name="line-2583"></a>  See #11450.
<a name="line-2584"></a>
<a name="line-2585"></a>* When the class variable isn't used on the RHS of the type instance,
<a name="line-2586"></a>  it's tempting to allow wildcards, thus
<a name="line-2587"></a>    instance C [p] Int
<a name="line-2588"></a>      type T [_] y Int = (y,y)
<a name="line-2589"></a>  But it's awkward to do the test, and it doesn't work if the
<a name="line-2590"></a>  variable is repeated:
<a name="line-2591"></a>    instance C (p,p) Int
<a name="line-2592"></a>      type T (_,_) y Int = (y,y)
<a name="line-2593"></a>  Even though 'p' is not used on the RHS, we still need to use 'p'
<a name="line-2594"></a>  on the LHS to establish the repeated pattern.  So to keep it simple
<a name="line-2595"></a>  we just require equality.
<a name="line-2596"></a>
<a name="line-2597"></a>* For variables in associated type families that are not bound by the class
<a name="line-2598"></a>  itself, we do _not_ check if they are over-specific. In other words,
<a name="line-2599"></a>  it's perfectly acceptable to have an instance like this:
<a name="line-2600"></a>
<a name="line-2601"></a>    instance C [p] Int where
<a name="line-2602"></a>      type T [p] (Maybe x) Int = x
<a name="line-2603"></a>
<a name="line-2604"></a>  While the first and third arguments to T are required to be exactly [p] and
<a name="line-2605"></a>  Int, respectively, since they are bound by C, the second argument is allowed
<a name="line-2606"></a>  to be more specific than just a type variable. Furthermore, it is permissible
<a name="line-2607"></a>  to define multiple equations for T that differ only in the non-class-bound
<a name="line-2608"></a>  argument:
<a name="line-2609"></a>
<a name="line-2610"></a>    instance C [p] Int where
<a name="line-2611"></a>      type T [p] (Maybe x)    Int = x
<a name="line-2612"></a>      type T [p] (Either x y) Int = x -&gt; y
<a name="line-2613"></a>
<a name="line-2614"></a>  We once considered requiring that non-class-bound variables in associated
<a name="line-2615"></a>  type family instances be instantiated with distinct type variables. However,
<a name="line-2616"></a>  that requirement proved too restrictive in practice, as there were examples
<a name="line-2617"></a>  of extremely simple associated type family instances that this check would
<a name="line-2618"></a>  reject, and fixing them required tiresome boilerplate in the form of
<a name="line-2619"></a>  auxiliary type families. For instance, you would have to define the above
<a name="line-2620"></a>  example as:
<a name="line-2621"></a>
<a name="line-2622"></a>    instance C [p] Int where
<a name="line-2623"></a>      type T [p] x Int = CAux x
<a name="line-2624"></a>
<a name="line-2625"></a>    type family CAux x where
<a name="line-2626"></a>      CAux (Maybe x)    = x
<a name="line-2627"></a>      CAux (Either x y) = x -&gt; y
<a name="line-2628"></a>
<a name="line-2629"></a>  We decided that this restriction wasn't buying us much, so we opted not
<a name="line-2630"></a>  to pursue that design (see also GHC #13398).
<a name="line-2631"></a>
<a name="line-2632"></a>Implementation
<a name="line-2633"></a>  * Form the mini-envt from the class type variables a,b
<a name="line-2634"></a>    to the instance decl types [p],Int:   [a-&gt;[p], b-&gt;Int]
<a name="line-2635"></a>
<a name="line-2636"></a>  * Look at the tyvars a,x,b of the type family constructor T
<a name="line-2637"></a>    (it shares tyvars with the class C)
<a name="line-2638"></a>
<a name="line-2639"></a>  * Apply the mini-evnt to them, and check that the result is
<a name="line-2640"></a>    consistent with the instance types [p] y Int. (where y can be any type, as
<a name="line-2641"></a>    it is not scoped over the class type variables.
<a name="line-2642"></a>
<a name="line-2643"></a>We make all the instance type variables scope over the
<a name="line-2644"></a>type instances, of course, which picks up non-obvious kinds.  Eg
<a name="line-2645"></a>   class Foo (a :: k) where
<a name="line-2646"></a>      type F a
<a name="line-2647"></a>   instance Foo (b :: k -&gt; k) where
<a name="line-2648"></a>      type F b = Int
<a name="line-2649"></a>Here the instance is kind-indexed and really looks like
<a name="line-2650"></a>      type F (k-&gt;k) (b::k-&gt;k) = Int
<a name="line-2651"></a>But if the 'b' didn't scope, we would make F's instance too
<a name="line-2652"></a>poly-kinded.
<a name="line-2653"></a>
<a name="line-2654"></a>Note [Printing conflicts with class header]
<a name="line-2655"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2656"></a>It's remarkably painful to give a decent error message for conflicts
<a name="line-2657"></a>with the class header.  Consider
<a name="line-2658"></a>   clase C b where
<a name="line-2659"></a>     type F a b c
<a name="line-2660"></a>   instance C [b] where
<a name="line-2661"></a>     type F x Int _ _ = ...
<a name="line-2662"></a>
<a name="line-2663"></a>Here we want to report a conflict between
<a name="line-2664"></a>    Expected: F _ [b] _
<a name="line-2665"></a>    Actual:   F x Int _ _
<a name="line-2666"></a>
<a name="line-2667"></a>But if the type instance shadows the class variable like this
<a name="line-2668"></a>(rename/should_fail/T15828):
<a name="line-2669"></a>   instance C [b] where
<a name="line-2670"></a>     type forall b. F x (Tree b) _ _ = ...
<a name="line-2671"></a>
<a name="line-2672"></a>then we must use a fresh variable name
<a name="line-2673"></a>    Expected: F _ [b] _
<a name="line-2674"></a>    Actual:   F x [b1] _ _
<a name="line-2675"></a>
<a name="line-2676"></a>Notice that:
<a name="line-2677"></a>  - We want to print an underscore in the "Expected" type in
<a name="line-2678"></a>    positions where the class header has no influence over the
<a name="line-2679"></a>    parameter.  Hence the fancy footwork in pp_expected_ty
<a name="line-2680"></a>
<a name="line-2681"></a>  - Although the binders in the axiom are already tidy, we must
<a name="line-2682"></a>    re-tidy them to get a fresh variable name when we shadow
<a name="line-2683"></a>
<a name="line-2684"></a>  - The (ax_tvs \\ inst_tvs) is to avoid tidying one of the
<a name="line-2685"></a>    class-instance variables a second time, from 'a' to 'a1' say.
<a name="line-2686"></a>    Remember, the ax_tvs of the axiom share identity with the
<a name="line-2687"></a>    class-instance variables, inst_tvs..
<a name="line-2688"></a>
<a name="line-2689"></a>  - We use tidyCoAxBndrsForUser to get underscores rather than
<a name="line-2690"></a>    _1, _2, etc in the axiom tyvars; see the definition of
<a name="line-2691"></a>    tidyCoAxBndrsForUser
<a name="line-2692"></a>
<a name="line-2693"></a>This all seems absurdly complicated.
<a name="line-2694"></a>
<a name="line-2695"></a>Note [Unused explicitly bound variables in a family pattern]
<a name="line-2696"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2697"></a>
<a name="line-2698"></a>Why is 'unusedExplicitForAllErr' not just a warning?
<a name="line-2699"></a>
<a name="line-2700"></a>Consider the following examples:
<a name="line-2701"></a>
<a name="line-2702"></a>  type instance F a = Maybe b
<a name="line-2703"></a>  type instance forall b. F a = Bool
<a name="line-2704"></a>  type instance forall b. F a = Maybe b
<a name="line-2705"></a>
<a name="line-2706"></a>In every case, b is a type variable not determined by the LHS pattern. The
<a name="line-2707"></a>first is caught by the renamer, but we catch the last two here. Perhaps one
<a name="line-2708"></a>could argue that the second should be accepted, albeit with a warning, but
<a name="line-2709"></a>consider the fact that in a type family instance, there is no way to interact
<a name="line-2710"></a>with such a varable. At least with @x :: forall a. Int@ we can use visibile
<a name="line-2711"></a>type application, like @x \@Bool 1@. (Of course it does nothing, but it is
<a name="line-2712"></a>permissible.) In the type family case, the only sensible explanation is that
<a name="line-2713"></a>the user has made a mistake -- thus we throw an error.
<a name="line-2714"></a>
<a name="line-2715"></a>Note [Oversaturated type family equations]
<a name="line-2716"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2717"></a>Type family tycons have very rigid arities. We want to reject something like
<a name="line-2718"></a>this:
<a name="line-2719"></a>
<a name="line-2720"></a>  type family Foo :: Type -&gt; Type where
<a name="line-2721"></a>    Foo x = ...
<a name="line-2722"></a>
<a name="line-2723"></a>Because Foo has arity zero (i.e., it doesn't bind anything to the left of the
<a name="line-2724"></a>double colon), we want to disallow any equation for Foo that has more than zero
<a name="line-2725"></a>arguments, such as `Foo x = ...`. The algorithm here is pretty simple: if an
<a name="line-2726"></a>equation has more arguments than the arity of the type family, reject.
<a name="line-2727"></a>
<a name="line-2728"></a>Things get trickier when visible kind application enters the picture. Consider
<a name="line-2729"></a>the following example:
<a name="line-2730"></a>
<a name="line-2731"></a>  type family Bar (x :: j) :: forall k. Either j k where
<a name="line-2732"></a>    Bar 5 @Symbol = ...
<a name="line-2733"></a>
<a name="line-2734"></a>The arity of Bar is two, since it binds two variables, `j` and `x`. But even
<a name="line-2735"></a>though Bar's equation has two arguments, it's still invalid. Imagine the same
<a name="line-2736"></a>equation in Core:
<a name="line-2737"></a>
<a name="line-2738"></a>    Bar Nat 5 Symbol = ...
<a name="line-2739"></a>
<a name="line-2740"></a>Here, it becomes apparent that Bar is actually taking /three/ arguments! So
<a name="line-2741"></a>we can't just rely on a simple counting argument to reject
<a name="line-2742"></a>`Bar 5 @Symbol = ...`, since it only has two user-written arguments.
<a name="line-2743"></a>Moreover, there's one explicit argument (5) and one visible kind argument
<a name="line-2744"></a>(@Symbol), which matches up perfectly with the fact that Bar has one required
<a name="line-2745"></a>binder (x) and one specified binder (j), so that's not a valid way to detect
<a name="line-2746"></a>oversaturation either.
<a name="line-2747"></a>
<a name="line-2748"></a>To solve this problem in a robust way, we do the following:
<a name="line-2749"></a>
<a name="line-2750"></a>1. When kind-checking, we count the number of user-written *required*
<a name="line-2751"></a>   arguments and check if there is an equal number of required tycon binders.
<a name="line-2752"></a>   If not, reject. (See `wrongNumberOfParmsErr` in GHC.Tc.TyCl.)
<a name="line-2753"></a>
<a name="line-2754"></a>   We perform this step during kind-checking, not during validity checking,
<a name="line-2755"></a>   since we can give better error messages if we catch it early.
<a name="line-2756"></a>2. When validity checking, take all of the (Core) type patterns from on
<a name="line-2757"></a>   equation, drop the first n of them (where n is the arity of the type family
<a name="line-2758"></a>   tycon), and check if there are any types leftover. If so, reject.
<a name="line-2759"></a>
<a name="line-2760"></a>   Why does this work? We know that after dropping the first n type patterns,
<a name="line-2761"></a>   none of the leftover types can be required arguments, since step (1) would
<a name="line-2762"></a>   have already caught that. Moreover, the only places where visible kind
<a name="line-2763"></a>   applications should be allowed are in the first n types, since those are the
<a name="line-2764"></a>   only arguments that can correspond to binding forms. Therefore, the
<a name="line-2765"></a>   remaining arguments must correspond to oversaturated uses of visible kind
<a name="line-2766"></a>   applications, which are precisely what we want to reject.
<a name="line-2767"></a>
<a name="line-2768"></a>Note that we only perform this check for type families, and not for data
<a name="line-2769"></a>families. This is because it is perfectly acceptable to oversaturate data
<a name="line-2770"></a>family instance equations: see Note [Arity of data families] in GHC.Core.FamInstEnv.
<a name="line-2771"></a>
<a name="line-2772"></a>************************************************************************
<a name="line-2773"></a>*                                                                      *
<a name="line-2774"></a>   Telescope checking
<a name="line-2775"></a>*                                                                      *
<a name="line-2776"></a>************************************************************************
<a name="line-2777"></a>
<a name="line-2778"></a>Note [Bad TyCon telescopes]
<a name="line-2779"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2780"></a>Now that we can mix type and kind variables, there are an awful lot of
<a name="line-2781"></a>ways to shoot yourself in the foot. Here are some.
<a name="line-2782"></a>
<a name="line-2783"></a>  data SameKind :: k -&gt; k -&gt; *   -- just to force unification
<a name="line-2784"></a>
<a name="line-2785"></a>1.  data T1 a k (b :: k) (x :: SameKind a b)
<a name="line-2786"></a>
<a name="line-2787"></a>The problem here is that we discover that a and b should have the same
<a name="line-2788"></a>kind. But this kind mentions k, which is bound *after* a.
<a name="line-2789"></a>(Testcase: dependent/should_fail/BadTelescope)
<a name="line-2790"></a>
<a name="line-2791"></a>2.  data T2 a (c :: Proxy b) (d :: Proxy a) (x :: SameKind b d)
<a name="line-2792"></a>
<a name="line-2793"></a>Note that b is not bound. Yet its kind mentions a. Because we have
<a name="line-2794"></a>a nice rule that all implicitly bound variables come before others,
<a name="line-2795"></a>this is bogus.
<a name="line-2796"></a>
<a name="line-2797"></a>To catch these errors, we call checkTyConTelescope during kind-checking
<a name="line-2798"></a>datatype declarations.  This checks for
<a name="line-2799"></a>
<a name="line-2800"></a>* Ill-scoped binders. From (1) and (2) above we can get putative
<a name="line-2801"></a>  kinds like
<a name="line-2802"></a>       T1 :: forall (a:k) (k:*) (b:k). SameKind a b -&gt; *
<a name="line-2803"></a>  where 'k' is mentioned a's kind before k is bound
<a name="line-2804"></a>
<a name="line-2805"></a>  This is easy to check for: just look for
<a name="line-2806"></a>  out-of-scope variables in the kind
<a name="line-2807"></a>
<a name="line-2808"></a>* We should arguably also check for ambiguous binders
<a name="line-2809"></a>  but we don't.  See Note [Ambiguous kind vars].
<a name="line-2810"></a>
<a name="line-2811"></a>See also
<a name="line-2812"></a>  * Note [Required, Specified, and Inferred for types] in GHC.Tc.TyCl.
<a name="line-2813"></a>  * Note [Checking telescopes] in GHC.Tc.Types.Constraint discusses how
<a name="line-2814"></a>    this check works for `forall x y z.` written in a type.
<a name="line-2815"></a>
<a name="line-2816"></a>Note [Ambiguous kind vars]
<a name="line-2817"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2818"></a>We used to be concerned about ambiguous binders. Suppose we have the kind
<a name="line-2819"></a>     S1 :: forall k -&gt; * -&gt; *
<a name="line-2820"></a>     S2 :: forall k. * -&gt; *
<a name="line-2821"></a>Here S1 is OK, because k is Required, and at a use of S1 we will
<a name="line-2822"></a>see (S1 *) or (S1 (*-&gt;*)) or whatever.
<a name="line-2823"></a>
<a name="line-2824"></a>But S2 is /not/ OK because 'k' is Specfied (and hence invisible) and
<a name="line-2825"></a>we have no way (ever) to figure out how 'k' should be instantiated.
<a name="line-2826"></a>For example if we see (S2 Int), that tells us nothing about k's
<a name="line-2827"></a>instantiation.  (In this case we'll instantiate it to Any, but that
<a name="line-2828"></a>seems wrong.)  This is really the same test as we make for ambiguous
<a name="line-2829"></a>type in term type signatures.
<a name="line-2830"></a>
<a name="line-2831"></a>Now, it's impossible for a Specified variable not to occur
<a name="line-2832"></a>at all in the kind -- after all, it is Specified so it must have
<a name="line-2833"></a>occurred.  (It /used/ to be possible; see tests T13983 and T7873.  But
<a name="line-2834"></a>with the advent of the forall-or-nothing rule for kind variables,
<a name="line-2835"></a>those strange cases went away. See Note [forall-or-nothing rule] in
<a name="line-2836"></a>GHC.Hs.Type.)
<a name="line-2837"></a>
<a name="line-2838"></a>But one might worry about
<a name="line-2839"></a>    type v k = *
<a name="line-2840"></a>    S3 :: forall k. V k -&gt; *
<a name="line-2841"></a>which appears to mention 'k' but doesn't really.  Or
<a name="line-2842"></a>    S4 :: forall k. F k -&gt; *
<a name="line-2843"></a>where F is a type function.  But we simply don't check for
<a name="line-2844"></a>those cases of ambiguity, yet anyway.  The worst that can happen
<a name="line-2845"></a>is ambiguity at the call sites.
<a name="line-2846"></a>
<a name="line-2847"></a>Historical note: this test used to be called reportFloatingKvs.
<a name="line-2848"></a>-}</span>
<a name="line-2849"></a>
<a name="line-2850"></a><a name="TelescopeAcc"></a><span class='hs-comment'>-- | Check a list of binders to see if they make a valid telescope.</span>
<a name="line-2851"></a><a name="TelescopeAcc"></a><span class='hs-comment'>-- See Note [Bad TyCon telescopes]</span>
<a name="line-2852"></a><a name="TelescopeAcc"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TelescopeAcc</span>
<a name="line-2853"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-conid'>TyVarSet</span>   <span class='hs-comment'>-- Bound earlier in the telescope</span>
<a name="line-2854"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span>       <span class='hs-comment'>-- At least one binder occurred (in a kind) before</span>
<a name="line-2855"></a>                     <span class='hs-comment'>-- it was bound in the telescope.  E.g.</span>
<a name="line-2856"></a>        <span class='hs-layout'>)</span>            <span class='hs-comment'>--    T :: forall (a::k) k. blah</span>
<a name="line-2857"></a>
<a name="line-2858"></a><a name="checkTyConTelescope"></a><span class='hs-definition'>checkTyConTelescope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-2859"></a><span class='hs-definition'>checkTyConTelescope</span> <span class='hs-varid'>tc</span>
<a name="line-2860"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bad_scope</span>
<a name="line-2861"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See "Ill-scoped binders" in Note [Bad TyCon telescopes]</span>
<a name="line-2862"></a>    <span class='hs-varid'>addErr</span> <span class='hs-varop'>$</span>
<a name="line-2863"></a>    <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"The kind of"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"is ill-scoped"</span><span class='hs-layout'>)</span>
<a name="line-2864"></a>              <span class='hs-num'>2</span> <span class='hs-varid'>pp_tc_kind</span>
<a name="line-2865"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>extra</span>
<a name="line-2866"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Perhaps try this order instead:"</span><span class='hs-layout'>)</span>
<a name="line-2867"></a>              <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprTyVars</span> <span class='hs-varid'>sorted_tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-2868"></a>
<a name="line-2869"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2870"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-2871"></a>  <span class='hs-keyword'>where</span>
<a name="line-2872"></a>    <span class='hs-varid'>tcbs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConBinders</span> <span class='hs-varid'>tc</span>
<a name="line-2873"></a>    <span class='hs-varid'>tvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binderVars</span> <span class='hs-varid'>tcbs</span>
<a name="line-2874"></a>    <span class='hs-varid'>sorted_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scopedSort</span> <span class='hs-varid'>tvs</span>
<a name="line-2875"></a>
<a name="line-2876"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>bad_scope</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>add_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyVarSet</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-varid'>tcbs</span>
<a name="line-2877"></a>
<a name="line-2878"></a>    <span class='hs-varid'>add_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TelescopeAcc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyConBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TelescopeAcc</span>
<a name="line-2879"></a>    <span class='hs-varid'>add_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>bound</span><span class='hs-layout'>,</span> <span class='hs-varid'>bad_scope</span><span class='hs-layout'>)</span> <span class='hs-varid'>tcb</span>
<a name="line-2880"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>bound</span> <span class='hs-varop'>`extendVarSet`</span> <span class='hs-varid'>tv</span>
<a name="line-2881"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>bad_scope</span> <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>fkvs</span> <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>bound</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-2882"></a>      <span class='hs-keyword'>where</span>
<a name="line-2883"></a>        <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binderVar</span> <span class='hs-varid'>tcb</span>
<a name="line-2884"></a>        <span class='hs-varid'>fkvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfType</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-2885"></a>
<a name="line-2886"></a>    <span class='hs-varid'>inferred_tvs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>binderVar</span> <span class='hs-varid'>tcb</span>
<a name="line-2887"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tcb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcbs</span><span class='hs-layout'>,</span> <span class='hs-conid'>Inferred</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tyConBinderArgFlag</span> <span class='hs-varid'>tcb</span> <span class='hs-keyglyph'>]</span>
<a name="line-2888"></a>    <span class='hs-varid'>specified_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>binderVar</span> <span class='hs-varid'>tcb</span>
<a name="line-2889"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tcb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcbs</span><span class='hs-layout'>,</span> <span class='hs-conid'>Specified</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tyConBinderArgFlag</span> <span class='hs-varid'>tcb</span> <span class='hs-keyglyph'>]</span>
<a name="line-2890"></a>
<a name="line-2891"></a>    <span class='hs-varid'>pp_inf</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"namely:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprTyVars</span> <span class='hs-varid'>inferred_tvs</span><span class='hs-layout'>)</span>
<a name="line-2892"></a>    <span class='hs-varid'>pp_spec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"namely:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprTyVars</span> <span class='hs-varid'>specified_tvs</span><span class='hs-layout'>)</span>
<a name="line-2893"></a>
<a name="line-2894"></a>    <span class='hs-varid'>pp_tc_kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Inferred kind:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr_untidy</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConKind</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span>
<a name="line-2895"></a>    <span class='hs-varid'>ppr_untidy</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprIfaceType</span> <span class='hs-layout'>(</span><span class='hs-varid'>toIfaceType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-2896"></a>      <span class='hs-comment'>-- We need ppr_untidy here because pprType will tidy the type, which</span>
<a name="line-2897"></a>      <span class='hs-comment'>-- will turn the bogus kind we are trying to report</span>
<a name="line-2898"></a>      <span class='hs-comment'>--     T :: forall (a::k) k (b::k) -&gt; blah</span>
<a name="line-2899"></a>      <span class='hs-comment'>-- into a misleadingly sanitised version</span>
<a name="line-2900"></a>      <span class='hs-comment'>--     T :: forall (a::k) k1 (b::k1) -&gt; blah</span>
<a name="line-2901"></a>
<a name="line-2902"></a>    <span class='hs-varid'>extra</span>
<a name="line-2903"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>inferred_tvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>specified_tvs</span>
<a name="line-2904"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>empty</span>
<a name="line-2905"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>inferred_tvs</span>
<a name="line-2906"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"NB: Specified variables"</span><span class='hs-layout'>)</span>
<a name="line-2907"></a>           <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>pp_spec</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"always come first"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2908"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>specified_tvs</span>
<a name="line-2909"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"NB: Inferred variables"</span><span class='hs-layout'>)</span>
<a name="line-2910"></a>           <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>pp_inf</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"always come first"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2911"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2912"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"NB: Inferred variables"</span><span class='hs-layout'>)</span>
<a name="line-2913"></a>           <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>pp_inf</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"always come first"</span><span class='hs-keyglyph'>]</span>
<a name="line-2914"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"then Specified variables"</span><span class='hs-layout'>,</span> <span class='hs-varid'>pp_spec</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2915"></a>
<a name="line-2916"></a><span class='hs-comment'>{-
<a name="line-2917"></a>************************************************************************
<a name="line-2918"></a>*                                                                      *
<a name="line-2919"></a>\subsection{Auxiliary functions}
<a name="line-2920"></a>*                                                                      *
<a name="line-2921"></a>************************************************************************
<a name="line-2922"></a>-}</span>
<a name="line-2923"></a>
<a name="line-2924"></a><a name="fvType"></a><span class='hs-comment'>-- Free variables of a type, retaining repetitions, and expanding synonyms</span>
<a name="line-2925"></a><span class='hs-comment'>-- This ignores coercions, as coercions aren't user-written</span>
<a name="line-2926"></a><span class='hs-definition'>fvType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCoVar</span><span class='hs-keyglyph'>]</span>
<a name="line-2927"></a><span class='hs-definition'>fvType</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>exp_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>exp_ty</span>
<a name="line-2928"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>tv</span><span class='hs-keyglyph'>]</span>
<a name="line-2929"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvTypes</span> <span class='hs-varid'>tys</span>
<a name="line-2930"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-2931"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>++</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>arg</span>
<a name="line-2932"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>w</span> <span class='hs-varop'>++</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>++</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>res</span>
<a name="line-2933"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-2934"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span>
<a name="line-2935"></a>    <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varop'>/=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>fvType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-2936"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>ty</span>
<a name="line-2937"></a><span class='hs-definition'>fvType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-2938"></a>
<a name="line-2939"></a><a name="fvTypes"></a><span class='hs-definition'>fvTypes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-2940"></a><span class='hs-definition'>fvTypes</span> <span class='hs-varid'>tys</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-varid'>fvType</span> <span class='hs-varid'>tys</span>
<a name="line-2941"></a>
<a name="line-2942"></a><a name="sizeType"></a><span class='hs-definition'>sizeType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2943"></a><span class='hs-comment'>-- Size of a type: the number of variables and constructors</span>
<a name="line-2944"></a><span class='hs-definition'>sizeType</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>exp_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>exp_ty</span>
<a name="line-2945"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-2946"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeTyConAppArgs</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-2947"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-2948"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>arg</span>
<a name="line-2949"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>w</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>res</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
<a name="line-2950"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>ty</span>
<a name="line-2951"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>ty</span>
<a name="line-2952"></a><span class='hs-definition'>sizeType</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-2953"></a>
<a name="line-2954"></a><a name="sizeTypes"></a><span class='hs-definition'>sizeTypes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2955"></a><span class='hs-definition'>sizeTypes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sizeType</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span>
<a name="line-2956"></a>
<a name="line-2957"></a><a name="sizeTyConAppArgs"></a><span class='hs-definition'>sizeTyConAppArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2958"></a><span class='hs-definition'>sizeTyConAppArgs</span> <span class='hs-sel'>_tc</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys</span> <span class='hs-comment'>-- (filterOutInvisibleTypes tc tys)</span>
<a name="line-2959"></a>                           <span class='hs-comment'>-- See Note [Invisible arguments and termination]</span>
<a name="line-2960"></a>
<a name="line-2961"></a><a name="sizePred"></a><span class='hs-comment'>-- Size of a predicate</span>
<a name="line-2962"></a><span class='hs-comment'>--</span>
<a name="line-2963"></a><span class='hs-comment'>-- We are considering whether class constraints terminate.</span>
<a name="line-2964"></a><span class='hs-comment'>-- Equality constraints and constraints for the implicit</span>
<a name="line-2965"></a><span class='hs-comment'>-- parameter class always terminate so it is safe to say "size 0".</span>
<a name="line-2966"></a><span class='hs-comment'>-- See #4200.</span>
<a name="line-2967"></a><span class='hs-definition'>sizePred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2968"></a><span class='hs-definition'>sizePred</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>goClass</span> <span class='hs-varid'>ty</span>
<a name="line-2969"></a>  <span class='hs-keyword'>where</span>
<a name="line-2970"></a>    <span class='hs-varid'>goClass</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-2971"></a>
<a name="line-2972"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span>
<a name="line-2973"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTerminatingClass</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-2974"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span>
<a name="line-2975"></a>                    <span class='hs-comment'>-- The filtering looks bogus</span>
<a name="line-2976"></a>                    <span class='hs-comment'>-- See Note [Invisible arguments and termination]</span>
<a name="line-2977"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>EqPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-2978"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>IrredPred</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeType</span> <span class='hs-varid'>ty</span>
<a name="line-2979"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllPred</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>goClass</span> <span class='hs-varid'>pred</span>
<a name="line-2980"></a>
<a name="line-2981"></a><a name="isTerminatingClass"></a><span class='hs-comment'>-- | When this says "True", ignore this class constraint during</span>
<a name="line-2982"></a><span class='hs-comment'>-- a termination check</span>
<a name="line-2983"></a><span class='hs-definition'>isTerminatingClass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2984"></a><span class='hs-definition'>isTerminatingClass</span> <span class='hs-varid'>cls</span>
<a name="line-2985"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isIPClass</span> <span class='hs-varid'>cls</span>    <span class='hs-comment'>-- Implicit parameter constraints always terminate because</span>
<a name="line-2986"></a>                     <span class='hs-comment'>-- there are no instances for them --- they are only solved</span>
<a name="line-2987"></a>                     <span class='hs-comment'>-- by "local instances" in expressions</span>
<a name="line-2988"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>isEqPredClass</span> <span class='hs-varid'>cls</span>
<a name="line-2989"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>typeableClassKey</span>
<a name="line-2990"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>coercibleTyConKey</span>
<a name="line-2991"></a>
<a name="line-2992"></a><a name="ppr_tidy"></a><span class='hs-comment'>-- | Tidy before printing a type</span>
<a name="line-2993"></a><span class='hs-definition'>ppr_tidy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TidyEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-2994"></a><span class='hs-definition'>ppr_tidy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprType</span> <span class='hs-layout'>(</span><span class='hs-varid'>tidyType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-2995"></a>
<a name="line-2996"></a><a name="allDistinctTyVars"></a><span class='hs-definition'>allDistinctTyVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2997"></a><span class='hs-comment'>-- (allDistinctTyVars tvs tys) returns True if tys are</span>
<a name="line-2998"></a><span class='hs-comment'>-- a) all tyvars</span>
<a name="line-2999"></a><span class='hs-comment'>-- b) all distinct</span>
<a name="line-3000"></a><span class='hs-comment'>-- c) disjoint from tvs</span>
<a name="line-3001"></a><span class='hs-definition'>allDistinctTyVars</span> <span class='hs-keyword'>_</span>    <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-3002"></a><span class='hs-definition'>allDistinctTyVars</span> <span class='hs-varid'>tkvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span> <span class='hs-conop'>:</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-3003"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>getTyVar_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-3004"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-3005"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tkvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-3006"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>allDistinctTyVars</span> <span class='hs-layout'>(</span><span class='hs-varid'>tkvs</span> <span class='hs-varop'>`extendVarSet`</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
</pre></body>
</html>
