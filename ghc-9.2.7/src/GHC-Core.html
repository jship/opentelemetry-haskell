<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-4"></a>-}</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE CPP, DeriveDataTypeable, FlexibleContexts #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE NamedFieldPuns #-}</span>
<a name="line-8"></a><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns   #-}</span>
<a name="line-11"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-record-updates #-}</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-comment'>-- | GHC.Core holds all the main data types for use by for the Glasgow Haskell Compiler midsection</span>
<a name="line-14"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core</span> <span class='hs-layout'>(</span>
<a name="line-15"></a>        <span class='hs-comment'>-- * Main data types</span>
<a name="line-16"></a>        <span class='hs-conid'>Expr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bind</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AltCon</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>Arg</span><span class='hs-layout'>,</span>
<a name="line-17"></a>        <span class='hs-conid'>CoreProgram</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBndr</span><span class='hs-layout'>,</span>
<a name="line-18"></a>        <span class='hs-conid'>TaggedExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>TaggedBndr</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>deTagExpr</span><span class='hs-layout'>,</span>
<a name="line-19"></a>
<a name="line-20"></a>        <span class='hs-comment'>-- * In/Out type synonyms</span>
<a name="line-21"></a>        <span class='hs-conid'>InId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>InAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>InArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>InType</span><span class='hs-layout'>,</span> <span class='hs-conid'>InKind</span><span class='hs-layout'>,</span>
<a name="line-22"></a>               <span class='hs-conid'>InBndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>InVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>InCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>InTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>InCoVar</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-conid'>OutId</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutBind</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutAlt</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutType</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutKind</span><span class='hs-layout'>,</span>
<a name="line-24"></a>               <span class='hs-conid'>OutBndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutTyVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>OutCoVar</span><span class='hs-layout'>,</span> <span class='hs-conid'>MOutCoercion</span><span class='hs-layout'>,</span>
<a name="line-25"></a>
<a name="line-26"></a>        <span class='hs-comment'>-- ** 'Expr' construction</span>
<a name="line-27"></a>        <span class='hs-varid'>mkLet</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLets</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLetNonRec</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLetRec</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLams</span><span class='hs-layout'>,</span>
<a name="line-28"></a>        <span class='hs-varid'>mkApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkVarApps</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyArg</span><span class='hs-layout'>,</span>
<a name="line-29"></a>
<a name="line-30"></a>        <span class='hs-varid'>mkIntLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkIntLitWrap</span><span class='hs-layout'>,</span>
<a name="line-31"></a>        <span class='hs-varid'>mkWordLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWordLitWrap</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-varid'>mkWord8Lit</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-varid'>mkWord64LitWord64</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInt64LitInt64</span><span class='hs-layout'>,</span>
<a name="line-34"></a>        <span class='hs-varid'>mkCharLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkStringLit</span><span class='hs-layout'>,</span>
<a name="line-35"></a>        <span class='hs-varid'>mkFloatLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkFloatLitFloat</span><span class='hs-layout'>,</span>
<a name="line-36"></a>        <span class='hs-varid'>mkDoubleLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkDoubleLitDouble</span><span class='hs-layout'>,</span>
<a name="line-37"></a>
<a name="line-38"></a>        <span class='hs-varid'>mkConApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkConApp2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCoBind</span><span class='hs-layout'>,</span>
<a name="line-39"></a>        <span class='hs-varid'>varToCoreExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>varsToCoreExprs</span><span class='hs-layout'>,</span>
<a name="line-40"></a>
<a name="line-41"></a>        <span class='hs-varid'>isId</span><span class='hs-layout'>,</span> <span class='hs-varid'>cmpAltCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>cmpAlt</span><span class='hs-layout'>,</span> <span class='hs-varid'>ltAlt</span><span class='hs-layout'>,</span>
<a name="line-42"></a>
<a name="line-43"></a>        <span class='hs-comment'>-- ** Simple 'Expr' access functions and predicates</span>
<a name="line-44"></a>        <span class='hs-varid'>bindersOf</span><span class='hs-layout'>,</span> <span class='hs-varid'>bindersOfBinds</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhssOfBind</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhssOfAlts</span><span class='hs-layout'>,</span>
<a name="line-45"></a>        <span class='hs-varid'>collectBinders</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectTyBinders</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectTyAndValBinders</span><span class='hs-layout'>,</span>
<a name="line-46"></a>        <span class='hs-varid'>collectNBinders</span><span class='hs-layout'>,</span>
<a name="line-47"></a>        <span class='hs-varid'>collectArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>stripNArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectArgsTicks</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenBinds</span><span class='hs-layout'>,</span>
<a name="line-48"></a>
<a name="line-49"></a>        <span class='hs-varid'>exprToType</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprToCoercion_maybe</span><span class='hs-layout'>,</span>
<a name="line-50"></a>        <span class='hs-varid'>applyTypeToArg</span><span class='hs-layout'>,</span>
<a name="line-51"></a>
<a name="line-52"></a>        <span class='hs-varid'>isValArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTypeArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isCoArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTyCoArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>valArgCount</span><span class='hs-layout'>,</span> <span class='hs-varid'>valBndrCount</span><span class='hs-layout'>,</span>
<a name="line-53"></a>        <span class='hs-varid'>isRuntimeArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>isRuntimeVar</span><span class='hs-layout'>,</span>
<a name="line-54"></a>
<a name="line-55"></a>        <span class='hs-comment'>-- * Unfolding data types</span>
<a name="line-56"></a>        <span class='hs-conid'>Unfolding</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>  <span class='hs-conid'>UnfoldingGuidance</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnfoldingSource</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-57"></a>
<a name="line-58"></a>        <span class='hs-comment'>-- ** Constructing 'Unfolding's</span>
<a name="line-59"></a>        <span class='hs-varid'>noUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>bootUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>evaldUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkOtherCon</span><span class='hs-layout'>,</span>
<a name="line-60"></a>        <span class='hs-varid'>unSaturatedOk</span><span class='hs-layout'>,</span> <span class='hs-varid'>needSaturated</span><span class='hs-layout'>,</span> <span class='hs-varid'>boringCxtOk</span><span class='hs-layout'>,</span> <span class='hs-varid'>boringCxtNotOk</span><span class='hs-layout'>,</span>
<a name="line-61"></a>
<a name="line-62"></a>        <span class='hs-comment'>-- ** Predicates and deconstruction on 'Unfolding'</span>
<a name="line-63"></a>        <span class='hs-varid'>unfoldingTemplate</span><span class='hs-layout'>,</span> <span class='hs-varid'>expandUnfolding_maybe</span><span class='hs-layout'>,</span>
<a name="line-64"></a>        <span class='hs-varid'>maybeUnfoldingTemplate</span><span class='hs-layout'>,</span> <span class='hs-varid'>otherCons</span><span class='hs-layout'>,</span>
<a name="line-65"></a>        <span class='hs-varid'>isValueUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isEvaldUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isCheapUnfolding</span><span class='hs-layout'>,</span>
<a name="line-66"></a>        <span class='hs-varid'>isExpandableUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isConLikeUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>isCompulsoryUnfolding</span><span class='hs-layout'>,</span>
<a name="line-67"></a>        <span class='hs-varid'>isStableUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>hasCoreUnfolding</span><span class='hs-layout'>,</span> <span class='hs-varid'>hasSomeUnfolding</span><span class='hs-layout'>,</span>
<a name="line-68"></a>        <span class='hs-varid'>isBootUnfolding</span><span class='hs-layout'>,</span>
<a name="line-69"></a>        <span class='hs-varid'>canUnfold</span><span class='hs-layout'>,</span> <span class='hs-varid'>neverUnfoldGuidance</span><span class='hs-layout'>,</span> <span class='hs-varid'>isStableSource</span><span class='hs-layout'>,</span>
<a name="line-70"></a>
<a name="line-71"></a>        <span class='hs-comment'>-- * Annotated expression data types</span>
<a name="line-72"></a>        <span class='hs-conid'>AnnExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr'</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnBind</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnAlt</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-73"></a>
<a name="line-74"></a>        <span class='hs-comment'>-- ** Operations on annotated expressions</span>
<a name="line-75"></a>        <span class='hs-varid'>collectAnnArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectAnnArgsTicks</span><span class='hs-layout'>,</span>
<a name="line-76"></a>
<a name="line-77"></a>        <span class='hs-comment'>-- ** Operations on annotations</span>
<a name="line-78"></a>        <span class='hs-varid'>deAnnotate</span><span class='hs-layout'>,</span> <span class='hs-varid'>deAnnotate'</span><span class='hs-layout'>,</span> <span class='hs-varid'>deAnnAlt</span><span class='hs-layout'>,</span> <span class='hs-varid'>deAnnBind</span><span class='hs-layout'>,</span>
<a name="line-79"></a>        <span class='hs-varid'>collectAnnBndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectNAnnBndrs</span><span class='hs-layout'>,</span>
<a name="line-80"></a>
<a name="line-81"></a>        <span class='hs-comment'>-- * Orphanhood</span>
<a name="line-82"></a>        <span class='hs-conid'>IsOrphan</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>isOrphan</span><span class='hs-layout'>,</span> <span class='hs-varid'>notOrphan</span><span class='hs-layout'>,</span> <span class='hs-varid'>chooseOrphanAnchor</span><span class='hs-layout'>,</span>
<a name="line-83"></a>
<a name="line-84"></a>        <span class='hs-comment'>-- * Core rule data types</span>
<a name="line-85"></a>        <span class='hs-conid'>CoreRule</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>RuleBase</span><span class='hs-layout'>,</span>
<a name="line-86"></a>        <span class='hs-conid'>RuleName</span><span class='hs-layout'>,</span> <span class='hs-conid'>RuleFun</span><span class='hs-layout'>,</span> <span class='hs-conid'>IdUnfoldingFun</span><span class='hs-layout'>,</span> <span class='hs-conid'>InScopeEnv</span><span class='hs-layout'>,</span>
<a name="line-87"></a>        <span class='hs-conid'>RuleEnv</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>RuleOpts</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkRuleEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyRuleEnv</span><span class='hs-layout'>,</span>
<a name="line-88"></a>
<a name="line-89"></a>        <span class='hs-comment'>-- ** Operations on 'CoreRule's</span>
<a name="line-90"></a>        <span class='hs-varid'>ruleArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleIdName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleActivation</span><span class='hs-layout'>,</span>
<a name="line-91"></a>        <span class='hs-varid'>setRuleIdName</span><span class='hs-layout'>,</span> <span class='hs-varid'>ruleModule</span><span class='hs-layout'>,</span>
<a name="line-92"></a>        <span class='hs-varid'>isBuiltinRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>isLocalRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>isAutoRule</span><span class='hs-layout'>,</span>
<a name="line-93"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-94"></a>
<a name="line-95"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-96"></a>
<a name="line-97"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-98"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Platform</span>
<a name="line-99"></a>
<a name="line-100"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span><span class='hs-layout'>(</span> <span class='hs-conid'>InScopeSet</span> <span class='hs-layout'>)</span>
<a name="line-101"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-102"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-103"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-104"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-105"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Set</span>
<a name="line-106"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Env</span><span class='hs-layout'>(</span> <span class='hs-conid'>NameEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyNameEnv</span> <span class='hs-layout'>)</span>
<a name="line-107"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Literal</span>
<a name="line-108"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-109"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-110"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module</span>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Set</span>
<a name="line-113"></a>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Binary</span>
<a name="line-115"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-116"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-117"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-118"></a>
<a name="line-119"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-120"></a>
<a name="line-121"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>)</span>
<a name="line-122"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Int</span>
<a name="line-123"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Word</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-keyword'>infixl</span> <span class='hs-num'>4</span> <span class='hs-varop'>`mkApps`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkTyApps`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkVarApps`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`App`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkCoApps`</span>
<a name="line-126"></a><span class='hs-comment'>-- Left associative, so that we can say (f `mkTyApps` xs `mkVarApps` ys)</span>
<a name="line-127"></a>
<a name="line-128"></a><span class='hs-comment'>{-
<a name="line-129"></a>************************************************************************
<a name="line-130"></a>*                                                                      *
<a name="line-131"></a>\subsection{The main data types}
<a name="line-132"></a>*                                                                      *
<a name="line-133"></a>************************************************************************
<a name="line-134"></a>
<a name="line-135"></a>These data types are the heart of the compiler
<a name="line-136"></a>-}</span>
<a name="line-137"></a>
<a name="line-138"></a><span class='hs-comment'>-- | This is the data type that represents GHCs core intermediate language. Currently</span>
<a name="line-139"></a><span class='hs-comment'>-- GHC uses System FC &lt;https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions/&gt; for this purpose,</span>
<a name="line-140"></a><span class='hs-comment'>-- which is closely related to the simpler and better known System F &lt;<a href="http://en.wikipedia.org/wiki/System_F">http://en.wikipedia.org/wiki/System_F</a>&gt;.</span>
<a name="line-141"></a><span class='hs-comment'>--</span>
<a name="line-142"></a><span class='hs-comment'>-- We get from Haskell source to this Core language in a number of stages:</span>
<a name="line-143"></a><span class='hs-comment'>--</span>
<a name="line-144"></a><span class='hs-comment'>-- 1. The source code is parsed into an abstract syntax tree, which is represented</span>
<a name="line-145"></a><span class='hs-comment'>--    by the data type 'GHC.Hs.Expr.HsExpr' with the names being 'GHC.Types.Name.Reader.RdrNames'</span>
<a name="line-146"></a><span class='hs-comment'>--</span>
<a name="line-147"></a><span class='hs-comment'>-- 2. This syntax tree is /renamed/, which attaches a 'GHC.Types.Unique.Unique' to every 'GHC.Types.Name.Reader.RdrName'</span>
<a name="line-148"></a><span class='hs-comment'>--    (yielding a 'GHC.Types.Name.Name') to disambiguate identifiers which are lexically identical.</span>
<a name="line-149"></a><span class='hs-comment'>--    For example, this program:</span>
<a name="line-150"></a><span class='hs-comment'>--</span>
<a name="line-151"></a><span class='hs-comment'>-- @</span>
<a name="line-152"></a><span class='hs-comment'>--      f x = let f x = x + 1</span>
<a name="line-153"></a><span class='hs-comment'>--            in f (x - 2)</span>
<a name="line-154"></a><span class='hs-comment'>-- @</span>
<a name="line-155"></a><span class='hs-comment'>--</span>
<a name="line-156"></a><span class='hs-comment'>--    Would be renamed by having 'Unique's attached so it looked something like this:</span>
<a name="line-157"></a><span class='hs-comment'>--</span>
<a name="line-158"></a><span class='hs-comment'>-- @</span>
<a name="line-159"></a><span class='hs-comment'>--      f_1 x_2 = let f_3 x_4 = x_4 + 1</span>
<a name="line-160"></a><span class='hs-comment'>--                in f_3 (x_2 - 2)</span>
<a name="line-161"></a><span class='hs-comment'>-- @</span>
<a name="line-162"></a><span class='hs-comment'>--    But see Note [Shadowing] below.</span>
<a name="line-163"></a><span class='hs-comment'>--</span>
<a name="line-164"></a><span class='hs-comment'>-- 3. The resulting syntax tree undergoes type checking (which also deals with instantiating</span>
<a name="line-165"></a><span class='hs-comment'>--    type class arguments) to yield a 'GHC.Hs.Expr.HsExpr' type that has 'GHC.Types.Id.Id' as it's names.</span>
<a name="line-166"></a><span class='hs-comment'>--</span>
<a name="line-167"></a><span class='hs-comment'>-- 4. Finally the syntax tree is /desugared/ from the expressive 'GHC.Hs.Expr.HsExpr' type into</span>
<a name="line-168"></a><span class='hs-comment'>--    this 'Expr' type, which has far fewer constructors and hence is easier to perform</span>
<a name="line-169"></a><span class='hs-comment'>--    optimization, analysis and code generation on.</span>
<a name="line-170"></a><span class='hs-comment'>--</span>
<a name="line-171"></a><span class='hs-comment'>-- The type parameter @b@ is for the type of binders in the expression tree.</span>
<a name="line-172"></a><span class='hs-comment'>--</span>
<a name="line-173"></a><span class='hs-comment'>-- The language consists of the following elements:</span>
<a name="line-174"></a><span class='hs-comment'>--</span>
<a name="line-175"></a><span class='hs-comment'>-- *  Variables</span>
<a name="line-176"></a><span class='hs-comment'>--    See Note [Variable occurrences in Core]</span>
<a name="line-177"></a><span class='hs-comment'>--</span>
<a name="line-178"></a><span class='hs-comment'>-- *  Primitive literals</span>
<a name="line-179"></a><span class='hs-comment'>--</span>
<a name="line-180"></a><span class='hs-comment'>-- *  Applications: note that the argument may be a 'Type'.</span>
<a name="line-181"></a><span class='hs-comment'>--    See Note [Core let/app invariant]</span>
<a name="line-182"></a><span class='hs-comment'>--    See Note [Levity polymorphism invariants]</span>
<a name="line-183"></a><span class='hs-comment'>--</span>
<a name="line-184"></a><span class='hs-comment'>-- *  Lambda abstraction</span>
<a name="line-185"></a><span class='hs-comment'>--    See Note [Levity polymorphism invariants]</span>
<a name="line-186"></a><span class='hs-comment'>--</span>
<a name="line-187"></a><span class='hs-comment'>-- *  Recursive and non recursive @let@s. Operationally</span>
<a name="line-188"></a><span class='hs-comment'>--    this corresponds to allocating a thunk for the things</span>
<a name="line-189"></a><span class='hs-comment'>--    bound and then executing the sub-expression.</span>
<a name="line-190"></a><span class='hs-comment'>--</span>
<a name="line-191"></a><span class='hs-comment'>--    See Note [Core letrec invariant]</span>
<a name="line-192"></a><span class='hs-comment'>--    See Note [Core let/app invariant]</span>
<a name="line-193"></a><span class='hs-comment'>--    See Note [Levity polymorphism invariants]</span>
<a name="line-194"></a><span class='hs-comment'>--    See Note [Core type and coercion invariant]</span>
<a name="line-195"></a><span class='hs-comment'>--</span>
<a name="line-196"></a><span class='hs-comment'>-- *  Case expression. Operationally this corresponds to evaluating</span>
<a name="line-197"></a><span class='hs-comment'>--    the scrutinee (expression examined) to weak head normal form</span>
<a name="line-198"></a><span class='hs-comment'>--    and then examining at most one level of resulting constructor (i.e. you</span>
<a name="line-199"></a><span class='hs-comment'>--    cannot do nested pattern matching directly with this).</span>
<a name="line-200"></a><span class='hs-comment'>--</span>
<a name="line-201"></a><span class='hs-comment'>--    The binder gets bound to the value of the scrutinee,</span>
<a name="line-202"></a><span class='hs-comment'>--    and the 'Type' must be that of all the case alternatives</span>
<a name="line-203"></a><span class='hs-comment'>--</span>
<a name="line-204"></a><span class='hs-comment'>--    IMPORTANT: see Note [Case expression invariants]</span>
<a name="line-205"></a><span class='hs-comment'>--</span>
<a name="line-206"></a><span class='hs-comment'>-- *  Cast an expression to a particular type.</span>
<a name="line-207"></a><span class='hs-comment'>--    This is used to implement @newtype@s (a @newtype@ constructor or</span>
<a name="line-208"></a><span class='hs-comment'>--    destructor just becomes a 'Cast' in Core) and GADTs.</span>
<a name="line-209"></a><span class='hs-comment'>--</span>
<a name="line-210"></a><span class='hs-comment'>-- *  Ticks. These are used to represent all the source annotation we</span>
<a name="line-211"></a><span class='hs-comment'>--    support: profiling SCCs, HPC ticks, and GHCi breakpoints.</span>
<a name="line-212"></a><span class='hs-comment'>--</span>
<a name="line-213"></a><span class='hs-comment'>-- *  A type: this should only show up at the top level of an Arg</span>
<a name="line-214"></a><span class='hs-comment'>--</span>
<a name="line-215"></a><span class='hs-comment'>-- *  A coercion</span>
<a name="line-216"></a>
<a name="line-217"></a><span class='hs-comment'>{- Note [Why does Case have a 'Type' field?]
<a name="line-218"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-219"></a>The obvious alternative is
<a name="line-220"></a>   exprType (Case scrut bndr alts)
<a name="line-221"></a>     | (_,_,rhs1):_ &lt;- alts
<a name="line-222"></a>     = exprType rhs1
<a name="line-223"></a>
<a name="line-224"></a>But caching the type in the Case constructor
<a name="line-225"></a>  exprType (Case scrut bndr ty alts) = ty
<a name="line-226"></a>is better for at least three reasons:
<a name="line-227"></a>
<a name="line-228"></a>* It works when there are no alternatives (see case invariant 1 above)
<a name="line-229"></a>
<a name="line-230"></a>* It might be faster in deeply-nested situations.
<a name="line-231"></a>
<a name="line-232"></a>* It might not be quite the same as (exprType rhs) for one
<a name="line-233"></a>  of the RHSs in alts. Consider a phantom type synonym
<a name="line-234"></a>       type S a = Int
<a name="line-235"></a>   and we want to form the case expression
<a name="line-236"></a>        case x of { K (a::*) -&gt; (e :: S a) }
<a name="line-237"></a>   Then exprType of the RHS is (S a), but we cannot make that be
<a name="line-238"></a>   the 'ty' in the Case constructor because 'a' is simply not in
<a name="line-239"></a>   scope there. Instead we must expand the synonym to Int before
<a name="line-240"></a>   putting it in the Case constructor.  See GHC.Core.Utils.mkSingleAltCase.
<a name="line-241"></a>
<a name="line-242"></a>   So we'd have to do synonym expansion in exprType which would
<a name="line-243"></a>   be inefficient.
<a name="line-244"></a>
<a name="line-245"></a>* The type stored in the case is checked with lintInTy. This checks
<a name="line-246"></a>  (among other things) that it does not mention any variables that are
<a name="line-247"></a>  not in scope. If we did not have the type there, it would be a bit
<a name="line-248"></a>  harder for Core Lint to reject case blah of Ex x -&gt; x where
<a name="line-249"></a>      data Ex = forall a. Ex a.
<a name="line-250"></a>-}</span>
<a name="line-251"></a>
<a name="line-252"></a><a name="Expr"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-253"></a><a name="Expr"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-254"></a><a name="Expr"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-255"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span>   <span class='hs-conid'>Id</span>
<a name="line-256"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Lit</span>   <span class='hs-conid'>Literal</span>
<a name="line-257"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>App</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-258"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Lam</span>   <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-259"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Let</span>   <span class='hs-layout'>(</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-260"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Case</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- See Note [Case expression invariants]</span>
<a name="line-261"></a>                                    <span class='hs-comment'>-- and Note [Why does Case have a 'Type' field?]</span>
<a name="line-262"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Cast</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-conid'>CoercionR</span>        <span class='hs-comment'>-- The Coercion has Representational role</span>
<a name="line-263"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Tick</span>  <span class='hs-conid'>CoreTickish</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-264"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Type</span>  <span class='hs-conid'>Type</span>
<a name="line-265"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Coercion</span> <span class='hs-conid'>Coercion</span>
<a name="line-266"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-267"></a>
<a name="line-268"></a><a name="Arg"></a><span class='hs-comment'>-- | Type synonym for expressions that occur in function argument positions.</span>
<a name="line-269"></a><a name="Arg"></a><span class='hs-comment'>-- Only 'Arg' should contain a 'Type' at top level, general 'Expr' should not</span>
<a name="line-270"></a><a name="Arg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-271"></a>
<a name="line-272"></a><span class='hs-comment'>-- | A case split alternative. Consists of the constructor leading to the alternative,</span>
<a name="line-273"></a><span class='hs-comment'>-- the variables bound from the constructor, and the expression to be executed given that binding.</span>
<a name="line-274"></a><span class='hs-comment'>-- The default alternative is @(DEFAULT, [], rhs)@</span>
<a name="line-275"></a>
<a name="line-276"></a><a name="Alt"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-277"></a><a name="Alt"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-278"></a><a name="Alt"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>b</span>
<a name="line-279"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-280"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-281"></a>
<a name="line-282"></a><span class='hs-comment'>-- | A case alternative constructor (i.e. pattern match)</span>
<a name="line-283"></a>
<a name="line-284"></a><a name="AltCon"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-285"></a><a name="AltCon"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-286"></a><a name="AltCon"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AltCon</span>
<a name="line-287"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DataAlt</span> <span class='hs-conid'>DataCon</span>   <span class='hs-comment'>--  ^ A plain data constructor: @case e of { Foo x -&gt; ... }@.</span>
<a name="line-288"></a>                      <span class='hs-comment'>-- Invariant: the 'DataCon' is always from a @data@ type, and never from a @newtype@</span>
<a name="line-289"></a>
<a name="line-290"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LitAlt</span>  <span class='hs-conid'>Literal</span>   <span class='hs-comment'>-- ^ A literal: @case e of { 1 -&gt; ... }@</span>
<a name="line-291"></a>                      <span class='hs-comment'>-- Invariant: always an *unlifted* literal</span>
<a name="line-292"></a>                      <span class='hs-comment'>-- See Note [Literal alternatives]</span>
<a name="line-293"></a>
<a name="line-294"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DEFAULT</span>           <span class='hs-comment'>-- ^ Trivial alternative: @case e of { _ -&gt; ... }@</span>
<a name="line-295"></a>   <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Data</span><span class='hs-layout'>)</span>
<a name="line-296"></a>
<a name="line-297"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- This instance is a bit shady. It can only be used to compare AltCons for</span>
<a name="line-298"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- a single type constructor. Fortunately, it seems quite unlikely that we'll</span>
<a name="line-299"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- ever need to compare AltCons for different type constructors.</span>
<a name="line-300"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-comment'>-- The instance adheres to the order described in [Core case invariants]</span>
<a name="line-301"></a><a name="instance%20Ord%20AltCon"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyword'>where</span>
<a name="line-302"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-303"></a>    <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>con1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>con2</span> <span class='hs-layout'>)</span>
<a name="line-304"></a>    <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTag</span> <span class='hs-varid'>con1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTag</span> <span class='hs-varid'>con2</span><span class='hs-layout'>)</span>
<a name="line-305"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-306"></a>  <span class='hs-varid'>compare</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-307"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>l1</span> <span class='hs-varid'>l2</span>
<a name="line-308"></a>  <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-309"></a>  <span class='hs-varid'>compare</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-310"></a>  <span class='hs-varid'>compare</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-311"></a>
<a name="line-312"></a><span class='hs-comment'>-- | Binding, used for top level bindings in a module and local bindings in a @let@.</span>
<a name="line-313"></a>
<a name="line-314"></a><a name="Bind"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-315"></a><a name="Bind"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-316"></a><a name="Bind"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-317"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Rec</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-318"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-319"></a>
<a name="line-320"></a><span class='hs-comment'>{-
<a name="line-321"></a>Note [Shadowing]
<a name="line-322"></a>~~~~~~~~~~~~~~~~
<a name="line-323"></a>While various passes attempt to rename on-the-fly in a manner that
<a name="line-324"></a>avoids "shadowing" (thereby simplifying downstream optimizations),
<a name="line-325"></a>neither the simplifier nor any other pass GUARANTEES that shadowing is
<a name="line-326"></a>avoided. Thus, all passes SHOULD work fine even in the presence of
<a name="line-327"></a>arbitrary shadowing in their inputs.
<a name="line-328"></a>
<a name="line-329"></a>In particular, scrutinee variables `x` in expressions of the form
<a name="line-330"></a>`Case e x t` are often renamed to variables with a prefix
<a name="line-331"></a>"wild_". These "wild" variables may appear in the body of the
<a name="line-332"></a>case-expression, and further, may be shadowed within the body.
<a name="line-333"></a>
<a name="line-334"></a>So the Unique in a Var is not really unique at all.  Still, it's very
<a name="line-335"></a>useful to give a constant-time equality/ordering for Vars, and to give
<a name="line-336"></a>a key that can be used to make sets of Vars (VarSet), or mappings from
<a name="line-337"></a>Vars to other things (VarEnv).   Moreover, if you do want to eliminate
<a name="line-338"></a>shadowing, you can give a new Unique to an Id without changing its
<a name="line-339"></a>printable name, which makes debugging easier.
<a name="line-340"></a>
<a name="line-341"></a>Note [Literal alternatives]
<a name="line-342"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-343"></a>Literal alternatives (LitAlt lit) are always for *un-lifted* literals.
<a name="line-344"></a>We have one literal, a literal Integer, that is lifted, and we don't
<a name="line-345"></a>allow in a LitAlt, because LitAlt cases don't do any evaluation. Also
<a name="line-346"></a>(see #5603) if you say
<a name="line-347"></a>    case 3 of
<a name="line-348"></a>      IS x -&gt; ...
<a name="line-349"></a>      IP _ -&gt; ...
<a name="line-350"></a>      IN _ -&gt; ...
<a name="line-351"></a>(where IS, IP, IN are the constructors for Integer) we don't want the
<a name="line-352"></a>simplifier calling findAlt with argument (LitAlt 3).  No no.  Integer
<a name="line-353"></a>literals are an opaque encoding of an algebraic data type, not of
<a name="line-354"></a>an unlifted literal, like all the others.
<a name="line-355"></a>
<a name="line-356"></a>Also, we do not permit case analysis with literal patterns on floating-point
<a name="line-357"></a>types. See #9238 and Note [Rules for floating-point comparisons] in
<a name="line-358"></a>GHC.Core.Opt.ConstantFold for the rationale for this restriction.
<a name="line-359"></a>
<a name="line-360"></a>-------------------------- GHC.Core INVARIANTS ---------------------------
<a name="line-361"></a>
<a name="line-362"></a>Note [Variable occurrences in Core]
<a name="line-363"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-364"></a>Variable /occurrences/ are never CoVars, though /bindings/ can be.
<a name="line-365"></a>All CoVars appear in Coercions.
<a name="line-366"></a>
<a name="line-367"></a>For example
<a name="line-368"></a>  \(c :: Age~#Int) (d::Int). d |&gt; (sym c)
<a name="line-369"></a>Here 'c' is a CoVar, which is lambda-bound, but it /occurs/ in
<a name="line-370"></a>a Coercion, (sym c).
<a name="line-371"></a>
<a name="line-372"></a>Note [Core letrec invariant]
<a name="line-373"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-374"></a>The right hand sides of all top-level and recursive @let@s
<a name="line-375"></a>/must/ be of lifted type (see "Type#type_classification" for
<a name="line-376"></a>the meaning of /lifted/ vs. /unlifted/).
<a name="line-377"></a>
<a name="line-378"></a>There is one exception to this rule, top-level @let@s are
<a name="line-379"></a>allowed to bind primitive string literals: see
<a name="line-380"></a>Note [Core top-level string literals].
<a name="line-381"></a>
<a name="line-382"></a>Note [Core top-level string literals]
<a name="line-383"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-384"></a>As an exception to the usual rule that top-level binders must be lifted,
<a name="line-385"></a>we allow binding primitive string literals (of type Addr#) of type Addr# at the
<a name="line-386"></a>top level. This allows us to share string literals earlier in the pipeline and
<a name="line-387"></a>crucially allows other optimizations in the Core2Core pipeline to fire.
<a name="line-388"></a>Consider,
<a name="line-389"></a>
<a name="line-390"></a>  f n = let a::Addr# = "foo"#
<a name="line-391"></a>        in \x -&gt; blah
<a name="line-392"></a>
<a name="line-393"></a>In order to be able to inline `f`, we would like to float `a` to the top.
<a name="line-394"></a>Another option would be to inline `a`, but that would lead to duplicating string
<a name="line-395"></a>literals, which we want to avoid. See #8472.
<a name="line-396"></a>
<a name="line-397"></a>The solution is simply to allow top-level unlifted binders. We can't allow
<a name="line-398"></a>arbitrary unlifted expression at the top-level though, unlifted binders cannot
<a name="line-399"></a>be thunks, so we just allow string literals.
<a name="line-400"></a>
<a name="line-401"></a>We allow the top-level primitive string literals to be wrapped in Ticks
<a name="line-402"></a>in the same way they can be wrapped when nested in an expression.
<a name="line-403"></a>CoreToSTG currently discards Ticks around top-level primitive string literals.
<a name="line-404"></a>See #14779.
<a name="line-405"></a>
<a name="line-406"></a>Also see Note [Compilation plan for top-level string literals].
<a name="line-407"></a>
<a name="line-408"></a>Note [Compilation plan for top-level string literals]
<a name="line-409"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-410"></a>Here is a summary on how top-level string literals are handled by various
<a name="line-411"></a>parts of the compilation pipeline.
<a name="line-412"></a>
<a name="line-413"></a>* In the source language, there is no way to bind a primitive string literal
<a name="line-414"></a>  at the top level.
<a name="line-415"></a>
<a name="line-416"></a>* In Core, we have a special rule that permits top-level Addr# bindings. See
<a name="line-417"></a>  Note [Core top-level string literals]. Core-to-core passes may introduce
<a name="line-418"></a>  new top-level string literals.
<a name="line-419"></a>
<a name="line-420"></a>* In STG, top-level string literals are explicitly represented in the syntax
<a name="line-421"></a>  tree.
<a name="line-422"></a>
<a name="line-423"></a>* A top-level string literal may end up exported from a module. In this case,
<a name="line-424"></a>  in the object file, the content of the exported literal is given a label with
<a name="line-425"></a>  the _bytes suffix.
<a name="line-426"></a>
<a name="line-427"></a>Note [Core let/app invariant]
<a name="line-428"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-429"></a>The let/app invariant
<a name="line-430"></a>     the right hand side of a non-recursive 'Let', and
<a name="line-431"></a>     the argument of an 'App',
<a name="line-432"></a>    /may/ be of unlifted type, but only if
<a name="line-433"></a>    the expression is ok-for-speculation
<a name="line-434"></a>    or the 'Let' is for a join point.
<a name="line-435"></a>
<a name="line-436"></a>This means that the let can be floated around
<a name="line-437"></a>without difficulty. For example, this is OK:
<a name="line-438"></a>
<a name="line-439"></a>   y::Int# = x +# 1#
<a name="line-440"></a>
<a name="line-441"></a>But this is not, as it may affect termination if the
<a name="line-442"></a>expression is floated out:
<a name="line-443"></a>
<a name="line-444"></a>   y::Int# = fac 4#
<a name="line-445"></a>
<a name="line-446"></a>In this situation you should use @case@ rather than a @let@. The function
<a name="line-447"></a>'GHC.Core.Utils.needsCaseBinding' can help you determine which to generate, or
<a name="line-448"></a>alternatively use 'GHC.Core.Make.mkCoreLet' rather than this constructor directly,
<a name="line-449"></a>which will generate a @case@ if necessary
<a name="line-450"></a>
<a name="line-451"></a>The let/app invariant is initially enforced by mkCoreLet and mkCoreApp in
<a name="line-452"></a>GHC.Core.Make.
<a name="line-453"></a>
<a name="line-454"></a>For discussion of some implications of the let/app invariant primops see
<a name="line-455"></a>Note [Checking versus non-checking primops] in GHC.Builtin.PrimOps.
<a name="line-456"></a>
<a name="line-457"></a>Note [Case expression invariants]
<a name="line-458"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-459"></a>Case expressions are one of the more complicated elements of the Core
<a name="line-460"></a>language, and come with a number of invariants.  All of them should be
<a name="line-461"></a>checked by Core Lint.
<a name="line-462"></a>
<a name="line-463"></a>1. The list of alternatives may be empty;
<a name="line-464"></a>   See Note [Empty case alternatives]
<a name="line-465"></a>
<a name="line-466"></a>2. The 'DEFAULT' case alternative must be first in the list,
<a name="line-467"></a>   if it occurs at all.  Checked in GHC.Core.Lint.checkCaseAlts.
<a name="line-468"></a>
<a name="line-469"></a>3. The remaining cases are in order of (strictly) increasing
<a name="line-470"></a>     tag  (for 'DataAlts') or
<a name="line-471"></a>     lit  (for 'LitAlts').
<a name="line-472"></a>   This makes finding the relevant constructor easy, and makes
<a name="line-473"></a>   comparison easier too.   Checked in GHC.Core.Lint.checkCaseAlts.
<a name="line-474"></a>
<a name="line-475"></a>4. The list of alternatives must be exhaustive. An /exhaustive/ case
<a name="line-476"></a>   does not necessarily mention all constructors:
<a name="line-477"></a>
<a name="line-478"></a>   @
<a name="line-479"></a>        data Foo = Red | Green | Blue
<a name="line-480"></a>        ... case x of
<a name="line-481"></a>              Red   -&gt; True
<a name="line-482"></a>              other -&gt; f (case x of
<a name="line-483"></a>                              Green -&gt; ...
<a name="line-484"></a>                              Blue  -&gt; ... ) ...
<a name="line-485"></a>   @
<a name="line-486"></a>
<a name="line-487"></a>   The inner case does not need a @Red@ alternative, because @x@
<a name="line-488"></a>   can't be @Red@ at that program point.
<a name="line-489"></a>
<a name="line-490"></a>   This is not checked by Core Lint -- it's very hard to do so.
<a name="line-491"></a>   E.g. suppose that inner case was floated out, thus:
<a name="line-492"></a>         let a = case x of
<a name="line-493"></a>                   Green -&gt; ...
<a name="line-494"></a>                   Blue  -&gt; ... )
<a name="line-495"></a>         case x of
<a name="line-496"></a>           Red   -&gt; True
<a name="line-497"></a>           other -&gt; f a
<a name="line-498"></a>   Now it's really hard to see that the Green/Blue case is
<a name="line-499"></a>   exhaustive.  But it is.
<a name="line-500"></a>
<a name="line-501"></a>   If you have a case-expression that really /isn't/ exhaustive,
<a name="line-502"></a>   we may generate seg-faults.  Consider the Green/Blue case
<a name="line-503"></a>   above.  Since there are only two branches we may generate
<a name="line-504"></a>   code that tests for Green, and if not Green simply /assumes/
<a name="line-505"></a>   Blue (since, if the case is exhaustive, that's all that
<a name="line-506"></a>   remains).  Of course, if it's not Blue and we start fetching
<a name="line-507"></a>   fields that should be in a Blue constructor, we may die
<a name="line-508"></a>   horribly. See also Note [Core Lint guarantee] in GHC.Core.Lint.
<a name="line-509"></a>
<a name="line-510"></a>5. Floating-point values must not be scrutinised against literals.
<a name="line-511"></a>   See #9238 and Note [Rules for floating-point comparisons]
<a name="line-512"></a>   in GHC.Core.Opt.ConstantFold for rationale.  Checked in lintCaseExpr;
<a name="line-513"></a>   see the call to isFloatingTy.
<a name="line-514"></a>
<a name="line-515"></a>6. The 'ty' field of (Case scrut bndr ty alts) is the type of the
<a name="line-516"></a>   /entire/ case expression.  Checked in lintAltExpr.
<a name="line-517"></a>   See also Note [Why does Case have a 'Type' field?].
<a name="line-518"></a>
<a name="line-519"></a>7. The type of the scrutinee must be the same as the type
<a name="line-520"></a>   of the case binder, obviously.  Checked in lintCaseExpr.
<a name="line-521"></a>
<a name="line-522"></a>8. The multiplicity of the binders in constructor patterns must be the
<a name="line-523"></a>   multiplicity of the corresponding field /scaled by the multiplicity of the
<a name="line-524"></a>   case binder/. Checked in lintCoreAlt.
<a name="line-525"></a>
<a name="line-526"></a>Note [Core type and coercion invariant]
<a name="line-527"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-528"></a>We allow a /non-recursive/, /non-top-level/ let to bind type and
<a name="line-529"></a>coercion variables.  These can be very convenient for postponing type
<a name="line-530"></a>substitutions until the next run of the simplifier.
<a name="line-531"></a>
<a name="line-532"></a>* A type variable binding must have a RHS of (Type ty)
<a name="line-533"></a>
<a name="line-534"></a>* A coercion variable binding must have a RHS of (Coercion co)
<a name="line-535"></a>
<a name="line-536"></a>  It is possible to have terms that return a coercion, but we use
<a name="line-537"></a>  case-binding for those; e.g.
<a name="line-538"></a>     case (eq_sel d) of (co :: a ~# b) -&gt; blah
<a name="line-539"></a>  where eq_sel :: (a~b) -&gt; (a~#b)
<a name="line-540"></a>
<a name="line-541"></a>  Or even
<a name="line-542"></a>      case (df @Int) of (co :: a ~# b) -&gt; blah
<a name="line-543"></a>  Which is very exotic, and I think never encountered; but see
<a name="line-544"></a>  Note [Equality superclasses in quantified constraints]
<a name="line-545"></a>  in GHC.Tc.Solver.Canonical
<a name="line-546"></a>
<a name="line-547"></a>Note [Core case invariants]
<a name="line-548"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-549"></a>See Note [Case expression invariants]
<a name="line-550"></a>
<a name="line-551"></a>Note [Levity polymorphism invariants]
<a name="line-552"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-553"></a>The levity-polymorphism invariants are these (as per "Levity Polymorphism",
<a name="line-554"></a>PLDI '17):
<a name="line-555"></a>
<a name="line-556"></a>* The type of a term-binder must not be levity-polymorphic,
<a name="line-557"></a>  unless it is a let(rec)-bound join point
<a name="line-558"></a>     (see Note [Invariants on join points])
<a name="line-559"></a>
<a name="line-560"></a>* The type of the argument of an App must not be levity-polymorphic.
<a name="line-561"></a>
<a name="line-562"></a>A type (t::TYPE r) is "levity polymorphic" if 'r' has any free variables.
<a name="line-563"></a>
<a name="line-564"></a>For example
<a name="line-565"></a>  \(r::RuntimeRep). \(a::TYPE r). \(x::a). e
<a name="line-566"></a>is illegal because x's type has kind (TYPE r), which has 'r' free.
<a name="line-567"></a>
<a name="line-568"></a>See Note [Levity polymorphism checking] in GHC.HsToCore.Monad to see where these
<a name="line-569"></a>invariants are established for user-written code.
<a name="line-570"></a>
<a name="line-571"></a>Note [Core let goal]
<a name="line-572"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-573"></a>* The simplifier tries to ensure that if the RHS of a let is a constructor
<a name="line-574"></a>  application, its arguments are trivial, so that the constructor can be
<a name="line-575"></a>  inlined vigorously.
<a name="line-576"></a>
<a name="line-577"></a>Note [Empty case alternatives]
<a name="line-578"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-579"></a>The alternatives of a case expression should be exhaustive.  But
<a name="line-580"></a>this exhaustive list can be empty!
<a name="line-581"></a>
<a name="line-582"></a>* A case expression can have empty alternatives if (and only if) the
<a name="line-583"></a>  scrutinee is bound to raise an exception or diverge. When do we know
<a name="line-584"></a>  this?  See Note [Bottoming expressions] in GHC.Core.Utils.
<a name="line-585"></a>
<a name="line-586"></a>* The possibility of empty alternatives is one reason we need a type on
<a name="line-587"></a>  the case expression: if the alternatives are empty we can't get the
<a name="line-588"></a>  type from the alternatives!
<a name="line-589"></a>
<a name="line-590"></a>* In the case of empty types (see Note [Bottoming expressions]), say
<a name="line-591"></a>    data T
<a name="line-592"></a>  we do NOT want to replace
<a name="line-593"></a>    case (x::T) of Bool {}   --&gt;   error Bool "Inaccessible case"
<a name="line-594"></a>  because x might raise an exception, and *that*'s what we want to see!
<a name="line-595"></a>  (#6067 is an example.) To preserve semantics we'd have to say
<a name="line-596"></a>     x `seq` error Bool "Inaccessible case"
<a name="line-597"></a>  but the 'seq' is just such a case, so we are back to square 1.
<a name="line-598"></a>
<a name="line-599"></a>* We can use the empty-alternative construct to coerce error values from
<a name="line-600"></a>  one type to another.  For example
<a name="line-601"></a>
<a name="line-602"></a>    f :: Int -&gt; Int
<a name="line-603"></a>    f n = error "urk"
<a name="line-604"></a>
<a name="line-605"></a>    g :: Int -&gt; (# Char, Bool #)
<a name="line-606"></a>    g x = case f x of { 0 -&gt; ..., n -&gt; ... }
<a name="line-607"></a>
<a name="line-608"></a>  Then if we inline f in g's RHS we get
<a name="line-609"></a>    case (error Int "urk") of (# Char, Bool #) { ... }
<a name="line-610"></a>  and we can discard the alternatives since the scrutinee is bottom to give
<a name="line-611"></a>    case (error Int "urk") of (# Char, Bool #) {}
<a name="line-612"></a>
<a name="line-613"></a>  This is nicer than using an unsafe coerce between Int ~ (# Char,Bool #),
<a name="line-614"></a>  if for no other reason that we don't need to instantiate the (~) at an
<a name="line-615"></a>  unboxed type.
<a name="line-616"></a>
<a name="line-617"></a>* We treat a case expression with empty alternatives as trivial iff
<a name="line-618"></a>  its scrutinee is (see GHC.Core.Utils.exprIsTrivial).  This is actually
<a name="line-619"></a>  important; see Note [Empty case is trivial] in GHC.Core.Utils
<a name="line-620"></a>
<a name="line-621"></a>* An empty case is replaced by its scrutinee during the CoreToStg
<a name="line-622"></a>  conversion; remember STG is un-typed, so there is no need for
<a name="line-623"></a>  the empty case to do the type conversion.
<a name="line-624"></a>
<a name="line-625"></a>Note [Join points]
<a name="line-626"></a>~~~~~~~~~~~~~~~~~~
<a name="line-627"></a>In Core, a *join point* is a specially tagged function whose only occurrences
<a name="line-628"></a>are saturated tail calls. A tail call can appear in these places:
<a name="line-629"></a>
<a name="line-630"></a>  1. In the branches (not the scrutinee) of a case
<a name="line-631"></a>  2. Underneath a let (value or join point)
<a name="line-632"></a>  3. Inside another join point
<a name="line-633"></a>
<a name="line-634"></a>We write a join-point declaration as
<a name="line-635"></a>  join j @a @b x y = e1 in e2,
<a name="line-636"></a>like a let binding but with "join" instead (or "join rec" for "let rec"). Note
<a name="line-637"></a>that we put the parameters before the = rather than using lambdas; this is
<a name="line-638"></a>because it's relevant how many parameters the join point takes *as a join
<a name="line-639"></a>point.* This number is called the *join arity,* distinct from arity because it
<a name="line-640"></a>counts types as well as values. Note that a join point may return a lambda! So
<a name="line-641"></a>  join j x = x + 1
<a name="line-642"></a>is different from
<a name="line-643"></a>  join j = \x -&gt; x + 1
<a name="line-644"></a>The former has join arity 1, while the latter has join arity 0.
<a name="line-645"></a>
<a name="line-646"></a>The identifier for a join point is called a join id or a *label.* An invocation
<a name="line-647"></a>is called a *jump.* We write a jump using the jump keyword:
<a name="line-648"></a>
<a name="line-649"></a>  jump j 3
<a name="line-650"></a>
<a name="line-651"></a>The words *label* and *jump* are evocative of assembly code (or Cmm) for a
<a name="line-652"></a>reason: join points are indeed compiled as labeled blocks, and jumps become
<a name="line-653"></a>actual jumps (plus argument passing and stack adjustment). There is no closure
<a name="line-654"></a>allocated and only a fraction of the function-call overhead. Hence we would
<a name="line-655"></a>like as many functions as possible to become join points (see OccurAnal) and
<a name="line-656"></a>the type rules for join points ensure we preserve the properties that make them
<a name="line-657"></a>efficient.
<a name="line-658"></a>
<a name="line-659"></a>In the actual AST, a join point is indicated by the IdDetails of the binder: a
<a name="line-660"></a>local value binding gets 'VanillaId' but a join point gets a 'JoinId' with its
<a name="line-661"></a>join arity.
<a name="line-662"></a>
<a name="line-663"></a>For more details, see the paper:
<a name="line-664"></a>
<a name="line-665"></a>  Luke Maurer, Paul Downen, Zena Ariola, and Simon Peyton Jones. "Compiling
<a name="line-666"></a>  without continuations." Submitted to PLDI'17.
<a name="line-667"></a>
<a name="line-668"></a>  https://www.microsoft.com/en-us/research/publication/compiling-without-continuations/
<a name="line-669"></a>
<a name="line-670"></a>Note [Invariants on join points]
<a name="line-671"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-672"></a>Join points must follow these invariants:
<a name="line-673"></a>
<a name="line-674"></a>  1. All occurrences must be tail calls. Each of these tail calls must pass the
<a name="line-675"></a>     same number of arguments, counting both types and values; we call this the
<a name="line-676"></a>     "join arity" (to distinguish from regular arity, which only counts values).
<a name="line-677"></a>
<a name="line-678"></a>     See Note [Join points are less general than the paper]
<a name="line-679"></a>
<a name="line-680"></a>  2. For join arity n, the right-hand side must begin with at least n lambdas.
<a name="line-681"></a>     No ticks, no casts, just lambdas!  C.f. GHC.Core.Utils.joinRhsArity.
<a name="line-682"></a>
<a name="line-683"></a>     2a. Moreover, this same constraint applies to any unfolding of
<a name="line-684"></a>         the binder.  Reason: if we want to push a continuation into
<a name="line-685"></a>         the RHS we must push it into the unfolding as well.
<a name="line-686"></a>
<a name="line-687"></a>     2b. The Arity (in the IdInfo) of a join point is the number of value
<a name="line-688"></a>         binders in the top n lambdas, where n is the join arity.
<a name="line-689"></a>
<a name="line-690"></a>         So arity &lt;= join arity; the former counts only value binders
<a name="line-691"></a>         while the latter counts all binders.
<a name="line-692"></a>         e.g. Suppose $j has join arity 1
<a name="line-693"></a>               let j = \x y. e in case x of { A -&gt; j 1; B -&gt; j 2 }
<a name="line-694"></a>         Then its ordinary arity is also 1, not 2.
<a name="line-695"></a>
<a name="line-696"></a>         The arity of a join point isn't very important; but short of setting
<a name="line-697"></a>         it to zero, it is helpful to have an invariant.  E.g. #17294.
<a name="line-698"></a>         See also Note [Do not eta-expand join points] in GHC.Core.Opt.Simplify.Utils.
<a name="line-699"></a>
<a name="line-700"></a>  3. If the binding is recursive, then all other bindings in the recursive group
<a name="line-701"></a>     must also be join points.
<a name="line-702"></a>
<a name="line-703"></a>  4. The binding's type must not be polymorphic in its return type (as defined
<a name="line-704"></a>     in Note [The polymorphism rule of join points]).
<a name="line-705"></a>
<a name="line-706"></a>However, join points have simpler invariants in other ways
<a name="line-707"></a>
<a name="line-708"></a>  5. A join point can have an unboxed type without the RHS being
<a name="line-709"></a>     ok-for-speculation (i.e. drop the let/app invariant)
<a name="line-710"></a>     e.g.  let j :: Int# = factorial x in ...
<a name="line-711"></a>
<a name="line-712"></a>  6. A join point can have a levity-polymorphic RHS
<a name="line-713"></a>     e.g.  let j :: r :: TYPE l = fail void# in ...
<a name="line-714"></a>     This happened in an intermediate program #13394
<a name="line-715"></a>
<a name="line-716"></a>Examples:
<a name="line-717"></a>
<a name="line-718"></a>  join j1  x = 1 + x in jump j (jump j x)  -- Fails 1: non-tail call
<a name="line-719"></a>  join j1' x = 1 + x in if even a
<a name="line-720"></a>                          then jump j1 a
<a name="line-721"></a>                          else jump j1 a b -- Fails 1: inconsistent calls
<a name="line-722"></a>  join j2  x = flip (+) x in j2 1 2        -- Fails 2: not enough lambdas
<a name="line-723"></a>  join j2' x = \y -&gt; x + y in j3 1         -- Passes: extra lams ok
<a name="line-724"></a>  join j @a (x :: a) = x                   -- Fails 4: polymorphic in ret type
<a name="line-725"></a>
<a name="line-726"></a>Invariant 1 applies to left-hand sides of rewrite rules, so a rule for a join
<a name="line-727"></a>point must have an exact call as its LHS.
<a name="line-728"></a>
<a name="line-729"></a>Strictly speaking, invariant 3 is redundant, since a call from inside a lazy
<a name="line-730"></a>binding isn't a tail call. Since a let-bound value can't invoke a free join
<a name="line-731"></a>point, then, they can't be mutually recursive. (A Core binding group *can*
<a name="line-732"></a>include spurious extra bindings if the occurrence analyser hasn't run, so
<a name="line-733"></a>invariant 3 does still need to be checked.) For the rigorous definition of
<a name="line-734"></a>"tail call", see Section 3 of the paper (Note [Join points]).
<a name="line-735"></a>
<a name="line-736"></a>Invariant 4 is subtle; see Note [The polymorphism rule of join points].
<a name="line-737"></a>
<a name="line-738"></a>Invariant 6 is to enable code like this:
<a name="line-739"></a>
<a name="line-740"></a>  f = \(r :: RuntimeRep) (a :: TYPE r) (x :: T).
<a name="line-741"></a>      join j :: a
<a name="line-742"></a>           j = error @r @a "bloop"
<a name="line-743"></a>      in case x of
<a name="line-744"></a>           A -&gt; j
<a name="line-745"></a>           B -&gt; j
<a name="line-746"></a>           C -&gt; error @r @a "blurp"
<a name="line-747"></a>
<a name="line-748"></a>Core Lint will check these invariants, anticipating that any binder whose
<a name="line-749"></a>OccInfo is marked AlwaysTailCalled will become a join point as soon as the
<a name="line-750"></a>simplifier (or simpleOptPgm) runs.
<a name="line-751"></a>
<a name="line-752"></a>Note [Join points are less general than the paper]
<a name="line-753"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-754"></a>In the paper "Compiling without continuations", this expression is
<a name="line-755"></a>perfectly valid:
<a name="line-756"></a>
<a name="line-757"></a>    join { j = \_ -&gt; e }
<a name="line-758"></a>    in (case blah of       )
<a name="line-759"></a>       (  True  -&gt; j void# ) arg
<a name="line-760"></a>       (  False -&gt; blah    )
<a name="line-761"></a>
<a name="line-762"></a>assuming 'j' has arity 1.   Here the call to 'j' does not look like a
<a name="line-763"></a>tail call, but actually everything is fine. See Section 3, "Managing \Delta"
<a name="line-764"></a>in the paper.
<a name="line-765"></a>
<a name="line-766"></a>In GHC, however, we adopt a slightly more restrictive subset, in which
<a name="line-767"></a>join point calls must be tail calls.  I think we /could/ loosen it up, but
<a name="line-768"></a>in fact the simplifier ensures that we always get tail calls, and it makes
<a name="line-769"></a>the back end a bit easier I think.  Generally, just less to think about;
<a name="line-770"></a>nothing deeper than that.
<a name="line-771"></a>
<a name="line-772"></a>Note [The type of a join point]
<a name="line-773"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-774"></a>A join point has the same type it would have as a function. That is, if it takes
<a name="line-775"></a>an Int and a Bool and its body produces a String, its type is `Int -&gt; Bool -&gt;
<a name="line-776"></a>String`. Natural as this may seem, it can be awkward. A join point shouldn't be
<a name="line-777"></a>thought to "return" in the same sense a function does---a jump is one-way. This
<a name="line-778"></a>is crucial for understanding how case-of-case interacts with join points:
<a name="line-779"></a>
<a name="line-780"></a>  case (join
<a name="line-781"></a>          j :: Int -&gt; Bool -&gt; String
<a name="line-782"></a>          j x y = ...
<a name="line-783"></a>        in
<a name="line-784"></a>          jump j z w) of
<a name="line-785"></a>    "" -&gt; True
<a name="line-786"></a>    _  -&gt; False
<a name="line-787"></a>
<a name="line-788"></a>The simplifier will pull the case into the join point (see Note [Join points
<a name="line-789"></a>and case-of-case] in GHC.Core.Opt.Simplify):
<a name="line-790"></a>
<a name="line-791"></a>  join
<a name="line-792"></a>    j :: Int -&gt; Bool -&gt; Bool -- changed!
<a name="line-793"></a>    j x y = case ... of "" -&gt; True
<a name="line-794"></a>                        _  -&gt; False
<a name="line-795"></a>  in
<a name="line-796"></a>    jump j z w
<a name="line-797"></a>
<a name="line-798"></a>The body of the join point now returns a Bool, so the label `j` has to
<a name="line-799"></a>have its type updated accordingly, which is done by
<a name="line-800"></a>GHC.Core.Opt.Simplify.Env.adjustJoinPointType. Inconvenient though
<a name="line-801"></a>this may be, it has the advantage that 'GHC.Core.Utils.exprType' can
<a name="line-802"></a>still return a type for any expression, including a jump.
<a name="line-803"></a>
<a name="line-804"></a>Relationship to the paper
<a name="line-805"></a>
<a name="line-806"></a>This plan differs from the paper (see Note [Invariants on join
<a name="line-807"></a>points]). In the paper, we instead give j the type `Int -&gt; Bool -&gt;
<a name="line-808"></a>forall a. a`. Then each jump carries the "return type" as a parameter,
<a name="line-809"></a>exactly the way other non-returning functions like `error` work:
<a name="line-810"></a>
<a name="line-811"></a>  case (join
<a name="line-812"></a>          j :: Int -&gt; Bool -&gt; forall a. a
<a name="line-813"></a>          j x y = ...
<a name="line-814"></a>        in
<a name="line-815"></a>          jump j z w @String) of
<a name="line-816"></a>    "" -&gt; True
<a name="line-817"></a>    _  -&gt; False
<a name="line-818"></a>
<a name="line-819"></a>Now we can move the case inward and we only have to change the jump:
<a name="line-820"></a>
<a name="line-821"></a>  join
<a name="line-822"></a>    j :: Int -&gt; Bool -&gt; forall a. a
<a name="line-823"></a>    j x y = case ... of "" -&gt; True
<a name="line-824"></a>                        _  -&gt; False
<a name="line-825"></a>  in
<a name="line-826"></a>    jump j z w @Bool
<a name="line-827"></a>
<a name="line-828"></a>(Core Lint would still check that the body of the join point has the right type;
<a name="line-829"></a>that type would simply not be reflected in the join id.)
<a name="line-830"></a>
<a name="line-831"></a>Note [The polymorphism rule of join points]
<a name="line-832"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-833"></a>Invariant 4 of Note [Invariants on join points] forbids a join point to be
<a name="line-834"></a>polymorphic in its return type. That is, if its type is
<a name="line-835"></a>
<a name="line-836"></a>  forall a1 ... ak. t1 -&gt; ... -&gt; tn -&gt; r
<a name="line-837"></a>
<a name="line-838"></a>where its join arity is k+n, none of the type parameters ai may occur free in r.
<a name="line-839"></a>
<a name="line-840"></a>In some way, this falls out of the fact that given
<a name="line-841"></a>
<a name="line-842"></a>  join
<a name="line-843"></a>     j @a1 ... @ak x1 ... xn = e1
<a name="line-844"></a>  in e2
<a name="line-845"></a>
<a name="line-846"></a>then all calls to `j` are in tail-call positions of `e`, and expressions in
<a name="line-847"></a>tail-call positions in `e` have the same type as `e`.
<a name="line-848"></a>Therefore the type of `e1` -- the return type of the join point -- must be the
<a name="line-849"></a>same as the type of e2.
<a name="line-850"></a>Since the type variables aren't bound in `e2`, its type can't include them, and
<a name="line-851"></a>thus neither can the type of `e1`.
<a name="line-852"></a>
<a name="line-853"></a>This unfortunately prevents the `go` in the following code from being a
<a name="line-854"></a>join-point:
<a name="line-855"></a>
<a name="line-856"></a>  iter :: forall a. Int -&gt; (a -&gt; a) -&gt; a -&gt; a
<a name="line-857"></a>  iter @a n f x = go @a n f x
<a name="line-858"></a>    where
<a name="line-859"></a>      go :: forall a. Int -&gt; (a -&gt; a) -&gt; a -&gt; a
<a name="line-860"></a>      go @a 0 _ x = x
<a name="line-861"></a>      go @a n f x = go @a (n-1) f (f x)
<a name="line-862"></a>
<a name="line-863"></a>In this case, a static argument transformation would fix that (see
<a name="line-864"></a>ticket #14620):
<a name="line-865"></a>
<a name="line-866"></a>  iter :: forall a. Int -&gt; (a -&gt; a) -&gt; a -&gt; a
<a name="line-867"></a>  iter @a n f x = go' @a n f x
<a name="line-868"></a>    where
<a name="line-869"></a>      go' :: Int -&gt; (a -&gt; a) -&gt; a -&gt; a
<a name="line-870"></a>      go' 0 _ x = x
<a name="line-871"></a>      go' n f x = go' (n-1) f (f x)
<a name="line-872"></a>
<a name="line-873"></a>In general, loopification could be employed to do that (see #14068.)
<a name="line-874"></a>
<a name="line-875"></a>Can we simply drop the requirement, and allow `go` to be a join-point? We
<a name="line-876"></a>could, and it would work. But we could not longer apply the case-of-join-point
<a name="line-877"></a>transformation universally. This transformation would do:
<a name="line-878"></a>
<a name="line-879"></a>  case (join go @a n f x = case n of 0 -&gt; x
<a name="line-880"></a>                                     n -&gt; go @a (n-1) f (f x)
<a name="line-881"></a>        in go @Bool n neg True) of
<a name="line-882"></a>    True -&gt; e1; False -&gt; e2
<a name="line-883"></a>
<a name="line-884"></a> ===&gt;
<a name="line-885"></a>
<a name="line-886"></a>  join go @a n f x = case n of 0 -&gt; case x of True -&gt; e1; False -&gt; e2
<a name="line-887"></a>                               n -&gt; go @a (n-1) f (f x)
<a name="line-888"></a>  in go @Bool n neg True
<a name="line-889"></a>
<a name="line-890"></a>but that is ill-typed, as `x` is type `a`, not `Bool`.
<a name="line-891"></a>
<a name="line-892"></a>
<a name="line-893"></a>This also justifies why we do not consider the `e` in `e |&gt; co` to be in
<a name="line-894"></a>tail position: A cast changes the type, but the type must be the same. But
<a name="line-895"></a>operationally, casts are vacuous, so this is a bit unfortunate! See #14610 for
<a name="line-896"></a>ideas how to fix this.
<a name="line-897"></a>
<a name="line-898"></a>************************************************************************
<a name="line-899"></a>*                                                                      *
<a name="line-900"></a>            In/Out type synonyms
<a name="line-901"></a>*                                                                      *
<a name="line-902"></a>********************************************************************* -}</span>
<a name="line-903"></a>
<a name="line-904"></a><span class='hs-comment'>{- Many passes apply a substitution, and it's very handy to have type
<a name="line-905"></a>   synonyms to remind us whether or not the substitution has been applied -}</span>
<a name="line-906"></a>
<a name="line-907"></a><a name="InBndr"></a><span class='hs-comment'>-- Pre-cloning or substitution</span>
<a name="line-908"></a><a name="InBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InBndr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-909"></a><a name="InType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InType</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-910"></a><a name="InKind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InKind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Kind</span>
<a name="line-911"></a><a name="InBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InBind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBind</span>
<a name="line-912"></a><a name="InExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InExpr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-913"></a><a name="InAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InAlt</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreAlt</span>
<a name="line-914"></a><a name="InArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InArg</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreArg</span>
<a name="line-915"></a><a name="InCoercion"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InCoercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>
<a name="line-916"></a>
<a name="line-917"></a><a name="OutBndr"></a><span class='hs-comment'>-- Post-cloning or substitution</span>
<a name="line-918"></a><a name="OutBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutBndr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-919"></a><a name="OutType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutType</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-920"></a><a name="OutKind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutKind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Kind</span>
<a name="line-921"></a><a name="OutCoercion"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutCoercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>
<a name="line-922"></a><a name="OutBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutBind</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreBind</span>
<a name="line-923"></a><a name="OutExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutExpr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-924"></a><a name="OutAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutAlt</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreAlt</span>
<a name="line-925"></a><a name="OutArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>OutArg</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoreArg</span>
<a name="line-926"></a><a name="MOutCoercion"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>MOutCoercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MCoercion</span>
<a name="line-927"></a>
<a name="line-928"></a>
<a name="line-929"></a><span class='hs-comment'>{-
<a name="line-930"></a>************************************************************************
<a name="line-931"></a>*                                                                      *
<a name="line-932"></a>                Orphans
<a name="line-933"></a>*                                                                      *
<a name="line-934"></a>************************************************************************
<a name="line-935"></a>-}</span>
<a name="line-936"></a>
<a name="line-937"></a><a name="IsOrphan"></a><span class='hs-comment'>-- | Is this instance an orphan?  If it is not an orphan, contains an 'OccName'</span>
<a name="line-938"></a><a name="IsOrphan"></a><span class='hs-comment'>-- witnessing the instance's non-orphanhood.</span>
<a name="line-939"></a><a name="IsOrphan"></a><span class='hs-comment'>-- See Note [Orphans]</span>
<a name="line-940"></a><a name="IsOrphan"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-941"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-942"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-conid'>OccName</span> <span class='hs-comment'>-- The OccName 'n' witnesses the instance's non-orphanhood</span>
<a name="line-943"></a>                      <span class='hs-comment'>-- In that case, the instance is fingerprinted as part</span>
<a name="line-944"></a>                      <span class='hs-comment'>-- of the definition of 'n's definition</span>
<a name="line-945"></a>    <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-946"></a>
<a name="line-947"></a><a name="isOrphan"></a><span class='hs-comment'>-- | Returns true if 'IsOrphan' is orphan.</span>
<a name="line-948"></a><span class='hs-definition'>isOrphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-949"></a><span class='hs-definition'>isOrphan</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-950"></a><span class='hs-definition'>isOrphan</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-951"></a>
<a name="line-952"></a><a name="notOrphan"></a><span class='hs-comment'>-- | Returns true if 'IsOrphan' is not an orphan.</span>
<a name="line-953"></a><span class='hs-definition'>notOrphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-954"></a><span class='hs-definition'>notOrphan</span> <span class='hs-conid'>NotOrphan</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-955"></a><span class='hs-definition'>notOrphan</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-956"></a>
<a name="line-957"></a><a name="chooseOrphanAnchor"></a><span class='hs-definition'>chooseOrphanAnchor</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-958"></a><span class='hs-comment'>-- Something (rule, instance) is relate to all the Names in this</span>
<a name="line-959"></a><span class='hs-comment'>-- list. Choose one of them to be an "anchor" for the orphan.  We make</span>
<a name="line-960"></a><span class='hs-comment'>-- the choice deterministic to avoid gratuitous changes in the ABI</span>
<a name="line-961"></a><span class='hs-comment'>-- hash (#4012).  Specifically, use lexicographic comparison of</span>
<a name="line-962"></a><span class='hs-comment'>-- OccName rather than comparing Uniques</span>
<a name="line-963"></a><span class='hs-comment'>--</span>
<a name="line-964"></a><span class='hs-comment'>-- NB: 'minimum' use Ord, and (Ord OccName) works lexicographically</span>
<a name="line-965"></a><span class='hs-comment'>--</span>
<a name="line-966"></a><span class='hs-definition'>chooseOrphanAnchor</span> <span class='hs-varid'>local_names</span>
<a name="line-967"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyNameSet</span> <span class='hs-varid'>local_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-968"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-layout'>(</span><span class='hs-varid'>minimum</span> <span class='hs-varid'>occs</span><span class='hs-layout'>)</span>
<a name="line-969"></a>  <span class='hs-keyword'>where</span>
<a name="line-970"></a>    <span class='hs-varid'>occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>nameOccName</span> <span class='hs-varop'>$</span> <span class='hs-varid'>nonDetEltsUniqSet</span> <span class='hs-varid'>local_names</span>
<a name="line-971"></a>    <span class='hs-comment'>-- It's OK to use nonDetEltsUFM here, see comments above</span>
<a name="line-972"></a>
<a name="line-973"></a><a name="instance%20Binary%20IsOrphan"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Binary</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyword'>where</span>
<a name="line-974"></a>    <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>0</span>
<a name="line-975"></a>    <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-layout'>(</span><span class='hs-conid'>NotOrphan</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-976"></a>        <span class='hs-varid'>putByte</span> <span class='hs-varid'>bh</span> <span class='hs-num'>1</span>
<a name="line-977"></a>        <span class='hs-varid'>put_</span> <span class='hs-varid'>bh</span> <span class='hs-varid'>n</span>
<a name="line-978"></a>    <span class='hs-varid'>get</span> <span class='hs-varid'>bh</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-979"></a>        <span class='hs-varid'>h</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getByte</span> <span class='hs-varid'>bh</span>
<a name="line-980"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>h</span> <span class='hs-keyword'>of</span>
<a name="line-981"></a>            <span class='hs-num'>0</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-982"></a>            <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span>
<a name="line-983"></a>                <span class='hs-varid'>n</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>get</span> <span class='hs-varid'>bh</span>
<a name="line-984"></a>                <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-varid'>n</span>
<a name="line-985"></a>
<a name="line-986"></a><span class='hs-comment'>{-
<a name="line-987"></a>Note [Orphans]
<a name="line-988"></a>~~~~~~~~~~~~~~
<a name="line-989"></a>Class instances, rules, and family instances are divided into orphans
<a name="line-990"></a>and non-orphans.  Roughly speaking, an instance/rule is an orphan if
<a name="line-991"></a>its left hand side mentions nothing defined in this module.  Orphan-hood
<a name="line-992"></a>has two major consequences
<a name="line-993"></a>
<a name="line-994"></a> * A module that contains orphans is called an "orphan module".  If
<a name="line-995"></a>   the module being compiled depends (transitively) on an orphan
<a name="line-996"></a>   module M, then M.hi is read in regardless of whether M is otherwise
<a name="line-997"></a>   needed. This is to ensure that we don't miss any instance decls in
<a name="line-998"></a>   M.  But it's painful, because it means we need to keep track of all
<a name="line-999"></a>   the orphan modules below us.
<a name="line-1000"></a>
<a name="line-1001"></a> * A non-orphan is not finger-printed separately.  Instead, for
<a name="line-1002"></a>   fingerprinting purposes it is treated as part of the entity it
<a name="line-1003"></a>   mentions on the LHS.  For example
<a name="line-1004"></a>      data T = T1 | T2
<a name="line-1005"></a>      instance Eq T where ....
<a name="line-1006"></a>   The instance (Eq T) is incorporated as part of T's fingerprint.
<a name="line-1007"></a>
<a name="line-1008"></a>   In contrast, orphans are all fingerprinted together in the
<a name="line-1009"></a>   mi_orph_hash field of the ModIface.
<a name="line-1010"></a>
<a name="line-1011"></a>   See GHC.Iface.Recomp.addFingerprints.
<a name="line-1012"></a>
<a name="line-1013"></a>Orphan-hood is computed
<a name="line-1014"></a>  * For class instances:
<a name="line-1015"></a>      when we make a ClsInst
<a name="line-1016"></a>    (because it is needed during instance lookup)
<a name="line-1017"></a>
<a name="line-1018"></a>  * For rules and family instances:
<a name="line-1019"></a>       when we generate an IfaceRule (GHC.Iface.Make.coreRuleToIfaceRule)
<a name="line-1020"></a>                     or IfaceFamInst (GHC.Iface.Make.instanceToIfaceInst)
<a name="line-1021"></a>-}</span>
<a name="line-1022"></a>
<a name="line-1023"></a><span class='hs-comment'>{-
<a name="line-1024"></a>************************************************************************
<a name="line-1025"></a>*                                                                      *
<a name="line-1026"></a>\subsection{Rewrite rules}
<a name="line-1027"></a>*                                                                      *
<a name="line-1028"></a>************************************************************************
<a name="line-1029"></a>
<a name="line-1030"></a>The CoreRule type and its friends are dealt with mainly in GHC.Core.Rules, but
<a name="line-1031"></a>GHC.Core.FVs, GHC.Core.Subst, GHC.Core.Ppr, GHC.Core.Tidy also inspect the
<a name="line-1032"></a>representation.
<a name="line-1033"></a>-}</span>
<a name="line-1034"></a>
<a name="line-1035"></a><a name="RuleBase"></a><span class='hs-comment'>-- | Gathers a collection of 'CoreRule's. Maps (the name of) an 'Id' to its rules</span>
<a name="line-1036"></a><a name="RuleBase"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RuleBase</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NameEnv</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreRule</span><span class='hs-keyglyph'>]</span>
<a name="line-1037"></a>        <span class='hs-comment'>-- The rules are unordered;</span>
<a name="line-1038"></a>        <span class='hs-comment'>-- we sort out any overlaps on lookup</span>
<a name="line-1039"></a>
<a name="line-1040"></a><a name="RuleEnv"></a><span class='hs-comment'>-- | A full rule environment which we can apply rules from.  Like a 'RuleBase',</span>
<a name="line-1041"></a><a name="RuleEnv"></a><span class='hs-comment'>-- but it also includes the set of visible orphans we use to filter out orphan</span>
<a name="line-1042"></a><a name="RuleEnv"></a><span class='hs-comment'>-- rules which are not visible (even though we can see them...)</span>
<a name="line-1043"></a><a name="RuleEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RuleEnv</span>
<a name="line-1044"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleEnv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>re_base</span>          <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleBase</span>
<a name="line-1045"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>re_visible_orphs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ModuleSet</span>
<a name="line-1046"></a>              <span class='hs-layout'>}</span>
<a name="line-1047"></a>
<a name="line-1048"></a><a name="mkRuleEnv"></a><span class='hs-definition'>mkRuleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleBase</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Module</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RuleEnv</span>
<a name="line-1049"></a><span class='hs-definition'>mkRuleEnv</span> <span class='hs-varid'>rules</span> <span class='hs-varid'>vis_orphs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleEnv</span> <span class='hs-varid'>rules</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkModuleSet</span> <span class='hs-varid'>vis_orphs</span><span class='hs-layout'>)</span>
<a name="line-1050"></a>
<a name="line-1051"></a><a name="emptyRuleEnv"></a><span class='hs-definition'>emptyRuleEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleEnv</span>
<a name="line-1052"></a><span class='hs-definition'>emptyRuleEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleEnv</span> <span class='hs-varid'>emptyNameEnv</span> <span class='hs-varid'>emptyModuleSet</span>
<a name="line-1053"></a>
<a name="line-1054"></a><a name="CoreRule"></a><span class='hs-comment'>-- | A 'CoreRule' is:</span>
<a name="line-1055"></a><a name="CoreRule"></a><span class='hs-comment'>--</span>
<a name="line-1056"></a><a name="CoreRule"></a><span class='hs-comment'>-- * \"Local\" if the function it is a rule for is defined in the</span>
<a name="line-1057"></a><a name="CoreRule"></a><span class='hs-comment'>--   same module as the rule itself.</span>
<a name="line-1058"></a><a name="CoreRule"></a><span class='hs-comment'>--</span>
<a name="line-1059"></a><a name="CoreRule"></a><span class='hs-comment'>-- * \"Orphan\" if nothing on the LHS is defined in the same module</span>
<a name="line-1060"></a><a name="CoreRule"></a><span class='hs-comment'>--   as the rule itself</span>
<a name="line-1061"></a><a name="CoreRule"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoreRule</span>
<a name="line-1062"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span>
<a name="line-1063"></a>        <span class='hs-varid'>ru_name</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span><span class='hs-layout'>,</span>            <span class='hs-comment'>-- ^ Name of the rule, for communication with the user</span>
<a name="line-1064"></a>        <span class='hs-varid'>ru_act</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Activation</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- ^ When the rule is active</span>
<a name="line-1065"></a>
<a name="line-1066"></a>        <span class='hs-comment'>-- Rough-matching stuff</span>
<a name="line-1067"></a>        <span class='hs-comment'>-- see comments with InstEnv.ClsInst( is_cls, is_rough )</span>
<a name="line-1068"></a>        <span class='hs-varid'>ru_fn</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span><span class='hs-layout'>,</span>               <span class='hs-comment'>-- ^ Name of the 'GHC.Types.Id.Id' at the head of this rule</span>
<a name="line-1069"></a>        <span class='hs-varid'>ru_rough</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Name</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- ^ Name at the head of each argument to the left hand side</span>
<a name="line-1070"></a>
<a name="line-1071"></a>        <span class='hs-comment'>-- Proper-matching stuff</span>
<a name="line-1072"></a>        <span class='hs-comment'>-- see comments with InstEnv.ClsInst( is_tvs, is_tys )</span>
<a name="line-1073"></a>        <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- ^ Variables quantified over</span>
<a name="line-1074"></a>        <span class='hs-varid'>ru_args</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- ^ Left hand side arguments</span>
<a name="line-1075"></a>
<a name="line-1076"></a>        <span class='hs-comment'>-- And the right-hand side</span>
<a name="line-1077"></a>        <span class='hs-varid'>ru_rhs</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>           <span class='hs-comment'>-- ^ Right hand side of the rule</span>
<a name="line-1078"></a>                                        <span class='hs-comment'>-- Occurrence info is guaranteed correct</span>
<a name="line-1079"></a>                                        <span class='hs-comment'>-- See Note [OccInfo in unfoldings and rules]</span>
<a name="line-1080"></a>
<a name="line-1081"></a>        <span class='hs-comment'>-- Locality</span>
<a name="line-1082"></a>        <span class='hs-varid'>ru_auto</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- ^ @True@  &lt;=&gt; this rule is auto-generated</span>
<a name="line-1083"></a>                           <span class='hs-comment'>--               (notably by Specialise or SpecConstr)</span>
<a name="line-1084"></a>                           <span class='hs-comment'>--   @False@ &lt;=&gt; generated at the user's behest</span>
<a name="line-1085"></a>                           <span class='hs-comment'>-- See Note [Trimming auto-rules] in "GHC.Iface.Tidy"</span>
<a name="line-1086"></a>                           <span class='hs-comment'>-- for the sole purpose of this field.</span>
<a name="line-1087"></a>
<a name="line-1088"></a>        <span class='hs-varid'>ru_origin</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Module</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- ^ 'Module' the rule was defined in, used</span>
<a name="line-1089"></a>                                <span class='hs-comment'>-- to test if we should see an orphan rule.</span>
<a name="line-1090"></a>
<a name="line-1091"></a>        <span class='hs-varid'>ru_orphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>IsOrphan</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- ^ Whether or not the rule is an orphan.</span>
<a name="line-1092"></a>
<a name="line-1093"></a>        <span class='hs-varid'>ru_local</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>        <span class='hs-comment'>-- ^ @True@ iff the fn at the head of the rule is</span>
<a name="line-1094"></a>                                <span class='hs-comment'>-- defined in the same module as the rule</span>
<a name="line-1095"></a>                                <span class='hs-comment'>-- and is not an implicit 'Id' (like a record selector,</span>
<a name="line-1096"></a>                                <span class='hs-comment'>-- class operation, or data constructor).  This</span>
<a name="line-1097"></a>                                <span class='hs-comment'>-- is different from 'ru_orphan', where a rule</span>
<a name="line-1098"></a>                                <span class='hs-comment'>-- can avoid being an orphan if *any* Name in</span>
<a name="line-1099"></a>                                <span class='hs-comment'>-- LHS of the rule was defined in the same</span>
<a name="line-1100"></a>                                <span class='hs-comment'>-- module as the rule.</span>
<a name="line-1101"></a>    <span class='hs-layout'>}</span>
<a name="line-1102"></a>
<a name="line-1103"></a>  <span class='hs-comment'>-- | Built-in rules are used for constant folding</span>
<a name="line-1104"></a>  <span class='hs-comment'>-- and suchlike.  They have no free variables.</span>
<a name="line-1105"></a>  <span class='hs-comment'>-- A built-in rule is always visible (there is no such thing as</span>
<a name="line-1106"></a>  <span class='hs-comment'>-- an orphan built-in rule.)</span>
<a name="line-1107"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span>
<a name="line-1108"></a>        <span class='hs-varid'>ru_name</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- ^ As above</span>
<a name="line-1109"></a>        <span class='hs-varid'>ru_fn</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- ^ As above</span>
<a name="line-1110"></a>        <span class='hs-varid'>ru_nargs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- ^ Number of arguments that 'ru_try' consumes,</span>
<a name="line-1111"></a>                                <span class='hs-comment'>-- if it fires, including type arguments</span>
<a name="line-1112"></a>        <span class='hs-varid'>ru_try</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleFun</span>
<a name="line-1113"></a>                <span class='hs-comment'>-- ^ This function does the rewrite.  It given too many</span>
<a name="line-1114"></a>                <span class='hs-comment'>-- arguments, it simply discards them; the returned 'CoreExpr'</span>
<a name="line-1115"></a>                <span class='hs-comment'>-- is just the rewrite of 'ru_fn' applied to the first 'ru_nargs' args</span>
<a name="line-1116"></a>    <span class='hs-layout'>}</span>
<a name="line-1117"></a>                <span class='hs-comment'>-- See Note [Extra args in rule matching] in GHC.Core.Rules</span>
<a name="line-1118"></a>
<a name="line-1119"></a><a name="RuleOpts"></a><span class='hs-comment'>-- | Rule options</span>
<a name="line-1120"></a><a name="RuleOpts"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RuleOpts</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleOpts</span>
<a name="line-1121"></a>   <span class='hs-layout'>{</span> <span class='hs-varid'>roPlatform</span>                <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Platform</span> <span class='hs-comment'>-- ^ Target platform</span>
<a name="line-1122"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>roNumConstantFolding</span>      <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>     <span class='hs-comment'>-- ^ Enable more advanced numeric constant folding</span>
<a name="line-1123"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>roExcessRationalPrecision</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>     <span class='hs-comment'>-- ^ Cut down precision of Rational values to that of Float/Double if disabled</span>
<a name="line-1124"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>roBignumRules</span>             <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>     <span class='hs-comment'>-- ^ Enable rules for bignums</span>
<a name="line-1125"></a>   <span class='hs-layout'>}</span>
<a name="line-1126"></a>
<a name="line-1127"></a><a name="RuleFun"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RuleFun</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RuleOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1128"></a><a name="InScopeEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InScopeEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>InScopeSet</span><span class='hs-layout'>,</span> <span class='hs-conid'>IdUnfoldingFun</span><span class='hs-layout'>)</span>
<a name="line-1129"></a>
<a name="line-1130"></a><a name="IdUnfoldingFun"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>IdUnfoldingFun</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1131"></a><span class='hs-comment'>-- A function that embodies how to unfold an Id if you need</span>
<a name="line-1132"></a><span class='hs-comment'>-- to do that in the Rule.  The reason we need to pass this info in</span>
<a name="line-1133"></a><span class='hs-comment'>-- is that whether an Id is unfoldable depends on the simplifier phase</span>
<a name="line-1134"></a>
<a name="line-1135"></a><a name="isBuiltinRule"></a><span class='hs-definition'>isBuiltinRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1136"></a><span class='hs-definition'>isBuiltinRule</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1137"></a><span class='hs-definition'>isBuiltinRule</span> <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1138"></a>
<a name="line-1139"></a><a name="isAutoRule"></a><span class='hs-definition'>isAutoRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1140"></a><span class='hs-definition'>isAutoRule</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1141"></a><span class='hs-definition'>isAutoRule</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_auto</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_auto</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_auto</span>
<a name="line-1142"></a>
<a name="line-1143"></a><a name="ruleArity"></a><span class='hs-comment'>-- | The number of arguments the 'ru_fn' must be applied</span>
<a name="line-1144"></a><span class='hs-comment'>-- to before the rule can match on it</span>
<a name="line-1145"></a><span class='hs-definition'>ruleArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1146"></a><span class='hs-definition'>ruleArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-varid'>ru_nargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-1147"></a><span class='hs-definition'>ruleArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span><span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span>
<a name="line-1148"></a>
<a name="line-1149"></a><a name="ruleName"></a><span class='hs-definition'>ruleName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RuleName</span>
<a name="line-1150"></a><span class='hs-definition'>ruleName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru_name</span>
<a name="line-1151"></a>
<a name="line-1152"></a><a name="ruleModule"></a><span class='hs-definition'>ruleModule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Module</span>
<a name="line-1153"></a><span class='hs-definition'>ruleModule</span> <span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_origin</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ru_origin</span>
<a name="line-1154"></a><span class='hs-definition'>ruleModule</span> <span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1155"></a>
<a name="line-1156"></a><a name="ruleActivation"></a><span class='hs-definition'>ruleActivation</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Activation</span>
<a name="line-1157"></a><span class='hs-definition'>ruleActivation</span> <span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AlwaysActive</span>
<a name="line-1158"></a><span class='hs-definition'>ruleActivation</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>act</span>
<a name="line-1159"></a>
<a name="line-1160"></a><a name="ruleIdName"></a><span class='hs-comment'>-- | The 'Name' of the 'GHC.Types.Id.Id' at the head of the rule left hand side</span>
<a name="line-1161"></a><span class='hs-definition'>ruleIdName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span>
<a name="line-1162"></a><span class='hs-definition'>ruleIdName</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru_fn</span>
<a name="line-1163"></a>
<a name="line-1164"></a><a name="isLocalRule"></a><span class='hs-definition'>isLocalRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1165"></a><span class='hs-definition'>isLocalRule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru_local</span>
<a name="line-1166"></a>
<a name="line-1167"></a><a name="setRuleIdName"></a><span class='hs-comment'>-- | Set the 'Name' of the 'GHC.Types.Id.Id' at the head of the rule left hand side</span>
<a name="line-1168"></a><span class='hs-definition'>setRuleIdName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreRule</span>
<a name="line-1169"></a><span class='hs-definition'>setRuleIdName</span> <span class='hs-varid'>nm</span> <span class='hs-varid'>ru</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ru</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nm</span> <span class='hs-layout'>}</span>
<a name="line-1170"></a>
<a name="line-1171"></a><span class='hs-comment'>{-
<a name="line-1172"></a>************************************************************************
<a name="line-1173"></a>*                                                                      *
<a name="line-1174"></a>                Unfoldings
<a name="line-1175"></a>*                                                                      *
<a name="line-1176"></a>************************************************************************
<a name="line-1177"></a>
<a name="line-1178"></a>The @Unfolding@ type is declared here to avoid numerous loops
<a name="line-1179"></a>-}</span>
<a name="line-1180"></a>
<a name="line-1181"></a><a name="Unfolding"></a><span class='hs-comment'>-- | Records the /unfolding/ of an identifier, which is approximately the form the</span>
<a name="line-1182"></a><a name="Unfolding"></a><span class='hs-comment'>-- identifier would have if we substituted its definition in for the identifier.</span>
<a name="line-1183"></a><a name="Unfolding"></a><span class='hs-comment'>-- This type should be treated as abstract everywhere except in "GHC.Core.Unfold"</span>
<a name="line-1184"></a><a name="Unfolding"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1185"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUnfolding</span>        <span class='hs-comment'>-- ^ We have no information about the unfolding.</span>
<a name="line-1186"></a>
<a name="line-1187"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BootUnfolding</span>      <span class='hs-comment'>-- ^ We have no information about the unfolding, because</span>
<a name="line-1188"></a>                       <span class='hs-comment'>-- this 'Id' came from an @hi-boot@ file.</span>
<a name="line-1189"></a>                       <span class='hs-comment'>-- See Note [Inlining and hs-boot files] in "GHC.CoreToIface"</span>
<a name="line-1190"></a>                       <span class='hs-comment'>-- for what this is used for.</span>
<a name="line-1191"></a>
<a name="line-1192"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OtherCon</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ^ It ain't one of these constructors.</span>
<a name="line-1193"></a>                       <span class='hs-comment'>-- @OtherCon xs@ also indicates that something has been evaluated</span>
<a name="line-1194"></a>                       <span class='hs-comment'>-- and hence there's no point in re-evaluating it.</span>
<a name="line-1195"></a>                       <span class='hs-comment'>-- @OtherCon []@ is used even for non-data-type values</span>
<a name="line-1196"></a>                       <span class='hs-comment'>-- to indicated evaluated-ness.  Notably:</span>
<a name="line-1197"></a>                       <span class='hs-comment'>--</span>
<a name="line-1198"></a>                       <span class='hs-comment'>-- &gt; data C = C !(Int -&gt; Int)</span>
<a name="line-1199"></a>                       <span class='hs-comment'>-- &gt; case x of { C f -&gt; ... }</span>
<a name="line-1200"></a>                       <span class='hs-comment'>--</span>
<a name="line-1201"></a>                       <span class='hs-comment'>-- Here, @f@ gets an @OtherCon []@ unfolding.</span>
<a name="line-1202"></a>
<a name="line-1203"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span>     <span class='hs-comment'>-- The Unfolding of a DFunId</span>
<a name="line-1204"></a>                        <span class='hs-comment'>-- See Note [DFun unfoldings]</span>
<a name="line-1205"></a>                        <span class='hs-comment'>--     df = /\a1..am. \d1..dn. MkD t1 .. tk</span>
<a name="line-1206"></a>                        <span class='hs-comment'>--                                 (op1 a1..am d1..dn)</span>
<a name="line-1207"></a>                        <span class='hs-comment'>--                                 (op2 a1..am d1..dn)</span>
<a name="line-1208"></a>        <span class='hs-varid'>df_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- The bound variables [a1..m],[d1..dn]</span>
<a name="line-1209"></a>        <span class='hs-varid'>df_con</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- The dictionary data constructor (never a newtype datacon)</span>
<a name="line-1210"></a>        <span class='hs-varid'>df_args</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Args of the data con: types, superclasses and methods,</span>
<a name="line-1211"></a>    <span class='hs-layout'>}</span>                           <span class='hs-comment'>-- in positional order</span>
<a name="line-1212"></a>
<a name="line-1213"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span>             <span class='hs-comment'>-- An unfolding for an Id with no pragma,</span>
<a name="line-1214"></a>                                <span class='hs-comment'>-- or perhaps a NOINLINE pragma</span>
<a name="line-1215"></a>                                <span class='hs-comment'>-- (For NOINLINE, the phase, if any, is in the</span>
<a name="line-1216"></a>                                <span class='hs-comment'>-- InlinePragInfo for this Id.)</span>
<a name="line-1217"></a>        <span class='hs-varid'>uf_tmpl</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Template; occurrence info is correct</span>
<a name="line-1218"></a>        <span class='hs-varid'>uf_src</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingSource</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Where the unfolding came from</span>
<a name="line-1219"></a>        <span class='hs-varid'>uf_is_top</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- True &lt;=&gt; top level binding</span>
<a name="line-1220"></a>        <span class='hs-varid'>uf_is_value</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- exprIsHNF template (cached); it is ok to discard</span>
<a name="line-1221"></a>                                        <span class='hs-comment'>--      a `seq` on this variable</span>
<a name="line-1222"></a>        <span class='hs-varid'>uf_is_conlike</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- True &lt;=&gt; applicn of constructor or CONLIKE function</span>
<a name="line-1223"></a>                                        <span class='hs-comment'>--      Cached version of exprIsConLike</span>
<a name="line-1224"></a>        <span class='hs-varid'>uf_is_work_free</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>                <span class='hs-comment'>-- True &lt;=&gt; doesn't waste (much) work to expand</span>
<a name="line-1225"></a>                                        <span class='hs-comment'>--          inside an inlining</span>
<a name="line-1226"></a>                                        <span class='hs-comment'>--      Cached version of exprIsCheap</span>
<a name="line-1227"></a>        <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>          <span class='hs-comment'>-- True &lt;=&gt; can expand in RULE matching</span>
<a name="line-1228"></a>                                        <span class='hs-comment'>--      Cached version of exprIsExpandable</span>
<a name="line-1229"></a>        <span class='hs-varid'>uf_guidance</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingGuidance</span>      <span class='hs-comment'>-- Tells about the *size* of the template.</span>
<a name="line-1230"></a>    <span class='hs-layout'>}</span>
<a name="line-1231"></a>  <span class='hs-comment'>-- ^ An unfolding with redundant cached information. Parameters:</span>
<a name="line-1232"></a>  <span class='hs-comment'>--</span>
<a name="line-1233"></a>  <span class='hs-comment'>--  uf_tmpl: Template used to perform unfolding;</span>
<a name="line-1234"></a>  <span class='hs-comment'>--           NB: Occurrence info is guaranteed correct:</span>
<a name="line-1235"></a>  <span class='hs-comment'>--               see Note [OccInfo in unfoldings and rules]</span>
<a name="line-1236"></a>  <span class='hs-comment'>--</span>
<a name="line-1237"></a>  <span class='hs-comment'>--  uf_is_top: Is this a top level binding?</span>
<a name="line-1238"></a>  <span class='hs-comment'>--</span>
<a name="line-1239"></a>  <span class='hs-comment'>--  uf_is_value: 'exprIsHNF' template (cached); it is ok to discard a 'seq' on</span>
<a name="line-1240"></a>  <span class='hs-comment'>--     this variable</span>
<a name="line-1241"></a>  <span class='hs-comment'>--</span>
<a name="line-1242"></a>  <span class='hs-comment'>--  uf_is_work_free:  Does this waste only a little work if we expand it inside an inlining?</span>
<a name="line-1243"></a>  <span class='hs-comment'>--     Basically this is a cached version of 'exprIsWorkFree'</span>
<a name="line-1244"></a>  <span class='hs-comment'>--</span>
<a name="line-1245"></a>  <span class='hs-comment'>--  uf_guidance:  Tells us about the /size/ of the unfolding template</span>
<a name="line-1246"></a>
<a name="line-1247"></a>
<a name="line-1248"></a><a name="UnfoldingSource"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1249"></a><a name="UnfoldingSource"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnfoldingSource</span>
<a name="line-1250"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See also Note [Historical note: unfoldings for wrappers]</span>
<a name="line-1251"></a>
<a name="line-1252"></a>    <span class='hs-conid'>InlineRhs</span>          <span class='hs-comment'>-- The current rhs of the function</span>
<a name="line-1253"></a>                       <span class='hs-comment'>-- Replace uf_tmpl each time around</span>
<a name="line-1254"></a>
<a name="line-1255"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InlineStable</span>       <span class='hs-comment'>-- From an INLINE or INLINABLE pragma</span>
<a name="line-1256"></a>                       <span class='hs-comment'>--   INLINE     if guidance is UnfWhen</span>
<a name="line-1257"></a>                       <span class='hs-comment'>--   INLINABLE  if guidance is UnfIfGoodArgs/UnfoldNever</span>
<a name="line-1258"></a>                       <span class='hs-comment'>-- (well, technically an INLINABLE might be made</span>
<a name="line-1259"></a>                       <span class='hs-comment'>-- UnfWhen if it was small enough, and then</span>
<a name="line-1260"></a>                       <span class='hs-comment'>-- it will behave like INLINE outside the current</span>
<a name="line-1261"></a>                       <span class='hs-comment'>-- module, but that is the way automatic unfoldings</span>
<a name="line-1262"></a>                       <span class='hs-comment'>-- work so it is consistent with the intended</span>
<a name="line-1263"></a>                       <span class='hs-comment'>-- meaning of INLINABLE).</span>
<a name="line-1264"></a>                       <span class='hs-comment'>--</span>
<a name="line-1265"></a>                       <span class='hs-comment'>-- uf_tmpl may change, but only as a result of</span>
<a name="line-1266"></a>                       <span class='hs-comment'>-- gentle simplification, it doesn't get updated</span>
<a name="line-1267"></a>                       <span class='hs-comment'>-- to the current RHS during compilation as with</span>
<a name="line-1268"></a>                       <span class='hs-comment'>-- InlineRhs.</span>
<a name="line-1269"></a>                       <span class='hs-comment'>--</span>
<a name="line-1270"></a>                       <span class='hs-comment'>-- See Note [InlineStable]</span>
<a name="line-1271"></a>
<a name="line-1272"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InlineCompulsory</span>   <span class='hs-comment'>-- Something that *has* no binding, so you *must* inline it</span>
<a name="line-1273"></a>                       <span class='hs-comment'>-- Only a few primop-like things have this property</span>
<a name="line-1274"></a>                       <span class='hs-comment'>-- (see "GHC.Types.Id.Make", calls to mkCompulsoryUnfolding).</span>
<a name="line-1275"></a>                       <span class='hs-comment'>-- Inline absolutely always, however boring the context.</span>
<a name="line-1276"></a>
<a name="line-1277"></a>
<a name="line-1278"></a>
<a name="line-1279"></a><a name="UnfoldingGuidance"></a><span class='hs-comment'>-- | 'UnfoldingGuidance' says when unfolding should take place</span>
<a name="line-1280"></a><a name="UnfoldingGuidance"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnfoldingGuidance</span>
<a name="line-1281"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Inline without thinking about the *size* of the uf_tmpl</span>
<a name="line-1282"></a>                <span class='hs-comment'>-- Used (a) for small *and* cheap unfoldings</span>
<a name="line-1283"></a>                <span class='hs-comment'>--      (b) for INLINE functions</span>
<a name="line-1284"></a>                <span class='hs-comment'>-- See Note [INLINE for small functions] in GHC.Core.Unfold</span>
<a name="line-1285"></a>      <span class='hs-varid'>ug_arity</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- Number of value arguments expected</span>
<a name="line-1286"></a>
<a name="line-1287"></a>      <span class='hs-varid'>ug_unsat_ok</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- True &lt;=&gt; ok to inline even if unsaturated</span>
<a name="line-1288"></a>      <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>      <span class='hs-comment'>-- True &lt;=&gt; ok to inline even if the context is boring</span>
<a name="line-1289"></a>                <span class='hs-comment'>-- So True,True means "always"</span>
<a name="line-1290"></a>    <span class='hs-layout'>}</span>
<a name="line-1291"></a>
<a name="line-1292"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span>     <span class='hs-comment'>-- Arose from a normal Id; the info here is the</span>
<a name="line-1293"></a>                        <span class='hs-comment'>-- result of a simple analysis of the RHS</span>
<a name="line-1294"></a>
<a name="line-1295"></a>      <span class='hs-varid'>ug_args</span> <span class='hs-keyglyph'>::</span>  <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Discount if the argument is evaluated.</span>
<a name="line-1296"></a>                          <span class='hs-comment'>-- (i.e., a simplification will definitely</span>
<a name="line-1297"></a>                          <span class='hs-comment'>-- be possible).  One elt of the list per *value* arg.</span>
<a name="line-1298"></a>
<a name="line-1299"></a>      <span class='hs-varid'>ug_size</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- The "size" of the unfolding.</span>
<a name="line-1300"></a>
<a name="line-1301"></a>      <span class='hs-varid'>ug_res</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>       <span class='hs-comment'>-- Scrutinee discount: the discount to subtract if the thing is in</span>
<a name="line-1302"></a>    <span class='hs-layout'>}</span>                     <span class='hs-comment'>-- a context (case (thing args) of ...),</span>
<a name="line-1303"></a>                          <span class='hs-comment'>-- (where there are the right number of arguments.)</span>
<a name="line-1304"></a>
<a name="line-1305"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnfNever</span>        <span class='hs-comment'>-- The RHS is big, so don't inline it</span>
<a name="line-1306"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-1307"></a>
<a name="line-1308"></a><span class='hs-comment'>{-
<a name="line-1309"></a>Note [Historical note: unfoldings for wrappers]
<a name="line-1310"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1311"></a>We used to have a nice clever scheme in interface files for
<a name="line-1312"></a>wrappers. A wrapper's unfolding can be reconstructed from its worker's
<a name="line-1313"></a>id and its strictness. This decreased .hi file size (sometimes
<a name="line-1314"></a>significantly, for modules like GHC.Classes with many high-arity w/w
<a name="line-1315"></a>splits) and had a slight corresponding effect on compile times.
<a name="line-1316"></a>
<a name="line-1317"></a>However, when we added the second demand analysis, this scheme lead to
<a name="line-1318"></a>some Core lint errors. The second analysis could change the strictness
<a name="line-1319"></a>signatures, which sometimes resulted in a wrapper's regenerated
<a name="line-1320"></a>unfolding applying the wrapper to too many arguments.
<a name="line-1321"></a>
<a name="line-1322"></a>Instead of repairing the clever .hi scheme, we abandoned it in favor
<a name="line-1323"></a>of simplicity. The .hi sizes are usually insignificant (excluding the
<a name="line-1324"></a>+1M for base libraries), and compile time barely increases (~+1% for
<a name="line-1325"></a>nofib). The nicer upshot is that the UnfoldingSource no longer mentions
<a name="line-1326"></a>an Id, so, eg, substitutions need not traverse them.
<a name="line-1327"></a>
<a name="line-1328"></a>
<a name="line-1329"></a>Note [DFun unfoldings]
<a name="line-1330"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1331"></a>The Arity in a DFunUnfolding is total number of args (type and value)
<a name="line-1332"></a>that the DFun needs to produce a dictionary.  That's not necessarily
<a name="line-1333"></a>related to the ordinary arity of the dfun Id, esp if the class has
<a name="line-1334"></a>one method, so the dictionary is represented by a newtype.  Example
<a name="line-1335"></a>
<a name="line-1336"></a>     class C a where { op :: a -&gt; Int }
<a name="line-1337"></a>     instance C a -&gt; C [a] where op xs = op (head xs)
<a name="line-1338"></a>
<a name="line-1339"></a>The instance translates to
<a name="line-1340"></a>
<a name="line-1341"></a>     $dfCList :: forall a. C a =&gt; C [a]  -- Arity 2!
<a name="line-1342"></a>     $dfCList = /\a.\d. $copList {a} d |&gt; co
<a name="line-1343"></a>
<a name="line-1344"></a>     $copList :: forall a. C a =&gt; [a] -&gt; Int  -- Arity 2!
<a name="line-1345"></a>     $copList = /\a.\d.\xs. op {a} d (head xs)
<a name="line-1346"></a>
<a name="line-1347"></a>Now we might encounter (op (dfCList {ty} d) a1 a2)
<a name="line-1348"></a>and we want the (op (dfList {ty} d)) rule to fire, because $dfCList
<a name="line-1349"></a>has all its arguments, even though its (value) arity is 2.  That's
<a name="line-1350"></a>why we record the number of expected arguments in the DFunUnfolding.
<a name="line-1351"></a>
<a name="line-1352"></a>Note that although it's an Arity, it's most convenient for it to give
<a name="line-1353"></a>the *total* number of arguments, both type and value.  See the use
<a name="line-1354"></a>site in exprIsConApp_maybe.
<a name="line-1355"></a>-}</span>
<a name="line-1356"></a>
<a name="line-1357"></a><a name="needSaturated"></a><span class='hs-comment'>-- Constants for the UnfWhen constructor</span>
<a name="line-1358"></a><span class='hs-definition'>needSaturated</span><span class='hs-layout'>,</span> <span class='hs-varid'>unSaturatedOk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1359"></a><span class='hs-definition'>needSaturated</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1360"></a><a name="unSaturatedOk"></a><span class='hs-definition'>unSaturatedOk</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1361"></a>
<a name="line-1362"></a><a name="boringCxtNotOk"></a><span class='hs-definition'>boringCxtNotOk</span><span class='hs-layout'>,</span> <span class='hs-varid'>boringCxtOk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1363"></a><a name="boringCxtOk"></a><span class='hs-definition'>boringCxtOk</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1364"></a><span class='hs-definition'>boringCxtNotOk</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1365"></a>
<a name="line-1366"></a><a name="noUnfolding"></a><span class='hs-comment'>------------------------------------------------</span>
<a name="line-1367"></a><span class='hs-definition'>noUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1368"></a><a name="evaldUnfolding"></a><span class='hs-comment'>-- ^ There is no known 'Unfolding'</span>
<a name="line-1369"></a><span class='hs-definition'>evaldUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1370"></a><span class='hs-comment'>-- ^ This unfolding marks the associated thing as being evaluated</span>
<a name="line-1371"></a>
<a name="line-1372"></a><span class='hs-definition'>noUnfolding</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoUnfolding</span>
<a name="line-1373"></a><span class='hs-definition'>evaldUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OtherCon</span> <span class='hs-conid'>[]</span>
<a name="line-1374"></a>
<a name="line-1375"></a><a name="bootUnfolding"></a><span class='hs-comment'>-- | There is no known 'Unfolding', because this came from an</span>
<a name="line-1376"></a><span class='hs-comment'>-- hi-boot file.</span>
<a name="line-1377"></a><span class='hs-definition'>bootUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1378"></a><span class='hs-definition'>bootUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BootUnfolding</span>
<a name="line-1379"></a>
<a name="line-1380"></a><a name="mkOtherCon"></a><span class='hs-definition'>mkOtherCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span>
<a name="line-1381"></a><span class='hs-definition'>mkOtherCon</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>OtherCon</span>
<a name="line-1382"></a>
<a name="line-1383"></a><a name="isStableSource"></a><span class='hs-definition'>isStableSource</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingSource</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1384"></a><span class='hs-comment'>-- Keep the unfolding template</span>
<a name="line-1385"></a><span class='hs-definition'>isStableSource</span> <span class='hs-conid'>InlineCompulsory</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1386"></a><span class='hs-definition'>isStableSource</span> <span class='hs-conid'>InlineStable</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1387"></a><span class='hs-definition'>isStableSource</span> <span class='hs-conid'>InlineRhs</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1388"></a>
<a name="line-1389"></a><a name="unfoldingTemplate"></a><span class='hs-comment'>-- | Retrieves the template of an unfolding: panics if none is known</span>
<a name="line-1390"></a><span class='hs-definition'>unfoldingTemplate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1391"></a><span class='hs-definition'>unfoldingTemplate</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uf_tmpl</span>
<a name="line-1392"></a>
<a name="line-1393"></a><a name="maybeUnfoldingTemplate"></a><span class='hs-comment'>-- | Retrieves the template of an unfolding if possible</span>
<a name="line-1394"></a><span class='hs-comment'>-- maybeUnfoldingTemplate is used mainly wnen specialising, and we do</span>
<a name="line-1395"></a><span class='hs-comment'>-- want to specialise DFuns, so it's important to return a template</span>
<a name="line-1396"></a><span class='hs-comment'>-- for DFunUnfoldings</span>
<a name="line-1397"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1398"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1399"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>expr</span>
<a name="line-1400"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>df_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_con</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span><span class='hs-layout'>,</span> <span class='hs-varid'>df_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1401"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1402"></a><span class='hs-definition'>maybeUnfoldingTemplate</span> <span class='hs-keyword'>_</span>
<a name="line-1403"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1404"></a>
<a name="line-1405"></a><a name="otherCons"></a><span class='hs-comment'>-- | The constructors that the unfolding could never be:</span>
<a name="line-1406"></a><span class='hs-comment'>-- returns @[]@ if no information is available</span>
<a name="line-1407"></a><span class='hs-definition'>otherCons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AltCon</span><span class='hs-keyglyph'>]</span>
<a name="line-1408"></a><span class='hs-definition'>otherCons</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherCon</span> <span class='hs-varid'>cons</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cons</span>
<a name="line-1409"></a><span class='hs-definition'>otherCons</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1410"></a>
<a name="line-1411"></a><a name="isValueUnfolding"></a><span class='hs-comment'>-- | Determines if it is certainly the case that the unfolding will</span>
<a name="line-1412"></a><span class='hs-comment'>-- yield a value (something in HNF): returns @False@ if unsure</span>
<a name="line-1413"></a><span class='hs-definition'>isValueUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1414"></a>        <span class='hs-comment'>-- Returns False for OtherCon</span>
<a name="line-1415"></a><span class='hs-definition'>isValueUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_value</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span>
<a name="line-1416"></a><span class='hs-definition'>isValueUnfolding</span> <span class='hs-keyword'>_</span>                                          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1417"></a>
<a name="line-1418"></a><a name="isEvaldUnfolding"></a><span class='hs-comment'>-- | Determines if it possibly the case that the unfolding will</span>
<a name="line-1419"></a><span class='hs-comment'>-- yield a value. Unlike 'isValueUnfolding' it returns @True@</span>
<a name="line-1420"></a><span class='hs-comment'>-- for 'OtherCon'</span>
<a name="line-1421"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1422"></a>        <span class='hs-comment'>-- Returns True for OtherCon</span>
<a name="line-1423"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherCon</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1424"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_value</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_evald</span>
<a name="line-1425"></a><span class='hs-definition'>isEvaldUnfolding</span> <span class='hs-keyword'>_</span>                                          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1426"></a>
<a name="line-1427"></a><a name="isConLikeUnfolding"></a><span class='hs-comment'>-- | @True@ if the unfolding is a constructor application, the application</span>
<a name="line-1428"></a><span class='hs-comment'>-- of a CONLIKE function or 'OtherCon'</span>
<a name="line-1429"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1430"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherCon</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1431"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_conlike</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con</span>
<a name="line-1432"></a><span class='hs-definition'>isConLikeUnfolding</span> <span class='hs-keyword'>_</span>                                        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1433"></a>
<a name="line-1434"></a><a name="isCheapUnfolding"></a><span class='hs-comment'>-- | Is the thing we will unfold into certainly cheap?</span>
<a name="line-1435"></a><span class='hs-definition'>isCheapUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1436"></a><span class='hs-definition'>isCheapUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_is_work_free</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_wf</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_wf</span>
<a name="line-1437"></a><span class='hs-definition'>isCheapUnfolding</span> <span class='hs-keyword'>_</span>                                           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1438"></a>
<a name="line-1439"></a><a name="isExpandableUnfolding"></a><span class='hs-definition'>isExpandableUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1440"></a><span class='hs-definition'>isExpandableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_expable</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_expable</span>
<a name="line-1441"></a><span class='hs-definition'>isExpandableUnfolding</span> <span class='hs-keyword'>_</span>                                              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1442"></a>
<a name="line-1443"></a><a name="expandUnfolding_maybe"></a><span class='hs-definition'>expandUnfolding_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1444"></a><span class='hs-comment'>-- Expand an expandable unfolding; this is used in rule matching</span>
<a name="line-1445"></a><span class='hs-comment'>--   See Note [Expanding variables] in GHC.Core.Rules</span>
<a name="line-1446"></a><span class='hs-comment'>-- The key point here is that CONLIKE things can be expanded</span>
<a name="line-1447"></a><span class='hs-definition'>expandUnfolding_maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs</span>
<a name="line-1448"></a><span class='hs-definition'>expandUnfolding_maybe</span> <span class='hs-keyword'>_</span>                                                       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1449"></a>
<a name="line-1450"></a><a name="isCompulsoryUnfolding"></a><span class='hs-definition'>isCompulsoryUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1451"></a><span class='hs-definition'>isCompulsoryUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InlineCompulsory</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1452"></a><span class='hs-definition'>isCompulsoryUnfolding</span> <span class='hs-keyword'>_</span>                                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1453"></a>
<a name="line-1454"></a><a name="isStableUnfolding"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1455"></a><span class='hs-comment'>-- True of unfoldings that should not be overwritten</span>
<a name="line-1456"></a><span class='hs-comment'>-- by a CoreUnfolding for the RHS of a let-binding</span>
<a name="line-1457"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStableSource</span> <span class='hs-varid'>src</span>
<a name="line-1458"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1459"></a><span class='hs-definition'>isStableUnfolding</span> <span class='hs-keyword'>_</span>                                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1460"></a>
<a name="line-1461"></a><a name="hasSomeUnfolding"></a><span class='hs-comment'>-- | Only returns False if there is no unfolding information available at all</span>
<a name="line-1462"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1463"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-conid'>NoUnfolding</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1464"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-conid'>BootUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1465"></a><span class='hs-definition'>hasSomeUnfolding</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1466"></a>
<a name="line-1467"></a><a name="isBootUnfolding"></a><span class='hs-definition'>isBootUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1468"></a><span class='hs-definition'>isBootUnfolding</span> <span class='hs-conid'>BootUnfolding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1469"></a><span class='hs-definition'>isBootUnfolding</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1470"></a>
<a name="line-1471"></a><a name="neverUnfoldGuidance"></a><span class='hs-definition'>neverUnfoldGuidance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingGuidance</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1472"></a><span class='hs-definition'>neverUnfoldGuidance</span> <span class='hs-conid'>UnfNever</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1473"></a><span class='hs-definition'>neverUnfoldGuidance</span> <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1474"></a>
<a name="line-1475"></a><a name="hasCoreUnfolding"></a><span class='hs-definition'>hasCoreUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1476"></a><span class='hs-comment'>-- An unfolding "has Core" if it contains a Core expression, which</span>
<a name="line-1477"></a><span class='hs-comment'>-- may mention free variables. See Note [Fragile unfoldings]</span>
<a name="line-1478"></a><span class='hs-definition'>hasCoreUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1479"></a><span class='hs-definition'>hasCoreUnfolding</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1480"></a><span class='hs-definition'>hasCoreUnfolding</span> <span class='hs-keyword'>_</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1481"></a>  <span class='hs-comment'>-- NoUnfolding, BootUnfolding, OtherCon have no Core</span>
<a name="line-1482"></a>
<a name="line-1483"></a><a name="canUnfold"></a><span class='hs-definition'>canUnfold</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1484"></a><span class='hs-definition'>canUnfold</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>g</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>neverUnfoldGuidance</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-1485"></a><span class='hs-definition'>canUnfold</span> <span class='hs-keyword'>_</span>                                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1486"></a>
<a name="line-1487"></a><span class='hs-comment'>{- Note [Fragile unfoldings]
<a name="line-1488"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1489"></a>An unfolding is "fragile" if it mentions free variables (and hence would
<a name="line-1490"></a>need substitution) or might be affected by optimisation.  The non-fragile
<a name="line-1491"></a>ones are
<a name="line-1492"></a>
<a name="line-1493"></a>   NoUnfolding, BootUnfolding
<a name="line-1494"></a>
<a name="line-1495"></a>   OtherCon {}    If we know this binder (say a lambda binder) will be
<a name="line-1496"></a>                  bound to an evaluated thing, we want to retain that
<a name="line-1497"></a>                  info in simpleOptExpr; see #13077.
<a name="line-1498"></a>
<a name="line-1499"></a>We consider even a StableUnfolding as fragile, because it needs substitution.
<a name="line-1500"></a>
<a name="line-1501"></a>Note [InlineStable]
<a name="line-1502"></a>~~~~~~~~~~~~~~~~~
<a name="line-1503"></a>When you say
<a name="line-1504"></a>      {-# INLINE f #-}
<a name="line-1505"></a>      f x = &lt;rhs&gt;
<a name="line-1506"></a>you intend that calls (f e) are replaced by &lt;rhs&gt;[e/x] So we
<a name="line-1507"></a>should capture (\x.&lt;rhs&gt;) in the Unfolding of 'f', and never meddle
<a name="line-1508"></a>with it.  Meanwhile, we can optimise &lt;rhs&gt; to our heart's content,
<a name="line-1509"></a>leaving the original unfolding intact in Unfolding of 'f'. For example
<a name="line-1510"></a>        all xs = foldr (&amp;&amp;) True xs
<a name="line-1511"></a>        any p = all . map p  {-# INLINE any #-}
<a name="line-1512"></a>We optimise any's RHS fully, but leave the InlineRule saying "all . map p",
<a name="line-1513"></a>which deforests well at the call site.
<a name="line-1514"></a>
<a name="line-1515"></a>So INLINE pragma gives rise to an InlineRule, which captures the original RHS.
<a name="line-1516"></a>
<a name="line-1517"></a>Moreover, it's only used when 'f' is applied to the
<a name="line-1518"></a>specified number of arguments; that is, the number of argument on
<a name="line-1519"></a>the LHS of the '=' sign in the original source definition.
<a name="line-1520"></a>For example, (.) is now defined in the libraries like this
<a name="line-1521"></a>   {-# INLINE (.) #-}
<a name="line-1522"></a>   (.) f g = \x -&gt; f (g x)
<a name="line-1523"></a>so that it'll inline when applied to two arguments. If 'x' appeared
<a name="line-1524"></a>on the left, thus
<a name="line-1525"></a>   (.) f g x = f (g x)
<a name="line-1526"></a>it'd only inline when applied to three arguments.  This slightly-experimental
<a name="line-1527"></a>change was requested by Roman, but it seems to make sense.
<a name="line-1528"></a>
<a name="line-1529"></a>See also Note [Inlining an InlineRule] in GHC.Core.Unfold.
<a name="line-1530"></a>
<a name="line-1531"></a>
<a name="line-1532"></a>Note [OccInfo in unfoldings and rules]
<a name="line-1533"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1534"></a>In unfoldings and rules, we guarantee that the template is occ-analysed,
<a name="line-1535"></a>so that the occurrence info on the binders is correct.  This is important,
<a name="line-1536"></a>because the Simplifier does not re-analyse the template when using it. If
<a name="line-1537"></a>the occurrence info is wrong
<a name="line-1538"></a>  - We may get more simplifier iterations than necessary, because
<a name="line-1539"></a>    once-occ info isn't there
<a name="line-1540"></a>  - More seriously, we may get an infinite loop if there's a Rec
<a name="line-1541"></a>    without a loop breaker marked
<a name="line-1542"></a>
<a name="line-1543"></a>
<a name="line-1544"></a>************************************************************************
<a name="line-1545"></a>*                                                                      *
<a name="line-1546"></a>                  AltCon
<a name="line-1547"></a>*                                                                      *
<a name="line-1548"></a>************************************************************************
<a name="line-1549"></a>-}</span>
<a name="line-1550"></a>
<a name="line-1551"></a><span class='hs-comment'>-- The Ord is needed for the FiniteMap used in the lookForConstructor</span>
<a name="line-1552"></a><span class='hs-comment'>-- in GHC.Core.Opt.Simplify.Env.  If you declared that lookForConstructor</span>
<a name="line-1553"></a><span class='hs-comment'>-- *ignores* constructor-applications with LitArg args, then you could get rid</span>
<a name="line-1554"></a><span class='hs-comment'>-- of this Ord.</span>
<a name="line-1555"></a>
<a name="line-1556"></a><a name="instance%20Outputable%20AltCon"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyword'>where</span>
<a name="line-1557"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc</span>
<a name="line-1558"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>lit</span>
<a name="line-1559"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"__DEFAULT"</span>
<a name="line-1560"></a>
<a name="line-1561"></a><a name="cmpAlt"></a><span class='hs-definition'>cmpAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-1562"></a><span class='hs-definition'>cmpAlt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con2</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>con1</span> <span class='hs-varop'>`cmpAltCon`</span> <span class='hs-varid'>con2</span>
<a name="line-1563"></a>
<a name="line-1564"></a><a name="ltAlt"></a><span class='hs-definition'>ltAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1565"></a><span class='hs-definition'>ltAlt</span> <span class='hs-varid'>a1</span> <span class='hs-varid'>a2</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a1</span> <span class='hs-varop'>`cmpAlt`</span> <span class='hs-varid'>a2</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>LT</span>
<a name="line-1566"></a>
<a name="line-1567"></a><a name="cmpAltCon"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-1568"></a><span class='hs-comment'>-- ^ Compares 'AltCon's within a single list of alternatives</span>
<a name="line-1569"></a><span class='hs-comment'>-- DEFAULT comes out smallest, so that sorting by AltCon puts</span>
<a name="line-1570"></a><span class='hs-comment'>-- alternatives in the order required: see Note [Case expression invariants]</span>
<a name="line-1571"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-conid'>DEFAULT</span>      <span class='hs-conid'>DEFAULT</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-1572"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-1573"></a>
<a name="line-1574"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>d1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>d2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConTag</span> <span class='hs-varid'>d1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>dataConTag</span> <span class='hs-varid'>d2</span>
<a name="line-1575"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-1576"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span>  <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span>  <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>l2</span>
<a name="line-1577"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-conid'>DEFAULT</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-1578"></a>
<a name="line-1579"></a><span class='hs-definition'>cmpAltCon</span> <span class='hs-varid'>con1</span> <span class='hs-varid'>con2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Comparing incomparable AltCons"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-1580"></a>                                  <span class='hs-varid'>ppr</span> <span class='hs-varid'>con1</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con2</span> <span class='hs-layout'>)</span>
<a name="line-1581"></a>                      <span class='hs-conid'>LT</span>
<a name="line-1582"></a>
<a name="line-1583"></a><span class='hs-comment'>{-
<a name="line-1584"></a>************************************************************************
<a name="line-1585"></a>*                                                                      *
<a name="line-1586"></a>\subsection{Useful synonyms}
<a name="line-1587"></a>*                                                                      *
<a name="line-1588"></a>************************************************************************
<a name="line-1589"></a>
<a name="line-1590"></a>Note [CoreProgram]
<a name="line-1591"></a>~~~~~~~~~~~~~~~~~~
<a name="line-1592"></a>The top level bindings of a program, a CoreProgram, are represented as
<a name="line-1593"></a>a list of CoreBind
<a name="line-1594"></a>
<a name="line-1595"></a> * Later bindings in the list can refer to earlier ones, but not vice
<a name="line-1596"></a>   versa.  So this is OK
<a name="line-1597"></a>      NonRec { x = 4 }
<a name="line-1598"></a>      Rec { p = ...q...x...
<a name="line-1599"></a>          ; q = ...p...x }
<a name="line-1600"></a>      Rec { f = ...p..x..f.. }
<a name="line-1601"></a>      NonRec { g = ..f..q...x.. }
<a name="line-1602"></a>   But it would NOT be ok for 'f' to refer to 'g'.
<a name="line-1603"></a>
<a name="line-1604"></a> * The occurrence analyser does strongly-connected component analysis
<a name="line-1605"></a>   on each Rec binding, and splits it into a sequence of smaller
<a name="line-1606"></a>   bindings where possible.  So the program typically starts life as a
<a name="line-1607"></a>   single giant Rec, which is then dependency-analysed into smaller
<a name="line-1608"></a>   chunks.
<a name="line-1609"></a>-}</span>
<a name="line-1610"></a>
<a name="line-1611"></a><a name="CoreProgram"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-1612"></a><a name="CoreProgram"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-1613"></a><a name="CoreProgram"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBind</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- See Note [CoreProgram]</span>
<a name="line-1614"></a>
<a name="line-1615"></a><a name="CoreBndr"></a><span class='hs-comment'>-- | The common case for the type of binders and variables when</span>
<a name="line-1616"></a><a name="CoreBndr"></a><span class='hs-comment'>-- we are manipulating the Core language within GHC</span>
<a name="line-1617"></a><a name="CoreBndr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span>
<a name="line-1618"></a><a name="CoreExpr"></a><span class='hs-comment'>-- | Expressions where binders are 'CoreBndr's</span>
<a name="line-1619"></a><a name="CoreExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-1620"></a><a name="CoreArg"></a><span class='hs-comment'>-- | Argument expressions where binders are 'CoreBndr's</span>
<a name="line-1621"></a><a name="CoreArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreArg</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Arg</span>  <span class='hs-conid'>CoreBndr</span>
<a name="line-1622"></a><a name="CoreBind"></a><span class='hs-comment'>-- | Binding groups where binders are 'CoreBndr's</span>
<a name="line-1623"></a><a name="CoreBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreBind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bind</span> <span class='hs-conid'>CoreBndr</span>
<a name="line-1624"></a><a name="CoreAlt"></a><span class='hs-comment'>-- | Case alternatives where binders are 'CoreBndr's</span>
<a name="line-1625"></a><a name="CoreAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreAlt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span>  <span class='hs-conid'>CoreBndr</span>
<a name="line-1626"></a>
<a name="line-1627"></a><span class='hs-comment'>{-
<a name="line-1628"></a>************************************************************************
<a name="line-1629"></a>*                                                                      *
<a name="line-1630"></a>\subsection{Tagging}
<a name="line-1631"></a>*                                                                      *
<a name="line-1632"></a>************************************************************************
<a name="line-1633"></a>-}</span>
<a name="line-1634"></a>
<a name="line-1635"></a><a name="TaggedBndr"></a><span class='hs-comment'>-- | Binders are /tagged/ with a t</span>
<a name="line-1636"></a><a name="TaggedBndr"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TB</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-varid'>t</span>       <span class='hs-comment'>-- TB for "tagged binder"</span>
<a name="line-1637"></a>
<a name="line-1638"></a><a name="TaggedBind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedBind</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Bind</span> <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1639"></a><a name="TaggedExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedExpr</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Expr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1640"></a><a name="TaggedArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedArg</span>  <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Arg</span>  <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1641"></a><a name="TaggedAlt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TaggedAlt</span>  <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span>  <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-1642"></a>
<a name="line-1643"></a><a name="instance%20Outputable%20(TaggedBndr%20b)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>TaggedBndr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-1644"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'&lt;'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>l</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'&gt;'</span>
<a name="line-1645"></a>
<a name="line-1646"></a><a name="deTagExpr"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TaggedExpr</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1647"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span>
<a name="line-1648"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>l</span>
<a name="line-1649"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span>
<a name="line-1650"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span>
<a name="line-1651"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>App</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>
<a name="line-1652"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1653"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagBind</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1654"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>deTagAlt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1655"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1656"></a><span class='hs-definition'>deTagExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-1657"></a>
<a name="line-1658"></a><a name="deTagBind"></a><span class='hs-definition'>deTagBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TaggedBind</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-1659"></a><span class='hs-definition'>deTagBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1660"></a><span class='hs-definition'>deTagBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rec</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>prs</span><span class='hs-keyglyph'>]</span>
<a name="line-1661"></a>
<a name="line-1662"></a><a name="deTagAlt"></a><span class='hs-definition'>deTagAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TaggedAlt</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreAlt</span>
<a name="line-1663"></a><span class='hs-definition'>deTagAlt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TB</span> <span class='hs-varid'>b</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-varid'>deTagExpr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1664"></a>
<a name="line-1665"></a><span class='hs-comment'>{-
<a name="line-1666"></a>************************************************************************
<a name="line-1667"></a>*                                                                      *
<a name="line-1668"></a>\subsection{Core-constructing functions with checking}
<a name="line-1669"></a>*                                                                      *
<a name="line-1670"></a>************************************************************************
<a name="line-1671"></a>-}</span>
<a name="line-1672"></a>
<a name="line-1673"></a><a name="mkApps"></a><span class='hs-comment'>-- | Apply a list of argument expressions to a function expression in a nested fashion. Prefer to</span>
<a name="line-1674"></a><span class='hs-comment'>-- use 'GHC.Core.Make.mkCoreApps' if possible</span>
<a name="line-1675"></a><span class='hs-definition'>mkApps</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1676"></a><a name="mkTyApps"></a><span class='hs-comment'>-- | Apply a list of type argument expressions to a function expression in a nested fashion</span>
<a name="line-1677"></a><span class='hs-definition'>mkTyApps</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1678"></a><a name="mkCoApps"></a><span class='hs-comment'>-- | Apply a list of coercion argument expressions to a function expression in a nested fashion</span>
<a name="line-1679"></a><span class='hs-definition'>mkCoApps</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1680"></a><a name="mkVarApps"></a><span class='hs-comment'>-- | Apply a list of type or value variables to a function expression in a nested fashion</span>
<a name="line-1681"></a><span class='hs-definition'>mkVarApps</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1682"></a><a name="mkConApp"></a><span class='hs-comment'>-- | Apply a list of argument expressions to a data constructor in a nested fashion. Prefer to</span>
<a name="line-1683"></a><span class='hs-comment'>-- use 'GHC.Core.Make.mkCoreConApps' if possible</span>
<a name="line-1684"></a><span class='hs-definition'>mkConApp</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1685"></a>
<a name="line-1686"></a><span class='hs-definition'>mkApps</span>    <span class='hs-varid'>f</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-conid'>App</span>                       <span class='hs-varid'>f</span> <span class='hs-varid'>args</span>
<a name="line-1687"></a><span class='hs-definition'>mkCoApps</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>args</span>
<a name="line-1688"></a><span class='hs-definition'>mkVarApps</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>vars</span>
<a name="line-1689"></a><span class='hs-definition'>mkConApp</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-1690"></a>
<a name="line-1691"></a><span class='hs-definition'>mkTyApps</span>  <span class='hs-varid'>f</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span> <span class='hs-varid'>e</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyArg</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span> <span class='hs-varid'>args</span>
<a name="line-1692"></a>
<a name="line-1693"></a><a name="mkConApp2"></a><span class='hs-definition'>mkConApp2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1694"></a><span class='hs-definition'>mkConApp2</span> <span class='hs-varid'>con</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>arg_ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConWorkId</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span>
<a name="line-1695"></a>                            <span class='hs-varop'>`mkApps`</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>tys</span>
<a name="line-1696"></a>                            <span class='hs-varop'>`mkApps`</span> <span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>arg_ids</span>
<a name="line-1697"></a>
<a name="line-1698"></a><a name="mkTyArg"></a><span class='hs-definition'>mkTyArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1699"></a><span class='hs-definition'>mkTyArg</span> <span class='hs-varid'>ty</span>
<a name="line-1700"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isCoercionTy_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span>
<a name="line-1701"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span>
<a name="line-1702"></a>
<a name="line-1703"></a><a name="mkIntLit"></a><span class='hs-comment'>-- | Create a machine integer literal expression of type @Int#@ from an @Integer@.</span>
<a name="line-1704"></a><span class='hs-comment'>-- If you want an expression of type @Int@ use 'GHC.Core.Make.mkIntExpr'</span>
<a name="line-1705"></a><span class='hs-definition'>mkIntLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Platform</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1706"></a><span class='hs-definition'>mkIntLit</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitInt</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-1707"></a>
<a name="line-1708"></a><a name="mkIntLitWrap"></a><span class='hs-comment'>-- | Create a machine integer literal expression of type @Int#@ from an</span>
<a name="line-1709"></a><span class='hs-comment'>-- @Integer@, wrapping if necessary.</span>
<a name="line-1710"></a><span class='hs-comment'>-- If you want an expression of type @Int@ use 'GHC.Core.Make.mkIntExpr'</span>
<a name="line-1711"></a><span class='hs-definition'>mkIntLitWrap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Platform</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1712"></a><span class='hs-definition'>mkIntLitWrap</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitIntWrap</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-1713"></a>
<a name="line-1714"></a><a name="mkWordLit"></a><span class='hs-comment'>-- | Create a machine word literal expression of type  @Word#@ from an @Integer@.</span>
<a name="line-1715"></a><span class='hs-comment'>-- If you want an expression of type @Word@ use 'GHC.Core.Make.mkWordExpr'</span>
<a name="line-1716"></a><span class='hs-definition'>mkWordLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Platform</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1717"></a><span class='hs-definition'>mkWordLit</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitWord</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span>
<a name="line-1718"></a>
<a name="line-1719"></a><a name="mkWordLitWrap"></a><span class='hs-comment'>-- | Create a machine word literal expression of type  @Word#@ from an</span>
<a name="line-1720"></a><span class='hs-comment'>-- @Integer@, wrapping if necessary.</span>
<a name="line-1721"></a><span class='hs-comment'>-- If you want an expression of type @Word@ use 'GHC.Core.Make.mkWordExpr'</span>
<a name="line-1722"></a><span class='hs-definition'>mkWordLitWrap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Platform</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1723"></a><span class='hs-definition'>mkWordLitWrap</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitWordWrap</span> <span class='hs-varid'>platform</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span>
<a name="line-1724"></a>
<a name="line-1725"></a><a name="mkWord8Lit"></a><span class='hs-definition'>mkWord8Lit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Integer</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1726"></a><span class='hs-definition'>mkWord8Lit</span>    <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitWord8</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span>
<a name="line-1727"></a>
<a name="line-1728"></a><a name="mkWord64LitWord64"></a><span class='hs-definition'>mkWord64LitWord64</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word64</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1729"></a><span class='hs-definition'>mkWord64LitWord64</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitWord64</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1730"></a>
<a name="line-1731"></a><a name="mkInt64LitInt64"></a><span class='hs-definition'>mkInt64LitInt64</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int64</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1732"></a><span class='hs-definition'>mkInt64LitInt64</span> <span class='hs-varid'>w</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitInt64</span> <span class='hs-layout'>(</span><span class='hs-varid'>toInteger</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1733"></a>
<a name="line-1734"></a><a name="mkCharLit"></a><span class='hs-comment'>-- | Create a machine character literal expression of type @Char#@.</span>
<a name="line-1735"></a><span class='hs-comment'>-- If you want an expression of type @Char@ use 'GHC.Core.Make.mkCharExpr'</span>
<a name="line-1736"></a><span class='hs-definition'>mkCharLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Char</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1737"></a><a name="mkStringLit"></a><span class='hs-comment'>-- | Create a machine string literal expression of type @Addr#@.</span>
<a name="line-1738"></a><span class='hs-comment'>-- If you want an expression of type @String@ use 'GHC.Core.Make.mkStringExpr'</span>
<a name="line-1739"></a><span class='hs-definition'>mkStringLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1740"></a>
<a name="line-1741"></a><span class='hs-definition'>mkCharLit</span>   <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitChar</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-1742"></a><span class='hs-definition'>mkStringLit</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitString</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-1743"></a>
<a name="line-1744"></a><a name="mkFloatLit"></a><span class='hs-comment'>-- | Create a machine single precision literal expression of type @Float#@ from a @Rational@.</span>
<a name="line-1745"></a><span class='hs-comment'>-- If you want an expression of type @Float@ use 'GHC.Core.Make.mkFloatExpr'</span>
<a name="line-1746"></a><span class='hs-definition'>mkFloatLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1747"></a><a name="mkFloatLitFloat"></a><span class='hs-comment'>-- | Create a machine single precision literal expression of type @Float#@ from a @Float@.</span>
<a name="line-1748"></a><span class='hs-comment'>-- If you want an expression of type @Float@ use 'GHC.Core.Make.mkFloatExpr'</span>
<a name="line-1749"></a><span class='hs-definition'>mkFloatLitFloat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Float</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1750"></a>
<a name="line-1751"></a><span class='hs-definition'>mkFloatLit</span>      <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitFloat</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span>
<a name="line-1752"></a><span class='hs-definition'>mkFloatLitFloat</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitFloat</span> <span class='hs-layout'>(</span><span class='hs-varid'>toRational</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1753"></a>
<a name="line-1754"></a><a name="mkDoubleLit"></a><span class='hs-comment'>-- | Create a machine double precision literal expression of type @Double#@ from a @Rational@.</span>
<a name="line-1755"></a><span class='hs-comment'>-- If you want an expression of type @Double@ use 'GHC.Core.Make.mkDoubleExpr'</span>
<a name="line-1756"></a><span class='hs-definition'>mkDoubleLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Rational</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1757"></a><a name="mkDoubleLitDouble"></a><span class='hs-comment'>-- | Create a machine double precision literal expression of type @Double#@ from a @Double@.</span>
<a name="line-1758"></a><span class='hs-comment'>-- If you want an expression of type @Double@ use 'GHC.Core.Make.mkDoubleExpr'</span>
<a name="line-1759"></a><span class='hs-definition'>mkDoubleLitDouble</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1760"></a>
<a name="line-1761"></a><span class='hs-definition'>mkDoubleLit</span>       <span class='hs-varid'>d</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitDouble</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span>
<a name="line-1762"></a><span class='hs-definition'>mkDoubleLitDouble</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLitDouble</span> <span class='hs-layout'>(</span><span class='hs-varid'>toRational</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1763"></a>
<a name="line-1764"></a><a name="mkLets"></a><span class='hs-comment'>-- | Bind all supplied binding groups over an expression in a nested let expression. Assumes</span>
<a name="line-1765"></a><span class='hs-comment'>-- that the rhs satisfies the let/app invariant.  Prefer to use 'GHC.Core.Make.mkCoreLets' if</span>
<a name="line-1766"></a><span class='hs-comment'>-- possible, which does guarantee the invariant</span>
<a name="line-1767"></a><span class='hs-definition'>mkLets</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1768"></a><a name="mkLams"></a><span class='hs-comment'>-- | Bind all supplied binders over an expression in a nested lambda expression. Prefer to</span>
<a name="line-1769"></a><span class='hs-comment'>-- use 'GHC.Core.Make.mkCoreLams' if possible</span>
<a name="line-1770"></a><span class='hs-definition'>mkLams</span>        <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1771"></a>
<a name="line-1772"></a><span class='hs-definition'>mkLams</span> <span class='hs-varid'>binders</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>body</span> <span class='hs-varid'>binders</span>
<a name="line-1773"></a><span class='hs-definition'>mkLets</span> <span class='hs-varid'>binds</span> <span class='hs-varid'>body</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkLet</span> <span class='hs-varid'>body</span> <span class='hs-varid'>binds</span>
<a name="line-1774"></a>
<a name="line-1775"></a><a name="mkLet"></a><span class='hs-definition'>mkLet</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1776"></a><span class='hs-comment'>-- The desugarer sometimes generates an empty Rec group</span>
<a name="line-1777"></a><span class='hs-comment'>-- which Lint rejects, so we kill it off right away</span>
<a name="line-1778"></a><span class='hs-definition'>mkLet</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1779"></a><span class='hs-definition'>mkLet</span> <span class='hs-varid'>bind</span>     <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span>
<a name="line-1780"></a>
<a name="line-1781"></a><a name="mkLetNonRec"></a><span class='hs-comment'>-- | @mkLetNonRec bndr rhs body@ wraps @body@ in a @let@ binding @bndr@.</span>
<a name="line-1782"></a><span class='hs-definition'>mkLetNonRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1783"></a><span class='hs-definition'>mkLetNonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1784"></a>
<a name="line-1785"></a><a name="mkLetRec"></a><span class='hs-comment'>-- | @mkLetRec binds body@ wraps @body@ in a @let rec@ with the given set of</span>
<a name="line-1786"></a><span class='hs-comment'>-- @binds@ if binds is non-empty.</span>
<a name="line-1787"></a><span class='hs-definition'>mkLetRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1788"></a><span class='hs-definition'>mkLetRec</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1789"></a><span class='hs-definition'>mkLetRec</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1790"></a>
<a name="line-1791"></a><a name="mkTyBind"></a><span class='hs-comment'>-- | Create a binding group where a type variable is bound to a type.</span>
<a name="line-1792"></a><span class='hs-comment'>-- Per Note [Core type and coercion invariant],</span>
<a name="line-1793"></a><span class='hs-comment'>-- this can only be used to bind something in a non-recursive @let@ expression</span>
<a name="line-1794"></a><span class='hs-definition'>mkTyBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-1795"></a><span class='hs-definition'>mkTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1796"></a>
<a name="line-1797"></a><a name="mkCoBind"></a><span class='hs-comment'>-- | Create a binding group where a type variable is bound to a type.</span>
<a name="line-1798"></a><span class='hs-comment'>-- Per Note [Core type and coercion invariant],</span>
<a name="line-1799"></a><span class='hs-comment'>-- this can only be used to bind something in a non-recursive @let@ expression</span>
<a name="line-1800"></a><span class='hs-definition'>mkCoBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-1801"></a><span class='hs-definition'>mkCoBind</span> <span class='hs-varid'>cv</span> <span class='hs-varid'>co</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1802"></a>
<a name="line-1803"></a><a name="varToCoreExpr"></a><span class='hs-comment'>-- | Convert a binder into either a 'Var' or 'Type' 'Expr' appropriately</span>
<a name="line-1804"></a><span class='hs-definition'>varToCoreExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreBndr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1805"></a><span class='hs-definition'>varToCoreExpr</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1806"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoVarCo</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1807"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span> <span class='hs-layout'>)</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span>
<a name="line-1808"></a>
<a name="line-1809"></a><a name="varsToCoreExprs"></a><span class='hs-definition'>varsToCoreExprs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1810"></a><span class='hs-definition'>varsToCoreExprs</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>vs</span>
<a name="line-1811"></a>
<a name="line-1812"></a><span class='hs-comment'>{-
<a name="line-1813"></a>************************************************************************
<a name="line-1814"></a>*                                                                      *
<a name="line-1815"></a>   Getting a result type
<a name="line-1816"></a>*                                                                      *
<a name="line-1817"></a>************************************************************************
<a name="line-1818"></a>
<a name="line-1819"></a>These are defined here to avoid a module loop between GHC.Core.Utils and GHC.Core.FVs
<a name="line-1820"></a>
<a name="line-1821"></a>-}</span>
<a name="line-1822"></a>
<a name="line-1823"></a><a name="applyTypeToArg"></a><span class='hs-definition'>applyTypeToArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1824"></a><span class='hs-comment'>-- ^ Determines the type resulting from applying an expression with given type</span>
<a name="line-1825"></a><span class='hs-comment'>-- to a given argument expression</span>
<a name="line-1826"></a><span class='hs-definition'>applyTypeToArg</span> <span class='hs-varid'>fun_ty</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>piResultTy</span> <span class='hs-varid'>fun_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprToType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-1827"></a>
<a name="line-1828"></a><a name="exprToType"></a><span class='hs-comment'>-- | If the expression is a 'Type', converts. Otherwise,</span>
<a name="line-1829"></a><span class='hs-comment'>-- panics. NB: This does /not/ convert 'Coercion' to 'CoercionTy'.</span>
<a name="line-1830"></a><span class='hs-definition'>exprToType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1831"></a><span class='hs-definition'>exprToType</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-1832"></a><span class='hs-definition'>exprToType</span> <span class='hs-sel'>_bad</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"exprToType"</span> <span class='hs-varid'>empty</span>
<a name="line-1833"></a>
<a name="line-1834"></a><a name="exprToCoercion_maybe"></a><span class='hs-comment'>-- | If the expression is a 'Coercion', converts.</span>
<a name="line-1835"></a><span class='hs-definition'>exprToCoercion_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Coercion</span>
<a name="line-1836"></a><span class='hs-definition'>exprToCoercion_maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>co</span>
<a name="line-1837"></a><span class='hs-definition'>exprToCoercion_maybe</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1838"></a>
<a name="line-1839"></a><span class='hs-comment'>{-
<a name="line-1840"></a>************************************************************************
<a name="line-1841"></a>*                                                                      *
<a name="line-1842"></a>\subsection{Simple access functions}
<a name="line-1843"></a>*                                                                      *
<a name="line-1844"></a>************************************************************************
<a name="line-1845"></a>-}</span>
<a name="line-1846"></a>
<a name="line-1847"></a><a name="bindersOf"></a><span class='hs-comment'>-- | Extract every variable by this group</span>
<a name="line-1848"></a><span class='hs-definition'>bindersOf</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1849"></a><span class='hs-comment'>-- If you edit this function, you may need to update the GHC formalism</span>
<a name="line-1850"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-1851"></a><span class='hs-definition'>bindersOf</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>binder</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>binder</span><span class='hs-keyglyph'>]</span>
<a name="line-1852"></a><span class='hs-definition'>bindersOf</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>binder</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>binder</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-1853"></a>
<a name="line-1854"></a><a name="bindersOfBinds"></a><span class='hs-comment'>-- | 'bindersOf' applied to a list of binding groups</span>
<a name="line-1855"></a><span class='hs-definition'>bindersOfBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1856"></a><span class='hs-definition'>bindersOfBinds</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>bindersOf</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>binds</span>
<a name="line-1857"></a>
<a name="line-1858"></a><a name="rhssOfBind"></a><span class='hs-definition'>rhssOfBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1859"></a><span class='hs-definition'>rhssOfBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span>
<a name="line-1860"></a><span class='hs-definition'>rhssOfBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-1861"></a>
<a name="line-1862"></a><a name="rhssOfAlts"></a><span class='hs-definition'>rhssOfAlts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span>
<a name="line-1863"></a><span class='hs-definition'>rhssOfAlts</span> <span class='hs-varid'>alts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>e</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>alts</span><span class='hs-keyglyph'>]</span>
<a name="line-1864"></a>
<a name="line-1865"></a><a name="flattenBinds"></a><span class='hs-comment'>-- | Collapse all the bindings in the supplied groups into a single</span>
<a name="line-1866"></a><span class='hs-comment'>-- list of lhs\/rhs pairs suitable for binding in a 'Rec' binding group</span>
<a name="line-1867"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1868"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>r</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>flattenBinds</span> <span class='hs-varid'>binds</span>
<a name="line-1869"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs1</span>   <span class='hs-conop'>:</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prs1</span> <span class='hs-varop'>++</span> <span class='hs-varid'>flattenBinds</span> <span class='hs-varid'>binds</span>
<a name="line-1870"></a><span class='hs-definition'>flattenBinds</span> <span class='hs-conid'>[]</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1871"></a>
<a name="line-1872"></a><a name="collectBinders"></a><span class='hs-comment'>-- | We often want to strip off leading lambdas before getting down to</span>
<a name="line-1873"></a><span class='hs-comment'>-- business. Variants are 'collectTyBinders', 'collectValBinders',</span>
<a name="line-1874"></a><span class='hs-comment'>-- and 'collectTyAndValBinders'</span>
<a name="line-1875"></a><span class='hs-definition'>collectBinders</span>         <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>     <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-1876"></a><a name="collectTyBinders"></a><span class='hs-definition'>collectTyBinders</span>       <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1877"></a><a name="collectValBinders"></a><span class='hs-definition'>collectValBinders</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1878"></a><a name="collectTyAndValBinders"></a><span class='hs-definition'>collectTyAndValBinders</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1879"></a><a name="collectNBinders"></a><span class='hs-comment'>-- | Strip off exactly N leading lambdas (type or value). Good for use with</span>
<a name="line-1880"></a><span class='hs-comment'>-- join points.</span>
<a name="line-1881"></a><span class='hs-definition'>collectNBinders</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-1882"></a>
<a name="line-1883"></a><span class='hs-definition'>collectBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1884"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-1885"></a>  <span class='hs-keyword'>where</span>
<a name="line-1886"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1887"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span>          <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1888"></a>
<a name="line-1889"></a><span class='hs-definition'>collectTyBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1890"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-1891"></a>  <span class='hs-keyword'>where</span>
<a name="line-1892"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1893"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>e</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1894"></a>
<a name="line-1895"></a><span class='hs-definition'>collectValBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1896"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-1897"></a>  <span class='hs-keyword'>where</span>
<a name="line-1898"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ids</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>ids</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1899"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>body</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1900"></a>
<a name="line-1901"></a><span class='hs-definition'>collectTyAndValBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1902"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1903"></a>  <span class='hs-keyword'>where</span>
<a name="line-1904"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectTyBinders</span> <span class='hs-varid'>expr</span>
<a name="line-1905"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>ids</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectValBinders</span> <span class='hs-varid'>body1</span>
<a name="line-1906"></a>
<a name="line-1907"></a><span class='hs-definition'>collectNBinders</span> <span class='hs-varid'>orig_n</span> <span class='hs-varid'>orig_expr</span>
<a name="line-1908"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>orig_n</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>orig_expr</span>
<a name="line-1909"></a>  <span class='hs-keyword'>where</span>
<a name="line-1910"></a>    <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>expr</span>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1911"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1912"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"collectNBinders"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>int</span> <span class='hs-varid'>orig_n</span>
<a name="line-1913"></a>
<a name="line-1914"></a><a name="collectArgs"></a><span class='hs-comment'>-- | Takes a nested application expression and returns the function</span>
<a name="line-1915"></a><span class='hs-comment'>-- being applied and the arguments to which it is applied</span>
<a name="line-1916"></a><span class='hs-definition'>collectArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1917"></a><span class='hs-definition'>collectArgs</span> <span class='hs-varid'>expr</span>
<a name="line-1918"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span>
<a name="line-1919"></a>  <span class='hs-keyword'>where</span>
<a name="line-1920"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-1921"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>         <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-1922"></a>
<a name="line-1923"></a><a name="stripNArgs"></a><span class='hs-comment'>-- | Attempt to remove the last N arguments of a function call.</span>
<a name="line-1924"></a><span class='hs-comment'>-- Strip off any ticks or coercions encountered along the way and any</span>
<a name="line-1925"></a><span class='hs-comment'>-- at the end.</span>
<a name="line-1926"></a><span class='hs-definition'>stripNArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Word</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-1927"></a><a name="!"></a><span class='hs-definition'>stripNArgs</span> <span class='hs-varop'>!</span><span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripNArgs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span>
<a name="line-1928"></a><span class='hs-definition'>stripNArgs</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripNArgs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>f</span>
<a name="line-1929"></a><span class='hs-definition'>stripNArgs</span> <span class='hs-num'>0</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>e</span>
<a name="line-1930"></a><span class='hs-definition'>stripNArgs</span> <span class='hs-varid'>n</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripNArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span>
<a name="line-1931"></a><span class='hs-definition'>stripNArgs</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1932"></a>
<a name="line-1933"></a><a name="collectArgsTicks"></a><span class='hs-comment'>-- | Like @collectArgs@, but also collects looks through floatable</span>
<a name="line-1934"></a><span class='hs-comment'>-- ticks if it means that we can find more arguments.</span>
<a name="line-1935"></a><span class='hs-definition'>collectArgsTicks</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreTickish</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span>
<a name="line-1936"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreTickish</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1937"></a><span class='hs-definition'>collectArgsTicks</span> <span class='hs-varid'>skipTick</span> <span class='hs-varid'>expr</span>
<a name="line-1938"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-1939"></a>  <span class='hs-keyword'>where</span>
<a name="line-1940"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>  <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span>
<a name="line-1941"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span>
<a name="line-1942"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>skipTick</span> <span class='hs-varid'>t</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>as</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-1943"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>          <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-1944"></a>
<a name="line-1945"></a>
<a name="line-1946"></a><span class='hs-comment'>{-
<a name="line-1947"></a>************************************************************************
<a name="line-1948"></a>*                                                                      *
<a name="line-1949"></a>\subsection{Predicates}
<a name="line-1950"></a>*                                                                      *
<a name="line-1951"></a>************************************************************************
<a name="line-1952"></a>
<a name="line-1953"></a>At one time we optionally carried type arguments through to runtime.
<a name="line-1954"></a>@isRuntimeVar v@ returns if (Lam v _) really becomes a lambda at runtime,
<a name="line-1955"></a>i.e. if type applications are actual lambdas because types are kept around
<a name="line-1956"></a>at runtime.  Similarly isRuntimeArg.
<a name="line-1957"></a>-}</span>
<a name="line-1958"></a>
<a name="line-1959"></a><a name="isRuntimeVar"></a><span class='hs-comment'>-- | Will this variable exist at runtime?</span>
<a name="line-1960"></a><span class='hs-definition'>isRuntimeVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1961"></a><span class='hs-definition'>isRuntimeVar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isId</span>
<a name="line-1962"></a>
<a name="line-1963"></a><a name="isRuntimeArg"></a><span class='hs-comment'>-- | Will this argument expression exist at runtime?</span>
<a name="line-1964"></a><span class='hs-definition'>isRuntimeArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1965"></a><span class='hs-definition'>isRuntimeArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isValArg</span>
<a name="line-1966"></a>
<a name="line-1967"></a><a name="isValArg"></a><span class='hs-comment'>-- | Returns @True@ for value arguments, false for type args</span>
<a name="line-1968"></a><span class='hs-comment'>-- NB: coercions are value arguments (zero width, to be sure,</span>
<a name="line-1969"></a><span class='hs-comment'>-- like State#, but still value args).</span>
<a name="line-1970"></a><span class='hs-definition'>isValArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1971"></a><span class='hs-definition'>isValArg</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeArg</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1972"></a>
<a name="line-1973"></a><a name="isTyCoArg"></a><span class='hs-comment'>-- | Returns @True@ iff the expression is a 'Type' or 'Coercion'</span>
<a name="line-1974"></a><span class='hs-comment'>-- expression at its top level</span>
<a name="line-1975"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1976"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1977"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1978"></a><span class='hs-definition'>isTyCoArg</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1979"></a>
<a name="line-1980"></a><a name="isCoArg"></a><span class='hs-comment'>-- | Returns @True@ iff the expression is a 'Coercion'</span>
<a name="line-1981"></a><span class='hs-comment'>-- expression at its top level</span>
<a name="line-1982"></a><span class='hs-definition'>isCoArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1983"></a><span class='hs-definition'>isCoArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1984"></a><span class='hs-definition'>isCoArg</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1985"></a>
<a name="line-1986"></a><a name="isTypeArg"></a><span class='hs-comment'>-- | Returns @True@ iff the expression is a 'Type' expression at its</span>
<a name="line-1987"></a><span class='hs-comment'>-- top level.  Note this does NOT include 'Coercion's.</span>
<a name="line-1988"></a><span class='hs-definition'>isTypeArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1989"></a><span class='hs-definition'>isTypeArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1990"></a><span class='hs-definition'>isTypeArg</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1991"></a>
<a name="line-1992"></a><a name="valBndrCount"></a><span class='hs-comment'>-- | The number of binders that bind values rather than types</span>
<a name="line-1993"></a><span class='hs-definition'>valBndrCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1994"></a><span class='hs-definition'>valBndrCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isId</span>
<a name="line-1995"></a>
<a name="line-1996"></a><a name="valArgCount"></a><span class='hs-comment'>-- | The number of argument expressions that are values rather than types at their top level</span>
<a name="line-1997"></a><span class='hs-definition'>valArgCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Arg</span> <span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1998"></a><span class='hs-definition'>valArgCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isValArg</span>
<a name="line-1999"></a>
<a name="line-2000"></a><span class='hs-comment'>{-
<a name="line-2001"></a>************************************************************************
<a name="line-2002"></a>*                                                                      *
<a name="line-2003"></a>\subsection{Annotated core}
<a name="line-2004"></a>*                                                                      *
<a name="line-2005"></a>************************************************************************
<a name="line-2006"></a>-}</span>
<a name="line-2007"></a>
<a name="line-2008"></a><a name="AnnExpr"></a><span class='hs-comment'>-- | Annotated core: allows annotation at every node in the tree</span>
<a name="line-2009"></a><a name="AnnExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>annot</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr'</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2010"></a>
<a name="line-2011"></a><a name="AnnExpr'"></a><span class='hs-comment'>-- | A clone of the 'Expr' type but allowing annotation at every tree node</span>
<a name="line-2012"></a><a name="AnnExpr'"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnnExpr'</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span>
<a name="line-2013"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AnnVar</span>      <span class='hs-conid'>Id</span>
<a name="line-2014"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnLit</span>      <span class='hs-conid'>Literal</span>
<a name="line-2015"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnLam</span>      <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2016"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnApp</span>      <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2017"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnCase</span>     <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-keyglyph'>]</span>
<a name="line-2018"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnLet</span>      <span class='hs-layout'>(</span><span class='hs-conid'>AnnBind</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2019"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnCast</span>     <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>annot</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-2020"></a>                   <span class='hs-comment'>-- Put an annotation on the (root of) the coercion</span>
<a name="line-2021"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnTick</span>     <span class='hs-conid'>CoreTickish</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2022"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnType</span>     <span class='hs-conid'>Type</span>
<a name="line-2023"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnCoercion</span> <span class='hs-conid'>Coercion</span>
<a name="line-2024"></a>
<a name="line-2025"></a><a name="AnnAlt"></a><span class='hs-comment'>-- | A clone of the 'Alt' type but allowing annotation at every tree node</span>
<a name="line-2026"></a><a name="AnnAlt"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AnnAlt</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2027"></a>
<a name="line-2028"></a><a name="AnnBind"></a><span class='hs-comment'>-- | A clone of the 'Bind' type but allowing annotation at every tree node</span>
<a name="line-2029"></a><a name="AnnBind"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnnBind</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span>
<a name="line-2030"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AnnNonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2031"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AnnRec</span>    <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2032"></a>
<a name="line-2033"></a><a name="collectAnnArgs"></a><span class='hs-comment'>-- | Takes a nested application expression and returns the function</span>
<a name="line-2034"></a><span class='hs-comment'>-- being applied and the arguments to which it is applied</span>
<a name="line-2035"></a><span class='hs-definition'>collectAnnArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2036"></a><span class='hs-definition'>collectAnnArgs</span> <span class='hs-varid'>expr</span>
<a name="line-2037"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span>
<a name="line-2038"></a>  <span class='hs-keyword'>where</span>
<a name="line-2039"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-2040"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>               <span class='hs-keyword'>as</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>)</span>
<a name="line-2041"></a>
<a name="line-2042"></a><a name="collectAnnArgsTicks"></a><span class='hs-definition'>collectAnnArgsTicks</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreTickish</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span>
<a name="line-2043"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>b</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreTickish</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2044"></a><span class='hs-definition'>collectAnnArgsTicks</span> <span class='hs-varid'>tickishOk</span> <span class='hs-varid'>expr</span>
<a name="line-2045"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>expr</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-2046"></a>  <span class='hs-keyword'>where</span>
<a name="line-2047"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnApp</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>  <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-conop'>:</span><span class='hs-keyword'>as</span><span class='hs-layout'>)</span> <span class='hs-varid'>ts</span>
<a name="line-2048"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnTick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishOk</span> <span class='hs-varid'>t</span>
<a name="line-2049"></a>                              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>as</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-2050"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>                <span class='hs-keyword'>as</span> <span class='hs-varid'>ts</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-keyword'>as</span><span class='hs-layout'>,</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-2051"></a>
<a name="line-2052"></a><a name="deAnnotate"></a><span class='hs-definition'>deAnnotate</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>bndr</span>
<a name="line-2053"></a><span class='hs-definition'>deAnnotate</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>deAnnotate'</span> <span class='hs-varid'>e</span>
<a name="line-2054"></a>
<a name="line-2055"></a><a name="deAnnotate'"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr'</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Expr</span> <span class='hs-varid'>bndr</span>
<a name="line-2056"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnType</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>t</span>
<a name="line-2057"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnCoercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span>
<a name="line-2058"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnVar</span>  <span class='hs-varid'>v</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span>
<a name="line-2059"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnLit</span>  <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span>
<a name="line-2060"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnLam</span>  <span class='hs-varid'>binder</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>binder</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2061"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnApp</span>  <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>App</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-2062"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnCast</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Cast</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-2063"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnTick</span> <span class='hs-varid'>tick</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>tick</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2064"></a>
<a name="line-2065"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnLet</span> <span class='hs-varid'>bind</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2066"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnBind</span> <span class='hs-varid'>bind</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2067"></a><span class='hs-definition'>deAnnotate'</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnCase</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2068"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>scrut</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>t</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>deAnnAlt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-2069"></a>
<a name="line-2070"></a><a name="deAnnAlt"></a><span class='hs-definition'>deAnnAlt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>bndr</span>
<a name="line-2071"></a><span class='hs-definition'>deAnnAlt</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnAlt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2072"></a>
<a name="line-2073"></a><a name="deAnnBind"></a><span class='hs-definition'>deAnnBind</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnBind</span> <span class='hs-varid'>b</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bind</span> <span class='hs-varid'>b</span>
<a name="line-2074"></a><span class='hs-definition'>deAnnBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnNonRec</span> <span class='hs-varid'>var</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>var</span> <span class='hs-layout'>(</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2075"></a><span class='hs-definition'>deAnnBind</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnnRec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rec</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span><span class='hs-varid'>deAnnotate</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pairs</span><span class='hs-keyglyph'>]</span>
<a name="line-2076"></a>
<a name="line-2077"></a><a name="collectAnnBndrs"></a><span class='hs-comment'>-- | As 'collectBinders' but for 'AnnExpr' rather than 'Expr'</span>
<a name="line-2078"></a><span class='hs-definition'>collectAnnBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2079"></a><span class='hs-definition'>collectAnnBndrs</span> <span class='hs-varid'>e</span>
<a name="line-2080"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>e</span>
<a name="line-2081"></a>  <span class='hs-keyword'>where</span>
<a name="line-2082"></a>    <span class='hs-varid'>collect</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnLam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-2083"></a>    <span class='hs-varid'>collect</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2084"></a>
<a name="line-2085"></a><a name="collectNAnnBndrs"></a><span class='hs-comment'>-- | As 'collectNBinders' but for 'AnnExpr' rather than 'Expr'</span>
<a name="line-2086"></a><span class='hs-definition'>collectNAnnBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnExpr</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>annot</span><span class='hs-layout'>)</span>
<a name="line-2087"></a><span class='hs-definition'>collectNAnnBndrs</span> <span class='hs-varid'>orig_n</span> <span class='hs-varid'>e</span>
<a name="line-2088"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-varid'>orig_n</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>e</span>
<a name="line-2089"></a>  <span class='hs-keyword'>where</span>
<a name="line-2090"></a>    <span class='hs-varid'>collect</span> <span class='hs-num'>0</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>body</span>               <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2091"></a>    <span class='hs-varid'>collect</span> <span class='hs-varid'>n</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnnLam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collect</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-2092"></a>    <span class='hs-varid'>collect</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"collectNBinders"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>int</span> <span class='hs-varid'>orig_n</span>
</pre></body>
</html>
