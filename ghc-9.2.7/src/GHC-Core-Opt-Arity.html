<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/Arity.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-4"></a>
<a name="line-5"></a>
<a name="line-6"></a>        Arity and eta expansion
<a name="line-7"></a>-}</span>
<a name="line-8"></a>
<a name="line-9"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-10"></a>
<a name="line-11"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-record-updates #-}</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-comment'>-- | Arity and eta expansion</span>
<a name="line-14"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.Arity</span>
<a name="line-15"></a>   <span class='hs-layout'>(</span> <span class='hs-varid'>manifestArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>joinRhsArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>exprArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>typeArity</span>
<a name="line-16"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>exprEtaExpandArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>findRhsArity</span>
<a name="line-17"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>etaExpand</span><span class='hs-layout'>,</span> <span class='hs-varid'>etaExpandAT</span>
<a name="line-18"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>exprBotStrictness_maybe</span>
<a name="line-19"></a>
<a name="line-20"></a>   <span class='hs-comment'>-- ** ArityType</span>
<a name="line-21"></a>   <span class='hs-layout'>,</span> <span class='hs-conid'>ArityType</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkBotArityType</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkManifestArityType</span><span class='hs-layout'>,</span> <span class='hs-varid'>expandableArityType</span>
<a name="line-22"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>arityTypeArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>maxWithArity</span><span class='hs-layout'>,</span> <span class='hs-varid'>idArityType</span>
<a name="line-23"></a>
<a name="line-24"></a>   <span class='hs-comment'>-- ** Join points</span>
<a name="line-25"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>etaExpandToJoinPoint</span><span class='hs-layout'>,</span> <span class='hs-varid'>etaExpandToJoinPointRule</span>
<a name="line-26"></a>
<a name="line-27"></a>   <span class='hs-comment'>-- ** Coercions and casts</span>
<a name="line-28"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>pushCoArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushCoArgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushCoValArg</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushCoTyArg</span>
<a name="line-29"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>pushCoercionIntoLambda</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushCoDataCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>collectBindersPushingCo</span>
<a name="line-30"></a>   <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>where</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-34"></a>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-46"></a>
<a name="line-47"></a><span class='hs-comment'>-- We have two sorts of substitution:</span>
<a name="line-48"></a><span class='hs-comment'>--   GHC.Core.Subst.Subst, and GHC.Core.TyCo.TCvSubst</span>
<a name="line-49"></a><span class='hs-comment'>-- Both have substTy, substCo  Hence need for qualification</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Subst</span>    <span class='hs-keyword'>as</span> <span class='hs-conid'>Core</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>     <span class='hs-keyword'>as</span> <span class='hs-conid'>Type</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Type</span>
<a name="line-53"></a>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>tyConArity</span> <span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon.RecWalk</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>initRecTc</span><span class='hs-layout'>,</span> <span class='hs-varid'>checkRecTc</span> <span class='hs-layout'>)</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Predicate</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isDictTy</span> <span class='hs-layout'>)</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Uniques</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span> <span class='hs-layout'>(</span> <span class='hs-conid'>DynFlags</span><span class='hs-layout'>,</span> <span class='hs-conid'>GeneralFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>gopt</span> <span class='hs-layout'>)</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Pair</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-68"></a>
<a name="line-69"></a><span class='hs-comment'>{-
<a name="line-70"></a>************************************************************************
<a name="line-71"></a>*                                                                      *
<a name="line-72"></a>              manifestArity and exprArity
<a name="line-73"></a>*                                                                      *
<a name="line-74"></a>************************************************************************
<a name="line-75"></a>
<a name="line-76"></a>exprArity is a cheap-and-cheerful version of exprEtaExpandArity.
<a name="line-77"></a>It tells how many things the expression can be applied to before doing
<a name="line-78"></a>any work.  It doesn't look inside cases, lets, etc.  The idea is that
<a name="line-79"></a>exprEtaExpandArity will do the hard work, leaving something that's easy
<a name="line-80"></a>for exprArity to grapple with.  In particular, Simplify uses exprArity to
<a name="line-81"></a>compute the ArityInfo for the Id.
<a name="line-82"></a>
<a name="line-83"></a>Originally I thought that it was enough just to look for top-level lambdas, but
<a name="line-84"></a>it isn't.  I've seen this
<a name="line-85"></a>
<a name="line-86"></a>        foo = PrelBase.timesInt
<a name="line-87"></a>
<a name="line-88"></a>We want foo to get arity 2 even though the eta-expander will leave it
<a name="line-89"></a>unchanged, in the expectation that it'll be inlined.  But occasionally it
<a name="line-90"></a>isn't, because foo is blacklisted (used in a rule).
<a name="line-91"></a>
<a name="line-92"></a>Similarly, see the ok_note check in exprEtaExpandArity.  So
<a name="line-93"></a>        f = __inline_me (\x -&gt; e)
<a name="line-94"></a>won't be eta-expanded.
<a name="line-95"></a>
<a name="line-96"></a>And in any case it seems more robust to have exprArity be a bit more intelligent.
<a name="line-97"></a>But note that   (\x y z -&gt; f x y z)
<a name="line-98"></a>should have arity 3, regardless of f's arity.
<a name="line-99"></a>-}</span>
<a name="line-100"></a>
<a name="line-101"></a><a name="manifestArity"></a><span class='hs-definition'>manifestArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span>
<a name="line-102"></a><span class='hs-comment'>-- ^ manifestArity sees how many leading value lambdas there are,</span>
<a name="line-103"></a><span class='hs-comment'>--   after looking through casts</span>
<a name="line-104"></a><span class='hs-definition'>manifestArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>manifestArity</span> <span class='hs-varid'>e</span>
<a name="line-105"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>manifestArity</span> <span class='hs-varid'>e</span>
<a name="line-106"></a><span class='hs-definition'>manifestArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>manifestArity</span> <span class='hs-varid'>e</span>
<a name="line-107"></a><span class='hs-definition'>manifestArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>manifestArity</span> <span class='hs-varid'>e</span>
<a name="line-108"></a><span class='hs-definition'>manifestArity</span> <span class='hs-keyword'>_</span>                         <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-109"></a>
<a name="line-110"></a><a name="joinRhsArity"></a><span class='hs-definition'>joinRhsArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>JoinArity</span>
<a name="line-111"></a><span class='hs-comment'>-- Join points are supposed to have manifestly-visible</span>
<a name="line-112"></a><span class='hs-comment'>-- lambdas at the top: no ticks, no casts, nothing</span>
<a name="line-113"></a><span class='hs-comment'>-- Moreover, type lambdas count in JoinArity</span>
<a name="line-114"></a><span class='hs-definition'>joinRhsArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>joinRhsArity</span> <span class='hs-varid'>e</span>
<a name="line-115"></a><span class='hs-definition'>joinRhsArity</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-116"></a>
<a name="line-117"></a>
<a name="line-118"></a><a name="exprArity"></a><span class='hs-comment'>---------------</span>
<a name="line-119"></a><span class='hs-definition'>exprArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span>
<a name="line-120"></a><span class='hs-comment'>-- ^ An approximate, fast, version of 'exprEtaExpandArity'</span>
<a name="line-121"></a><span class='hs-definition'>exprArity</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>
<a name="line-122"></a>  <span class='hs-keyword'>where</span>
<a name="line-123"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>v</span>
<a name="line-124"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>x</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span>
<a name="line-125"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>
<a name="line-126"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>
<a name="line-127"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trim_arity</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionRKind</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-128"></a>                                        <span class='hs-comment'>-- Note [exprArity invariant]</span>
<a name="line-129"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>e</span>
<a name="line-130"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>f</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`max`</span> <span class='hs-num'>0</span>
<a name="line-131"></a>        <span class='hs-comment'>-- See Note [exprArity for applications]</span>
<a name="line-132"></a>        <span class='hs-comment'>-- NB: coercions count as a value argument</span>
<a name="line-133"></a>
<a name="line-134"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-135"></a>
<a name="line-136"></a>    <span class='hs-varid'>trim_arity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span>
<a name="line-137"></a>    <span class='hs-varid'>trim_arity</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arity</span> <span class='hs-varop'>`min`</span> <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeArity</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-138"></a>
<a name="line-139"></a><a name="typeArity"></a><span class='hs-comment'>---------------</span>
<a name="line-140"></a><span class='hs-definition'>typeArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>
<a name="line-141"></a><span class='hs-comment'>-- How many value arrows are visible in the type?</span>
<a name="line-142"></a><span class='hs-comment'>-- We look through foralls, and newtypes</span>
<a name="line-143"></a><span class='hs-comment'>-- See Note [exprArity invariant]</span>
<a name="line-144"></a><span class='hs-definition'>typeArity</span> <span class='hs-varid'>ty</span>
<a name="line-145"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>initRecTc</span> <span class='hs-varid'>ty</span>
<a name="line-146"></a>  <span class='hs-keyword'>where</span>
<a name="line-147"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>ty</span>
<a name="line-148"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-149"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>ty'</span>
<a name="line-150"></a>
<a name="line-151"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>arg</span><span class='hs-layout'>,</span><span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-152"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeOneShot</span> <span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>res</span>
<a name="line-153"></a>
<a name="line-154"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-155"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>instNewTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-156"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rec_nts'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkRecTc</span> <span class='hs-varid'>rec_nts</span> <span class='hs-varid'>tc</span>  <span class='hs-comment'>-- See Note [Expanding newtypes]</span>
<a name="line-157"></a>                                                <span class='hs-comment'>-- in GHC.Core.TyCon</span>
<a name="line-158"></a><span class='hs-comment'>--   , not (isClassTyCon tc)    -- Do not eta-expand through newtype classes</span>
<a name="line-159"></a><span class='hs-comment'>--                              -- See Note [Newtype classes and eta expansion]</span>
<a name="line-160"></a><span class='hs-comment'>--                              (no longer required)</span>
<a name="line-161"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>rec_nts'</span> <span class='hs-varid'>ty'</span>
<a name="line-162"></a>        <span class='hs-comment'>-- Important to look through non-recursive newtypes, so that, eg</span>
<a name="line-163"></a>        <span class='hs-comment'>--      (f x)   where f has arity 2, f :: Int -&gt; IO ()</span>
<a name="line-164"></a>        <span class='hs-comment'>-- Here we want to get arity 1 for the result!</span>
<a name="line-165"></a>        <span class='hs-comment'>--</span>
<a name="line-166"></a>        <span class='hs-comment'>-- AND through a layer of recursive newtypes</span>
<a name="line-167"></a>        <span class='hs-comment'>-- e.g. newtype Stream m a b = Stream (m (Either b (a, Stream m a b)))</span>
<a name="line-168"></a>
<a name="line-169"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-170"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-171"></a>
<a name="line-172"></a><a name="exprBotStrictness_maybe"></a><span class='hs-comment'>---------------</span>
<a name="line-173"></a><span class='hs-definition'>exprBotStrictness_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Arity</span><span class='hs-layout'>,</span> <span class='hs-conid'>StrictSig</span><span class='hs-layout'>)</span>
<a name="line-174"></a><span class='hs-comment'>-- A cheap and cheerful function that identifies bottoming functions</span>
<a name="line-175"></a><span class='hs-comment'>-- and gives them a suitable strictness signatures.  It's used during</span>
<a name="line-176"></a><span class='hs-comment'>-- float-out</span>
<a name="line-177"></a><span class='hs-definition'>exprBotStrictness_maybe</span> <span class='hs-varid'>e</span>
<a name="line-178"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>getBotArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>botStrictnessArityEnv</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-179"></a>        <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-180"></a>        <span class='hs-conid'>Just</span> <span class='hs-varid'>ar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ar</span><span class='hs-layout'>,</span> <span class='hs-varid'>sig</span> <span class='hs-varid'>ar</span><span class='hs-layout'>)</span>
<a name="line-181"></a>  <span class='hs-keyword'>where</span>
<a name="line-182"></a>    <span class='hs-varid'>sig</span> <span class='hs-varid'>ar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>replicate</span> <span class='hs-varid'>ar</span> <span class='hs-varid'>topDmd</span><span class='hs-layout'>)</span> <span class='hs-varid'>botDiv</span>
<a name="line-183"></a>
<a name="line-184"></a><span class='hs-comment'>{-
<a name="line-185"></a>Note [exprArity invariant]
<a name="line-186"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-187"></a>exprArity has the following invariants:
<a name="line-188"></a>
<a name="line-189"></a>  (1) If typeArity (exprType e) = n,
<a name="line-190"></a>      then manifestArity (etaExpand e n) = n
<a name="line-191"></a>
<a name="line-192"></a>      That is, etaExpand can always expand as much as typeArity says
<a name="line-193"></a>      So the case analysis in etaExpand and in typeArity must match
<a name="line-194"></a>
<a name="line-195"></a>  (2) exprArity e &lt;= typeArity (exprType e)
<a name="line-196"></a>
<a name="line-197"></a>  (3) Hence if (exprArity e) = n, then manifestArity (etaExpand e n) = n
<a name="line-198"></a>
<a name="line-199"></a>      That is, if exprArity says "the arity is n" then etaExpand really
<a name="line-200"></a>      can get "n" manifest lambdas to the top.
<a name="line-201"></a>
<a name="line-202"></a>Why is this important?  Because
<a name="line-203"></a>  - In GHC.Iface.Tidy we use exprArity to fix the *final arity* of
<a name="line-204"></a>    each top-level Id, and in
<a name="line-205"></a>  - In CorePrep we use etaExpand on each rhs, so that the visible lambdas
<a name="line-206"></a>    actually match that arity, which in turn means
<a name="line-207"></a>    that the StgRhs has the right number of lambdas
<a name="line-208"></a>
<a name="line-209"></a>An alternative would be to do the eta-expansion in GHC.Iface.Tidy, at least
<a name="line-210"></a>for top-level bindings, in which case we would not need the trim_arity
<a name="line-211"></a>in exprArity.  That is a less local change, so I'm going to leave it for today!
<a name="line-212"></a>
<a name="line-213"></a>Note [Newtype classes and eta expansion]
<a name="line-214"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-215"></a>    NB: this nasty special case is no longer required, because
<a name="line-216"></a>    for newtype classes we don't use the class-op rule mechanism
<a name="line-217"></a>    at all.  See Note [Single-method classes] in GHC.Tc.TyCl.Instance. SLPJ May 2013
<a name="line-218"></a>
<a name="line-219"></a>-------- Old out of date comments, just for interest -----------
<a name="line-220"></a>We have to be careful when eta-expanding through newtypes.  In general
<a name="line-221"></a>it's a good idea, but annoyingly it interacts badly with the class-op
<a name="line-222"></a>rule mechanism.  Consider
<a name="line-223"></a>
<a name="line-224"></a>   class C a where { op :: a -&gt; a }
<a name="line-225"></a>   instance C b =&gt; C [b] where
<a name="line-226"></a>     op x = ...
<a name="line-227"></a>
<a name="line-228"></a>These translate to
<a name="line-229"></a>
<a name="line-230"></a>   co :: forall a. (a-&gt;a) ~ C a
<a name="line-231"></a>
<a name="line-232"></a>   $copList :: C b -&gt; [b] -&gt; [b]
<a name="line-233"></a>   $copList d x = ...
<a name="line-234"></a>
<a name="line-235"></a>   $dfList :: C b -&gt; C [b]
<a name="line-236"></a>   {-# DFunUnfolding = [$copList] #-}
<a name="line-237"></a>   $dfList d = $copList d |&gt; co@[b]
<a name="line-238"></a>
<a name="line-239"></a>Now suppose we have:
<a name="line-240"></a>
<a name="line-241"></a>   dCInt :: C Int
<a name="line-242"></a>
<a name="line-243"></a>   blah :: [Int] -&gt; [Int]
<a name="line-244"></a>   blah = op ($dfList dCInt)
<a name="line-245"></a>
<a name="line-246"></a>Now we want the built-in op/$dfList rule will fire to give
<a name="line-247"></a>   blah = $copList dCInt
<a name="line-248"></a>
<a name="line-249"></a>But with eta-expansion 'blah' might (and in #3772, which is
<a name="line-250"></a>slightly more complicated, does) turn into
<a name="line-251"></a>
<a name="line-252"></a>   blah = op (\eta. ($dfList dCInt |&gt; sym co) eta)
<a name="line-253"></a>
<a name="line-254"></a>and now it is *much* harder for the op/$dfList rule to fire, because
<a name="line-255"></a>exprIsConApp_maybe won't hold of the argument to op.  I considered
<a name="line-256"></a>trying to *make* it hold, but it's tricky and I gave up.
<a name="line-257"></a>
<a name="line-258"></a>The test simplCore/should_compile/T3722 is an excellent example.
<a name="line-259"></a>-------- End of old out of date comments, just for interest -----------
<a name="line-260"></a>
<a name="line-261"></a>
<a name="line-262"></a>Note [exprArity for applications]
<a name="line-263"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-264"></a>When we come to an application we check that the arg is trivial.
<a name="line-265"></a>   eg  f (fac x) does not have arity 2,
<a name="line-266"></a>                 even if f has arity 3!
<a name="line-267"></a>
<a name="line-268"></a>* We require that is trivial rather merely cheap.  Suppose f has arity 2.
<a name="line-269"></a>  Then    f (Just y)
<a name="line-270"></a>  has arity 0, because if we gave it arity 1 and then inlined f we'd get
<a name="line-271"></a>          let v = Just y in \w. &lt;f-body&gt;
<a name="line-272"></a>  which has arity 0.  And we try to maintain the invariant that we don't
<a name="line-273"></a>  have arity decreases.
<a name="line-274"></a>
<a name="line-275"></a>*  The `max 0` is important!  (\x y -&gt; f x) has arity 2, even if f is
<a name="line-276"></a>   unknown, hence arity 0
<a name="line-277"></a>
<a name="line-278"></a>
<a name="line-279"></a>************************************************************************
<a name="line-280"></a>*                                                                      *
<a name="line-281"></a>           Computing the "arity" of an expression
<a name="line-282"></a>*                                                                      *
<a name="line-283"></a>************************************************************************
<a name="line-284"></a>
<a name="line-285"></a>Note [Definition of arity]
<a name="line-286"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-287"></a>The "arity" of an expression 'e' is n if
<a name="line-288"></a>   applying 'e' to *fewer* than n *value* arguments
<a name="line-289"></a>   converges rapidly
<a name="line-290"></a>
<a name="line-291"></a>Or, to put it another way
<a name="line-292"></a>
<a name="line-293"></a>   there is no work lost in duplicating the partial
<a name="line-294"></a>   application (e x1 .. x(n-1))
<a name="line-295"></a>
<a name="line-296"></a>In the divergent case, no work is lost by duplicating because if the thing
<a name="line-297"></a>is evaluated once, that's the end of the program.
<a name="line-298"></a>
<a name="line-299"></a>Or, to put it another way, in any context C
<a name="line-300"></a>
<a name="line-301"></a>   C[ (\x1 .. xn. e x1 .. xn) ]
<a name="line-302"></a>         is as efficient as
<a name="line-303"></a>   C[ e ]
<a name="line-304"></a>
<a name="line-305"></a>It's all a bit more subtle than it looks:
<a name="line-306"></a>
<a name="line-307"></a>Note [One-shot lambdas]
<a name="line-308"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-309"></a>Consider one-shot lambdas
<a name="line-310"></a>                let x = expensive in \y z -&gt; E
<a name="line-311"></a>We want this to have arity 1 if the \y-abstraction is a 1-shot lambda.
<a name="line-312"></a>
<a name="line-313"></a>Note [Dealing with bottom]
<a name="line-314"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-315"></a>A Big Deal with computing arities is expressions like
<a name="line-316"></a>
<a name="line-317"></a>   f = \x -&gt; case x of
<a name="line-318"></a>               True  -&gt; \s -&gt; e1
<a name="line-319"></a>               False -&gt; \s -&gt; e2
<a name="line-320"></a>
<a name="line-321"></a>This happens all the time when f :: Bool -&gt; IO ()
<a name="line-322"></a>In this case we do eta-expand, in order to get that \s to the
<a name="line-323"></a>top, and give f arity 2.
<a name="line-324"></a>
<a name="line-325"></a>This isn't really right in the presence of seq.  Consider
<a name="line-326"></a>        (f bot) `seq` 1
<a name="line-327"></a>
<a name="line-328"></a>This should diverge!  But if we eta-expand, it won't.  We ignore this
<a name="line-329"></a>"problem" (unless -fpedantic-bottoms is on), because being scrupulous
<a name="line-330"></a>would lose an important transformation for many programs. (See
<a name="line-331"></a>#5587 for an example.)
<a name="line-332"></a>
<a name="line-333"></a>Consider also
<a name="line-334"></a>        f = \x -&gt; error "foo"
<a name="line-335"></a>Here, arity 1 is fine.  But if it is
<a name="line-336"></a>        f = \x -&gt; case x of
<a name="line-337"></a>                        True  -&gt; error "foo"
<a name="line-338"></a>                        False -&gt; \y -&gt; x+y
<a name="line-339"></a>then we want to get arity 2.  Technically, this isn't quite right, because
<a name="line-340"></a>        (f True) `seq` 1
<a name="line-341"></a>should diverge, but it'll converge if we eta-expand f.  Nevertheless, we
<a name="line-342"></a>do so; it improves some programs significantly, and increasing convergence
<a name="line-343"></a>isn't a bad thing.  Hence the ABot/ATop in ArityType.
<a name="line-344"></a>
<a name="line-345"></a>So these two transformations aren't always the Right Thing, and we
<a name="line-346"></a>have several tickets reporting unexpected behaviour resulting from
<a name="line-347"></a>this transformation.  So we try to limit it as much as possible:
<a name="line-348"></a>
<a name="line-349"></a> (1) Do NOT move a lambda outside a known-bottom case expression
<a name="line-350"></a>       case undefined of { (a,b) -&gt; \y -&gt; e }
<a name="line-351"></a>     This showed up in #5557
<a name="line-352"></a>
<a name="line-353"></a> (2) Do NOT move a lambda outside a case unless
<a name="line-354"></a>     (a) The scrutinee is ok-for-speculation, or
<a name="line-355"></a>     (b) more liberally: the scrutinee is cheap (e.g. a variable), and
<a name="line-356"></a>         -fpedantic-bottoms is not enforced (see #2915 for an example)
<a name="line-357"></a>
<a name="line-358"></a>Of course both (1) and (2) are readily defeated by disguising the bottoms.
<a name="line-359"></a>
<a name="line-360"></a>4. Note [Newtype arity]
<a name="line-361"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-362"></a>Non-recursive newtypes are transparent, and should not get in the way.
<a name="line-363"></a>We do (currently) eta-expand recursive newtypes too.  So if we have, say
<a name="line-364"></a>
<a name="line-365"></a>        newtype T = MkT ([T] -&gt; Int)
<a name="line-366"></a>
<a name="line-367"></a>Suppose we have
<a name="line-368"></a>        e = coerce T f
<a name="line-369"></a>where f has arity 1.  Then: etaExpandArity e = 1;
<a name="line-370"></a>that is, etaExpandArity looks through the coerce.
<a name="line-371"></a>
<a name="line-372"></a>When we eta-expand e to arity 1: eta_expand 1 e T
<a name="line-373"></a>we want to get:                  coerce T (\x::[T] -&gt; (coerce ([T]-&gt;Int) e) x)
<a name="line-374"></a>
<a name="line-375"></a>  HOWEVER, note that if you use coerce bogusly you can ge
<a name="line-376"></a>        coerce Int negate
<a name="line-377"></a>  And since negate has arity 2, you might try to eta expand.  But you can't
<a name="line-378"></a>  decompose Int to a function type.   Hence the final case in eta_expand.
<a name="line-379"></a>
<a name="line-380"></a>Note [The state-transformer hack]
<a name="line-381"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-382"></a>Suppose we have
<a name="line-383"></a>        f = e
<a name="line-384"></a>where e has arity n.  Then, if we know from the context that f has
<a name="line-385"></a>a usage type like
<a name="line-386"></a>        t1 -&gt; ... -&gt; tn -1-&gt; t(n+1) -1-&gt; ... -1-&gt; tm -&gt; ...
<a name="line-387"></a>then we can expand the arity to m.  This usage type says that
<a name="line-388"></a>any application (x e1 .. en) will be applied to uniquely to (m-n) more args
<a name="line-389"></a>Consider f = \x. let y = &lt;expensive&gt;
<a name="line-390"></a>                 in case x of
<a name="line-391"></a>                      True  -&gt; foo
<a name="line-392"></a>                      False -&gt; \(s:RealWorld) -&gt; e
<a name="line-393"></a>where foo has arity 1.  Then we want the state hack to
<a name="line-394"></a>apply to foo too, so we can eta expand the case.
<a name="line-395"></a>
<a name="line-396"></a>Then we expect that if f is applied to one arg, it'll be applied to two
<a name="line-397"></a>(that's the hack -- we don't really know, and sometimes it's false)
<a name="line-398"></a>See also Id.isOneShotBndr.
<a name="line-399"></a>
<a name="line-400"></a>Note [State hack and bottoming functions]
<a name="line-401"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-402"></a>It's a terrible idea to use the state hack on a bottoming function.
<a name="line-403"></a>Here's what happens (#2861):
<a name="line-404"></a>
<a name="line-405"></a>  f :: String -&gt; IO T
<a name="line-406"></a>  f = \p. error "..."
<a name="line-407"></a>
<a name="line-408"></a>Eta-expand, using the state hack:
<a name="line-409"></a>
<a name="line-410"></a>  f = \p. (\s. ((error "...") |&gt; g1) s) |&gt; g2
<a name="line-411"></a>  g1 :: IO T ~ (S -&gt; (S,T))
<a name="line-412"></a>  g2 :: (S -&gt; (S,T)) ~ IO T
<a name="line-413"></a>
<a name="line-414"></a>Extrude the g2
<a name="line-415"></a>
<a name="line-416"></a>  f' = \p. \s. ((error "...") |&gt; g1) s
<a name="line-417"></a>  f = f' |&gt; (String -&gt; g2)
<a name="line-418"></a>
<a name="line-419"></a>Discard args for bottomming function
<a name="line-420"></a>
<a name="line-421"></a>  f' = \p. \s. ((error "...") |&gt; g1 |&gt; g3
<a name="line-422"></a>  g3 :: (S -&gt; (S,T)) ~ (S,T)
<a name="line-423"></a>
<a name="line-424"></a>Extrude g1.g3
<a name="line-425"></a>
<a name="line-426"></a>  f'' = \p. \s. (error "...")
<a name="line-427"></a>  f' = f'' |&gt; (String -&gt; S -&gt; g1.g3)
<a name="line-428"></a>
<a name="line-429"></a>And now we can repeat the whole loop.  Aargh!  The bug is in applying the
<a name="line-430"></a>state hack to a function which then swallows the argument.
<a name="line-431"></a>
<a name="line-432"></a>This arose in another guise in #3959.  Here we had
<a name="line-433"></a>
<a name="line-434"></a>     catch# (throw exn &gt;&gt; return ())
<a name="line-435"></a>
<a name="line-436"></a>Note that (throw :: forall a e. Exn e =&gt; e -&gt; a) is called with [a = IO ()].
<a name="line-437"></a>After inlining (&gt;&gt;) we get
<a name="line-438"></a>
<a name="line-439"></a>     catch# (\_. throw {IO ()} exn)
<a name="line-440"></a>
<a name="line-441"></a>We must *not* eta-expand to
<a name="line-442"></a>
<a name="line-443"></a>     catch# (\_ _. throw {...} exn)
<a name="line-444"></a>
<a name="line-445"></a>because 'catch#' expects to get a (# _,_ #) after applying its argument to
<a name="line-446"></a>a State#, not another function!
<a name="line-447"></a>
<a name="line-448"></a>In short, we use the state hack to allow us to push let inside a lambda,
<a name="line-449"></a>but not to introduce a new lambda.
<a name="line-450"></a>
<a name="line-451"></a>
<a name="line-452"></a>Note [ArityType]
<a name="line-453"></a>~~~~~~~~~~~~~~~~
<a name="line-454"></a>ArityType is the result of a compositional analysis on expressions,
<a name="line-455"></a>from which we can decide the real arity of the expression (extracted
<a name="line-456"></a>with function exprEtaExpandArity).
<a name="line-457"></a>
<a name="line-458"></a>We use the following notation:
<a name="line-459"></a>  at  ::= \o1..on.div
<a name="line-460"></a>  div ::= T | x | ⊥
<a name="line-461"></a>  o   ::= ? | 1
<a name="line-462"></a>And omit the \. if n = 0. Examples:
<a name="line-463"></a>  \?11.T stands for @AT [NoOneShotInfo,OneShotLam,OneShotLam] topDiv@
<a name="line-464"></a>  ⊥      stands for @AT [] botDiv@
<a name="line-465"></a>See the 'Outputable' instance for more information. It's pretty simple.
<a name="line-466"></a>
<a name="line-467"></a>Here is what the fields mean. If an arbitrary expression 'f' has
<a name="line-468"></a>ArityType 'at', then
<a name="line-469"></a>
<a name="line-470"></a> * If @at = AT [o1,..,on] botDiv@ (notation: \o1..on.⊥), then @f x1..xn@
<a name="line-471"></a>   definitely diverges. Partial applications to fewer than n args may *or
<a name="line-472"></a>   may not* diverge.
<a name="line-473"></a>
<a name="line-474"></a>   We allow ourselves to eta-expand bottoming functions, even
<a name="line-475"></a>   if doing so may lose some `seq` sharing,
<a name="line-476"></a>       let x = &lt;expensive&gt; in \y. error (g x y)
<a name="line-477"></a>       ==&gt; \y. let x = &lt;expensive&gt; in error (g x y)
<a name="line-478"></a>
<a name="line-479"></a> * If @at = AT [o1,..,on] topDiv@ (notation: \o1..on.T), then expanding 'f'
<a name="line-480"></a>   to @\x1..xn. f x1..xn@ loses no sharing, assuming the calls of f respect
<a name="line-481"></a>   the one-shot-ness o1..on of its definition.
<a name="line-482"></a>
<a name="line-483"></a>   NB 'f' is an arbitrary expression, eg @f = g e1 e2@.  This 'f' can have
<a name="line-484"></a>   arity type @AT oss _@, with @length oss &gt; 0@, only if e1 e2 are themselves
<a name="line-485"></a>   cheap.
<a name="line-486"></a>
<a name="line-487"></a> * In both cases, @f@, @f x1@, ... @f x1 ... x(n-1)@ are definitely
<a name="line-488"></a>   really functions, or bottom, but *not* casts from a data type, in
<a name="line-489"></a>   at least one case branch.  (If it's a function in one case branch but
<a name="line-490"></a>   an unsafe cast from a data type in another, the program is bogus.)
<a name="line-491"></a>   So eta expansion is dynamically ok; see Note [State hack and
<a name="line-492"></a>   bottoming functions], the part about catch#
<a name="line-493"></a>
<a name="line-494"></a>Example:
<a name="line-495"></a>      f = \x\y. let v = &lt;expensive&gt; in
<a name="line-496"></a>          \s(one-shot) \t(one-shot). blah
<a name="line-497"></a>      'f' has arity type \??11.T
<a name="line-498"></a>      The one-shot-ness means we can, in effect, push that
<a name="line-499"></a>      'let' inside the \st.
<a name="line-500"></a>
<a name="line-501"></a>
<a name="line-502"></a>Suppose f = \xy. x+y
<a name="line-503"></a>Then  f             :: \??.T
<a name="line-504"></a>      f v           :: \?.T
<a name="line-505"></a>      f &lt;expensive&gt; :: T
<a name="line-506"></a>-}</span>
<a name="line-507"></a>
<a name="line-508"></a>
<a name="line-509"></a><a name="ArityType"></a><span class='hs-comment'>-- | The analysis lattice of arity analysis. It is isomorphic to</span>
<a name="line-510"></a><a name="ArityType"></a><span class='hs-comment'>--</span>
<a name="line-511"></a><a name="ArityType"></a><span class='hs-comment'>-- @</span>
<a name="line-512"></a><a name="ArityType"></a><span class='hs-comment'>--    data ArityType'</span>
<a name="line-513"></a><a name="ArityType"></a><span class='hs-comment'>--      = AEnd Divergence</span>
<a name="line-514"></a><a name="ArityType"></a><span class='hs-comment'>--      | ALam OneShotInfo ArityType'</span>
<a name="line-515"></a><a name="ArityType"></a><span class='hs-comment'>-- @</span>
<a name="line-516"></a><a name="ArityType"></a><span class='hs-comment'>--</span>
<a name="line-517"></a><a name="ArityType"></a><span class='hs-comment'>-- Which is easier to display the Hasse diagram for:</span>
<a name="line-518"></a><a name="ArityType"></a><span class='hs-comment'>--</span>
<a name="line-519"></a><a name="ArityType"></a><span class='hs-comment'>-- @</span>
<a name="line-520"></a><a name="ArityType"></a><span class='hs-comment'>--  ALam OneShotLam at</span>
<a name="line-521"></a><a name="ArityType"></a><span class='hs-comment'>--          |</span>
<a name="line-522"></a><a name="ArityType"></a><span class='hs-comment'>--      AEnd topDiv</span>
<a name="line-523"></a><a name="ArityType"></a><span class='hs-comment'>--          |</span>
<a name="line-524"></a><a name="ArityType"></a><span class='hs-comment'>--  ALam NoOneShotInfo at</span>
<a name="line-525"></a><a name="ArityType"></a><span class='hs-comment'>--          |</span>
<a name="line-526"></a><a name="ArityType"></a><span class='hs-comment'>--      AEnd exnDiv</span>
<a name="line-527"></a><a name="ArityType"></a><span class='hs-comment'>--          |</span>
<a name="line-528"></a><a name="ArityType"></a><span class='hs-comment'>--      AEnd botDiv</span>
<a name="line-529"></a><a name="ArityType"></a><span class='hs-comment'>-- @</span>
<a name="line-530"></a><a name="ArityType"></a><span class='hs-comment'>--</span>
<a name="line-531"></a><a name="ArityType"></a><span class='hs-comment'>-- where the @at@ fields of @ALam@ are inductively subject to the same order.</span>
<a name="line-532"></a><a name="ArityType"></a><span class='hs-comment'>-- That is, @ALam os at1 &lt; ALam os at2@ iff @at1 &lt; at2@.</span>
<a name="line-533"></a><a name="ArityType"></a><span class='hs-comment'>--</span>
<a name="line-534"></a><a name="ArityType"></a><span class='hs-comment'>-- Why the strange Top element?</span>
<a name="line-535"></a><a name="ArityType"></a><span class='hs-comment'>--   See Note [Combining case branches: optimistic one-shot-ness]</span>
<a name="line-536"></a><a name="ArityType"></a><span class='hs-comment'>--</span>
<a name="line-537"></a><a name="ArityType"></a><span class='hs-comment'>-- We rely on this lattice structure for fixed-point iteration in</span>
<a name="line-538"></a><a name="ArityType"></a><span class='hs-comment'>-- 'findRhsArity'. For the semantics of 'ArityType', see Note [ArityType].</span>
<a name="line-539"></a><a name="ArityType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArityType</span>
<a name="line-540"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-varop'>!</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>!</span><span class='hs-conid'>Divergence</span>
<a name="line-541"></a>  <span class='hs-comment'>-- ^ @AT oss div@ means this value can safely be eta-expanded @length oss@</span>
<a name="line-542"></a>  <span class='hs-comment'>-- times, provided use sites respect the 'OneShotInfo's in @oss@.</span>
<a name="line-543"></a>  <span class='hs-comment'>-- A 'OneShotLam' annotation can come from two sources:</span>
<a name="line-544"></a>  <span class='hs-comment'>--     * The user annotated a lambda as one-shot with 'GHC.Exts.oneShot'</span>
<a name="line-545"></a>  <span class='hs-comment'>--     * It's from a lambda binder of a type affected by `-fstate-hack`.</span>
<a name="line-546"></a>  <span class='hs-comment'>--       See 'idStateHackOneShotInfo'.</span>
<a name="line-547"></a>  <span class='hs-comment'>-- In both cases, 'OneShotLam' should win over 'NoOneShotInfo', see</span>
<a name="line-548"></a>  <span class='hs-comment'>-- Note [Combining case branches].</span>
<a name="line-549"></a>  <span class='hs-comment'>--</span>
<a name="line-550"></a>  <span class='hs-comment'>-- If @div@ is dead-ending ('isDeadEndDiv'), then application to</span>
<a name="line-551"></a>  <span class='hs-comment'>-- @length os@ arguments will surely diverge, similar to the situation</span>
<a name="line-552"></a>  <span class='hs-comment'>-- with 'DmdType'.</span>
<a name="line-553"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Eq</span>
<a name="line-554"></a>
<a name="line-555"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- | This is the BNF of the generated output:</span>
<a name="line-556"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>--</span>
<a name="line-557"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- @</span>
<a name="line-558"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- @</span>
<a name="line-559"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>--</span>
<a name="line-560"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- We format</span>
<a name="line-561"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- @AT [o1,..,on] topDiv@ as @\o1..on.T@ and</span>
<a name="line-562"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- @AT [o1,..,on] botDiv@ as @\o1..on.⊥@, respectively.</span>
<a name="line-563"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- More concretely, @AT [NOI,OS,OS] topDiv@ is formatted as @\?11.T@.</span>
<a name="line-564"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-comment'>-- If the one-shot info is empty, we omit the leading @\.@.</span>
<a name="line-565"></a><a name="instance%20Outputable%20ArityType"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyword'>where</span>
<a name="line-566"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-567"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>oss</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pp_div</span> <span class='hs-varid'>div</span>
<a name="line-568"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'\\'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>hcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>pp_os</span> <span class='hs-varid'>oss</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>dot</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>pp_div</span> <span class='hs-varid'>div</span>
<a name="line-569"></a>    <span class='hs-keyword'>where</span>
<a name="line-570"></a>      <span class='hs-varid'>pp_div</span> <span class='hs-conid'>Diverges</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'⊥'</span>
<a name="line-571"></a>      <span class='hs-varid'>pp_div</span> <span class='hs-conid'>ExnOrDiv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'x'</span>
<a name="line-572"></a>      <span class='hs-varid'>pp_div</span> <span class='hs-conid'>Dunno</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'T'</span>
<a name="line-573"></a>      <span class='hs-varid'>pp_os</span> <span class='hs-conid'>OneShotLam</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'1'</span>
<a name="line-574"></a>      <span class='hs-varid'>pp_os</span> <span class='hs-conid'>NoOneShotInfo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'?'</span>
<a name="line-575"></a>
<a name="line-576"></a><a name="mkBotArityType"></a><span class='hs-definition'>mkBotArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-577"></a><span class='hs-definition'>mkBotArityType</span> <span class='hs-varid'>oss</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>botDiv</span>
<a name="line-578"></a>
<a name="line-579"></a><a name="botArityType"></a><span class='hs-definition'>botArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span>
<a name="line-580"></a><span class='hs-definition'>botArityType</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkBotArityType</span> <span class='hs-conid'>[]</span>
<a name="line-581"></a>
<a name="line-582"></a><a name="mkManifestArityType"></a><span class='hs-definition'>mkManifestArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-583"></a><span class='hs-definition'>mkManifestArityType</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-584"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span>
<a name="line-585"></a>  <span class='hs-keyword'>where</span>
<a name="line-586"></a>    <span class='hs-varid'>oss</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>idOneShotInfo</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndr</span><span class='hs-keyglyph'>]</span>
<a name="line-587"></a>    <span class='hs-varid'>div</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsDeadEnd</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>botDiv</span>
<a name="line-588"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topDiv</span>
<a name="line-589"></a>
<a name="line-590"></a><a name="topArityType"></a><span class='hs-definition'>topArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span>
<a name="line-591"></a><span class='hs-definition'>topArityType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>topDiv</span>
<a name="line-592"></a>
<a name="line-593"></a><a name="arityTypeArity"></a><span class='hs-comment'>-- | The number of value args for the arity type</span>
<a name="line-594"></a><span class='hs-definition'>arityTypeArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span>
<a name="line-595"></a><span class='hs-definition'>arityTypeArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>oss</span>
<a name="line-596"></a>
<a name="line-597"></a><a name="expandableArityType"></a><span class='hs-comment'>-- | True &lt;=&gt; eta-expansion will add at least one lambda</span>
<a name="line-598"></a><span class='hs-definition'>expandableArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-599"></a><span class='hs-definition'>expandableArityType</span> <span class='hs-varid'>at</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityTypeArity</span> <span class='hs-varid'>at</span> <span class='hs-varop'>/=</span> <span class='hs-num'>0</span>
<a name="line-600"></a>
<a name="line-601"></a><a name="isDeadEndArityType"></a><span class='hs-comment'>-- | See Note [Dead ends] in "GHC.Types.Demand".</span>
<a name="line-602"></a><span class='hs-comment'>-- Bottom implies a dead end.</span>
<a name="line-603"></a><span class='hs-definition'>isDeadEndArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-604"></a><span class='hs-definition'>isDeadEndArityType</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div</span>
<a name="line-605"></a>
<a name="line-606"></a><a name="maxWithArity"></a><span class='hs-comment'>-- | Expand a non-bottoming arity type so that it has at least the given arity.</span>
<a name="line-607"></a><span class='hs-definition'>maxWithArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-608"></a><span class='hs-definition'>maxWithArity</span> <span class='hs-varid'>at</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span> <span class='hs-varop'>!</span><span class='hs-varid'>ar</span>
<a name="line-609"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndArityType</span> <span class='hs-varid'>at</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at</span>
<a name="line-610"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>oss</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>ar</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at</span>
<a name="line-611"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>ar</span> <span class='hs-varop'>$</span> <span class='hs-varid'>oss</span> <span class='hs-varop'>++</span> <span class='hs-varid'>repeat</span> <span class='hs-conid'>NoOneShotInfo</span><span class='hs-layout'>)</span> <span class='hs-varid'>div</span>
<a name="line-612"></a>
<a name="line-613"></a><a name="minWithArity"></a><span class='hs-comment'>-- | Trim an arity type so that it has at most the given arity.</span>
<a name="line-614"></a><span class='hs-comment'>-- Any excess 'OneShotInfo's are truncated to 'topDiv', even if they end in</span>
<a name="line-615"></a><span class='hs-comment'>-- 'ABot'.</span>
<a name="line-616"></a><span class='hs-definition'>minWithArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-617"></a><span class='hs-definition'>minWithArity</span> <span class='hs-varid'>at</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>ar</span>
<a name="line-618"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>oss</span> <span class='hs-varop'>`lengthAtMost`</span> <span class='hs-varid'>ar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at</span>
<a name="line-619"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>ar</span> <span class='hs-varid'>oss</span><span class='hs-layout'>)</span> <span class='hs-varid'>topDiv</span>
<a name="line-620"></a>
<a name="line-621"></a><a name="takeWhileOneShot"></a><span class='hs-definition'>takeWhileOneShot</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-622"></a><span class='hs-definition'>takeWhileOneShot</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-623"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>takeWhile</span> <span class='hs-varid'>isOneShotInfo</span> <span class='hs-varid'>oss</span><span class='hs-layout'>)</span> <span class='hs-varid'>topDiv</span>
<a name="line-624"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>takeWhile</span> <span class='hs-varid'>isOneShotInfo</span> <span class='hs-varid'>oss</span><span class='hs-layout'>)</span> <span class='hs-varid'>div</span>
<a name="line-625"></a>
<a name="line-626"></a><a name="exprEtaExpandArity"></a><span class='hs-comment'>-- | The Arity returned is the number of value args the</span>
<a name="line-627"></a><span class='hs-comment'>-- expression can be applied to without doing much work</span>
<a name="line-628"></a><span class='hs-definition'>exprEtaExpandArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-629"></a><span class='hs-comment'>-- exprEtaExpandArity is used when eta expanding</span>
<a name="line-630"></a><span class='hs-comment'>--      e  ==&gt;  \xy -&gt; e x y</span>
<a name="line-631"></a><span class='hs-definition'>exprEtaExpandArity</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityType</span> <span class='hs-layout'>(</span><span class='hs-varid'>findRhsArityEnv</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-632"></a>
<a name="line-633"></a><a name="getBotArity"></a><span class='hs-definition'>getBotArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Arity</span>
<a name="line-634"></a><span class='hs-comment'>-- Arity of a divergent function</span>
<a name="line-635"></a><span class='hs-definition'>getBotArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-636"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>length</span> <span class='hs-varid'>oss</span>
<a name="line-637"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-638"></a>
<a name="line-639"></a><a name="findRhsArity"></a><span class='hs-comment'>----------------------</span>
<a name="line-640"></a><span class='hs-definition'>findRhsArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-641"></a><span class='hs-comment'>-- This implements the fixpoint loop for arity analysis</span>
<a name="line-642"></a><span class='hs-comment'>-- See Note [Arity analysis]</span>
<a name="line-643"></a><span class='hs-comment'>-- If findRhsArity e = (n, is_bot) then</span>
<a name="line-644"></a><span class='hs-comment'>--  (a) any application of e to &lt;n arguments will not do much work,</span>
<a name="line-645"></a><span class='hs-comment'>--      so it is safe to expand e  ==&gt;  (\x1..xn. e x1 .. xn)</span>
<a name="line-646"></a><span class='hs-comment'>--  (b) if is_bot=True, then e applied to n args is guaranteed bottom</span>
<a name="line-647"></a><span class='hs-definition'>findRhsArity</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>old_arity</span>
<a name="line-648"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>botArityType</span>
<a name="line-649"></a>      <span class='hs-comment'>-- We always do one step, but usually that produces a result equal to</span>
<a name="line-650"></a>      <span class='hs-comment'>-- old_arity, and then we stop right away, because old_arity is assumed</span>
<a name="line-651"></a>      <span class='hs-comment'>-- to be sound. In other words, arities should never decrease.</span>
<a name="line-652"></a>      <span class='hs-comment'>-- Result: the common case is that there is just one iteration</span>
<a name="line-653"></a>  <span class='hs-keyword'>where</span>
<a name="line-654"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-655"></a>    <span class='hs-varid'>go</span> <span class='hs-varop'>!</span><span class='hs-varid'>n</span> <span class='hs-varid'>cur_at</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-656"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- the "stop right away" case</span>
<a name="line-657"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>length</span> <span class='hs-varid'>oss</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>old_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cur_at</span> <span class='hs-comment'>-- from above</span>
<a name="line-658"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>next_at</span> <span class='hs-varop'>==</span> <span class='hs-varid'>cur_at</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cur_at</span>
<a name="line-659"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>               <span class='hs-keyglyph'>=</span>
<a name="line-660"></a>         <span class='hs-comment'>-- Warn if more than 2 iterations. Why 2? See Note [Exciting arity]</span>
<a name="line-661"></a>         <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-varid'>debugIsOn</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>2</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Exciting arity"</span>
<a name="line-662"></a>                                   <span class='hs-varop'>$$</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span>
<a name="line-663"></a>                                        <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cur_at</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>next_at</span>
<a name="line-664"></a>                                        <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-665"></a>         <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>next_at</span>
<a name="line-666"></a>      <span class='hs-keyword'>where</span>
<a name="line-667"></a>        <span class='hs-varid'>next_at</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>step</span> <span class='hs-varid'>cur_at</span>
<a name="line-668"></a>
<a name="line-669"></a>    <span class='hs-varid'>step</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-670"></a>    <span class='hs-varid'>step</span> <span class='hs-varid'>at</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "step" (ppr bndr &lt;+&gt; ppr at &lt;+&gt; ppr (arityType env rhs)) $</span>
<a name="line-671"></a>              <span class='hs-varid'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs</span>
<a name="line-672"></a>      <span class='hs-keyword'>where</span>
<a name="line-673"></a>        <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>findRhsArityEnv</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>at</span>
<a name="line-674"></a>
<a name="line-675"></a><span class='hs-comment'>{-
<a name="line-676"></a>Note [Arity analysis]
<a name="line-677"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-678"></a>The motivating example for arity analysis is this:
<a name="line-679"></a>
<a name="line-680"></a>  f = \x. let g = f (x+1)
<a name="line-681"></a>          in \y. ...g...
<a name="line-682"></a>
<a name="line-683"></a>What arity does f have?  Really it should have arity 2, but a naive
<a name="line-684"></a>look at the RHS won't see that.  You need a fixpoint analysis which
<a name="line-685"></a>says it has arity "infinity" the first time round.
<a name="line-686"></a>
<a name="line-687"></a>This example happens a lot; it first showed up in Andy Gill's thesis,
<a name="line-688"></a>fifteen years ago!  It also shows up in the code for 'rnf' on lists
<a name="line-689"></a>in #4138.
<a name="line-690"></a>
<a name="line-691"></a>We do the necessary, quite simple fixed-point iteration in 'findRhsArity',
<a name="line-692"></a>which assumes for a single binding 'ABot' on the first run and iterates
<a name="line-693"></a>until it finds a stable arity type. Two wrinkles
<a name="line-694"></a>
<a name="line-695"></a>* We often have to ask (see the Case or Let case of 'arityType') whether some
<a name="line-696"></a>  expression is cheap. In the case of an application, that depends on the arity
<a name="line-697"></a>  of the application head! That's why we have our own version of 'exprIsCheap',
<a name="line-698"></a>  'myExprIsCheap', that will integrate the optimistic arity types we have on
<a name="line-699"></a>  f and g into the cheapness check.
<a name="line-700"></a>
<a name="line-701"></a>* Consider this (#18793)
<a name="line-702"></a>
<a name="line-703"></a>    go = \ds. case ds of
<a name="line-704"></a>           []     -&gt; id
<a name="line-705"></a>           (x:ys) -&gt; let acc = go ys in
<a name="line-706"></a>                     case blah of
<a name="line-707"></a>                       True  -&gt; acc
<a name="line-708"></a>                       False -&gt; \ x1 -&gt; acc (negate x1)
<a name="line-709"></a>
<a name="line-710"></a>  We must propagate go's optimistically large arity to @acc@, so that the
<a name="line-711"></a>  tail call to @acc@ in the True branch has sufficient arity.  This is done
<a name="line-712"></a>  by the 'am_sigs' field in 'FindRhsArity', and 'lookupSigEnv' in the Var case
<a name="line-713"></a>  of 'arityType'.
<a name="line-714"></a>
<a name="line-715"></a>Note [Exciting Arity]
<a name="line-716"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-717"></a>The fixed-point iteration in 'findRhsArity' stabilises very quickly in almost
<a name="line-718"></a>all cases. To get notified of cases where we need an usual number of iterations,
<a name="line-719"></a>we emit a warning in debug mode, so that we can investigate and make sure that
<a name="line-720"></a>we really can't do better. It's a gross hack, but catches real bugs (#18870).
<a name="line-721"></a>
<a name="line-722"></a>Now, which number is "unusual"? We pick n &gt; 2. Here's a pretty common and
<a name="line-723"></a>expected example that takes two iterations and would ruin the specificity
<a name="line-724"></a>of the warning (from T18937):
<a name="line-725"></a>
<a name="line-726"></a>  f :: [Int] -&gt; Int -&gt; Int
<a name="line-727"></a>  f []     = id
<a name="line-728"></a>  f (x:xs) = let y = sum [0..x]
<a name="line-729"></a>             in \z -&gt; f xs (y + z)
<a name="line-730"></a>
<a name="line-731"></a>Fixed-point iteration starts with arity type ⊥ for f. After the first
<a name="line-732"></a>iteration, we get arity type \??.T, e.g. arity 2, because we unconditionally
<a name="line-733"></a>'floatIn' the let-binding (see its bottom case).  After the second iteration,
<a name="line-734"></a>we get arity type \?.T, e.g. arity 1, because now we are no longer allowed
<a name="line-735"></a>to floatIn the non-cheap let-binding.  Which is all perfectly benign, but
<a name="line-736"></a>means we do two iterations (well, actually 3 'step's to detect we are stable)
<a name="line-737"></a>and don't want to emit the warning.
<a name="line-738"></a>
<a name="line-739"></a>Note [Eta expanding through dictionaries]
<a name="line-740"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-741"></a>If the experimental -fdicts-cheap flag is on, we eta-expand through
<a name="line-742"></a>dictionary bindings.  This improves arities. Thereby, it also
<a name="line-743"></a>means that full laziness is less prone to floating out the
<a name="line-744"></a>application of a function to its dictionary arguments, which
<a name="line-745"></a>can thereby lose opportunities for fusion.  Example:
<a name="line-746"></a>        foo :: Ord a =&gt; a -&gt; ...
<a name="line-747"></a>     foo = /\a \(d:Ord a). let d' = ...d... in \(x:a). ....
<a name="line-748"></a>        -- So foo has arity 1
<a name="line-749"></a>
<a name="line-750"></a>     f = \x. foo dInt $ bar x
<a name="line-751"></a>
<a name="line-752"></a>The (foo DInt) is floated out, and makes ineffective a RULE
<a name="line-753"></a>     foo (bar x) = ...
<a name="line-754"></a>
<a name="line-755"></a>One could go further and make exprIsCheap reply True to any
<a name="line-756"></a>dictionary-typed expression, but that's more work.
<a name="line-757"></a>-}</span>
<a name="line-758"></a>
<a name="line-759"></a><a name="arityLam"></a><span class='hs-definition'>arityLam</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-760"></a><span class='hs-definition'>arityLam</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>idStateHackOneShotInfo</span> <span class='hs-varid'>id</span> <span class='hs-conop'>:</span> <span class='hs-varid'>oss</span><span class='hs-layout'>)</span> <span class='hs-varid'>div</span>
<a name="line-761"></a>
<a name="line-762"></a><a name="floatIn"></a><span class='hs-definition'>floatIn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-763"></a><span class='hs-comment'>-- We have something like (let x = E in b),</span>
<a name="line-764"></a><span class='hs-comment'>-- where b has the given arity type.</span>
<a name="line-765"></a><span class='hs-definition'>floatIn</span> <span class='hs-varid'>cheap</span> <span class='hs-varid'>at</span>
<a name="line-766"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndArityType</span> <span class='hs-varid'>at</span> <span class='hs-varop'>||</span> <span class='hs-varid'>cheap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at</span>
<a name="line-767"></a>  <span class='hs-comment'>-- If E is not cheap, keep arity only for one-shots</span>
<a name="line-768"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>takeWhileOneShot</span> <span class='hs-varid'>at</span>
<a name="line-769"></a>
<a name="line-770"></a><a name="arityApp"></a><span class='hs-definition'>arityApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-771"></a>
<a name="line-772"></a><span class='hs-comment'>-- Processing (fun arg) where at is the ArityType of fun,</span>
<a name="line-773"></a><span class='hs-comment'>-- Knock off an argument and behave like 'let'</span>
<a name="line-774"></a><span class='hs-definition'>arityApp</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>oss</span><span class='hs-layout'>)</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span> <span class='hs-varid'>cheap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floatIn</span> <span class='hs-varid'>cheap</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-775"></a><span class='hs-definition'>arityApp</span> <span class='hs-varid'>at</span>               <span class='hs-keyword'>_</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at</span>
<a name="line-776"></a>
<a name="line-777"></a><a name="andArityType"></a><span class='hs-comment'>-- | Least upper bound in the 'ArityType' lattice.</span>
<a name="line-778"></a><span class='hs-comment'>-- See the haddocks on 'ArityType' for the lattice.</span>
<a name="line-779"></a><span class='hs-comment'>--</span>
<a name="line-780"></a><span class='hs-comment'>-- Used for branches of a @case@.</span>
<a name="line-781"></a><span class='hs-definition'>andArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-782"></a><span class='hs-definition'>andArityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>lam1</span><span class='hs-conop'>:</span><span class='hs-varid'>lams1</span><span class='hs-layout'>)</span> <span class='hs-varid'>div1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>lam2</span><span class='hs-conop'>:</span><span class='hs-varid'>lams2</span><span class='hs-layout'>)</span> <span class='hs-varid'>div2</span><span class='hs-layout'>)</span>
<a name="line-783"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AT</span> <span class='hs-varid'>lams'</span> <span class='hs-varid'>div'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>andArityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>lams1</span> <span class='hs-varid'>div1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>lams2</span> <span class='hs-varid'>div2</span><span class='hs-layout'>)</span>
<a name="line-784"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>lam1</span> <span class='hs-varop'>`and_lam`</span> <span class='hs-varid'>lam2</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>lams'</span><span class='hs-layout'>)</span> <span class='hs-varid'>div'</span>
<a name="line-785"></a>  <span class='hs-keyword'>where</span>
<a name="line-786"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>os1</span><span class='hs-layout'>)</span> <span class='hs-varop'>`and_lam`</span> <span class='hs-layout'>(</span><span class='hs-varid'>os2</span><span class='hs-layout'>)</span>
<a name="line-787"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-varid'>os1</span> <span class='hs-varop'>`bestOneShot`</span> <span class='hs-varid'>os2</span><span class='hs-layout'>)</span>
<a name="line-788"></a>        <span class='hs-comment'>-- bestOneShot: see Note [Combining case branches: optimistic one-shot-ness]</span>
<a name="line-789"></a>
<a name="line-790"></a><span class='hs-definition'>andArityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>div1</span><span class='hs-layout'>)</span> <span class='hs-varid'>at2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>andWithTail</span> <span class='hs-varid'>env</span> <span class='hs-varid'>div1</span> <span class='hs-varid'>at2</span>
<a name="line-791"></a><span class='hs-definition'>andArityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>at1</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>div2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>andWithTail</span> <span class='hs-varid'>env</span> <span class='hs-varid'>div2</span> <span class='hs-varid'>at1</span>
<a name="line-792"></a>
<a name="line-793"></a><a name="andWithTail"></a><span class='hs-definition'>andWithTail</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Divergence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-794"></a><span class='hs-definition'>andWithTail</span> <span class='hs-varid'>env</span> <span class='hs-varid'>div1</span> <span class='hs-varid'>at2</span>
<a name="line-795"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div1</span>     <span class='hs-comment'>-- case x of { T -&gt; error; F -&gt; \y.e }</span>
<a name="line-796"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at2</span>        <span class='hs-comment'>-- Note [ABot branches: max arity wins]</span>
<a name="line-797"></a>
<a name="line-798"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pedanticBottoms</span> <span class='hs-varid'>env</span>  <span class='hs-comment'>-- Note [Combining case branches: andWithTail]</span>
<a name="line-799"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>topDiv</span>
<a name="line-800"></a>
<a name="line-801"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- case x of { T -&gt; plusInt &lt;expensive&gt;; F -&gt; \y.e }</span>
<a name="line-802"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>takeWhileOneShot</span> <span class='hs-varid'>at2</span>    <span class='hs-comment'>-- We know div1 = topDiv</span>
<a name="line-803"></a>    <span class='hs-comment'>-- See Note [Combining case branches: andWithTail]</span>
<a name="line-804"></a>
<a name="line-805"></a>
<a name="line-806"></a><span class='hs-comment'>{- Note [ABot branches: max arity wins]
<a name="line-807"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-808"></a>Consider   case x of
<a name="line-809"></a>             True  -&gt; \x.  error "urk"
<a name="line-810"></a>             False -&gt; \xy. error "urk2"
<a name="line-811"></a>
<a name="line-812"></a>Remember: \o1..on.⊥ means "if you apply to n args, it'll definitely diverge".
<a name="line-813"></a>So we need \??.⊥ for the whole thing, the /max/ of both arities.
<a name="line-814"></a>
<a name="line-815"></a>Note [Combining case branches: optimistic one-shot-ness]
<a name="line-816"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-817"></a>When combining the ArityTypes for two case branches (with andArityType)
<a name="line-818"></a>and both ArityTypes have ATLamInfo, then we just combine their
<a name="line-819"></a>expensive-ness and one-shot info.  The tricky point is when we have
<a name="line-820"></a>     case x of True -&gt; \x{one-shot). blah1
<a name="line-821"></a>               Fale -&gt; \y.           blah2
<a name="line-822"></a>
<a name="line-823"></a>Since one-shot-ness is about the /consumer/ not the /producer/, we
<a name="line-824"></a>optimistically assume that if either branch is one-shot, we combine
<a name="line-825"></a>the best of the two branches, on the (slightly dodgy) basis that if we
<a name="line-826"></a>know one branch is one-shot, then they all must be.  Surprisingly,
<a name="line-827"></a>this means that the one-shot arity type is effectively the top element
<a name="line-828"></a>of the lattice.
<a name="line-829"></a>
<a name="line-830"></a>Hence the call to `bestOneShot` in `andArityType`.
<a name="line-831"></a>
<a name="line-832"></a>Note [Combining case branches: andWithTail]
<a name="line-833"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-834"></a>When combining the ArityTypes for two case branches (with andArityType)
<a name="line-835"></a>and one side or the other has run out of ATLamInfo; then we get
<a name="line-836"></a>into `andWithTail`.
<a name="line-837"></a>
<a name="line-838"></a>* If one branch is guaranteed bottom (isDeadEndDiv), we just take
<a name="line-839"></a>  the other; see Note [ABot branches: max arity wins]
<a name="line-840"></a>
<a name="line-841"></a>* Otherwise, if pedantic-bottoms is on, we just have to return
<a name="line-842"></a>  AT [] topDiv.  E.g. if we have
<a name="line-843"></a>    f x z = case x of True  -&gt; \y. blah
<a name="line-844"></a>                      False -&gt; z
<a name="line-845"></a>  then we can't eta-expand, because that would change the behaviour
<a name="line-846"></a>  of (f False bottom().
<a name="line-847"></a>
<a name="line-848"></a>* But if pedantic-bottoms is not on, we allow ourselves to push
<a name="line-849"></a>  `z` under a lambda (much as we allow ourselves to put the `case x`
<a name="line-850"></a>  under a lambda).  However we know nothing about the expensiveness
<a name="line-851"></a>  or one-shot-ness of `z`, so we'd better assume it looks like
<a name="line-852"></a>  (Expensive, NoOneShotInfo) all the way. Remembering
<a name="line-853"></a>  Note [Combining case branches: optimistic one-shot-ness],
<a name="line-854"></a>  we just add work to ever ATLamInfo, keeping the one-shot-ness.
<a name="line-855"></a>
<a name="line-856"></a>Here's an example:
<a name="line-857"></a>  go = \x. let z = go e0
<a name="line-858"></a>               go2 = \x. case x of
<a name="line-859"></a>                           True  -&gt; z
<a name="line-860"></a>                           False -&gt; \s(one-shot). e1
<a name="line-861"></a>           in go2 x
<a name="line-862"></a>We *really* want to respect the one-shot annotation provided by the
<a name="line-863"></a>user and eta-expand go and go2.
<a name="line-864"></a>When combining the branches of the case we have
<a name="line-865"></a>     T `andAT` \1.T
<a name="line-866"></a>and we want to get \1.T.
<a name="line-867"></a>But if the inner lambda wasn't one-shot (\?.T) we don't want to do this.
<a name="line-868"></a>(We need a usage analysis to justify that.)
<a name="line-869"></a>
<a name="line-870"></a>So we combine the best of the two branches, on the (slightly dodgy)
<a name="line-871"></a>basis that if we know one branch is one-shot, then they all must be.
<a name="line-872"></a>Surprisingly, this means that the one-shot arity type is effectively the top
<a name="line-873"></a>element of the lattice.
<a name="line-874"></a>
<a name="line-875"></a>Note [Arity trimming]
<a name="line-876"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-877"></a>Consider ((\x y. blah) |&gt; co), where co :: (Int-&gt;Int-&gt;Int) ~ (Int -&gt; F a) , and
<a name="line-878"></a>F is some type family.
<a name="line-879"></a>
<a name="line-880"></a>Because of Note [exprArity invariant], item (2), we must return with arity at
<a name="line-881"></a>most 1, because typeArity (Int -&gt; F a) = 1.  So we have to trim the result of
<a name="line-882"></a>calling arityType on (\x y. blah).  Failing to do so, and hence breaking the
<a name="line-883"></a>exprArity invariant, led to #5441.
<a name="line-884"></a>
<a name="line-885"></a>How to trim?  If we end in topDiv, it's easy.  But we must take great care with
<a name="line-886"></a>dead ends (i.e. botDiv). Suppose the expression was (\x y. error "urk"),
<a name="line-887"></a>we'll get \??.⊥.  We absolutely must not trim that to \?.⊥, because that
<a name="line-888"></a>claims that ((\x y. error "urk") |&gt; co) diverges when given one argument,
<a name="line-889"></a>which it absolutely does not. And Bad Things happen if we think something
<a name="line-890"></a>returns bottom when it doesn't (#16066).
<a name="line-891"></a>
<a name="line-892"></a>So, if we need to trim a dead-ending arity type, switch (conservatively) to
<a name="line-893"></a>topDiv.
<a name="line-894"></a>
<a name="line-895"></a>Historical note: long ago, we unconditionally switched to topDiv when we
<a name="line-896"></a>encountered a cast, but that is far too conservative: see #5475
<a name="line-897"></a>-}</span>
<a name="line-898"></a>
<a name="line-899"></a><span class='hs-comment'>---------------------------</span>
<a name="line-900"></a>
<a name="line-901"></a><a name="AnalysisMode"></a><span class='hs-comment'>-- | Each of the entry-points of the analyser ('arityType') has different</span>
<a name="line-902"></a><a name="AnalysisMode"></a><span class='hs-comment'>-- requirements. The entry-points are</span>
<a name="line-903"></a><a name="AnalysisMode"></a><span class='hs-comment'>--</span>
<a name="line-904"></a><a name="AnalysisMode"></a><span class='hs-comment'>--   1. 'exprBotStrictness_maybe'</span>
<a name="line-905"></a><a name="AnalysisMode"></a><span class='hs-comment'>--   2. 'exprEtaExpandArity'</span>
<a name="line-906"></a><a name="AnalysisMode"></a><span class='hs-comment'>--   3. 'findRhsArity'</span>
<a name="line-907"></a><a name="AnalysisMode"></a><span class='hs-comment'>--</span>
<a name="line-908"></a><a name="AnalysisMode"></a><span class='hs-comment'>-- For each of the entry-points, there is a separate mode that governs</span>
<a name="line-909"></a><a name="AnalysisMode"></a><span class='hs-comment'>--</span>
<a name="line-910"></a><a name="AnalysisMode"></a><span class='hs-comment'>--   1. How pedantic we are wrt. ⊥, in 'pedanticBottoms'.</span>
<a name="line-911"></a><a name="AnalysisMode"></a><span class='hs-comment'>--   2. Whether we store arity signatures for non-recursive let-bindings,</span>
<a name="line-912"></a><a name="AnalysisMode"></a><span class='hs-comment'>--      accessed in 'extendSigEnv'/'lookupSigEnv'.</span>
<a name="line-913"></a><a name="AnalysisMode"></a><span class='hs-comment'>--      See Note [Arity analysis] why that's important.</span>
<a name="line-914"></a><a name="AnalysisMode"></a><span class='hs-comment'>--   3. Which expressions we consider cheap to float inside a lambda,</span>
<a name="line-915"></a><a name="AnalysisMode"></a><span class='hs-comment'>--      in 'myExprIsCheap'.</span>
<a name="line-916"></a><a name="AnalysisMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnalysisMode</span>
<a name="line-917"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BotStrictness</span>
<a name="line-918"></a>  <span class='hs-comment'>-- ^ Used during 'exprBotStrictness_maybe'.</span>
<a name="line-919"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EtaExpandArity</span> <span class='hs-layout'>{</span> <span class='hs-varid'>am_ped_bot</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>
<a name="line-920"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>am_dicts_cheap</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span> <span class='hs-layout'>}</span>
<a name="line-921"></a>  <span class='hs-comment'>-- ^ Used for finding an expression's eta-expanding arity quickly, without</span>
<a name="line-922"></a>  <span class='hs-comment'>-- fixed-point iteration ('exprEtaExpandArity').</span>
<a name="line-923"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FindRhsArity</span> <span class='hs-layout'>{</span> <span class='hs-varid'>am_ped_bot</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>
<a name="line-924"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>am_dicts_cheap</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>
<a name="line-925"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>am_sigs</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>IdEnv</span> <span class='hs-conid'>ArityType</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-926"></a>  <span class='hs-comment'>-- ^ Used for regular, fixed-point arity analysis ('findRhsArity').</span>
<a name="line-927"></a>  <span class='hs-comment'>--   See Note [Arity analysis] for details about fixed-point iteration.</span>
<a name="line-928"></a>  <span class='hs-comment'>--   INVARIANT: Disjoint with 'ae_joins'.</span>
<a name="line-929"></a>
<a name="line-930"></a><a name="ArityEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-931"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span>
<a name="line-932"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span>   <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>AnalysisMode</span>
<a name="line-933"></a>  <span class='hs-comment'>-- ^ The analysis mode. See 'AnalysisMode'.</span>
<a name="line-934"></a>  <span class='hs-layout'>}</span>
<a name="line-935"></a>
<a name="line-936"></a><a name="botStrictnessArityEnv"></a><span class='hs-comment'>-- | The @ArityEnv@ used by 'exprBotStrictness_maybe'. Pedantic about bottoms</span>
<a name="line-937"></a><span class='hs-comment'>-- and no application is ever considered cheap.</span>
<a name="line-938"></a><span class='hs-definition'>botStrictnessArityEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-939"></a><span class='hs-definition'>botStrictnessArityEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BotStrictness</span> <span class='hs-layout'>}</span>
<a name="line-940"></a>
<a name="line-941"></a><span class='hs-comment'>{-
<a name="line-942"></a>-- | The @ArityEnv@ used by 'exprEtaExpandArity'.
<a name="line-943"></a>etaExpandArityEnv :: DynFlags -&gt; ArityEnv
<a name="line-944"></a>etaExpandArityEnv dflags
<a name="line-945"></a>  = AE { ae_mode  = EtaExpandArity { am_ped_bot = gopt Opt_PedanticBottoms dflags
<a name="line-946"></a>                                   , am_dicts_cheap = gopt Opt_DictsCheap dflags }
<a name="line-947"></a>       , ae_joins = emptyVarSet }
<a name="line-948"></a>-}</span>
<a name="line-949"></a>
<a name="line-950"></a><a name="findRhsArityEnv"></a><span class='hs-comment'>-- | The @ArityEnv@ used by 'findRhsArity'.</span>
<a name="line-951"></a><span class='hs-definition'>findRhsArityEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-952"></a><span class='hs-definition'>findRhsArityEnv</span> <span class='hs-varid'>dflags</span>
<a name="line-953"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FindRhsArity</span> <span class='hs-layout'>{</span> <span class='hs-varid'>am_ped_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_PedanticBottoms</span> <span class='hs-varid'>dflags</span>
<a name="line-954"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>am_dicts_cheap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_DictsCheap</span> <span class='hs-varid'>dflags</span>
<a name="line-955"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>am_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-layout'>}</span>
<a name="line-956"></a>       <span class='hs-layout'>}</span>
<a name="line-957"></a>
<a name="line-958"></a><a name="isFindRhsArity"></a><span class='hs-definition'>isFindRhsArity</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-959"></a><span class='hs-definition'>isFindRhsArity</span> <span class='hs-layout'>(</span><span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FindRhsArity</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-960"></a><span class='hs-definition'>isFindRhsArity</span> <span class='hs-keyword'>_</span>                                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-961"></a>
<a name="line-962"></a><span class='hs-comment'>-- First some internal functions in snake_case for deleting in certain VarEnvs</span>
<a name="line-963"></a><span class='hs-comment'>-- of the ArityType. Don't call these; call delInScope* instead!</span>
<a name="line-964"></a>
<a name="line-965"></a><a name="modifySigEnv"></a><span class='hs-definition'>modifySigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>IdEnv</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IdEnv</span> <span class='hs-conid'>ArityType</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-966"></a><span class='hs-definition'>modifySigEnv</span> <span class='hs-varid'>f</span> <span class='hs-varid'>env</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>am</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>FindRhsArity</span><span class='hs-layout'>{</span><span class='hs-varid'>am_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sigs</span><span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span>
<a name="line-967"></a>  <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>am</span> <span class='hs-layout'>{</span> <span class='hs-varid'>am_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-varid'>sigs</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-968"></a><span class='hs-definition'>modifySigEnv</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-969"></a><span class='hs-comment'>{-# INLINE modifySigEnv #-}</span>
<a name="line-970"></a>
<a name="line-971"></a><a name="del_sig_env"></a><span class='hs-definition'>del_sig_env</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-comment'>-- internal!</span>
<a name="line-972"></a><span class='hs-definition'>del_sig_env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifySigEnv</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>delVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-973"></a><span class='hs-comment'>{-# INLINE del_sig_env #-}</span>
<a name="line-974"></a>
<a name="line-975"></a><a name="del_sig_env_list"></a><span class='hs-definition'>del_sig_env_list</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-comment'>-- internal!</span>
<a name="line-976"></a><span class='hs-definition'>del_sig_env_list</span> <span class='hs-varid'>ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifySigEnv</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>delVarEnvList</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>ids</span><span class='hs-layout'>)</span>
<a name="line-977"></a><span class='hs-comment'>{-# INLINE del_sig_env_list #-}</span>
<a name="line-978"></a>
<a name="line-979"></a><span class='hs-comment'>-- end of internal deletion functions</span>
<a name="line-980"></a>
<a name="line-981"></a><a name="extendSigEnv"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-982"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>ar_ty</span>
<a name="line-983"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifySigEnv</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>id</span> <span class='hs-varid'>ar_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span>
<a name="line-984"></a>
<a name="line-985"></a><a name="delInScope"></a><span class='hs-definition'>delInScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-986"></a><span class='hs-definition'>delInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>del_sig_env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>env</span>
<a name="line-987"></a>
<a name="line-988"></a><a name="delInScopeList"></a><span class='hs-definition'>delInScopeList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-989"></a><span class='hs-definition'>delInScopeList</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>del_sig_env_list</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>env</span>
<a name="line-990"></a>
<a name="line-991"></a><a name="lookupSigEnv"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>ArityType</span>
<a name="line-992"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-conid'>AE</span><span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mode</span> <span class='hs-layout'>}</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-993"></a>  <span class='hs-conid'>BotStrictness</span>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-994"></a>  <span class='hs-conid'>EtaExpandArity</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-995"></a>  <span class='hs-conid'>FindRhsArity</span><span class='hs-layout'>{</span> <span class='hs-varid'>am_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sigs</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>id</span>
<a name="line-996"></a>
<a name="line-997"></a><a name="pedanticBottoms"></a><span class='hs-comment'>-- | Whether the analysis should be pedantic about bottoms.</span>
<a name="line-998"></a><span class='hs-comment'>-- 'exprBotStrictness_maybe' always is.</span>
<a name="line-999"></a><span class='hs-definition'>pedanticBottoms</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1000"></a><span class='hs-definition'>pedanticBottoms</span> <span class='hs-conid'>AE</span><span class='hs-layout'>{</span> <span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mode</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1001"></a>  <span class='hs-conid'>BotStrictness</span>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1002"></a>  <span class='hs-conid'>EtaExpandArity</span><span class='hs-layout'>{</span> <span class='hs-varid'>am_ped_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ped_bot</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ped_bot</span>
<a name="line-1003"></a>  <span class='hs-conid'>FindRhsArity</span><span class='hs-layout'>{</span> <span class='hs-varid'>am_ped_bot</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ped_bot</span> <span class='hs-layout'>}</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ped_bot</span>
<a name="line-1004"></a>
<a name="line-1005"></a><a name="myExprIsCheap"></a><span class='hs-comment'>-- | A version of 'exprIsCheap' that considers results from arity analysis</span>
<a name="line-1006"></a><span class='hs-comment'>-- and optionally the expression's type.</span>
<a name="line-1007"></a><span class='hs-comment'>-- Under 'exprBotStrictness_maybe', no expressions are cheap.</span>
<a name="line-1008"></a><span class='hs-definition'>myExprIsCheap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1009"></a><span class='hs-definition'>myExprIsCheap</span> <span class='hs-conid'>AE</span><span class='hs-layout'>{</span><span class='hs-varid'>ae_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mode</span><span class='hs-layout'>}</span> <span class='hs-varid'>e</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1010"></a>  <span class='hs-conid'>BotStrictness</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1011"></a>  <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cheap_dict</span> <span class='hs-varop'>||</span> <span class='hs-varid'>cheap_fun</span> <span class='hs-varid'>e</span>
<a name="line-1012"></a>    <span class='hs-keyword'>where</span>
<a name="line-1013"></a>      <span class='hs-varid'>cheap_dict</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>am_dicts_cheap</span> <span class='hs-varid'>mode</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>isDictTy</span> <span class='hs-varid'>mb_ty</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>True</span>
<a name="line-1014"></a>      <span class='hs-varid'>cheap_fun</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mode</span> <span class='hs-keyword'>of</span>
<a name="line-1015"></a><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &lt;= 900</span>
<a name="line-1016"></a>        <span class='hs-conid'>BotStrictness</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"impossible"</span>
<a name="line-1017"></a><span class='hs-cpp'>#endif</span>
<a name="line-1018"></a>        <span class='hs-conid'>EtaExpandArity</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>exprIsCheap</span> <span class='hs-varid'>e</span>
<a name="line-1019"></a>        <span class='hs-conid'>FindRhsArity</span><span class='hs-layout'>{</span><span class='hs-varid'>am_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sigs</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>exprIsCheapX</span> <span class='hs-layout'>(</span><span class='hs-varid'>myIsCheapApp</span> <span class='hs-varid'>sigs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1020"></a>
<a name="line-1021"></a><a name="myIsCheapApp"></a><span class='hs-comment'>-- | A version of 'isCheapApp' that considers results from arity analysis.</span>
<a name="line-1022"></a><span class='hs-comment'>-- See Note [Arity analysis] for what's in the signature environment and why</span>
<a name="line-1023"></a><span class='hs-comment'>-- it's important.</span>
<a name="line-1024"></a><span class='hs-definition'>myIsCheapApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IdEnv</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CheapAppFun</span>
<a name="line-1025"></a><span class='hs-definition'>myIsCheapApp</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>n_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>fn</span> <span class='hs-keyword'>of</span>
<a name="line-1026"></a>  <span class='hs-comment'>-- Nothing means not a local function, fall back to regular</span>
<a name="line-1027"></a>  <span class='hs-comment'>-- 'GHC.Core.Utils.isCheapApp'</span>
<a name="line-1028"></a>  <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>isCheapApp</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>n_val_args</span>
<a name="line-1029"></a>
<a name="line-1030"></a>  <span class='hs-comment'>-- `Just at` means local function with `at` as current SafeArityType.</span>
<a name="line-1031"></a>  <span class='hs-comment'>-- NB the SafeArityType bit: that means we can ignore the cost flags</span>
<a name="line-1032"></a>  <span class='hs-comment'>--    in 'lams', and just consider the length</span>
<a name="line-1033"></a>  <span class='hs-comment'>-- Roughly approximate what 'isCheapApp' is doing.</span>
<a name="line-1034"></a>  <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span>
<a name="line-1035"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndDiv</span> <span class='hs-varid'>div</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- See Note [isCheapApp: bottoming functions] in GHC.Core.Utils</span>
<a name="line-1036"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>length</span> <span class='hs-varid'>oss</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- Essentially isWorkFreeApp</span>
<a name="line-1037"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1038"></a>
<a name="line-1039"></a><a name="arityType"></a><span class='hs-comment'>----------------</span>
<a name="line-1040"></a><span class='hs-definition'>arityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HasDebugCallStack</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-1041"></a><span class='hs-comment'>-- Precondition: all the free join points of the expression</span>
<a name="line-1042"></a><span class='hs-comment'>--               are bound by the ArityEnv</span>
<a name="line-1043"></a><span class='hs-comment'>-- See Note [No free join points in arityType]</span>
<a name="line-1044"></a>
<a name="line-1045"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1046"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minWithArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co_arity</span> <span class='hs-comment'>-- See Note [Arity trimming]</span>
<a name="line-1047"></a>  <span class='hs-keyword'>where</span>
<a name="line-1048"></a>    <span class='hs-varid'>co_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-varid'>typeArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionRKind</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1049"></a>    <span class='hs-comment'>-- See Note [exprArity invariant] (2); must be true of</span>
<a name="line-1050"></a>    <span class='hs-comment'>-- arityType too, since that is how we compute the arity</span>
<a name="line-1051"></a>    <span class='hs-comment'>-- of variables, and they in turn affect result of exprArity</span>
<a name="line-1052"></a>    <span class='hs-comment'>-- #5441 is a nice demo</span>
<a name="line-1053"></a>
<a name="line-1054"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1055"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>at</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-comment'>-- Local binding</span>
<a name="line-1056"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>at</span>
<a name="line-1057"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1058"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isFindRhsArity</span> <span class='hs-varid'>env</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1059"></a>    <span class='hs-comment'>-- All join-point should be in the ae_sigs</span>
<a name="line-1060"></a>    <span class='hs-comment'>-- See Note [No free join points in arityType]</span>
<a name="line-1061"></a>    <span class='hs-varid'>idArityType</span> <span class='hs-varid'>v</span>
<a name="line-1062"></a>
<a name="line-1063"></a>        <span class='hs-comment'>-- Lambdas; increase arity</span>
<a name="line-1064"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1065"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>x</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityLam</span> <span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1066"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityType</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span>
<a name="line-1067"></a>  <span class='hs-keyword'>where</span>
<a name="line-1068"></a>    <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>delInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>x</span>
<a name="line-1069"></a>
<a name="line-1070"></a>        <span class='hs-comment'>-- Applications; decrease arity, except for types</span>
<a name="line-1071"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1072"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun</span>
<a name="line-1073"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>)</span>
<a name="line-1074"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>myExprIsCheap</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
<a name="line-1075"></a>
<a name="line-1076"></a>        <span class='hs-comment'>-- Case/Let; keep arity if either the expression is cheap</span>
<a name="line-1077"></a>        <span class='hs-comment'>-- or it's a 1-shot lambda</span>
<a name="line-1078"></a>        <span class='hs-comment'>-- The former is not really right for Haskell</span>
<a name="line-1079"></a>        <span class='hs-comment'>--      f x = case x of { (a,b) -&gt; \y. e }</span>
<a name="line-1080"></a>        <span class='hs-comment'>--  ===&gt;</span>
<a name="line-1081"></a>        <span class='hs-comment'>--      f x y = case x of { (a,b) -&gt; e }</span>
<a name="line-1082"></a>        <span class='hs-comment'>-- The difference is observable using 'seq'</span>
<a name="line-1083"></a>        <span class='hs-comment'>--</span>
<a name="line-1084"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1085"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprIsDeadEnd</span> <span class='hs-varid'>scrut</span> <span class='hs-varop'>||</span> <span class='hs-varid'>null</span> <span class='hs-varid'>alts</span>
<a name="line-1086"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>botArityType</span>    <span class='hs-comment'>-- Do not eta expand. See Note [Dealing with bottom (1)]</span>
<a name="line-1087"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>pedanticBottoms</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [Dealing with bottom (2)]</span>
<a name="line-1088"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>myExprIsCheap</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1089"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts_type</span>
<a name="line-1090"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>exprOkForSpeculation</span> <span class='hs-varid'>scrut</span>
<a name="line-1091"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alts_type</span>
<a name="line-1092"></a>
<a name="line-1093"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                  <span class='hs-comment'>-- In the remaining cases we may not push</span>
<a name="line-1094"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>takeWhileOneShot</span> <span class='hs-varid'>alts_type</span> <span class='hs-comment'>-- evaluation of the scrutinee in</span>
<a name="line-1095"></a>  <span class='hs-keyword'>where</span>
<a name="line-1096"></a>    <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>delInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-1097"></a>    <span class='hs-varid'>arity_type_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-sel'>_con</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityType</span> <span class='hs-layout'>(</span><span class='hs-varid'>delInScopeList</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-1098"></a>    <span class='hs-varid'>alts_type</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr1</span> <span class='hs-layout'>(</span><span class='hs-varid'>andArityType</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>arity_type_alt</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1099"></a>
<a name="line-1100"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1101"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See Note [arityType for let-bindings]</span>
<a name="line-1102"></a>    <span class='hs-varid'>floatIn</span> <span class='hs-varid'>cheap_rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1103"></a>  <span class='hs-keyword'>where</span>
<a name="line-1104"></a>    <span class='hs-varid'>cheap_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>myExprIsCheap</span> <span class='hs-varid'>env</span> <span class='hs-varid'>r</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1105"></a>    <span class='hs-varid'>env'</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span>
<a name="line-1106"></a>
<a name="line-1107"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1108"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floatIn</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-varid'>is_cheap</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>arityType</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1109"></a>  <span class='hs-keyword'>where</span>
<a name="line-1110"></a>    <span class='hs-varid'>is_cheap</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>myExprIsCheap</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1111"></a>    <span class='hs-varid'>env'</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-varid'>extend_rec</span> <span class='hs-varid'>env</span> <span class='hs-varid'>prs</span>
<a name="line-1112"></a>    <span class='hs-varid'>extend_rec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityEnv</span>
<a name="line-1113"></a>    <span class='hs-varid'>extend_rec</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span>  <span class='hs-varop'>$</span>
<a name="line-1114"></a>                           <span class='hs-varid'>mkManifestArityType</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>body</span>
<a name="line-1115"></a>                         <span class='hs-keyword'>where</span>
<a name="line-1116"></a>                           <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>e</span>
<a name="line-1117"></a>      <span class='hs-comment'>-- We can't call arityType on the RHS, because it might mention</span>
<a name="line-1118"></a>      <span class='hs-comment'>-- join points bound in this very letrec, and we don't want to</span>
<a name="line-1119"></a>      <span class='hs-comment'>-- do a fixpoint calculation here.  So we make do with the</span>
<a name="line-1120"></a>      <span class='hs-comment'>-- manifest arity</span>
<a name="line-1121"></a>
<a name="line-1122"></a><span class='hs-definition'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1123"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arityType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-1124"></a>
<a name="line-1125"></a><span class='hs-definition'>arityType</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topArityType</span>
<a name="line-1126"></a>
<a name="line-1127"></a>
<a name="line-1128"></a><span class='hs-comment'>{- Note [No free join points in arityType]
<a name="line-1129"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1130"></a>Suppose we call arityType on this expression (EX1)
<a name="line-1131"></a>   \x . case x of True  -&gt; \y. e
<a name="line-1132"></a>                  False -&gt; $j 3
<a name="line-1133"></a>where $j is a join point.  It really makes no sense to talk of the arity
<a name="line-1134"></a>of this expression, because it has a free join point.  In particular, we
<a name="line-1135"></a>can't eta-expand the expression because we'd have do the same thing to the
<a name="line-1136"></a>binding of $j, and we can't see that binding.
<a name="line-1137"></a>
<a name="line-1138"></a>If we had (EX2)
<a name="line-1139"></a>   \x. join $j y = blah
<a name="line-1140"></a>       case x of True  -&gt; \y. e
<a name="line-1141"></a>                 False -&gt; $j 3
<a name="line-1142"></a>then it would make perfect sense: we can determine $j's ArityType, and
<a name="line-1143"></a>propagate it to the usage site as usual.
<a name="line-1144"></a>
<a name="line-1145"></a>But how can we get (EX1)?  It doesn't make much sense, because $j can't
<a name="line-1146"></a>be a join point under the \x anyway.  So we make it a precondition of
<a name="line-1147"></a>arityType that the argument has no free join-point Ids.  (This is checked
<a name="line-1148"></a>with an assesrt in the Var case of arityType.)
<a name="line-1149"></a>
<a name="line-1150"></a>BUT the invariant risks being invalidated by one very narrow special case: runRW#
<a name="line-1151"></a>   join $j y = blah
<a name="line-1152"></a>   runRW# (\s. case x of True  -&gt; \y. e
<a name="line-1153"></a>                         False -&gt; $j x)
<a name="line-1154"></a>
<a name="line-1155"></a>We have special magic in OccurAnal, and Simplify to allow continuations to
<a name="line-1156"></a>move into the body of a runRW# call.
<a name="line-1157"></a>
<a name="line-1158"></a>So we are careful never to attempt to eta-expand the (\s.blah) in the
<a name="line-1159"></a>argument to runRW#, at least not when there is a literal lambda there,
<a name="line-1160"></a>so that OccurAnal has seen it and allowed join points bound outside.
<a name="line-1161"></a>See Note [No eta-expansion in runRW#] in GHC.Core.Opt.Simplify.Iteration.
<a name="line-1162"></a>
<a name="line-1163"></a>Note [arityType for let-bindings]
<a name="line-1164"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1165"></a>For non-recursive let-bindings, we just get the arityType of the RHS,
<a name="line-1166"></a>and extend the environment.  That works nicely for things like this
<a name="line-1167"></a>(#18793):
<a name="line-1168"></a>  go = \ ds. case ds_a2CF of {
<a name="line-1169"></a>               []     -&gt; id
<a name="line-1170"></a>               : y ys -&gt; case y of { GHC.Types.I# x -&gt;
<a name="line-1171"></a>                         let acc = go ys in
<a name="line-1172"></a>                         case x &gt;# 42# of {
<a name="line-1173"></a>                            __DEFAULT -&gt; acc
<a name="line-1174"></a>                            1# -&gt; \x1. acc (negate x2)
<a name="line-1175"></a>
<a name="line-1176"></a>Here we want to get a good arity for `acc`, based on the ArityType
<a name="line-1177"></a>of `go`.
<a name="line-1178"></a>
<a name="line-1179"></a>All this is particularly important for join points. Consider this (#18328)
<a name="line-1180"></a>
<a name="line-1181"></a>  f x = join j y = case y of
<a name="line-1182"></a>                      True -&gt; \a. blah
<a name="line-1183"></a>                      False -&gt; \b. blah
<a name="line-1184"></a>        in case x of
<a name="line-1185"></a>              A -&gt; j True
<a name="line-1186"></a>              B -&gt; \c. blah
<a name="line-1187"></a>              C -&gt; j False
<a name="line-1188"></a>
<a name="line-1189"></a>and suppose the join point is too big to inline.  Now, what is the
<a name="line-1190"></a>arity of f?  If we inlined the join point, we'd definitely say "arity
<a name="line-1191"></a>2" because we are prepared to push case-scrutinisation inside a
<a name="line-1192"></a>lambda. It's important that we extend the envt with j's ArityType,
<a name="line-1193"></a>so that we can use that information in the A/C branch of the case.
<a name="line-1194"></a>
<a name="line-1195"></a>For /recursive/ bindings it's more difficult, to call arityType,
<a name="line-1196"></a>because we don't have an ArityType to put in the envt for the
<a name="line-1197"></a>recursively bound Ids.  So for non-join-point bindings we satisfy
<a name="line-1198"></a>ourselves with mkManifestArityType.  Typically we'll have eta-expanded
<a name="line-1199"></a>the binding (based on an earlier fixpoint calculation in
<a name="line-1200"></a>findRhsArity), so the manifest arity is good.
<a name="line-1201"></a>
<a name="line-1202"></a>But for /recursive join points/ things are not so good.
<a name="line-1203"></a>See Note [Arity type for recursive join bindings]
<a name="line-1204"></a>
<a name="line-1205"></a>See Note [Arity type for recursive join bindings]
<a name="line-1206"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1207"></a>Consider
<a name="line-1208"></a>  f x = joinrec j 0 = \ a b c -&gt; (a,x,b)
<a name="line-1209"></a>                j n = j (n-1)
<a name="line-1210"></a>        in j 20
<a name="line-1211"></a>
<a name="line-1212"></a>Obviously `f` should get arity 4.  But the manifest arity of `j`
<a name="line-1213"></a>is 1.  Remember, we don't eta-expand join points; see
<a name="line-1214"></a>GHC.Core.Opt.Simplify.Utils Note [Do not eta-expand join points].
<a name="line-1215"></a>And the ArityInfo on `j` will be just 1 too; see GHC.Core
<a name="line-1216"></a>Note [Invariants on join points], item (2b).  So using
<a name="line-1217"></a>Note [ArityType for let-bindings] won't work well.
<a name="line-1218"></a>
<a name="line-1219"></a>We could do a fixpoint iteration, but that's a heavy hammer
<a name="line-1220"></a>to use in arityType.  So we take advantage of it being a join
<a name="line-1221"></a>point:
<a name="line-1222"></a>
<a name="line-1223"></a>* Extend the ArityEnv to bind each of the recursive binders
<a name="line-1224"></a>  (all join points) to `botArityType`.  This means that any
<a name="line-1225"></a>  jump to the join point will return botArityType, which is
<a name="line-1226"></a>  unit for `andArityType`:
<a name="line-1227"></a>      botAritType `andArityType` at = at
<a name="line-1228"></a>  So it's almost as if those "jump" branches didn't exist.
<a name="line-1229"></a>
<a name="line-1230"></a>* In this extended env, find the ArityType of each of the RHS, after
<a name="line-1231"></a>  stripping off the join-point binders.
<a name="line-1232"></a>
<a name="line-1233"></a>* Use andArityType to combine all these RHS ArityTypes.
<a name="line-1234"></a>
<a name="line-1235"></a>* Find the ArityType of the body, also in this strange extended
<a name="line-1236"></a>  environment
<a name="line-1237"></a>
<a name="line-1238"></a>* And combine that into the result with andArityType.
<a name="line-1239"></a>
<a name="line-1240"></a>In our example, the jump (j 20) will yield Bot, as will the jump
<a name="line-1241"></a>(j (n-1)). We'll 'and' those the ArityType of (\abc. blah).  Good!
<a name="line-1242"></a>
<a name="line-1243"></a>In effect we are treating the RHSs as alternative bodies (like
<a name="line-1244"></a>in a case), and ignoring all jumps.  In this way we don't need
<a name="line-1245"></a>to take a fixpoint.  Tricky!
<a name="line-1246"></a>
<a name="line-1247"></a>NB: we treat /non-recursive/ join points in the same way, but
<a name="line-1248"></a>actually it works fine to treat them uniformly with normal
<a name="line-1249"></a>let-bindings, and that takes less code.
<a name="line-1250"></a>-}</span>
<a name="line-1251"></a>
<a name="line-1252"></a><a name="idArityType"></a><span class='hs-definition'>idArityType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArityType</span>
<a name="line-1253"></a><span class='hs-definition'>idArityType</span> <span class='hs-varid'>v</span>
<a name="line-1254"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>strict_sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>idStrictness</span> <span class='hs-varid'>v</span>
<a name="line-1255"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varop'>$</span> <span class='hs-varid'>isTopSig</span> <span class='hs-varid'>strict_sig</span>
<a name="line-1256"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ds</span><span class='hs-layout'>,</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitStrictSig</span> <span class='hs-varid'>strict_sig</span>
<a name="line-1257"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>ds</span>
<a name="line-1258"></a>  <span class='hs-comment'>-- Every strictness signature admits an arity signature!</span>
<a name="line-1259"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>one_shots</span><span class='hs-layout'>)</span> <span class='hs-varid'>div</span>
<a name="line-1260"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1261"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AT</span> <span class='hs-layout'>(</span><span class='hs-varid'>take</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArity</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>one_shots</span><span class='hs-layout'>)</span> <span class='hs-varid'>topDiv</span>
<a name="line-1262"></a>  <span class='hs-keyword'>where</span>
<a name="line-1263"></a>    <span class='hs-varid'>one_shots</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- One-shot-ness derived from the type</span>
<a name="line-1264"></a>    <span class='hs-varid'>one_shots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1265"></a>
<a name="line-1266"></a><span class='hs-comment'>{-
<a name="line-1267"></a>%************************************************************************
<a name="line-1268"></a>%*                                                                      *
<a name="line-1269"></a>              The main eta-expander
<a name="line-1270"></a>%*                                                                      *
<a name="line-1271"></a>%************************************************************************
<a name="line-1272"></a>
<a name="line-1273"></a>We go for:
<a name="line-1274"></a>   f = \x1..xn -&gt; N  ==&gt;   f = \x1..xn y1..ym -&gt; N y1..ym
<a name="line-1275"></a>                                 (n &gt;= 0)
<a name="line-1276"></a>
<a name="line-1277"></a>where (in both cases)
<a name="line-1278"></a>
<a name="line-1279"></a>        * The xi can include type variables
<a name="line-1280"></a>
<a name="line-1281"></a>        * The yi are all value variables
<a name="line-1282"></a>
<a name="line-1283"></a>        * N is a NORMAL FORM (i.e. no redexes anywhere)
<a name="line-1284"></a>          wanting a suitable number of extra args.
<a name="line-1285"></a>
<a name="line-1286"></a>The biggest reason for doing this is for cases like
<a name="line-1287"></a>
<a name="line-1288"></a>        f = \x -&gt; case x of
<a name="line-1289"></a>                    True  -&gt; \y -&gt; e1
<a name="line-1290"></a>                    False -&gt; \y -&gt; e2
<a name="line-1291"></a>
<a name="line-1292"></a>Here we want to get the lambdas together.  A good example is the nofib
<a name="line-1293"></a>program fibheaps, which gets 25% more allocation if you don't do this
<a name="line-1294"></a>eta-expansion.
<a name="line-1295"></a>
<a name="line-1296"></a>We may have to sandwich some coerces between the lambdas
<a name="line-1297"></a>to make the types work.   exprEtaExpandArity looks through coerces
<a name="line-1298"></a>when computing arity; and etaExpand adds the coerces as necessary when
<a name="line-1299"></a>actually computing the expansion.
<a name="line-1300"></a>
<a name="line-1301"></a>Note [No crap in eta-expanded code]
<a name="line-1302"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1303"></a>The eta expander is careful not to introduce "crap".  In particular,
<a name="line-1304"></a>given a CoreExpr satisfying the 'CpeRhs' invariant (in CorePrep), it
<a name="line-1305"></a>returns a CoreExpr satisfying the same invariant. See Note [Eta
<a name="line-1306"></a>expansion and the CorePrep invariants] in CorePrep.
<a name="line-1307"></a>
<a name="line-1308"></a>This means the eta-expander has to do a bit of on-the-fly
<a name="line-1309"></a>simplification but it's not too hard.  The alternative, of relying on
<a name="line-1310"></a>a subsequent clean-up phase of the Simplifier to de-crapify the result,
<a name="line-1311"></a>means you can't really use it in CorePrep, which is painful.
<a name="line-1312"></a>
<a name="line-1313"></a>Note [Eta expansion for join points]
<a name="line-1314"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1315"></a>The no-crap rule is very tiresome to guarantee when
<a name="line-1316"></a>we have join points. Consider eta-expanding
<a name="line-1317"></a>   let j :: Int -&gt; Int -&gt; Bool
<a name="line-1318"></a>       j x = e
<a name="line-1319"></a>   in b
<a name="line-1320"></a>
<a name="line-1321"></a>The simple way is
<a name="line-1322"></a>  \(y::Int). (let j x = e in b) y
<a name="line-1323"></a>
<a name="line-1324"></a>The no-crap way is
<a name="line-1325"></a>  \(y::Int). let j' :: Int -&gt; Bool
<a name="line-1326"></a>                 j' x = e y
<a name="line-1327"></a>             in b[j'/j] y
<a name="line-1328"></a>where I have written to stress that j's type has
<a name="line-1329"></a>changed.  Note that (of course!) we have to push the application
<a name="line-1330"></a>inside the RHS of the join as well as into the body.  AND if j
<a name="line-1331"></a>has an unfolding we have to push it into there too.  AND j might
<a name="line-1332"></a>be recursive...
<a name="line-1333"></a>
<a name="line-1334"></a>So for now I'm abandoning the no-crap rule in this case. I think
<a name="line-1335"></a>that for the use in CorePrep it really doesn't matter; and if
<a name="line-1336"></a>it does, then CoreToStg.myCollectArgs will fall over.
<a name="line-1337"></a>
<a name="line-1338"></a>(Moreover, I think that casts can make the no-crap rule fail too.)
<a name="line-1339"></a>
<a name="line-1340"></a>Note [Eta expansion and SCCs]
<a name="line-1341"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1342"></a>Note that SCCs are not treated specially by etaExpand.  If we have
<a name="line-1343"></a>        etaExpand 2 (\x -&gt; scc "foo" e)
<a name="line-1344"></a>        = (\xy -&gt; (scc "foo" e) y)
<a name="line-1345"></a>So the costs of evaluating 'e' (not 'e y') are attributed to "foo"
<a name="line-1346"></a>
<a name="line-1347"></a>Note [Eta expansion and source notes]
<a name="line-1348"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1349"></a>CorePrep puts floatable ticks outside of value applications, but not
<a name="line-1350"></a>type applications. As a result we might be trying to eta-expand an
<a name="line-1351"></a>expression like
<a name="line-1352"></a>
<a name="line-1353"></a>  (src&lt;...&gt; v) @a
<a name="line-1354"></a>
<a name="line-1355"></a>which we want to lead to code like
<a name="line-1356"></a>
<a name="line-1357"></a>  \x -&gt; src&lt;...&gt; v @a x
<a name="line-1358"></a>
<a name="line-1359"></a>This means that we need to look through type applications and be ready
<a name="line-1360"></a>to re-add floats on the top.
<a name="line-1361"></a>
<a name="line-1362"></a>Note [Eta expansion with ArityType]
<a name="line-1363"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1364"></a>The etaExpandAT function takes an ArityType (not just an Arity) to
<a name="line-1365"></a>guide eta-expansion.  Why? Because we want to preserve one-shot info.
<a name="line-1366"></a>Consider
<a name="line-1367"></a>  foo = \x. case x of
<a name="line-1368"></a>              True  -&gt; (\s{os}. blah) |&gt; co
<a name="line-1369"></a>              False -&gt; wubble
<a name="line-1370"></a>We'll get an ArityType for foo of \?1.T.
<a name="line-1371"></a>
<a name="line-1372"></a>Then we want to eta-expand to
<a name="line-1373"></a>  foo = \x. (\eta{os}. (case x of ...as before...) eta) |&gt; some_co
<a name="line-1374"></a>
<a name="line-1375"></a>That 'eta' binder is fresh, and we really want it to have the
<a name="line-1376"></a>one-shot flag from the inner \s{os}.  By expanding with the
<a name="line-1377"></a>ArityType gotten from analysing the RHS, we achieve this neatly.
<a name="line-1378"></a>
<a name="line-1379"></a>This makes a big difference to the one-shot monad trick;
<a name="line-1380"></a>see Note [The one-shot state monad trick] in GHC.Utils.Monad.
<a name="line-1381"></a>-}</span>
<a name="line-1382"></a>
<a name="line-1383"></a><a name="etaExpand"></a><span class='hs-comment'>-- | @etaExpand n e@ returns an expression with</span>
<a name="line-1384"></a><span class='hs-comment'>-- the same meaning as @e@, but with arity @n@.</span>
<a name="line-1385"></a><span class='hs-comment'>--</span>
<a name="line-1386"></a><span class='hs-comment'>-- Given:</span>
<a name="line-1387"></a><span class='hs-comment'>--</span>
<a name="line-1388"></a><span class='hs-comment'>-- &gt; e' = etaExpand n e</span>
<a name="line-1389"></a><span class='hs-comment'>--</span>
<a name="line-1390"></a><span class='hs-comment'>-- We should have that:</span>
<a name="line-1391"></a><span class='hs-comment'>--</span>
<a name="line-1392"></a><span class='hs-comment'>-- &gt; ty = exprType e = exprType e'</span>
<a name="line-1393"></a><span class='hs-definition'>etaExpand</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1394"></a><a name="etaExpandAT"></a><span class='hs-definition'>etaExpandAT</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArityType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1395"></a>
<a name="line-1396"></a><span class='hs-definition'>etaExpand</span>   <span class='hs-varid'>n</span>          <span class='hs-varid'>orig_expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eta_expand</span> <span class='hs-layout'>(</span><span class='hs-varid'>replicate</span> <span class='hs-varid'>n</span> <span class='hs-conid'>NoOneShotInfo</span><span class='hs-layout'>)</span> <span class='hs-varid'>orig_expr</span>
<a name="line-1397"></a><span class='hs-definition'>etaExpandAT</span> <span class='hs-layout'>(</span><span class='hs-conid'>AT</span> <span class='hs-varid'>oss</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>orig_expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eta_expand</span> <span class='hs-varid'>oss</span>                         <span class='hs-varid'>orig_expr</span>
<a name="line-1398"></a>                           <span class='hs-comment'>-- See Note [Eta expansion with ArityType]</span>
<a name="line-1399"></a>
<a name="line-1400"></a><span class='hs-comment'>-- etaExpand arity e = res</span>
<a name="line-1401"></a><span class='hs-comment'>-- Then 'res' has at least 'arity' lambdas at the top</span>
<a name="line-1402"></a><span class='hs-comment'>--    possibly with a cast wrapped around the outside</span>
<a name="line-1403"></a><span class='hs-comment'>-- See Note [Eta expansion with ArityType]</span>
<a name="line-1404"></a><span class='hs-comment'>--</span>
<a name="line-1405"></a><span class='hs-comment'>-- etaExpand deals with for-alls. For example:</span>
<a name="line-1406"></a><span class='hs-comment'>--              etaExpand 1 E</span>
<a name="line-1407"></a><span class='hs-comment'>-- where  E :: forall a. a -&gt; a</span>
<a name="line-1408"></a><span class='hs-comment'>-- would return</span>
<a name="line-1409"></a><span class='hs-comment'>--      (/\b. \y::a -&gt; E b y)</span>
<a name="line-1410"></a>
<a name="line-1411"></a><a name="eta_expand"></a><span class='hs-definition'>eta_expand</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1412"></a><span class='hs-definition'>eta_expand</span> <span class='hs-varid'>one_shots</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1413"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCast</span> <span class='hs-layout'>(</span><span class='hs-varid'>eta_expand</span> <span class='hs-varid'>one_shots</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-1414"></a>
<a name="line-1415"></a><span class='hs-definition'>eta_expand</span> <span class='hs-varid'>one_shots</span> <span class='hs-varid'>orig_expr</span>
<a name="line-1416"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>one_shots</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>orig_expr</span>
<a name="line-1417"></a>  <span class='hs-keyword'>where</span>
<a name="line-1418"></a>      <span class='hs-comment'>-- Strip off existing lambdas and casts before handing off to mkEtaWW</span>
<a name="line-1419"></a>      <span class='hs-comment'>-- This is mainly to avoid spending time cloning binders and substituting</span>
<a name="line-1420"></a>      <span class='hs-comment'>-- when there is actually nothing to do.  It's slightly awkward to deal</span>
<a name="line-1421"></a>      <span class='hs-comment'>-- with casts here, apart from the topmost one, and they are rare, so</span>
<a name="line-1422"></a>      <span class='hs-comment'>-- if we find one we just hand off to mkEtaWW anyway</span>
<a name="line-1423"></a>      <span class='hs-comment'>-- Note [Eta expansion and SCCs]</span>
<a name="line-1424"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_expr</span>  <span class='hs-comment'>-- Already has the specified arity; no-op</span>
<a name="line-1425"></a>
<a name="line-1426"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>oss</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-conop'>:</span><span class='hs-varid'>oss1</span><span class='hs-layout'>)</span> <span class='hs-varid'>vs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1427"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>oss</span>  <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1428"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>oss1</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1429"></a>
<a name="line-1430"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>rev_vs</span> <span class='hs-varid'>expr</span>
<a name="line-1431"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "ee" (vcat [ppr orig_expr, ppr expr, pprEtaInfos etas]) $</span>
<a name="line-1432"></a>        <span class='hs-varid'>retick</span> <span class='hs-varop'>$</span> <span class='hs-varid'>etaInfoAbs</span> <span class='hs-varid'>top_eis</span> <span class='hs-varop'>$</span>
<a name="line-1433"></a>                 <span class='hs-varid'>etaInfoApp</span> <span class='hs-varid'>in_scope'</span> <span class='hs-varid'>sexpr</span> <span class='hs-varid'>eis</span>
<a name="line-1434"></a>      <span class='hs-keyword'>where</span>
<a name="line-1435"></a>          <span class='hs-varid'>in_scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprFreeVars</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1436"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>in_scope'</span><span class='hs-layout'>,</span> <span class='hs-varid'>eis</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>eta_bndrs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1437"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEtaWW</span> <span class='hs-varid'>oss</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>orig_expr</span><span class='hs-layout'>)</span> <span class='hs-varid'>in_scope</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-1438"></a>          <span class='hs-varid'>top_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_vs</span>
<a name="line-1439"></a>          <span class='hs-varid'>top_eis</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EI</span> <span class='hs-layout'>(</span><span class='hs-varid'>top_bndrs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>eta_bndrs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkPiMCos</span> <span class='hs-varid'>top_bndrs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span>
<a name="line-1440"></a>
<a name="line-1441"></a>          <span class='hs-comment'>-- Find ticks behind type apps.</span>
<a name="line-1442"></a>          <span class='hs-comment'>-- See Note [Eta expansion and source notes]</span>
<a name="line-1443"></a>          <span class='hs-comment'>-- I don't really understand this code SLPJ May 21</span>
<a name="line-1444"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>expr'</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectArgs</span> <span class='hs-varid'>expr</span>
<a name="line-1445"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>ticks</span><span class='hs-layout'>,</span> <span class='hs-varid'>expr''</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stripTicksTop</span> <span class='hs-varid'>tickishFloatable</span> <span class='hs-varid'>expr'</span>
<a name="line-1446"></a>          <span class='hs-varid'>sexpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>expr''</span> <span class='hs-varid'>args</span>
<a name="line-1447"></a>          <span class='hs-varid'>retick</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkTick</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>ticks</span>
<a name="line-1448"></a>
<a name="line-1449"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1450"></a>*                                                                      *
<a name="line-1451"></a>              The EtaInfo mechanism
<a name="line-1452"></a>          mkEtaWW, etaInfoAbs, etaInfoApp
<a name="line-1453"></a>*                                                                      *
<a name="line-1454"></a>********************************************************************* -}</span>
<a name="line-1455"></a>
<a name="line-1456"></a><span class='hs-comment'>{- Note [The EtaInfo mechanism]
<a name="line-1457"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1458"></a>Suppose we have (e :: ty) and we want to eta-expand it to arity N.
<a name="line-1459"></a>This what eta_expand does.  We do it in two steps:
<a name="line-1460"></a>
<a name="line-1461"></a>1.  mkEtaWW: from 'ty' and 'N' build a EtaInfo which describes
<a name="line-1462"></a>    the shape of the expansion necessary to expand to arity N.
<a name="line-1463"></a>
<a name="line-1464"></a>2.  Build the term
<a name="line-1465"></a>       \ v1..vn.  e v1 .. vn
<a name="line-1466"></a>    where those abstractions and applications are described by
<a name="line-1467"></a>    the same EtaInfo.  Specifically we build the term
<a name="line-1468"></a>
<a name="line-1469"></a>       etaInfoAbs etas (etaInfoApp in_scope e etas)
<a name="line-1470"></a>
<a name="line-1471"></a>   where etas :: EtaInfo
<a name="line-1472"></a>         etaInfoAbs builds the lambdas
<a name="line-1473"></a>         etaInfoApp builds the applictions
<a name="line-1474"></a>
<a name="line-1475"></a>   Note that the /same/ EtaInfo drives both etaInfoAbs and etaInfoApp
<a name="line-1476"></a>
<a name="line-1477"></a>To a first approximation EtaInfo is just [Var].  But
<a name="line-1478"></a>casts complicate the question.  If we have
<a name="line-1479"></a>   newtype N a = MkN (S -&gt; a)
<a name="line-1480"></a>and
<a name="line-1481"></a>   ty = N (N Int)
<a name="line-1482"></a>then the eta-expansion must look like
<a name="line-1483"></a>        (\x (\y. ((e |&gt; co1) x) |&gt; co2) y)
<a name="line-1484"></a>           |&gt; sym co2)
<a name="line-1485"></a>        |&gt; sym co1
<a name="line-1486"></a>where
<a name="line-1487"></a>  co1 :: N (N Int) ~ S -&gt; N Int
<a name="line-1488"></a>  co2 :: N Int     ~ S -&gt; Int
<a name="line-1489"></a>
<a name="line-1490"></a>Blimey!  Look at all those casts.  Moreover, if the type
<a name="line-1491"></a>is very deeply nested (as happens in #18223), the repetition
<a name="line-1492"></a>of types can make the overall term very large.  So there is a big
<a name="line-1493"></a>payoff in cancelling out casts aggressively wherever possible.
<a name="line-1494"></a>(See also Note [No crap in eta-expanded code].)
<a name="line-1495"></a>
<a name="line-1496"></a>This matters a lot in etaEInfoApp, where we
<a name="line-1497"></a>* Do beta-reduction on the fly
<a name="line-1498"></a>* Use getArg_maybe to get a cast out of the way,
<a name="line-1499"></a>  so that we can do beta reduction
<a name="line-1500"></a>Together this makes a big difference.  Consider when e is
<a name="line-1501"></a>   case x of
<a name="line-1502"></a>      True  -&gt; (\x -&gt; e1) |&gt; c1
<a name="line-1503"></a>      False -&gt; (\p -&gt; e2) |&gt; c2
<a name="line-1504"></a>
<a name="line-1505"></a>When we eta-expand this to arity 1, say, etaInfoAbs will wrap
<a name="line-1506"></a>a (\eta) around the outside and use etaInfoApp to apply each
<a name="line-1507"></a>alternative to 'eta'.  We want to beta-reduce all that junk
<a name="line-1508"></a>away.
<a name="line-1509"></a>
<a name="line-1510"></a>#18223 was a dramatic example in which the intermediate term was
<a name="line-1511"></a>grotesquely huge, even though the next Simplifier iteration squashed
<a name="line-1512"></a>it.  Better to kill it at birth.
<a name="line-1513"></a>-}</span>
<a name="line-1514"></a>
<a name="line-1515"></a><a name="EtaInfo"></a><span class='hs-comment'>--------------</span>
<a name="line-1516"></a><a name="EtaInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>EtaInfo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EI</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>MCoercionR</span>
<a name="line-1517"></a>
<a name="line-1518"></a><span class='hs-comment'>-- EI bs co</span>
<a name="line-1519"></a><span class='hs-comment'>-- Abstraction:  (\b1 b2 .. bn. []) |&gt; sym co</span>
<a name="line-1520"></a><span class='hs-comment'>-- Application:  ([] |&gt; co) b1 b2 .. bn</span>
<a name="line-1521"></a><span class='hs-comment'>--</span>
<a name="line-1522"></a><span class='hs-comment'>--    e :: T    co :: T ~ (t1 -&gt; t2 -&gt; .. -&gt; tn -&gt; tr)</span>
<a name="line-1523"></a><span class='hs-comment'>--    e = (\b1 b2 ... bn. (e |&gt; co) b1 b2 .. bn) |&gt; sym co</span>
<a name="line-1524"></a>
<a name="line-1525"></a>
<a name="line-1526"></a><a name="etaInfoApp"></a><span class='hs-definition'>etaInfoApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InScopeSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EtaInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1527"></a><span class='hs-comment'>-- (etaInfoApp s e eis) returns something equivalent to</span>
<a name="line-1528"></a><span class='hs-comment'>--             (substExpr s e `appliedto` eis)</span>
<a name="line-1529"></a><span class='hs-comment'>-- See Note [The EtaInfo mechanism]</span>
<a name="line-1530"></a>
<a name="line-1531"></a><span class='hs-definition'>etaInfoApp</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>eis</span>
<a name="line-1532"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkEmptySubst</span> <span class='hs-varid'>in_scope</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>eis</span>
<a name="line-1533"></a>  <span class='hs-keyword'>where</span>
<a name="line-1534"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EtaInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1535"></a>    <span class='hs-comment'>-- 'go' pushed down the eta-infos into the branch of a case</span>
<a name="line-1536"></a>    <span class='hs-comment'>-- and the body of a let; and does beta-reduction if possible</span>
<a name="line-1537"></a>    <span class='hs-comment'>--   go subst fun co [b1,..,bn]  returns  (subst(fun) |&gt; co) b1 .. bn</span>
<a name="line-1538"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>eis</span>
<a name="line-1539"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Tick</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTickish</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>e</span> <span class='hs-varid'>eis</span><span class='hs-layout'>)</span>
<a name="line-1540"></a>
<a name="line-1541"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span>
<a name="line-1542"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Core.substCo</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`mkTransMCoR`</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1543"></a>
<a name="line-1544"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-varid'>b</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-varid'>eis</span>
<a name="line-1545"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Case</span> <span class='hs-layout'>(</span><span class='hs-conid'>Core.substExprSC</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>b1</span> <span class='hs-varid'>ty'</span> <span class='hs-varid'>alts'</span>
<a name="line-1546"></a>      <span class='hs-keyword'>where</span>
<a name="line-1547"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>subst1</span><span class='hs-layout'>,</span> <span class='hs-varid'>b1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Core.substBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>b</span>
<a name="line-1548"></a>        <span class='hs-varid'>alts'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>subst_alt</span> <span class='hs-varid'>alts</span>
<a name="line-1549"></a>        <span class='hs-varid'>ty'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>etaInfoAppTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Core.substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>eis</span>
<a name="line-1550"></a>        <span class='hs-varid'>subst_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bs'</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>subst2</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>eis</span><span class='hs-layout'>)</span>
<a name="line-1551"></a>                 <span class='hs-keyword'>where</span>
<a name="line-1552"></a>                  <span class='hs-layout'>(</span><span class='hs-varid'>subst2</span><span class='hs-layout'>,</span><span class='hs-varid'>bs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Core.substBndrs</span> <span class='hs-varid'>subst1</span> <span class='hs-varid'>bs</span>
<a name="line-1553"></a>
<a name="line-1554"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>eis</span>
<a name="line-1555"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinBind</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [Eta expansion for join points]</span>
<a name="line-1556"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-varid'>b'</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>e</span> <span class='hs-varid'>eis</span><span class='hs-layout'>)</span>
<a name="line-1557"></a>      <span class='hs-keyword'>where</span>
<a name="line-1558"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Core.substBindSC</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>b</span>
<a name="line-1559"></a>
<a name="line-1560"></a>    <span class='hs-comment'>-- Beta-reduction if possible, pushing any intervening casts past</span>
<a name="line-1561"></a>    <span class='hs-comment'>-- the argument. See Note [The EtaInfo mechansim]</span>
<a name="line-1562"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>v</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span>
<a name="line-1563"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-layout'>,</span><span class='hs-varid'>mco'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushMCoArg</span> <span class='hs-varid'>mco</span> <span class='hs-layout'>(</span><span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-1564"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>Core.extendSubst</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>v</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco'</span><span class='hs-layout'>)</span>
<a name="line-1565"></a>
<a name="line-1566"></a>    <span class='hs-comment'>-- Stop pushing down; just wrap the expression up</span>
<a name="line-1567"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Core.substExprSC</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>e</span>
<a name="line-1568"></a>                             <span class='hs-varop'>`mkCastMCo`</span> <span class='hs-varid'>mco</span>
<a name="line-1569"></a>                             <span class='hs-varop'>`mkVarApps`</span> <span class='hs-varid'>bs</span>
<a name="line-1570"></a>
<a name="line-1571"></a><a name="etaInfoAppTy"></a><span class='hs-comment'>--------------</span>
<a name="line-1572"></a><span class='hs-definition'>etaInfoAppTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EtaInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1573"></a><span class='hs-comment'>-- If                    e :: ty</span>
<a name="line-1574"></a><span class='hs-comment'>-- then   etaInfoApp e eis :: etaInfoApp ty eis</span>
<a name="line-1575"></a><span class='hs-definition'>etaInfoAppTy</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span>
<a name="line-1576"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyTypeToArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"etaInfoAppTy"</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty1</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span>
<a name="line-1577"></a>  <span class='hs-keyword'>where</span>
<a name="line-1578"></a>    <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mco</span> <span class='hs-keyword'>of</span>
<a name="line-1579"></a>             <span class='hs-conid'>MRefl</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ty</span>
<a name="line-1580"></a>             <span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>coercionRKind</span> <span class='hs-varid'>co</span>
<a name="line-1581"></a>
<a name="line-1582"></a><a name="etaInfoAbs"></a><span class='hs-comment'>--------------</span>
<a name="line-1583"></a><span class='hs-definition'>etaInfoAbs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EtaInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1584"></a><span class='hs-comment'>-- See Note [The EtaInfo mechanism]</span>
<a name="line-1585"></a><span class='hs-definition'>etaInfoAbs</span> <span class='hs-layout'>(</span><span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkLams</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkCastMCo`</span> <span class='hs-varid'>mkSymMCo</span> <span class='hs-varid'>mco</span>
<a name="line-1586"></a>
<a name="line-1587"></a><a name="mkEtaWW"></a><span class='hs-comment'>--------------</span>
<a name="line-1588"></a><span class='hs-comment'>-- | @mkEtaWW n _ fvs ty@ will compute the 'EtaInfo' necessary for eta-expanding</span>
<a name="line-1589"></a><span class='hs-comment'>-- an expression @e :: ty@ to take @n@ value arguments, where @fvs@ are the</span>
<a name="line-1590"></a><span class='hs-comment'>-- free variables of @e@.</span>
<a name="line-1591"></a><span class='hs-comment'>--</span>
<a name="line-1592"></a><span class='hs-comment'>-- Note that this function is entirely unconcerned about cost centres and other</span>
<a name="line-1593"></a><span class='hs-comment'>-- semantically-irrelevant source annotations, so call sites must take care to</span>
<a name="line-1594"></a><span class='hs-comment'>-- preserve that info. See Note [Eta expansion and SCCs].</span>
<a name="line-1595"></a><span class='hs-definition'>mkEtaWW</span>
<a name="line-1596"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>
<a name="line-1597"></a>  <span class='hs-comment'>-- ^ How many value arguments to eta-expand</span>
<a name="line-1598"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1599"></a>  <span class='hs-comment'>-- ^ The pretty-printed original expression, for warnings.</span>
<a name="line-1600"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeSet</span>
<a name="line-1601"></a>  <span class='hs-comment'>-- ^ A super-set of the free vars of the expression to eta-expand.</span>
<a name="line-1602"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1603"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>InScopeSet</span><span class='hs-layout'>,</span> <span class='hs-conid'>EtaInfo</span><span class='hs-layout'>)</span>
<a name="line-1604"></a>  <span class='hs-comment'>-- ^ The variables in 'EtaInfo' are fresh wrt. to the incoming 'InScopeSet'.</span>
<a name="line-1605"></a>  <span class='hs-comment'>-- The outgoing 'InScopeSet' extends the incoming 'InScopeSet' with the</span>
<a name="line-1606"></a>  <span class='hs-comment'>-- fresh variables in 'EtaInfo'.</span>
<a name="line-1607"></a>
<a name="line-1608"></a><span class='hs-definition'>mkEtaWW</span> <span class='hs-varid'>orig_oss</span> <span class='hs-varid'>ppr_orig_expr</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>orig_ty</span>
<a name="line-1609"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>orig_oss</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>orig_ty</span>
<a name="line-1610"></a>  <span class='hs-keyword'>where</span>
<a name="line-1611"></a>    <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-varid'>in_scope</span>
<a name="line-1612"></a>
<a name="line-1613"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>                <span class='hs-comment'>-- For fresh names</span>
<a name="line-1614"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneShotInfo</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- Number of value args to expand to</span>
<a name="line-1615"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TCvSubst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>   <span class='hs-comment'>-- We are really looking at subst(ty)</span>
<a name="line-1616"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>InScopeSet</span><span class='hs-layout'>,</span> <span class='hs-conid'>EtaInfo</span><span class='hs-layout'>)</span>
<a name="line-1617"></a>    <span class='hs-comment'>-- (go [o1,..,on] subst ty) = (in_scope, EI [b1,..,bn] co)</span>
<a name="line-1618"></a>    <span class='hs-comment'>--    co :: subst(ty) ~ b1_ty -&gt; ... -&gt; bn_ty -&gt; tr</span>
<a name="line-1619"></a>
<a name="line-1620"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>subst</span> <span class='hs-keyword'>_</span>       <span class='hs-comment'>-- See Note [exprArity invariant]</span>
<a name="line-1621"></a>       <span class='hs-comment'>----------- Done!  No more expansion needed</span>
<a name="line-1622"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>getTCvInScope</span> <span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-1623"></a>
<a name="line-1624"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>oss</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>one_shot</span><span class='hs-conop'>:</span><span class='hs-varid'>oss1</span><span class='hs-layout'>)</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty</span>       <span class='hs-comment'>-- See Note [exprArity invariant]</span>
<a name="line-1625"></a>       <span class='hs-comment'>----------- Forall types  (forall a. ty)</span>
<a name="line-1626"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcv</span><span class='hs-layout'>,</span><span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1627"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcv'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>Type.substVarBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tcv</span>
<a name="line-1628"></a>       <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>oss'</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>tcv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oss</span>
<a name="line-1629"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oss1</span>
<a name="line-1630"></a>         <span class='hs-comment'>-- A forall can bind a CoVar, in which case</span>
<a name="line-1631"></a>         <span class='hs-comment'>-- we consume one of the [OneShotInfo]</span>
<a name="line-1632"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>oss'</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>ty'</span>
<a name="line-1633"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcv'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkHomoForAllMCo</span> <span class='hs-varid'>tcv'</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1634"></a>
<a name="line-1635"></a>       <span class='hs-comment'>----------- Function types  (t1 -&gt; t2)</span>
<a name="line-1636"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>mult</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1637"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeLevPoly</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1638"></a>          <span class='hs-comment'>-- See Note [Representation polymorphism invariants] in GHC.Core</span>
<a name="line-1639"></a>          <span class='hs-comment'>-- See also test case typecheck/should_run/EtaExpandLevPoly</span>
<a name="line-1640"></a>
<a name="line-1641"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>eta_id</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>freshEtaId</span> <span class='hs-varid'>n</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1642"></a>          <span class='hs-comment'>-- Avoid free vars of the original expression</span>
<a name="line-1643"></a>
<a name="line-1644"></a>       <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>eta_id'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eta_id</span> <span class='hs-varop'>`setIdOneShotInfo`</span> <span class='hs-varid'>one_shot</span>
<a name="line-1645"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>oss1</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>res_ty</span>
<a name="line-1646"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-layout'>(</span><span class='hs-varid'>eta_id'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFunResMCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>idScaledType</span> <span class='hs-varid'>eta_id'</span><span class='hs-layout'>)</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1647"></a>
<a name="line-1648"></a>       <span class='hs-comment'>----------- Newtypes</span>
<a name="line-1649"></a>       <span class='hs-comment'>-- Given this:</span>
<a name="line-1650"></a>       <span class='hs-comment'>--      newtype T = MkT ([T] -&gt; Int)</span>
<a name="line-1651"></a>       <span class='hs-comment'>-- Consider eta-expanding this</span>
<a name="line-1652"></a>       <span class='hs-comment'>--      eta_expand 1 e T</span>
<a name="line-1653"></a>       <span class='hs-comment'>-- We want to get</span>
<a name="line-1654"></a>       <span class='hs-comment'>--      coerce T (\x::[T] -&gt; (coerce ([T]-&gt;Int) e) x)</span>
<a name="line-1655"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>topNormaliseNewType_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1656"></a>       <span class='hs-layout'>,</span> <span class='hs-comment'>-- co :: ty ~ ty'</span>
<a name="line-1657"></a>         <span class='hs-keyword'>let</span> <span class='hs-varid'>co'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type.substCo</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>co</span>
<a name="line-1658"></a>             <span class='hs-comment'>-- Remember to apply the substitution to co (#16979)</span>
<a name="line-1659"></a>             <span class='hs-comment'>-- (or we could have applied to ty, but then</span>
<a name="line-1660"></a>             <span class='hs-comment'>--  we'd have had to zap it for the recursive call)</span>
<a name="line-1661"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>oss</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty'</span>
<a name="line-1662"></a>         <span class='hs-comment'>-- mco :: subst(ty') ~ b1_ty -&gt; ... -&gt; bn_ty -&gt; tr</span>
<a name="line-1663"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>in_scope</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTransMCoR</span> <span class='hs-varid'>co'</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1664"></a>
<a name="line-1665"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-comment'>-- We have an expression of arity &gt; 0,</span>
<a name="line-1666"></a>                         <span class='hs-comment'>-- but its type isn't a function, or a binder</span>
<a name="line-1667"></a>                         <span class='hs-comment'>-- is representation-polymorphic</span>
<a name="line-1668"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>orig_oss</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>orig_ty</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr_orig_expr</span> <span class='hs-layout'>)</span>
<a name="line-1669"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>getTCvInScope</span> <span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-conid'>EI</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-1670"></a>        <span class='hs-comment'>-- This *can* legitimately happen:</span>
<a name="line-1671"></a>        <span class='hs-comment'>-- e.g.  coerce Int (\x. x) Essentially the programmer is</span>
<a name="line-1672"></a>        <span class='hs-comment'>-- playing fast and loose with types (Happy does this a lot).</span>
<a name="line-1673"></a>        <span class='hs-comment'>-- So we simply decline to eta-expand.  Otherwise we'd end up</span>
<a name="line-1674"></a>        <span class='hs-comment'>-- with an explicit lambda having a non-function type</span>
<a name="line-1675"></a>
<a name="line-1676"></a>
<a name="line-1677"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1678"></a>*                                                                      *
<a name="line-1679"></a>              The "push rules"
<a name="line-1680"></a>*                                                                      *
<a name="line-1681"></a>************************************************************************
<a name="line-1682"></a>
<a name="line-1683"></a>Here we implement the "push rules" from FC papers:
<a name="line-1684"></a>
<a name="line-1685"></a>* The push-argument rules, where we can move a coercion past an argument.
<a name="line-1686"></a>  We have
<a name="line-1687"></a>      (fun |&gt; co) arg
<a name="line-1688"></a>  and we want to transform it to
<a name="line-1689"></a>    (fun arg') |&gt; co'
<a name="line-1690"></a>  for some suitable co' and transformed arg'.
<a name="line-1691"></a>
<a name="line-1692"></a>* The PushK rule for data constructors.  We have
<a name="line-1693"></a>       (K e1 .. en) |&gt; co
<a name="line-1694"></a>  and we want to transform to
<a name="line-1695"></a>       (K e1' .. en')
<a name="line-1696"></a>  by pushing the coercion into the arguments
<a name="line-1697"></a>-}</span>
<a name="line-1698"></a>
<a name="line-1699"></a><a name="pushCoArgs"></a><span class='hs-definition'>pushCoArgs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercion</span><span class='hs-layout'>)</span>
<a name="line-1700"></a><span class='hs-definition'>pushCoArgs</span> <span class='hs-varid'>co</span> <span class='hs-conid'>[]</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1701"></a><span class='hs-definition'>pushCoArgs</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-conop'>:</span><span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg'</span><span class='hs-layout'>,</span>  <span class='hs-varid'>m_co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushCoArg</span>  <span class='hs-varid'>co</span>  <span class='hs-varid'>arg</span>
<a name="line-1702"></a>                              <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m_co1</span> <span class='hs-keyword'>of</span>
<a name="line-1703"></a>                                  <span class='hs-conid'>MCo</span> <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>args'</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushCoArgs</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>args</span>
<a name="line-1704"></a>                                                 <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg'</span><span class='hs-conop'>:</span><span class='hs-varid'>args'</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1705"></a>                                  <span class='hs-conid'>MRefl</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg'</span><span class='hs-conop'>:</span><span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1706"></a>
<a name="line-1707"></a><a name="pushMCoArg"></a><span class='hs-definition'>pushMCoArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>MCoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreArg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercion</span><span class='hs-layout'>)</span>
<a name="line-1708"></a><span class='hs-definition'>pushMCoArg</span> <span class='hs-conid'>MRefl</span>    <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-layout'>,</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-1709"></a><span class='hs-definition'>pushMCoArg</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushCoArg</span> <span class='hs-varid'>co</span> <span class='hs-varid'>arg</span>
<a name="line-1710"></a>
<a name="line-1711"></a><a name="pushCoArg"></a><span class='hs-definition'>pushCoArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreArg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreArg</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercion</span><span class='hs-layout'>)</span>
<a name="line-1712"></a><span class='hs-comment'>-- We have (fun |&gt; co) arg, and we want to transform it to</span>
<a name="line-1713"></a><span class='hs-comment'>--         (fun arg) |&gt; co</span>
<a name="line-1714"></a><span class='hs-comment'>-- This may fail, e.g. if (fun :: N) where N is a newtype</span>
<a name="line-1715"></a><span class='hs-comment'>-- C.f. simplCast in GHC.Core.Opt.Simplify</span>
<a name="line-1716"></a><span class='hs-comment'>-- 'co' is always Representational</span>
<a name="line-1717"></a><span class='hs-definition'>pushCoArg</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushCoTyArg</span> <span class='hs-varid'>co</span> <span class='hs-varid'>ty</span>
<a name="line-1718"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1719"></a><span class='hs-definition'>pushCoArg</span> <span class='hs-varid'>co</span> <span class='hs-varid'>val_arg</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushCoValArg</span> <span class='hs-varid'>co</span>
<a name="line-1720"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>val_arg</span> <span class='hs-varop'>`mkCastMCo`</span> <span class='hs-varid'>arg_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>m_co'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1721"></a>
<a name="line-1722"></a><a name="pushCoTyArg"></a><span class='hs-definition'>pushCoTyArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercionR</span><span class='hs-layout'>)</span>
<a name="line-1723"></a><span class='hs-comment'>-- We have (fun |&gt; co) @ty</span>
<a name="line-1724"></a><span class='hs-comment'>-- Push the coercion through to return</span>
<a name="line-1725"></a><span class='hs-comment'>--         (fun @ty') |&gt; co'</span>
<a name="line-1726"></a><span class='hs-comment'>-- 'co' is always Representational</span>
<a name="line-1727"></a><span class='hs-comment'>-- If the returned coercion is Nothing, then it would have been reflexive;</span>
<a name="line-1728"></a><span class='hs-comment'>-- it's faster not to compute it, though.</span>
<a name="line-1729"></a><span class='hs-definition'>pushCoTyArg</span> <span class='hs-varid'>co</span> <span class='hs-varid'>ty</span>
<a name="line-1730"></a>  <span class='hs-comment'>-- The following is inefficient - don't do `eqType` here, the coercion</span>
<a name="line-1731"></a>  <span class='hs-comment'>-- optimizer will take care of it. See #14737.</span>
<a name="line-1732"></a>  <span class='hs-comment'>-- -- | tyL `eqType` tyR</span>
<a name="line-1733"></a>  <span class='hs-comment'>-- -- = Just (ty, Nothing)</span>
<a name="line-1734"></a>
<a name="line-1735"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isReflCo</span> <span class='hs-varid'>co</span>
<a name="line-1736"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-1737"></a>
<a name="line-1738"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isForAllTy_ty</span> <span class='hs-varid'>tyL</span>
<a name="line-1739"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isForAllTy_ty</span> <span class='hs-varid'>tyR</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>)</span>
<a name="line-1740"></a>    <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCo</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-1741"></a>
<a name="line-1742"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1743"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1744"></a>  <span class='hs-keyword'>where</span>
<a name="line-1745"></a>    <span class='hs-conid'>Pair</span> <span class='hs-varid'>tyL</span> <span class='hs-varid'>tyR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1746"></a>       <span class='hs-comment'>-- co :: tyL ~ tyR</span>
<a name="line-1747"></a>       <span class='hs-comment'>-- tyL = forall (a1 :: k1). ty1</span>
<a name="line-1748"></a>       <span class='hs-comment'>-- tyR = forall (a2 :: k2). ty2</span>
<a name="line-1749"></a>
<a name="line-1750"></a>    <span class='hs-varid'>co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNthCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-num'>0</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1751"></a>       <span class='hs-comment'>-- co1 :: k2 ~N k1</span>
<a name="line-1752"></a>       <span class='hs-comment'>-- Note that NthCo can extract a Nominal equality between the</span>
<a name="line-1753"></a>       <span class='hs-comment'>-- kinds of the types related by a coercion between forall-types.</span>
<a name="line-1754"></a>       <span class='hs-comment'>-- See the NthCo case in GHC.Core.Lint.</span>
<a name="line-1755"></a>
<a name="line-1756"></a>    <span class='hs-varid'>co2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInstCo</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkGReflLeftCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span>
<a name="line-1757"></a>        <span class='hs-comment'>-- co2 :: ty1[ (ty|&gt;co1)/a1 ] ~ ty2[ ty/a2 ]</span>
<a name="line-1758"></a>        <span class='hs-comment'>-- Arg of mkInstCo is always nominal, hence mkNomReflCo</span>
<a name="line-1759"></a>
<a name="line-1760"></a><a name="pushCoValArg"></a><span class='hs-definition'>pushCoValArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCoercionR</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercionR</span><span class='hs-layout'>)</span>
<a name="line-1761"></a><span class='hs-comment'>-- We have (fun |&gt; co) arg</span>
<a name="line-1762"></a><span class='hs-comment'>-- Push the coercion through to return</span>
<a name="line-1763"></a><span class='hs-comment'>--         (fun (arg |&gt; co_arg)) |&gt; co_res</span>
<a name="line-1764"></a><span class='hs-comment'>-- 'co' is always Representational</span>
<a name="line-1765"></a><span class='hs-comment'>-- If the second returned Coercion is actually Nothing, then no cast is necessary;</span>
<a name="line-1766"></a><span class='hs-comment'>-- the returned coercion would have been reflexive.</span>
<a name="line-1767"></a><span class='hs-definition'>pushCoValArg</span> <span class='hs-varid'>co</span>
<a name="line-1768"></a>  <span class='hs-comment'>-- The following is inefficient - don't do `eqType` here, the coercion</span>
<a name="line-1769"></a>  <span class='hs-comment'>-- optimizer will take care of it. See #14737.</span>
<a name="line-1770"></a>  <span class='hs-comment'>-- -- | tyL `eqType` tyR</span>
<a name="line-1771"></a>  <span class='hs-comment'>-- -- = Just (mkRepReflCo arg, Nothing)</span>
<a name="line-1772"></a>
<a name="line-1773"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isReflCo</span> <span class='hs-varid'>co</span>
<a name="line-1774"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>MRefl</span><span class='hs-layout'>,</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-1775"></a>
<a name="line-1776"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFunTy</span> <span class='hs-varid'>tyL</span>
<a name="line-1777"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>co_mult</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decomposeFunCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>co</span>
<a name="line-1778"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isReflexiveCo</span> <span class='hs-varid'>co_mult</span>
<a name="line-1779"></a>    <span class='hs-comment'>-- We can't push the coercion in the case where co_mult isn't reflexivity:</span>
<a name="line-1780"></a>    <span class='hs-comment'>-- it could be an unsafe axiom, and losing this information could yield</span>
<a name="line-1781"></a>    <span class='hs-comment'>-- ill-typed terms. For instance (fun x ::(1) Int -&gt; (fun _ -&gt; () |&gt; co) x)</span>
<a name="line-1782"></a>    <span class='hs-comment'>-- with co :: (Int -&gt; ()) ~ (Int %1 -&gt; ()), would reduce to (fun x ::(1) Int</span>
<a name="line-1783"></a>    <span class='hs-comment'>-- -&gt; (fun _ ::(Many) Int -&gt; ()) x) which is ill-typed</span>
<a name="line-1784"></a>
<a name="line-1785"></a>              <span class='hs-comment'>-- If   co  :: (tyL1 -&gt; tyL2) ~ (tyR1 -&gt; tyR2)</span>
<a name="line-1786"></a>              <span class='hs-comment'>-- then co1 :: tyL1 ~ tyR1</span>
<a name="line-1787"></a>              <span class='hs-comment'>--      co2 :: tyL2 ~ tyR2</span>
<a name="line-1788"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isFunTy</span> <span class='hs-varid'>tyR</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>)</span>
<a name="line-1789"></a>    <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>coToMCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>coToMCo</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-1790"></a>    <span class='hs-comment'>-- Critically, coToMCo to checks for ReflCo; the whole coercion may not</span>
<a name="line-1791"></a>    <span class='hs-comment'>-- be reflexive, but either of its components might be</span>
<a name="line-1792"></a>    <span class='hs-comment'>-- We could use isReflexiveCo, but it's not clear if the benefit</span>
<a name="line-1793"></a>    <span class='hs-comment'>-- is worth the cost, and it makes no difference in #18223</span>
<a name="line-1794"></a>
<a name="line-1795"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1796"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1797"></a>  <span class='hs-keyword'>where</span>
<a name="line-1798"></a>    <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>funArgTy</span> <span class='hs-varid'>tyR</span>
<a name="line-1799"></a>    <span class='hs-conid'>Pair</span> <span class='hs-varid'>tyL</span> <span class='hs-varid'>tyR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1800"></a>
<a name="line-1801"></a><a name="pushCoercionIntoLambda"></a><span class='hs-definition'>pushCoercionIntoLambda</span>
<a name="line-1802"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HasDebugCallStack</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>InScopeSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1803"></a><span class='hs-comment'>-- This implements the Push rule from the paper on coercions</span>
<a name="line-1804"></a><span class='hs-comment'>--    (\x. e) |&gt; co</span>
<a name="line-1805"></a><span class='hs-comment'>-- ===&gt;</span>
<a name="line-1806"></a><span class='hs-comment'>--    (\x'. e |&gt; co')</span>
<a name="line-1807"></a><span class='hs-definition'>pushCoercionIntoLambda</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span>
<a name="line-1808"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyVar</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isCoVar</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-1809"></a>    <span class='hs-layout'>,</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>s1s2</span> <span class='hs-varid'>t1t2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1810"></a>    <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-sel'>_s1</span><span class='hs-layout'>,</span><span class='hs-sel'>_s2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>s1s2</span>
<a name="line-1811"></a>    <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>w1</span><span class='hs-layout'>,</span> <span class='hs-varid'>t1</span><span class='hs-layout'>,</span><span class='hs-sel'>_t2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>t1t2</span>
<a name="line-1812"></a>    <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>co_mult</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decomposeFunCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>co</span>
<a name="line-1813"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>isReflexiveCo</span> <span class='hs-varid'>co_mult</span>
<a name="line-1814"></a>      <span class='hs-comment'>-- We can't push the coercion in the case where co_mult isn't</span>
<a name="line-1815"></a>      <span class='hs-comment'>-- reflexivity. See pushCoValArg for more details.</span>
<a name="line-1816"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-1817"></a>          <span class='hs-comment'>-- Should we optimize the coercions here?</span>
<a name="line-1818"></a>          <span class='hs-comment'>-- Otherwise they might not match too well</span>
<a name="line-1819"></a>          <span class='hs-varid'>x'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`setIdType`</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>`setIdMult`</span> <span class='hs-varid'>w1</span>
<a name="line-1820"></a>          <span class='hs-varid'>in_scope'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>in_scope</span> <span class='hs-varop'>`extendInScopeSet`</span> <span class='hs-varid'>x'</span>
<a name="line-1821"></a>          <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendIdSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkEmptySubst</span> <span class='hs-varid'>in_scope'</span><span class='hs-layout'>)</span>
<a name="line-1822"></a>                                <span class='hs-varid'>x</span>
<a name="line-1823"></a>                                <span class='hs-layout'>(</span><span class='hs-varid'>mkCast</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>x'</span><span class='hs-layout'>)</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span>
<a name="line-1824"></a>      <span class='hs-keyword'>in</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x'</span><span class='hs-layout'>,</span> <span class='hs-varid'>substExpr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>e</span> <span class='hs-varop'>`mkCast`</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-1825"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1826"></a>      <span class='hs-comment'>-- See #21555 / #21577 for a case where this trace fired but the cause was benign</span>
<a name="line-1827"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "exprIsLambda_maybe: Unexpected lambda in case" (ppr (Lam x e))</span>
<a name="line-1828"></a>      <span class='hs-conid'>Nothing</span>
<a name="line-1829"></a>
<a name="line-1830"></a><a name="pushCoDataCon"></a><span class='hs-definition'>pushCoDataCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span>
<a name="line-1831"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataCon</span>
<a name="line-1832"></a>                       <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- Universal type args</span>
<a name="line-1833"></a>                       <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- All other args incl existentials</span>
<a name="line-1834"></a><span class='hs-comment'>-- Implement the KPush reduction rule as described in "Down with kinds"</span>
<a name="line-1835"></a><span class='hs-comment'>-- The transformation applies iff we have</span>
<a name="line-1836"></a><span class='hs-comment'>--      (C e1 ... en) `cast` co</span>
<a name="line-1837"></a><span class='hs-comment'>-- where co :: (T t1 .. tn) ~ to_ty</span>
<a name="line-1838"></a><span class='hs-comment'>-- The left-hand one must be a T, because exprIsConApp returned True</span>
<a name="line-1839"></a><span class='hs-comment'>-- but the right-hand one might not be.  (Though it usually will.)</span>
<a name="line-1840"></a><span class='hs-definition'>pushCoDataCon</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>dc_args</span> <span class='hs-varid'>co</span>
<a name="line-1841"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isReflCo</span> <span class='hs-varid'>co</span> <span class='hs-varop'>||</span> <span class='hs-varid'>from_ty</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>to_ty</span>  <span class='hs-comment'>-- try cheap test first</span>
<a name="line-1842"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>univ_ty_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>rest_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAtList</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varid'>dc_args</span>
<a name="line-1843"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>map</span> <span class='hs-varid'>exprToType</span> <span class='hs-varid'>univ_ty_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>rest_args</span><span class='hs-layout'>)</span>
<a name="line-1844"></a>
<a name="line-1845"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>to_tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>to_tc_arg_tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>to_ty</span>
<a name="line-1846"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>to_tc</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span>
<a name="line-1847"></a>        <span class='hs-comment'>-- These two tests can fail; we might see</span>
<a name="line-1848"></a>        <span class='hs-comment'>--      (C x y) `cast` (g :: T a ~ S [a]),</span>
<a name="line-1849"></a>        <span class='hs-comment'>-- where S is a type function.  In fact, exprIsConApp</span>
<a name="line-1850"></a>        <span class='hs-comment'>-- will probably not be called in such circumstances,</span>
<a name="line-1851"></a>        <span class='hs-comment'>-- but there's nothing wrong with it</span>
<a name="line-1852"></a>
<a name="line-1853"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-1854"></a>        <span class='hs-varid'>tc_arity</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>to_tc</span>
<a name="line-1855"></a>        <span class='hs-varid'>dc_univ_tyvars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>dc</span>
<a name="line-1856"></a>        <span class='hs-varid'>dc_ex_tcvars</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>dc</span>
<a name="line-1857"></a>        <span class='hs-varid'>arg_tys</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dataConRepArgTys</span> <span class='hs-varid'>dc</span>
<a name="line-1858"></a>
<a name="line-1859"></a>        <span class='hs-varid'>non_univ_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropList</span> <span class='hs-varid'>dc_univ_tyvars</span> <span class='hs-varid'>dc_args</span>
<a name="line-1860"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>ex_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAtList</span> <span class='hs-varid'>dc_ex_tcvars</span> <span class='hs-varid'>non_univ_args</span>
<a name="line-1861"></a>
<a name="line-1862"></a>        <span class='hs-comment'>-- Make the "Psi" from the paper</span>
<a name="line-1863"></a>        <span class='hs-varid'>omegas</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decomposeCo</span> <span class='hs-varid'>tc_arity</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRolesRepresentational</span> <span class='hs-varid'>to_tc</span><span class='hs-layout'>)</span>
<a name="line-1864"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>psi_subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>to_ex_arg_tys</span><span class='hs-layout'>)</span>
<a name="line-1865"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>liftCoSubstWithEx</span> <span class='hs-conid'>Representational</span>
<a name="line-1866"></a>                              <span class='hs-varid'>dc_univ_tyvars</span>
<a name="line-1867"></a>                              <span class='hs-varid'>omegas</span>
<a name="line-1868"></a>                              <span class='hs-varid'>dc_ex_tcvars</span>
<a name="line-1869"></a>                              <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>exprToType</span> <span class='hs-varid'>ex_args</span><span class='hs-layout'>)</span>
<a name="line-1870"></a>
<a name="line-1871"></a>          <span class='hs-comment'>-- Cast the value arguments (which include dictionaries)</span>
<a name="line-1872"></a>        <span class='hs-varid'>new_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>cast_arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>val_args</span>
<a name="line-1873"></a>        <span class='hs-varid'>cast_arg</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCast</span> <span class='hs-varid'>arg</span> <span class='hs-layout'>(</span><span class='hs-varid'>psi_subst</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-1874"></a>
<a name="line-1875"></a>        <span class='hs-varid'>to_ex_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>to_ex_arg_tys</span>
<a name="line-1876"></a>
<a name="line-1877"></a>        <span class='hs-varid'>dump_doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span>      <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc_univ_tyvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc_ex_tcvars</span><span class='hs-layout'>,</span>
<a name="line-1878"></a>                         <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dc_args</span><span class='hs-layout'>,</span>
<a name="line-1879"></a>                         <span class='hs-varid'>ppr</span> <span class='hs-varid'>ex_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>from_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>to_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>to_tc</span>
<a name="line-1880"></a>                         <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>to_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>exprToType</span> <span class='hs-varop'>$</span> <span class='hs-varid'>takeList</span> <span class='hs-varid'>dc_univ_tyvars</span> <span class='hs-varid'>dc_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1881"></a>    <span class='hs-keyword'>in</span>
<a name="line-1882"></a>    <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>eqType</span> <span class='hs-varid'>from_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>to_tc</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>exprToType</span> <span class='hs-varop'>$</span> <span class='hs-varid'>takeList</span> <span class='hs-varid'>dc_univ_tyvars</span> <span class='hs-varid'>dc_args</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>dump_doc</span> <span class='hs-layout'>)</span>
<a name="line-1883"></a>    <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>equalLength</span> <span class='hs-varid'>val_args</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>dump_doc</span> <span class='hs-layout'>)</span>
<a name="line-1884"></a>    <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>to_tc_arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>to_ex_args</span> <span class='hs-varop'>++</span> <span class='hs-varid'>new_val_args</span><span class='hs-layout'>)</span>
<a name="line-1885"></a>
<a name="line-1886"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1887"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1888"></a>
<a name="line-1889"></a>  <span class='hs-keyword'>where</span>
<a name="line-1890"></a>    <span class='hs-conid'>Pair</span> <span class='hs-varid'>from_ty</span> <span class='hs-varid'>to_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1891"></a>
<a name="line-1892"></a><a name="collectBindersPushingCo"></a><span class='hs-definition'>collectBindersPushingCo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1893"></a><span class='hs-comment'>-- Collect lambda binders, pushing coercions inside if possible</span>
<a name="line-1894"></a><span class='hs-comment'>-- E.g.   (\x.e) |&gt; g         g :: &lt;Int&gt; -&gt; blah</span>
<a name="line-1895"></a><span class='hs-comment'>--        = (\x. e |&gt; Nth 1 g)</span>
<a name="line-1896"></a><span class='hs-comment'>--</span>
<a name="line-1897"></a><span class='hs-comment'>-- That is,</span>
<a name="line-1898"></a><span class='hs-comment'>--</span>
<a name="line-1899"></a><span class='hs-comment'>-- collectBindersPushingCo ((\x.e) |&gt; g) === ([x], e |&gt; Nth 1 g)</span>
<a name="line-1900"></a><span class='hs-definition'>collectBindersPushingCo</span> <span class='hs-varid'>e</span>
<a name="line-1901"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>e</span>
<a name="line-1902"></a>  <span class='hs-keyword'>where</span>
<a name="line-1903"></a>    <span class='hs-comment'>-- Peel off lambdas until we hit a cast.</span>
<a name="line-1904"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1905"></a>    <span class='hs-comment'>-- The accumulator is in reverse order</span>
<a name="line-1906"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1907"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_c</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span>
<a name="line-1908"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span>           <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1909"></a>
<a name="line-1910"></a>    <span class='hs-comment'>-- We are in a cast; peel off casts until we hit a lambda.</span>
<a name="line-1911"></a>    <span class='hs-varid'>go_c</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1912"></a>    <span class='hs-comment'>-- (go_c bs e c) is same as (go bs e (e |&gt; c))</span>
<a name="line-1913"></a>    <span class='hs-varid'>go_c</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-varid'>co2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_c</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>co1</span> <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-1914"></a>    <span class='hs-varid'>go_c</span> <span class='hs-varid'>bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>    <span class='hs-varid'>co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_lam</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span>
<a name="line-1915"></a>    <span class='hs-varid'>go_c</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>e</span>            <span class='hs-varid'>co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1916"></a>
<a name="line-1917"></a>    <span class='hs-comment'>-- We are in a lambda under a cast; peel off lambdas and build a</span>
<a name="line-1918"></a>    <span class='hs-comment'>-- new coercion for the body.</span>
<a name="line-1919"></a>    <span class='hs-varid'>go_lam</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1920"></a>    <span class='hs-comment'>-- (go_lam bs b e c) is same as (go_c bs (\b.e) c)</span>
<a name="line-1921"></a>    <span class='hs-varid'>go_lam</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span>
<a name="line-1922"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span>
<a name="line-1923"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>tyL</span> <span class='hs-varid'>tyR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1924"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isForAllTy_ty</span> <span class='hs-varid'>tyL</span> <span class='hs-layout'>)</span>
<a name="line-1925"></a>        <span class='hs-varid'>isForAllTy_ty</span> <span class='hs-varid'>tyR</span>
<a name="line-1926"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNthCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-num'>0</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [collectBindersPushingCo]</span>
<a name="line-1927"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_c</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInstCo</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNomReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1928"></a>
<a name="line-1929"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCoVar</span> <span class='hs-varid'>b</span>
<a name="line-1930"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>tyL</span> <span class='hs-varid'>tyR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1931"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isForAllTy_co</span> <span class='hs-varid'>tyL</span> <span class='hs-layout'>)</span>
<a name="line-1932"></a>        <span class='hs-varid'>isForAllTy_co</span> <span class='hs-varid'>tyR</span>
<a name="line-1933"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNthCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-num'>0</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [collectBindersPushingCo]</span>
<a name="line-1934"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>cov</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoVarCo</span> <span class='hs-varid'>b</span>
<a name="line-1935"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_c</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInstCo</span> <span class='hs-varid'>co</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNomReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoercionTy</span> <span class='hs-varid'>cov</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1936"></a>
<a name="line-1937"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span>
<a name="line-1938"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>tyL</span> <span class='hs-varid'>tyR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-1939"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isFunTy</span> <span class='hs-varid'>tyL</span><span class='hs-layout'>)</span> <span class='hs-varid'>isFunTy</span> <span class='hs-varid'>tyR</span>
<a name="line-1940"></a>      <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>co_mult</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_arg</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decomposeFunCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>co</span>
<a name="line-1941"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isReflCo</span> <span class='hs-varid'>co_mult</span> <span class='hs-comment'>-- See Note [collectBindersPushingCo]</span>
<a name="line-1942"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isReflCo</span> <span class='hs-varid'>co_arg</span>  <span class='hs-comment'>-- See Note [collectBindersPushingCo]</span>
<a name="line-1943"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_c</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-conop'>:</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co_res</span>
<a name="line-1944"></a>
<a name="line-1945"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1946"></a>
<a name="line-1947"></a><span class='hs-comment'>{-
<a name="line-1948"></a>
<a name="line-1949"></a>Note [collectBindersPushingCo]
<a name="line-1950"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1951"></a>We just look for coercions of form
<a name="line-1952"></a>   &lt;type&gt; # w -&gt; blah
<a name="line-1953"></a>(and similarly for foralls) to keep this function simple.  We could do
<a name="line-1954"></a>more elaborate stuff, but it'd involve substitution etc.
<a name="line-1955"></a>
<a name="line-1956"></a>-}</span>
<a name="line-1957"></a>
<a name="line-1958"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1959"></a>*                                                                      *
<a name="line-1960"></a>                Join points
<a name="line-1961"></a>*                                                                      *
<a name="line-1962"></a>********************************************************************* -}</span>
<a name="line-1963"></a>
<a name="line-1964"></a><a name="etaExpandToJoinPoint"></a><span class='hs-comment'>-------------------</span>
<a name="line-1965"></a><span class='hs-comment'>-- | Split an expression into the given number of binders and a body,</span>
<a name="line-1966"></a><span class='hs-comment'>-- eta-expanding if necessary. Counts value *and* type binders.</span>
<a name="line-1967"></a><span class='hs-definition'>etaExpandToJoinPoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>JoinArity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1968"></a><span class='hs-definition'>etaExpandToJoinPoint</span> <span class='hs-varid'>join_arity</span> <span class='hs-varid'>expr</span>
<a name="line-1969"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>join_arity</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>expr</span>
<a name="line-1970"></a>  <span class='hs-keyword'>where</span>
<a name="line-1971"></a>    <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>rev_bs</span> <span class='hs-varid'>e</span>         <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1972"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>rev_bs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rev_bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-1973"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>rev_bs</span> <span class='hs-varid'>e</span>         <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>etaBodyForJoinPoint</span> <span class='hs-varid'>n</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>of</span>
<a name="line-1974"></a>                              <span class='hs-layout'>(</span><span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_bs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-1975"></a>
<a name="line-1976"></a><a name="etaExpandToJoinPointRule"></a><span class='hs-definition'>etaExpandToJoinPointRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>JoinArity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreRule</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreRule</span>
<a name="line-1977"></a><span class='hs-definition'>etaExpandToJoinPointRule</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rule</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>BuiltinRule</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1978"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"Can't eta-expand built-in rule:"</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rule</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1979"></a>      <span class='hs-comment'>-- How did a local binding get a built-in rule anyway? Probably a plugin.</span>
<a name="line-1980"></a>    <span class='hs-varid'>rule</span>
<a name="line-1981"></a><span class='hs-definition'>etaExpandToJoinPointRule</span> <span class='hs-varid'>join_arity</span> <span class='hs-varid'>rule</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-1982"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ru_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1983"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>need_args</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span>
<a name="line-1984"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span>
<a name="line-1985"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>need_args</span> <span class='hs-varop'>&lt;</span> <span class='hs-num'>0</span>
<a name="line-1986"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"etaExpandToJoinPointRule"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>join_arity</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rule</span><span class='hs-layout'>)</span>
<a name="line-1987"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1988"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ru_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndrs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>new_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ru_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-varop'>++</span> <span class='hs-varid'>new_args</span>
<a name="line-1989"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>ru_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_rhs</span> <span class='hs-layout'>}</span>
<a name="line-1990"></a>  <span class='hs-keyword'>where</span>
<a name="line-1991"></a>    <span class='hs-varid'>need_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>join_arity</span> <span class='hs-comment'>-</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span>
<a name="line-1992"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>new_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>etaBodyForJoinPoint</span> <span class='hs-varid'>need_args</span> <span class='hs-varid'>rhs</span>
<a name="line-1993"></a>    <span class='hs-varid'>new_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varsToCoreExprs</span> <span class='hs-varid'>new_bndrs</span>
<a name="line-1994"></a>
<a name="line-1995"></a><a name="etaBodyForJoinPoint"></a><span class='hs-comment'>-- Adds as many binders as asked for; assumes expr is not a lambda</span>
<a name="line-1996"></a><span class='hs-definition'>etaBodyForJoinPoint</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreBndr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1997"></a><span class='hs-definition'>etaBodyForJoinPoint</span> <span class='hs-varid'>need_args</span> <span class='hs-varid'>body</span>
<a name="line-1998"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>need_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>init_subst</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span>
<a name="line-1999"></a>  <span class='hs-keyword'>where</span>
<a name="line-2000"></a>    <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-keyword'>_</span>  <span class='hs-keyword'>_</span>     <span class='hs-varid'>rev_bs</span> <span class='hs-varid'>e</span>
<a name="line-2001"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>rev_bs</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-2002"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>rev_bs</span> <span class='hs-varid'>e</span>
<a name="line-2003"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitForAllTyCoVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-2004"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substVarBndr</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tv</span>
<a name="line-2005"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>res_ty</span> <span class='hs-varid'>subst'</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rev_bs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-varop'>`App`</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span>
<a name="line-2006"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>mult</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitFunTy_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-2007"></a>        <span class='hs-comment'>-- The varToCoreExpr is important: `tv` might be a coercion variable</span>
<a name="line-2008"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>freshEtaId</span> <span class='hs-varid'>n</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg_ty</span><span class='hs-layout'>)</span>
<a name="line-2009"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>res_ty</span> <span class='hs-varid'>subst'</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rev_bs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-varop'>`App`</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-2010"></a>        <span class='hs-comment'>-- The varToCoreExpr is important: `b` might be a coercion variable</span>
<a name="line-2011"></a>
<a name="line-2012"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2013"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"etaBodyForJoinPoint"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>int</span> <span class='hs-varid'>need_args</span> <span class='hs-varop'>$$</span>
<a name="line-2014"></a>                                         <span class='hs-varid'>ppr</span> <span class='hs-varid'>body</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-2015"></a>
<a name="line-2016"></a>    <span class='hs-varid'>init_subst</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprFreeVars</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2017"></a>
<a name="line-2018"></a>
<a name="line-2019"></a>
<a name="line-2020"></a><a name="freshEtaId"></a><span class='hs-comment'>--------------</span>
<a name="line-2021"></a><span class='hs-definition'>freshEtaId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TCvSubst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TCvSubst</span><span class='hs-layout'>,</span> <span class='hs-conid'>Id</span><span class='hs-layout'>)</span>
<a name="line-2022"></a><span class='hs-comment'>-- Make a fresh Id, with specified type (after applying substitution)</span>
<a name="line-2023"></a><span class='hs-comment'>-- It should be "fresh" in the sense that it's not in the in-scope set</span>
<a name="line-2024"></a><span class='hs-comment'>-- of the TvSubstEnv; and it should itself then be added to the in-scope</span>
<a name="line-2025"></a><span class='hs-comment'>-- set of the TvSubstEnv</span>
<a name="line-2026"></a><span class='hs-comment'>--</span>
<a name="line-2027"></a><span class='hs-comment'>-- The Int is just a reasonable starting point for generating a unique;</span>
<a name="line-2028"></a><span class='hs-comment'>-- it does not necessarily have to be unique itself.</span>
<a name="line-2029"></a><span class='hs-definition'>freshEtaId</span> <span class='hs-varid'>n</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty</span>
<a name="line-2030"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>eta_id'</span><span class='hs-layout'>)</span>
<a name="line-2031"></a>      <span class='hs-keyword'>where</span>
<a name="line-2032"></a>        <span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult'</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type.substScaledTyUnchecked</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>ty</span>
<a name="line-2033"></a>        <span class='hs-varid'>eta_id'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uniqAway</span> <span class='hs-layout'>(</span><span class='hs-varid'>getTCvInScope</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2034"></a>                  <span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"eta"</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkBuiltinUnique</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-varid'>mult'</span> <span class='hs-varid'>ty'</span>
<a name="line-2035"></a>                  <span class='hs-comment'>-- "OrCoVar" since this can be used to eta-expand</span>
<a name="line-2036"></a>                  <span class='hs-comment'>-- coercion abstractions</span>
<a name="line-2037"></a>        <span class='hs-varid'>subst'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendTCvInScope</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>eta_id'</span>
</pre></body>
</html>
