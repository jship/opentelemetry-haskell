<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681074342"><span id="local-6989586621681074343"><span id="local-6989586621681074344"><span id="local-6989586621681074345"><span id="local-6989586621681074346"><span id="local-6989586621681074347"><span id="local-6989586621681074348"><span id="local-6989586621681074349"><span id="local-6989586621681074350"><span id="local-6989586621681074351"><span id="local-6989586621681074352"><span id="local-6989586621681074353"><span id="local-6989586621681074354"><span id="local-6989586621681074355"><span id="local-6989586621681074356"><span id="local-6989586621681074357"></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE DataKinds #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE ExistentialQuantification #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-9"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilyDependencies #-}</span><span>
</span><span id="line-11"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-12"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span class="hs-pragma">{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span><span>
</span><span id="line-15"></span><span>
</span><span id="line-16"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
-}</span><span>
</span><span id="line-20"></span><span>
</span><span id="line-21"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span class="hs-comment">-- | Abstract Haskell syntax for expressions.</span><span>
</span><span id="line-24"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Expr</span><span> </span><span class="hs-keyword">where</span><span class="hs-cpp">

#include &quot;HsVersions.h&quot;
</span><span>
</span><span id="line-28"></span><span class="hs-comment">-- friends:</span><span>
</span><span id="line-29"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-30"></span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html"><span class="hs-identifier">Language.Haskell.Syntax.Decls</span></a></span><span>
</span><span id="line-32"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-33"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html"><span class="hs-identifier">Language.Haskell.Syntax.Lit</span></a></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html"><span class="hs-identifier">Language.Haskell.Syntax.Type</span></a></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html"><span class="hs-identifier">Language.Haskell.Syntax.Binds</span></a></span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span class="hs-comment">-- others:</span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html"><span class="hs-identifier">GHC.Core.DataCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.FieldLabel.html#FieldLabelString"><span class="hs-identifier">FieldLabelString</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Name.html"><span class="hs-identifier">GHC.Types.Name</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html"><span class="hs-identifier">GHC.Types.Fixity</span></a></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span>
</span><span id="line-46"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Tickish.html"><span class="hs-identifier">GHC.Types.Tickish</span></a></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.ConLike.html"><span class="hs-identifier">GHC.Core.ConLike</span></a></span><span>
</span><span id="line-48"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Unit.Module.html"><span class="hs-identifier">GHC.Unit.Module</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Unit.Module.Name.html#ModuleName"><span class="hs-identifier">ModuleName</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html"><span class="hs-identifier">GHC.Utils.Outputable</span></a></span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Panic.html"><span class="hs-identifier">GHC.Utils.Panic</span></a></span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html"><span class="hs-identifier">GHC.Data.FastString</span></a></span><span>
</span><span id="line-52"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-53"></span><span>
</span><span id="line-54"></span><span class="hs-comment">-- libraries:</span><span>
</span><span id="line-55"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#"><span class="hs-identifier">Data.Data</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-56"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#"><span class="hs-identifier">Data.Data</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Data</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-57"></span><span>
</span><span id="line-58"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-List-NonEmpty.html#"><span class="hs-identifier">Data.List.NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#NonEmpty"><span class="hs-identifier">NonEmpty</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-59"></span><span>
</span><span id="line-60"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../ghci-9.2.7/src/GHCi-RemoteTypes.html#"><span class="hs-identifier">GHCi.RemoteTypes</span></a></span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../ghci-9.2.7/src/GHCi-RemoteTypes.html#ForeignRef"><span class="hs-identifier">ForeignRef</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><a href="../../template-haskell-2.18.0.0/src/Language-Haskell-TH.html#"><span class="hs-identifier">Language.Haskell.TH</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">TH</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../template-haskell-2.18.0.0/src/Language-Haskell-TH-Syntax.html#Q"><span class="hs-identifier">Q</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>
</span><span id="line-63"></span><span class="hs-comment">{- Note [RecordDotSyntax field updates]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The extensions @OverloadedRecordDot@ @OverloadedRecordUpdate@ together
enable record updates like @a{foo.bar.baz = 1}@. Introducing this
syntax slightly complicates parsing. This note explains how it's done.

In the event a record is being constructed or updated, it's this
production that's in play:
@
aexp1 -&gt; aexp1 '{' fbinds '}' {
  ...
  mkHsRecordPV ... $1 (snd $3)
}
@
@fbinds@ is a list of field bindings. @mkHsRecordPV@ is a function of
the @DisambECP b@ typeclass, see Note [Ambiguous syntactic
categories].

The &quot;normal&quot; rules for an @fbind@ are:
@
fbind
        : qvar '=' texp
        | qvar
@
These rules compute values of @LHsRecField GhcPs (Located b)@. They
apply in the context of record construction, record updates, record
patterns and record expressions. That is, @b@ ranges over @HsExpr
GhcPs@, @HsPat GhcPs@ and @HsCmd GhcPs@.

When @OverloadedRecordDot@ and @OverloadedRecordUpdate@ are both
enabled, two additional @fbind@ rules are admitted:
@
        | field TIGHT_INFIX_PROJ fieldToUpdate '=' texp
        | field TIGHT_INFIX_PROJ fieldToUpdate
@

These rules only make sense when parsing record update expressions
(that is, patterns and commands cannot be parsed by these rules and
neither record constructions).

The results of these new rules cannot be represented by @LHsRecField
GhcPs (LHsExpr GhcPs)@ values as the type is defined today. We
minimize modifying existing code by having these new rules calculate
@LHsRecProj GhcPs (Located b)@ (&quot;record projection&quot;) values instead:
@
newtype FieldLabelStrings = FieldLabelStrings [Located FieldLabelString]
type RecProj arg = HsRecField' FieldLabelStrings arg
type LHsRecProj p arg = Located (RecProj arg)
@

The @fbind@ rule is then given the type @fbind :: { forall b.
DisambECP b =&gt; PV (Fbind b) }@ accomodating both alternatives:
@
type Fbind b = Either
                  (LHsRecField GhcPs (Located b))
                  ( LHsRecProj GhcPs (Located b))
@

In @data HsExpr p@, the @RecordUpd@ constuctor indicates regular
updates vs. projection updates by means of the @rupd_flds@ member
type, an @Either@ instance:
@
  | RecordUpd
      { rupd_ext  :: XRecordUpd p
      , rupd_expr :: LHsExpr p
      , rupd_flds :: Either [LHsRecUpdField p] [LHsRecUpdProj p]
      }
@
Here,
@
type RecUpdProj p = RecProj (LHsExpr p)
type LHsRecUpdProj p = Located (RecUpdProj p)
@
and @Left@ values indicating regular record update, @Right@ values
updates desugared to @setField@s.

If @OverloadedRecordUpdate@ is enabled, any updates parsed as
@LHsRecField GhcPs@ values are converted to @LHsRecUpdProj GhcPs@
values (see function @mkRdrRecordUpd@ in 'GHC.Parser.PostProcess').
-}</span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span class="hs-comment">-- | RecordDotSyntax field updates</span><span>
</span><span id="line-145"></span><span>
</span><span id="line-146"></span><span class="hs-keyword">newtype</span><span> </span><span id="FieldLabelStrings"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-var">FieldLabelStrings</span></a></span></span><span> </span><span id="local-6989586621681074330"><span class="annot"><a href="#local-6989586621681074330"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-147"></span><span>  </span><span id="FieldLabelStrings"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-var">FieldLabelStrings</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-type">HsFieldLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074330"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-148"></span><span>
</span><span id="line-149"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681074874"><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074874"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-150"></span><span>  </span><span id="local-6989586621681074323"><span class="annot"><span class="annottext">ppr :: FieldLabelStrings p -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span id="local-6989586621681074321"><span class="annot"><span class="annottext">[Located (HsFieldLabel p)]
</span><a href="#local-6989586621681074321"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-151"></span><span>    </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
</span><a href="GHC.Utils.Outputable.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="GHC.Utils.Outputable.html#dot"><span class="hs-identifier hs-var">dot</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Located (HsFieldLabel p)]
</span><a href="#local-6989586621681074321"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681074308"><span id="local-6989586621681074312"><span id="local-6989586621681074860"><span class="annot"><a href="GHC.Utils.Outputable.html#OutputableBndr"><span class="hs-identifier hs-type">OutputableBndr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074860"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-154"></span><span>  </span><span id="local-6989586621681074306"><span class="annot"><span class="annottext">pprInfixOcc :: FieldLabelStrings p -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprInfixOcc"><span class="hs-identifier hs-var hs-var hs-var hs-var">pprInfixOcc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. FieldLabelStrings p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprFieldLabelStrings"><span class="hs-identifier hs-var">pprFieldLabelStrings</span></a></span><span>
</span><span id="line-155"></span><span>  </span><span id="local-6989586621681074303"><span class="annot"><span class="annottext">pprPrefixOcc :: FieldLabelStrings p -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#pprPrefixOcc"><span class="hs-identifier hs-var hs-var hs-var hs-var">pprPrefixOcc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall p. FieldLabelStrings p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprFieldLabelStrings"><span class="hs-identifier hs-var">pprFieldLabelStrings</span></a></span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span id="local-6989586621681074301"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprFieldLabelStrings"><span class="hs-identifier hs-type">pprFieldLabelStrings</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074301"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-158"></span><span id="pprFieldLabelStrings"><span class="annot"><span class="annottext">pprFieldLabelStrings :: forall p. FieldLabelStrings p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprFieldLabelStrings"><span class="hs-identifier hs-var hs-var">pprFieldLabelStrings</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span id="local-6989586621681074299"><span class="annot"><span class="annottext">[Located (HsFieldLabel p)]
</span><a href="#local-6989586621681074299"><span class="hs-identifier hs-var">flds</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-159"></span><span>    </span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#hcat"><span class="hs-identifier hs-var">hcat</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SDoc -&gt; [SDoc] -&gt; [SDoc]
</span><a href="GHC.Utils.Outputable.html#punctuate"><span class="hs-identifier hs-var">punctuate</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="GHC.Utils.Outputable.html#dot"><span class="hs-identifier hs-var">dot</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#map"><span class="hs-identifier hs-var">map</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#."><span class="hs-operator hs-var">.</span></a></span><span> </span><span class="annot"><span class="annottext">forall l e. GenLocated l e -&gt; e
</span><a href="GHC.Types.SrcLoc.html#unLoc"><span class="hs-identifier hs-var">unLoc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Located (HsFieldLabel p)]
</span><a href="#local-6989586621681074299"><span class="hs-identifier hs-var">flds</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-160"></span><span>
</span><span id="line-161"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681074872"><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-type">HsFieldLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074872"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-162"></span><span>  </span><span id="local-6989586621681074295"><span class="annot"><span class="annottext">ppr :: HsFieldLabel p -&gt; SDoc
</span><a href="#local-6989586621681074295"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-type">HsFieldLabel</span></a></span><span> </span><span class="annot"><span class="annottext">XCHsFieldLabel p
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681074293"><span class="annot"><span class="annottext">Located FastString
</span><a href="#local-6989586621681074293"><span class="hs-identifier hs-var">s</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">Located FastString
</span><a href="#local-6989586621681074293"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-163"></span><span>  </span><span class="annot"><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XHsFieldLabel"><span class="hs-identifier hs-type">XHsFieldLabel</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;XHsFieldLabel&quot;</span></span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-comment">-- Field projection updates (e.g. @foo.bar.baz = 1@). See Note</span><span>
</span><span id="line-166"></span><span class="hs-comment">-- [RecordDotSyntax field updates].</span><span>
</span><span id="line-167"></span><span class="hs-keyword">type</span><span> </span><span id="RecProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecProj"><span class="hs-identifier hs-var">RecProj</span></a></span></span><span> </span><span id="local-6989586621681074289"><span class="annot"><a href="#local-6989586621681074289"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681074288"><span class="annot"><a href="#local-6989586621681074288"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecField%27"><span class="hs-identifier hs-type">HsRecField'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FieldLabelStrings"><span class="hs-identifier hs-type">FieldLabelStrings</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074289"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621681074288"><span class="hs-identifier hs-type">arg</span></a></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span class="hs-comment">-- The phantom type parameter @p@ is for symmetry with @LHsRecField p</span><span>
</span><span id="line-170"></span><span class="hs-comment">-- arg@ in the definition of @data Fbind@ (see GHC.Parser.Process).</span><span>
</span><span id="line-171"></span><span class="hs-keyword">type</span><span> </span><span id="LHsRecProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsRecProj"><span class="hs-identifier hs-var">LHsRecProj</span></a></span></span><span> </span><span id="local-6989586621681074285"><span class="annot"><a href="#local-6989586621681074285"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681074284"><span class="annot"><a href="#local-6989586621681074284"><span class="hs-identifier hs-type">arg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074285"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecProj"><span class="hs-identifier hs-type">RecProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074285"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074284"><span class="hs-identifier hs-type">arg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-172"></span><span>
</span><span id="line-173"></span><span class="hs-comment">-- These two synonyms are used in the definition of syntax @RecordUpd@</span><span>
</span><span id="line-174"></span><span class="hs-comment">-- below.</span><span>
</span><span id="line-175"></span><span class="hs-keyword">type</span><span> </span><span id="RecUpdProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecUpdProj"><span class="hs-identifier hs-var">RecUpdProj</span></a></span></span><span> </span><span id="local-6989586621681074282"><span class="annot"><a href="#local-6989586621681074282"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecProj"><span class="hs-identifier hs-type">RecProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074282"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074282"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-176"></span><span class="hs-keyword">type</span><span> </span><span id="LHsRecUpdProj"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsRecUpdProj"><span class="hs-identifier hs-var">LHsRecUpdProj</span></a></span></span><span> </span><span id="local-6989586621681074281"><span class="annot"><a href="#local-6989586621681074281"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074281"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecUpdProj"><span class="hs-identifier hs-type">RecUpdProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074281"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-177"></span><span>
</span><span id="line-178"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Expressions proper}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span class="hs-comment">-- * Expressions proper</span><span>
</span><span id="line-187"></span><span>
</span><span id="line-188"></span><span class="hs-comment">-- | Located Haskell Expression</span><span>
</span><span id="line-189"></span><span class="hs-keyword">type</span><span> </span><span id="LHsExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-var">LHsExpr</span></a></span></span><span> </span><span id="local-6989586621681074280"><span class="annot"><a href="#local-6989586621681074280"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074280"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074280"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-190"></span><span>  </span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span><span>
</span><span id="line-191"></span><span>  </span><span class="hs-comment">--   in a list</span><span>
</span><span id="line-192"></span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-194"></span><span>
</span><span id="line-195"></span><span class="hs-comment">-------------------------</span><span>
</span><span id="line-196"></span><span class="hs-comment">{- Note [NoSyntaxExpr]
~~~~~~~~~~~~~~~~~~~~~~
Syntax expressions can be missing (NoSyntaxExprRn or NoSyntaxExprTc)
for several reasons:

 1. As described in Note [Rebindable if]

 2. In order to suppress &quot;not in scope: xyz&quot; messages when a bit of
    rebindable syntax does not apply. For example, when using an irrefutable
    pattern in a BindStmt, we don't need a `fail` operator.

 3. Rebindable syntax might just not make sense. For example, a BodyStmt
    contains the syntax for `guard`, but that's used only in monad comprehensions.
    If we had more of a whiz-bang type system, we might be able to rule this
    case out statically.
-}</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span class="hs-comment">-- | Syntax Expression</span><span>
</span><span id="line-214"></span><span class="hs-comment">--</span><span>
</span><span id="line-215"></span><span class="hs-comment">-- SyntaxExpr is represents the function used in interpreting rebindable</span><span>
</span><span id="line-216"></span><span class="hs-comment">-- syntax. In the parser, we have no information to supply; in the renamer,</span><span>
</span><span id="line-217"></span><span class="hs-comment">-- we have the name of the function (but see</span><span>
</span><span id="line-218"></span><span class="hs-comment">-- Note [Monad fail : Rebindable syntax, overloaded strings] for a wrinkle)</span><span>
</span><span id="line-219"></span><span class="hs-comment">-- and in the type-checker we have a more elaborate structure 'SyntaxExprTc'.</span><span>
</span><span id="line-220"></span><span class="hs-comment">--</span><span>
</span><span id="line-221"></span><span class="hs-comment">-- In some contexts, rebindable syntax is not implemented, and so we have</span><span>
</span><span id="line-222"></span><span class="hs-comment">-- constructors to represent that possibility in both the renamer and</span><span>
</span><span id="line-223"></span><span class="hs-comment">-- typechecker instantiations.</span><span>
</span><span id="line-224"></span><span class="hs-comment">--</span><span>
</span><span id="line-225"></span><span class="hs-comment">-- E.g. @(&gt;&gt;=)@ is filled in before the renamer by the appropriate 'Name' for</span><span>
</span><span id="line-226"></span><span class="hs-comment">--      @(&gt;&gt;=)@, and then instantiated by the type checker with its type args</span><span>
</span><span id="line-227"></span><span class="hs-comment">--      etc</span><span>
</span><span id="line-228"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="SyntaxExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-var">SyntaxExpr</span></a></span></span><span> </span><span id="local-6989586621681074279"><span class="annot"><a href="#local-6989586621681074279"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-229"></span><span>
</span><span id="line-230"></span><span class="hs-comment">-- | Command Syntax Table (for Arrow syntax)</span><span>
</span><span id="line-231"></span><span class="hs-keyword">type</span><span> </span><span id="CmdSyntaxTable"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdSyntaxTable"><span class="hs-identifier hs-var">CmdSyntaxTable</span></a></span></span><span> </span><span id="local-6989586621681074277"><span class="annot"><a href="#local-6989586621681074277"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074277"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-232"></span><span class="hs-comment">-- See Note [CmdSyntaxTable]</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-comment">{-
Note [CmdSyntaxTable]
~~~~~~~~~~~~~~~~~~~~~
Used only for arrow-syntax stuff (HsCmdTop), the CmdSyntaxTable keeps
track of the methods needed for a Cmd.

* Before the renamer, this list is an empty list

* After the renamer, it takes the form @[(std_name, HsVar actual_name)]@
  For example, for the 'arr' method
   * normal case:            (GHC.Control.Arrow.arr, HsVar GHC.Control.Arrow.arr)
   * with rebindable syntax: (GHC.Control.Arrow.arr, arr_22)
             where @arr_22@ is whatever 'arr' is in scope

* After the type checker, it takes the form [(std_name, &lt;expression&gt;)]
  where &lt;expression&gt; is the evidence for the method.  This evidence is
  instantiated with the class, but is still polymorphic in everything
  else.  For example, in the case of 'arr', the evidence has type
         forall b c. (b-&gt;c) -&gt; a b c
  where 'a' is the ambient type of the arrow.  This polymorphism is
  important because the desugarer uses the same evidence at multiple
  different types.

This is Less Cool than what we normally do for rebindable syntax, which is to
make fully-instantiated piece of evidence at every use site.  The Cmd way
is Less Cool because
  * The renamer has to predict which methods are needed.
    See the tedious GHC.Rename.Expr.methodNamesCmd.

  * The desugarer has to know the polymorphic type of the instantiated
    method. This is checked by Inst.tcSyntaxName, but is less flexible
    than the rest of rebindable syntax, where the type is less
    pre-ordained.  (And this flexibility is useful; for example we can
    typecheck do-notation with (&gt;&gt;=) :: m1 a -&gt; (a -&gt; m2 b) -&gt; m2 b.)
-}</span><span>
</span><span id="line-269"></span><span>
</span><span id="line-270"></span><span class="hs-comment">-- | A Haskell expression.</span><span>
</span><span id="line-271"></span><span class="hs-keyword">data</span><span> </span><span id="HsExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-var">HsExpr</span></a></span></span><span> </span><span id="local-6989586621681074855"><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-272"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsVar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsVar"><span class="hs-identifier hs-var">HsVar</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVar"><span class="hs-identifier hs-type">XVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-273"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Variable</span><span>
</span><span id="line-274"></span><span>                       </span><span class="hs-comment">-- See Note [Located RdrNames]</span><span>
</span><span id="line-275"></span><span>
</span><span id="line-276"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsUnboundVar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUnboundVar"><span class="hs-identifier hs-var">HsUnboundVar</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUnboundVar"><span class="hs-identifier hs-type">XUnboundVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-277"></span><span>                 </span><span class="annot"><a href="GHC.Types.Name.Occurrence.html#OccName"><span class="hs-identifier hs-type">OccName</span></a></span><span>     </span><span class="hs-comment">-- ^ Unbound variable; also used for &quot;holes&quot;</span><span>
</span><span id="line-278"></span><span>                             </span><span class="hs-comment">--   (_ or _x).</span><span>
</span><span id="line-279"></span><span>                             </span><span class="hs-comment">-- Turned from HsVar to HsUnboundVar by the</span><span>
</span><span id="line-280"></span><span>                             </span><span class="hs-comment">--   renamer, when it finds an out-of-scope</span><span>
</span><span id="line-281"></span><span>                             </span><span class="hs-comment">--   variable or hole.</span><span>
</span><span id="line-282"></span><span>                             </span><span class="hs-comment">-- The (XUnboundVar p) field becomes an HoleExprRef</span><span>
</span><span id="line-283"></span><span>                             </span><span class="hs-comment">--   after typechecking; this is where the</span><span>
</span><span id="line-284"></span><span>                             </span><span class="hs-comment">--   erroring expression will be written after</span><span>
</span><span id="line-285"></span><span>                             </span><span class="hs-comment">--   solving. See Note [Holes] in GHC.Tc.Types.Constraint.</span><span>
</span><span id="line-286"></span><span>
</span><span id="line-287"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsConLikeOut"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsConLikeOut"><span class="hs-identifier hs-var">HsConLikeOut</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XConLikeOut"><span class="hs-identifier hs-type">XConLikeOut</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span>                 </span><span class="annot"><a href="GHC.Core.ConLike.html#ConLike"><span class="hs-identifier hs-type">ConLike</span></a></span><span>     </span><span class="hs-comment">-- ^ After typechecker only; must be different</span><span>
</span><span id="line-289"></span><span>                             </span><span class="hs-comment">-- HsVar for pretty printing</span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsRecFld"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRecFld"><span class="hs-identifier hs-var">HsRecFld</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecFld"><span class="hs-identifier hs-type">XRecFld</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-292"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#AmbiguousFieldOcc"><span class="hs-identifier hs-type">AmbiguousFieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Variable pointing to record selector</span><span>
</span><span id="line-293"></span><span>              </span><span class="hs-comment">-- The parser produces HsVars</span><span>
</span><span id="line-294"></span><span>              </span><span class="hs-comment">-- The renamer renames record-field selectors to HsRecFld</span><span>
</span><span id="line-295"></span><span>              </span><span class="hs-comment">-- The typechecker preserves HsRecFld</span><span>
</span><span id="line-296"></span><span>
</span><span id="line-297"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsOverLabel"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsOverLabel"><span class="hs-identifier hs-var">HsOverLabel</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOverLabel"><span class="hs-identifier hs-type">XOverLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span>
</span><span id="line-298"></span><span>     </span><span class="hs-comment">-- ^ Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)</span><span>
</span><span id="line-299"></span><span>
</span><span id="line-300"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIPVar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsIPVar"><span class="hs-identifier hs-var">HsIPVar</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIPVar"><span class="hs-identifier hs-type">XIPVar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-301"></span><span>              </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span>   </span><span class="hs-comment">-- ^ Implicit parameter (not in use after typechecking)</span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsOverLit"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsOverLit"><span class="hs-identifier hs-var">HsOverLit</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOverLitE"><span class="hs-identifier hs-type">XOverLitE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-303"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsOverLit"><span class="hs-identifier hs-type">HsOverLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ Overloaded literals</span><span>
</span><span id="line-304"></span><span>
</span><span id="line-305"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLit"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLit"><span class="hs-identifier hs-var">HsLit</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLitE"><span class="hs-identifier hs-type">XLitE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-306"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Lit.html#HsLit"><span class="hs-identifier hs-type">HsLit</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^ Simple (non-overloaded) literals</span><span>
</span><span id="line-307"></span><span>
</span><span id="line-308"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLam"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLam"><span class="hs-identifier hs-var">HsLam</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLam"><span class="hs-identifier hs-type">XLam</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-309"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-310"></span><span>                       </span><span class="hs-comment">-- ^ Lambda abstraction. Currently always a single match</span><span>
</span><span id="line-311"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-312"></span><span>       </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-313"></span><span>       </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnRarrow',</span><span>
</span><span id="line-314"></span><span>
</span><span id="line-315"></span><span>       </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-316"></span><span>
</span><span id="line-317"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLamCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLamCase"><span class="hs-identifier hs-var">HsLamCase</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLamCase"><span class="hs-identifier hs-type">XLamCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Lambda-case</span><span>
</span><span id="line-318"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-319"></span><span>       </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-320"></span><span>       </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnCase','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-321"></span><span>       </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-322"></span><span>
</span><span id="line-323"></span><span>       </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-324"></span><span>
</span><span id="line-325"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsApp"><span class="hs-identifier hs-var">HsApp</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApp"><span class="hs-identifier hs-type">XApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Application</span><span>
</span><span id="line-326"></span><span>
</span><span id="line-327"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsAppType"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsAppType"><span class="hs-identifier hs-var">HsAppType</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAppTypeE"><span class="hs-identifier hs-type">XAppTypeE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- After typechecking: the type argument</span><span>
</span><span id="line-328"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-329"></span><span>              </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsWcType"><span class="hs-identifier hs-type">LHsWcType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ Visible type application</span><span>
</span><span id="line-330"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-331"></span><span>       </span><span class="hs-comment">-- Explicit type argument; e.g  f @Int x y</span><span>
</span><span id="line-332"></span><span>       </span><span class="hs-comment">-- NB: Has wildcards, but no implicit quantification</span><span>
</span><span id="line-333"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-334"></span><span>       </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnAt',</span><span>
</span><span id="line-335"></span><span>
</span><span id="line-336"></span><span>  </span><span class="hs-comment">-- | Operator applications:</span><span>
</span><span id="line-337"></span><span>  </span><span class="hs-comment">-- NB Bracketed ops such as (+) come out as Vars.</span><span>
</span><span id="line-338"></span><span>
</span><span id="line-339"></span><span>  </span><span class="hs-comment">-- NB Sadly, we need an expr for the operator in an OpApp/Section since</span><span>
</span><span id="line-340"></span><span>  </span><span class="hs-comment">-- the renamer may turn a HsVar into HsRecFld or HsUnboundVar</span><span>
</span><span id="line-341"></span><span>
</span><span id="line-342"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="OpApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#OpApp"><span class="hs-identifier hs-var">OpApp</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XOpApp"><span class="hs-identifier hs-type">XOpApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-343"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- left operand</span><span>
</span><span id="line-344"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- operator</span><span>
</span><span id="line-345"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- right operand</span><span>
</span><span id="line-346"></span><span>
</span><span id="line-347"></span><span>  </span><span class="hs-comment">-- | Negation operator. Contains the negated expression and the name</span><span>
</span><span id="line-348"></span><span>  </span><span class="hs-comment">-- of 'negate'</span><span>
</span><span id="line-349"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-350"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnMinus'</span><span>
</span><span id="line-351"></span><span>
</span><span id="line-352"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-353"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NegApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#NegApp"><span class="hs-identifier hs-var">NegApp</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XNegApp"><span class="hs-identifier hs-type">XNegApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-354"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-355"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-358"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-359"></span><span>
</span><span id="line-360"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-361"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsPar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPar"><span class="hs-identifier hs-var">HsPar</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPar"><span class="hs-identifier hs-type">XPar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-362"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^ Parenthesised expr; see Note [Parens in HsSyn]</span><span>
</span><span id="line-363"></span><span>
</span><span id="line-364"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SectionL"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SectionL"><span class="hs-identifier hs-var">SectionL</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSectionL"><span class="hs-identifier hs-type">XSectionL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-365"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operand; see Note [Sections in HsSyn]</span><span>
</span><span id="line-366"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operator</span><span>
</span><span id="line-367"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SectionR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SectionR"><span class="hs-identifier hs-var">SectionR</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSectionR"><span class="hs-identifier hs-type">XSectionR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-368"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operator; see Note [Sections in HsSyn]</span><span>
</span><span id="line-369"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- operand</span><span>
</span><span id="line-370"></span><span>
</span><span id="line-371"></span><span>  </span><span class="hs-comment">-- | Used for explicit tuples and sections thereof</span><span>
</span><span id="line-372"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-373"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-374"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-375"></span><span>
</span><span id="line-376"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-377"></span><span>  </span><span class="hs-comment">-- Note [ExplicitTuple]</span><span>
</span><span id="line-378"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitTuple"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExplicitTuple"><span class="hs-identifier hs-var">ExplicitTuple</span></a></span></span><span>
</span><span id="line-379"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitTuple"><span class="hs-identifier hs-type">XExplicitTuple</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-380"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTupArg"><span class="hs-identifier hs-type">HsTupArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-381"></span><span>        </span><span class="annot"><a href="GHC.Types.Basic.html#Boxity"><span class="hs-identifier hs-type">Boxity</span></a></span><span>
</span><span id="line-382"></span><span>
</span><span id="line-383"></span><span>  </span><span class="hs-comment">-- | Used for unboxed sum types</span><span>
</span><span id="line-384"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-385"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span><span>
</span><span id="line-386"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnVbar', 'GHC.Parser.Annotation.AnnClose' @'#)'@,</span><span>
</span><span id="line-387"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-comment">--  There will be multiple 'GHC.Parser.Annotation.AnnVbar', (1 - alternative) before</span><span>
</span><span id="line-389"></span><span>  </span><span class="hs-comment">--  the expression, (arity - alternative) after it</span><span>
</span><span id="line-390"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitSum"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExplicitSum"><span class="hs-identifier hs-var">ExplicitSum</span></a></span></span><span>
</span><span id="line-391"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitSum"><span class="hs-identifier hs-type">XExplicitSum</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-392"></span><span>          </span><span class="annot"><a href="GHC.Types.Basic.html#ConTag"><span class="hs-identifier hs-type">ConTag</span></a></span><span> </span><span class="hs-comment">--  Alternative (one-based)</span><span>
</span><span id="line-393"></span><span>          </span><span class="annot"><a href="GHC.Types.Basic.html#Arity"><span class="hs-identifier hs-type">Arity</span></a></span><span>  </span><span class="hs-comment">--  Sum arity</span><span>
</span><span id="line-394"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnCase',</span><span>
</span><span id="line-397"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOf','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-398"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-401"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCase"><span class="hs-identifier hs-var">HsCase</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCase"><span class="hs-identifier hs-type">XCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-402"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-403"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-404"></span><span>
</span><span id="line-405"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf',</span><span>
</span><span id="line-406"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-407"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnThen','GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-408"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnElse',</span><span>
</span><span id="line-409"></span><span>
</span><span id="line-410"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-411"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIf"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsIf"><span class="hs-identifier hs-var">HsIf</span></a></span></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIf"><span class="hs-identifier hs-type">XIf</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- GhcPs: this is a Bool; False &lt;=&gt; do not use</span><span>
</span><span id="line-412"></span><span>                               </span><span class="hs-comment">--  rebindable syntax</span><span>
</span><span id="line-413"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">--  predicate</span><span>
</span><span id="line-414"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">--  then part</span><span>
</span><span id="line-415"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">--  else part</span><span>
</span><span id="line-416"></span><span>
</span><span id="line-417"></span><span>  </span><span class="hs-comment">-- | Multi-way if</span><span>
</span><span id="line-418"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-419"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf'</span><span>
</span><span id="line-420"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-421"></span><span>
</span><span id="line-422"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-423"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsMultiIf"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMultiIf"><span class="hs-identifier hs-var">HsMultiIf</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMultiIf"><span class="hs-identifier hs-type">XMultiIf</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LGRHS"><span class="hs-identifier hs-type">LGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-424"></span><span>
</span><span id="line-425"></span><span>  </span><span class="hs-comment">-- | let(rec)</span><span>
</span><span id="line-426"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-427"></span><span>  </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet',</span><span>
</span><span id="line-428"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-429"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@,'GHC.Parser.Annotation.AnnIn'</span><span>
</span><span id="line-430"></span><span>
</span><span id="line-431"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-432"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsLet"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsLet"><span class="hs-identifier hs-var">HsLet</span></a></span></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLet"><span class="hs-identifier hs-type">XLet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-433"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-434"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDo',</span><span>
</span><span id="line-437"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnOpen', 'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-439"></span><span>  </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-440"></span><span>
</span><span id="line-441"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-442"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsDo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDo"><span class="hs-identifier hs-var">HsDo</span></a></span></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDo"><span class="hs-identifier hs-type">XDo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                  </span><span class="hs-comment">-- Type of the whole expression</span><span>
</span><span id="line-443"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoRn"><span class="hs-identifier hs-type">HsDoRn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-444"></span><span>                </span><span class="hs-comment">-- The parameterisation of the above is unimportant</span><span>
</span><span id="line-445"></span><span>                </span><span class="hs-comment">-- because in this context we never use</span><span>
</span><span id="line-446"></span><span>                </span><span class="hs-comment">-- the PatGuard or ParStmt variant</span><span>
</span><span id="line-447"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- &quot;do&quot;:one or more stmts</span><span>
</span><span id="line-448"></span><span>
</span><span id="line-449"></span><span>  </span><span class="hs-comment">-- | Syntactic list: [a,b,c,...]</span><span>
</span><span id="line-450"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-451"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span><span>
</span><span id="line-452"></span><span>  </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-455"></span><span>  </span><span class="hs-comment">-- See Note [Empty lists]</span><span>
</span><span id="line-456"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitList"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExplicitList"><span class="hs-identifier hs-var">ExplicitList</span></a></span></span><span>
</span><span id="line-457"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExplicitList"><span class="hs-identifier hs-type">XExplicitList</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- Gives type of components of list</span><span>
</span><span id="line-458"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-459"></span><span>
</span><span id="line-460"></span><span>  </span><span class="hs-comment">-- | Record construction</span><span>
</span><span id="line-461"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-462"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-463"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-464"></span><span>
</span><span id="line-465"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-466"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordCon"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecordCon"><span class="hs-identifier hs-var">RecordCon</span></a></span></span><span>
</span><span id="line-467"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="rcon_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRecordCon p
</span><a href="Language.Haskell.Syntax.Expr.html#rcon_ext"><span class="hs-identifier hs-var hs-var">rcon_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecordCon"><span class="hs-identifier hs-type">XRecordCon</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-468"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rcon_con"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRec p (ConLikeP p)
</span><a href="Language.Haskell.Syntax.Expr.html#rcon_con"><span class="hs-identifier hs-var hs-var">rcon_con</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#ConLikeP"><span class="hs-identifier hs-type">ConLikeP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The constructor</span><span>
</span><span id="line-469"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rcon_flds"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; HsRecordBinds p
</span><a href="Language.Haskell.Syntax.Expr.html#rcon_flds"><span class="hs-identifier hs-var hs-var">rcon_flds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRecordBinds"><span class="hs-identifier hs-type">HsRecordBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">}</span><span>    </span><span class="hs-comment">-- The fields</span><span>
</span><span id="line-470"></span><span>
</span><span id="line-471"></span><span>  </span><span class="hs-comment">-- | Record update</span><span>
</span><span id="line-472"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-473"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-474"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-475"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnComma, 'GHC.Parser.Annotation.AnnDot',</span><span>
</span><span id="line-476"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-477"></span><span>
</span><span id="line-478"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-479"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordUpd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecordUpd"><span class="hs-identifier hs-var">RecordUpd</span></a></span></span><span>
</span><span id="line-480"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="rupd_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XRecordUpd p
</span><a href="Language.Haskell.Syntax.Expr.html#rupd_ext"><span class="hs-identifier hs-var hs-var">rupd_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecordUpd"><span class="hs-identifier hs-type">XRecordUpd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-481"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rupd_expr"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; LHsExpr p
</span><a href="Language.Haskell.Syntax.Expr.html#rupd_expr"><span class="hs-identifier hs-var hs-var">rupd_expr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-482"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="rupd_flds"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; Either [LHsRecUpdField p] [LHsRecUpdProj p]
</span><a href="Language.Haskell.Syntax.Expr.html#rupd_flds"><span class="hs-identifier hs-var hs-var">rupd_flds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Either.html#Either"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LHsRecUpdField"><span class="hs-identifier hs-type">LHsRecUpdField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsRecUpdProj"><span class="hs-identifier hs-type">LHsRecUpdProj</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-483"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-484"></span><span>  </span><span class="hs-comment">-- For a type family, the arg types are of the *instance* tycon,</span><span>
</span><span id="line-485"></span><span>  </span><span class="hs-comment">-- not the family tycon</span><span>
</span><span id="line-486"></span><span>
</span><span id="line-487"></span><span>  </span><span class="hs-comment">-- | Record field selection e.g @z.x@.</span><span>
</span><span id="line-488"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-489"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDot'</span><span>
</span><span id="line-490"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-491"></span><span>  </span><span class="hs-comment">-- This case only arises when the OverloadedRecordDot langauge</span><span>
</span><span id="line-492"></span><span>  </span><span class="hs-comment">-- extension is enabled.</span><span>
</span><span id="line-493"></span><span>
</span><span id="line-494"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsGetField"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsGetField"><span class="hs-identifier hs-var">HsGetField</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-495"></span><span>        </span><span id="gf_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XGetField p
</span><a href="Language.Haskell.Syntax.Expr.html#gf_ext"><span class="hs-identifier hs-var hs-var">gf_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XGetField"><span class="hs-identifier hs-type">XGetField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-496"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="gf_expr"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; LHsExpr p
</span><a href="Language.Haskell.Syntax.Expr.html#gf_expr"><span class="hs-identifier hs-var hs-var">gf_expr</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-497"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="gf_field"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; Located (HsFieldLabel p)
</span><a href="Language.Haskell.Syntax.Expr.html#gf_field"><span class="hs-identifier hs-var hs-var">gf_field</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-type">HsFieldLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-498"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-499"></span><span>
</span><span id="line-500"></span><span>  </span><span class="hs-comment">-- | Record field selector. e.g. @(.x)@ or @(.x.y)@</span><span>
</span><span id="line-501"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-502"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpenP'</span><span>
</span><span id="line-503"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnDot', 'GHC.Parser.Annotation.AnnCloseP'</span><span>
</span><span id="line-504"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-505"></span><span>  </span><span class="hs-comment">-- This case only arises when the OverloadedRecordDot langauge</span><span>
</span><span id="line-506"></span><span>  </span><span class="hs-comment">-- extensions is enabled.</span><span>
</span><span id="line-507"></span><span>
</span><span id="line-508"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsProjection"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsProjection"><span class="hs-identifier hs-var">HsProjection</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-509"></span><span>        </span><span id="proj_ext"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; XProjection p
</span><a href="Language.Haskell.Syntax.Expr.html#proj_ext"><span class="hs-identifier hs-var hs-var">proj_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XProjection"><span class="hs-identifier hs-type">XProjection</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-510"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="proj_flds"><span class="annot"><span class="annottext">forall p. HsExpr p -&gt; NonEmpty (Located (HsFieldLabel p))
</span><a href="Language.Haskell.Syntax.Expr.html#proj_flds"><span class="hs-identifier hs-var hs-var">proj_flds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Base.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-type">HsFieldLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-511"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-512"></span><span>
</span><span id="line-513"></span><span>  </span><span class="hs-comment">-- | Expression with an explicit type signature. @e :: type@</span><span>
</span><span id="line-514"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-515"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-516"></span><span>
</span><span id="line-517"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-518"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExprWithTySig"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprWithTySig"><span class="hs-identifier hs-var">ExprWithTySig</span></a></span></span><span>
</span><span id="line-519"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExprWithTySig"><span class="hs-identifier hs-type">XExprWithTySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-520"></span><span>
</span><span id="line-521"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-522"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier hs-type">LHsSigWcType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-523"></span><span>
</span><span id="line-524"></span><span>  </span><span class="hs-comment">-- | Arithmetic sequence</span><span>
</span><span id="line-525"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-526"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span><span>
</span><span id="line-527"></span><span>  </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnComma','GHC.Parser.Annotation.AnnDotdot',</span><span>
</span><span id="line-528"></span><span>  </span><span class="hs-comment">--              'GHC.Parser.Annotation.AnnClose' @']'@</span><span>
</span><span id="line-529"></span><span>
</span><span id="line-530"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-531"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArithSeq"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArithSeq"><span class="hs-identifier hs-var">ArithSeq</span></a></span></span><span>
</span><span id="line-532"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XArithSeq"><span class="hs-identifier hs-type">XArithSeq</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-533"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-534"></span><span>                                  </span><span class="hs-comment">-- For OverloadedLists, the fromList witness</span><span>
</span><span id="line-535"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArithSeqInfo"><span class="hs-identifier hs-type">ArithSeqInfo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-536"></span><span>
</span><span id="line-537"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-538"></span><span>
</span><span id="line-539"></span><span>  </span><span class="hs-comment">-----------------------------------------------------------</span><span>
</span><span id="line-540"></span><span>  </span><span class="hs-comment">-- MetaHaskell Extensions</span><span>
</span><span id="line-541"></span><span>
</span><span id="line-542"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-543"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnOpenE','GHC.Parser.Annotation.AnnOpenEQ',</span><span>
</span><span id="line-544"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose','GHC.Parser.Annotation.AnnCloseQ'</span><span>
</span><span id="line-545"></span><span>
</span><span id="line-546"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-547"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsBracket"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracket"><span class="hs-identifier hs-var">HsBracket</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBracket"><span class="hs-identifier hs-type">XBracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracket"><span class="hs-identifier hs-type">HsBracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-548"></span><span>
</span><span id="line-549"></span><span>    </span><span class="hs-comment">-- See Note [Pending Splices]</span><span>
</span><span id="line-550"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsRnBracketOut"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRnBracketOut"><span class="hs-identifier hs-var">HsRnBracketOut</span></a></span></span><span>
</span><span id="line-551"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRnBracketOut"><span class="hs-identifier hs-type">XRnBracketOut</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-552"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracket"><span class="hs-identifier hs-type">HsBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracketRn"><span class="hs-identifier hs-type">HsBracketRn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Output of the renamer is the *original* renamed</span><span>
</span><span id="line-553"></span><span>                                  </span><span class="hs-comment">-- expression, plus</span><span>
</span><span id="line-554"></span><span>      </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PendingRnSplice%27"><span class="hs-identifier hs-type">PendingRnSplice'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- _renamed_ splices to be type checked</span><span>
</span><span id="line-555"></span><span>
</span><span id="line-556"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTcBracketOut"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTcBracketOut"><span class="hs-identifier hs-var">HsTcBracketOut</span></a></span></span><span>
</span><span id="line-557"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTcBracketOut"><span class="hs-identifier hs-type">XTcBracketOut</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-558"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#QuoteWrapper"><span class="hs-identifier hs-type">QuoteWrapper</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- The wrapper to apply type and dictionary argument</span><span>
</span><span id="line-559"></span><span>                           </span><span class="hs-comment">-- to the quote.</span><span>
</span><span id="line-560"></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracket"><span class="hs-identifier hs-type">HsBracket</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracketRn"><span class="hs-identifier hs-type">HsBracketRn</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Output of the type checker is the *original*</span><span>
</span><span id="line-561"></span><span>                                 </span><span class="hs-comment">-- renamed expression, plus</span><span>
</span><span id="line-562"></span><span>      </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PendingTcSplice%27"><span class="hs-identifier hs-type">PendingTcSplice'</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- _typechecked_ splices to be</span><span>
</span><span id="line-563"></span><span>                           </span><span class="hs-comment">-- pasted back in by the desugarer</span><span>
</span><span id="line-564"></span><span>
</span><span id="line-565"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-566"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-567"></span><span>
</span><span id="line-568"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-569"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsSpliceE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSpliceE"><span class="hs-identifier hs-var">HsSpliceE</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpliceE"><span class="hs-identifier hs-type">XSpliceE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplice"><span class="hs-identifier hs-type">HsSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-570"></span><span>
</span><span id="line-571"></span><span>  </span><span class="hs-comment">-----------------------------------------------------------</span><span>
</span><span id="line-572"></span><span>  </span><span class="hs-comment">-- Arrow notation extension</span><span>
</span><span id="line-573"></span><span>
</span><span id="line-574"></span><span>  </span><span class="hs-comment">-- | @proc@ notation for Arrows</span><span>
</span><span id="line-575"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-576"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnProc',</span><span>
</span><span id="line-577"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnRarrow'</span><span>
</span><span id="line-578"></span><span>
</span><span id="line-579"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-580"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsProc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsProc"><span class="hs-identifier hs-var">HsProc</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XProc"><span class="hs-identifier hs-type">XProc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-581"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- arrow abstraction, proc</span><span>
</span><span id="line-582"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmdTop"><span class="hs-identifier hs-type">LHsCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>          </span><span class="hs-comment">-- body of the abstraction</span><span>
</span><span id="line-583"></span><span>                                       </span><span class="hs-comment">-- always has an empty stack</span><span>
</span><span id="line-584"></span><span>
</span><span id="line-585"></span><span>  </span><span class="hs-comment">---------------------------------------</span><span>
</span><span id="line-586"></span><span>  </span><span class="hs-comment">-- static pointers extension</span><span>
</span><span id="line-587"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnStatic',</span><span>
</span><span id="line-588"></span><span>
</span><span id="line-589"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-590"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsStatic"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStatic"><span class="hs-identifier hs-var">HsStatic</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XStatic"><span class="hs-identifier hs-type">XStatic</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Free variables of the body</span><span>
</span><span id="line-591"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Body</span><span>
</span><span id="line-592"></span><span>
</span><span id="line-593"></span><span>  </span><span class="hs-comment">---------------------------------------</span><span>
</span><span id="line-594"></span><span>  </span><span class="hs-comment">-- Haskell program coverage (Hpc) Support</span><span>
</span><span id="line-595"></span><span>
</span><span id="line-596"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsTick"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTick"><span class="hs-identifier hs-var">HsTick</span></a></span></span><span>
</span><span id="line-597"></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTick"><span class="hs-identifier hs-type">XTick</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-598"></span><span>     </span><span class="annot"><a href="GHC.Types.Tickish.html#CoreTickish"><span class="hs-identifier hs-type">CoreTickish</span></a></span><span>
</span><span id="line-599"></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                       </span><span class="hs-comment">-- sub-expression</span><span>
</span><span id="line-600"></span><span>
</span><span id="line-601"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsBinTick"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBinTick"><span class="hs-identifier hs-var">HsBinTick</span></a></span></span><span>
</span><span id="line-602"></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBinTick"><span class="hs-identifier hs-type">XBinTick</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-603"></span><span>     </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>                                </span><span class="hs-comment">-- module-local tick number for True</span><span>
</span><span id="line-604"></span><span>     </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>                                </span><span class="hs-comment">-- module-local tick number for False</span><span>
</span><span id="line-605"></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>                        </span><span class="hs-comment">-- sub-expression</span><span>
</span><span id="line-606"></span><span>
</span><span id="line-607"></span><span>  </span><span class="hs-comment">---------------------------------------</span><span>
</span><span id="line-608"></span><span>  </span><span class="hs-comment">-- Expressions annotated with pragmas, written as {-# ... #-}</span><span>
</span><span id="line-609"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsPragE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragE"><span class="hs-identifier hs-var">HsPragE</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPragE"><span class="hs-identifier hs-type">XPragE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragE"><span class="hs-identifier hs-type">HsPragE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-610"></span><span>
</span><span id="line-611"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XExpr"><span class="hs-identifier hs-var">XExpr</span></a></span></span><span>       </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXExpr"><span class="hs-identifier hs-type">XXExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074855"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-612"></span><span>  </span><span class="hs-comment">-- Note [Trees that Grow] extension constructor for the</span><span>
</span><span id="line-613"></span><span>  </span><span class="hs-comment">-- general idea, and Note [Rebindable syntax and HsExpansion] in GHC.Hs.Expr</span><span>
</span><span id="line-614"></span><span>  </span><span class="hs-comment">-- for an example of how we use it.</span><span>
</span><span id="line-615"></span><span>
</span><span id="line-616"></span><span class="hs-comment">-- | The AST used to hard-refer to GhcPass, which was a layer violation. For now,</span><span>
</span><span id="line-617"></span><span class="hs-comment">-- we paper it over with this new extension point.</span><span>
</span><span id="line-618"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="HsDoRn"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsDoRn"><span class="hs-identifier hs-var">HsDoRn</span></a></span></span><span> </span><span id="local-6989586621681074165"><span class="annot"><a href="#local-6989586621681074165"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-619"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="HsBracketRn"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracketRn"><span class="hs-identifier hs-var">HsBracketRn</span></a></span></span><span> </span><span id="local-6989586621681074164"><span class="annot"><a href="#local-6989586621681074164"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-620"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="PendingRnSplice%27"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PendingRnSplice%27"><span class="hs-identifier hs-var">PendingRnSplice'</span></a></span></span><span> </span><span id="local-6989586621681074163"><span class="annot"><a href="#local-6989586621681074163"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-621"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="PendingTcSplice%27"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PendingTcSplice%27"><span class="hs-identifier hs-var">PendingTcSplice'</span></a></span></span><span> </span><span id="local-6989586621681074162"><span class="annot"><a href="#local-6989586621681074162"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-622"></span><span>
</span><span id="line-623"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-624"></span><span>
</span><span id="line-625"></span><span class="hs-keyword">data</span><span> </span><span id="HsFieldLabel"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-var">HsFieldLabel</span></a></span></span><span> </span><span id="local-6989586621681074830"><span class="annot"><a href="#local-6989586621681074830"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-626"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsFieldLabel"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFieldLabel"><span class="hs-identifier hs-var">HsFieldLabel</span></a></span></span><span>
</span><span id="line-627"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="hflExt"><span class="annot"><span class="annottext">forall p. HsFieldLabel p -&gt; XCHsFieldLabel p
</span><a href="Language.Haskell.Syntax.Expr.html#hflExt"><span class="hs-identifier hs-var hs-var">hflExt</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCHsFieldLabel"><span class="hs-identifier hs-type">XCHsFieldLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074830"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-628"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="hflLabel"><span class="annot"><span class="annottext">forall p. HsFieldLabel p -&gt; Located FastString
</span><a href="Language.Haskell.Syntax.Expr.html#hflLabel"><span class="hs-identifier hs-var hs-var">hflLabel</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="GHC.Types.FieldLabel.html#FieldLabelString"><span class="hs-identifier hs-type">FieldLabelString</span></a></span><span>
</span><span id="line-629"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-630"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsFieldLabel"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XHsFieldLabel"><span class="hs-identifier hs-var">XHsFieldLabel</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsFieldLabel"><span class="hs-identifier hs-type">XXHsFieldLabel</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074830"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-631"></span><span>
</span><span id="line-632"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-633"></span><span>
</span><span id="line-634"></span><span class="hs-comment">-- | A pragma, written as {-# ... #-}, that may appear within an expression.</span><span>
</span><span id="line-635"></span><span class="hs-keyword">data</span><span> </span><span id="HsPragE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragE"><span class="hs-identifier hs-var">HsPragE</span></a></span></span><span> </span><span id="local-6989586621681074158"><span class="annot"><a href="#local-6989586621681074158"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-636"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsPragSCC"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsPragSCC"><span class="hs-identifier hs-var">HsPragSCC</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSCC"><span class="hs-identifier hs-type">XSCC</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074158"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-637"></span><span>                </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span>            </span><span class="hs-comment">-- Note [Pragma source text] in GHC.Types.SourceText</span><span>
</span><span id="line-638"></span><span>                </span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier hs-type">StringLiteral</span></a></span><span>         </span><span class="hs-comment">-- &quot;set cost centre&quot; SCC pragma</span><span>
</span><span id="line-639"></span><span>
</span><span id="line-640"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-641"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{-\# GENERATED'@,</span><span>
</span><span id="line-642"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-643"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnColon','GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-644"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnMinus',</span><span>
</span><span id="line-645"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnColon',</span><span>
</span><span id="line-646"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-647"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'\#-}'@</span><span>
</span><span id="line-648"></span><span>
</span><span id="line-649"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsPragE"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XHsPragE"><span class="hs-identifier hs-var">XHsPragE</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPragE"><span class="hs-identifier hs-type">XXPragE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074158"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-650"></span><span>
</span><span id="line-651"></span><span class="hs-comment">-- | Located Haskell Tuple Argument</span><span>
</span><span id="line-652"></span><span class="hs-comment">--</span><span>
</span><span id="line-653"></span><span class="hs-comment">-- 'HsTupArg' is used for tuple sections</span><span>
</span><span id="line-654"></span><span class="hs-comment">-- @(,a,)@ is represented by</span><span>
</span><span id="line-655"></span><span class="hs-comment">-- @ExplicitTuple [Missing ty1, Present a, Missing ty3]@</span><span>
</span><span id="line-656"></span><span class="hs-comment">-- Which in turn stands for @(\x:ty1 \y:ty2. (x,a,y))@</span><span>
</span><span id="line-657"></span><span class="hs-keyword">type</span><span> </span><span id="LHsTupArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsTupArg"><span class="hs-identifier hs-var">LHsTupArg</span></a></span></span><span> </span><span id="local-6989586621681074152"><span class="annot"><a href="#local-6989586621681074152"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074152"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTupArg"><span class="hs-identifier hs-type">HsTupArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074152"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-658"></span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma'</span><span>
</span><span id="line-659"></span><span>
</span><span id="line-660"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-661"></span><span>
</span><span id="line-662"></span><span class="hs-comment">-- | Haskell Tuple Argument</span><span>
</span><span id="line-663"></span><span class="hs-keyword">data</span><span> </span><span id="HsTupArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTupArg"><span class="hs-identifier hs-var">HsTupArg</span></a></span></span><span> </span><span id="local-6989586621681074151"><span class="annot"><a href="#local-6989586621681074151"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-664"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Present"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Present"><span class="hs-identifier hs-var">Present</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPresent"><span class="hs-identifier hs-type">XPresent</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074151"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074151"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- ^ The argument</span><span>
</span><span id="line-665"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Missing"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Missing"><span class="hs-identifier hs-var">Missing</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMissing"><span class="hs-identifier hs-type">XMissing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074151"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ The argument is missing, but this is its type</span><span>
</span><span id="line-666"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XTupArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XTupArg"><span class="hs-identifier hs-var">XTupArg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXTupArg"><span class="hs-identifier hs-type">XXTupArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074151"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- ^ Note [Trees that Grow] extension point</span><span>
</span><span id="line-667"></span><span>
</span><span id="line-668"></span><span class="hs-comment">{-
Note [Parens in HsSyn]
~~~~~~~~~~~~~~~~~~~~~~
HsPar (and ParPat in patterns, HsParTy in types) is used as follows

  * HsPar is required; the pretty printer does not add parens.

  * HsPars are respected when rearranging operator fixities.
    So   a * (b + c)  means what it says (where the parens are an HsPar)

  * For ParPat and HsParTy the pretty printer does add parens but this should be
    a no-op for ParsedSource, based on the pretty printer round trip feature
    introduced in
    https://phabricator.haskell.org/rGHC499e43824bda967546ebf95ee33ec1f84a114a7c

  * ParPat and HsParTy are pretty printed as '( .. )' regardless of whether or
    not they are strictly necessary. This should be addressed when #13238 is
    completed, to be treated the same as HsPar.


Note [Sections in HsSyn]
~~~~~~~~~~~~~~~~~~~~~~~~
Sections should always appear wrapped in an HsPar, thus
         HsPar (SectionR ...)
The parser parses sections in a wider variety of situations
(See Note [Parsing sections]), but the renamer checks for those
parens.  This invariant makes pretty-printing easier; we don't need
a special case for adding the parens round sections.

Note [Rebindable if]
~~~~~~~~~~~~~~~~~~~~
The rebindable syntax for 'if' is a bit special, because when
rebindable syntax is *off* we do not want to treat
   (if c then t else e)
as if it was an application (ifThenElse c t e).  Why not?
Because we allow an 'if' to return *unboxed* results, thus
  if blah then 3# else 4#
whereas that would not be possible using a all to a polymorphic function
(because you can't call a polymorphic function at an unboxed type).

So we use NoSyntaxExpr to mean &quot;use the old built-in typing rule&quot;.

A further complication is that, in the `deriving` code, we never want
to use rebindable syntax. So, even in GhcPs, we want to denote whether
to use rebindable syntax or not. This is done via the type instance
for XIf GhcPs.

Note [Record Update HsWrapper]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
There is a wrapper in RecordUpd which is used for the *required*
constraints for pattern synonyms. This wrapper is created in the
typechecking and is then directly used in the desugaring without
modification.

For example, if we have the record pattern synonym P,
  pattern P :: (Show a) =&gt; a -&gt; Maybe a
  pattern P{x} = Just x

  foo = (Just True) { x = False }
then `foo` desugars to something like
  foo = case Just True of
          P x -&gt; P False
hence we need to provide the correct dictionaries to P's matcher on
the RHS so that we can build the expression.

Note [Located RdrNames]
~~~~~~~~~~~~~~~~~~~~~~~
A number of syntax elements have seemingly redundant locations
attached to them.  This is deliberate, to allow transformations making
use of the exact print annotations to easily correlate a Located Name
in the RenamedSource with a Located RdrName in the ParsedSource.

There are unfortunately enough differences between the ParsedSource
and the RenamedSource that the exact print annotations cannot be used
directly with RenamedSource, so this allows a simple mapping to be
used based on the location.

Note [ExplicitTuple]
~~~~~~~~~~~~~~~~~~~~
An ExplicitTuple is never just a data constructor like (,,,).
That is, the `[LHsTupArg p]` argument of `ExplicitTuple` has at least
one `Present` member (and is thus never empty).

A tuple data constructor like () or (,,,) is parsed as an `HsVar`, not an
`ExplicitTuple`, and stays that way. This is important for two reasons:

  1. We don't need -XTupleSections for (,,,)
  2. The type variables in (,,,) can be instantiated with visible type application.
     That is,

       (,,)     :: forall a b c. a -&gt; b -&gt; c -&gt; (a,b,c)
       (True,,) :: forall {b} {c}. b -&gt; c -&gt; (Bool,b,c)

     Note that the tuple section has *inferred* arguments, while the data
     constructor has *specified* ones.
     (See Note [Required, Specified, and Inferred for types] in GHC.Tc.TyCl
     for background.)

Sadly, the grammar for this is actually ambiguous, and it's only thanks to the
preference of a shift in a shift/reduce conflict that the parser works as this
Note details. Search for a reference to this Note in GHC.Parser for further
explanation.

Note [Empty lists]
~~~~~~~~~~~~~~~~~~
An empty list could be considered either a data constructor (stored with
HsVar) or an ExplicitList. This Note describes how empty lists flow through the
various phases and why.

Parsing
-------
An empty list is parsed by the sysdcon nonterminal. It thus comes to life via
HsVar nilDataCon (defined in GHC.Builtin.Types). A freshly-parsed (HsExpr GhcPs) empty list
is never a ExplicitList.

Renaming
--------
If -XOverloadedLists is enabled, we must type-check the empty list as if it
were a call to fromListN. (This is true regardless of the setting of
-XRebindableSyntax.) This is very easy if the empty list is an ExplicitList,
but an annoying special case if it's an HsVar. So the renamer changes a
HsVar nilDataCon to an ExplicitList [], but only if -XOverloadedLists is on.
(Why not always? Read on, dear friend.) This happens in the HsVar case of rnExpr.

Type-checking
-------------
We want to accept an expression like [] @Int. To do this, we must infer that
[] :: forall a. [a]. This is easy if [] is a HsVar with the right DataCon inside.
However, the type-checking for explicit lists works differently: [x,y,z] is never
polymorphic. Instead, we unify the types of x, y, and z together, and use the
unified type as the argument to the cons and nil constructors. Thus, treating
[] as an empty ExplicitList in the type-checker would prevent [] @Int from working.

However, if -XOverloadedLists is on, then [] @Int really shouldn't be allowed:
it's just like fromListN 0 [] @Int. Since
  fromListN :: forall list. IsList list =&gt; Int -&gt; [Item list] -&gt; list
that expression really should be rejected. Thus, the renamer's behaviour is
exactly what we want: treat [] as a datacon when -XNoOverloadedLists, and as
an empty ExplicitList when -XOverloadedLists.

See also #13680, which requested [] @Int to work.
-}</span><span>
</span><span id="line-810"></span><span>
</span><span id="line-811"></span><span>
</span><span id="line-812"></span><span class="hs-comment">-----------------------</span><span>
</span><span id="line-813"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprExternalSrcLoc"><span class="hs-identifier hs-type">pprExternalSrcLoc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier hs-type">StringLiteral</span></a></span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-814"></span><span id="pprExternalSrcLoc"><span class="annot"><span class="annottext">pprExternalSrcLoc :: (StringLiteral, (Int, Int), (Int, Int)) -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprExternalSrcLoc"><span class="hs-identifier hs-var hs-var">pprExternalSrcLoc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier hs-type">StringLiteral</span></a></span><span> </span><span class="annot"><span class="annottext">SourceText
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681074142"><span class="annot"><span class="annottext">FastString
</span><a href="#local-6989586621681074142"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe RealSrcSpan
</span><span class="hs-identifier">_</span></span><span class="hs-special">,</span><span class="hs-special">(</span><span id="local-6989586621681074141"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074141"><span class="hs-identifier hs-var">n1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681074140"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074140"><span class="hs-identifier hs-var">n2</span></a></span></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">(</span><span id="local-6989586621681074139"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074139"><span class="hs-identifier hs-var">n3</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621681074138"><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074138"><span class="hs-identifier hs-var">n4</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-815"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">FastString
</span><a href="#local-6989586621681074142"><span class="hs-identifier hs-var">src</span></a></span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074141"><span class="hs-identifier hs-var">n1</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074140"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074139"><span class="hs-identifier hs-var">n3</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621681074138"><span class="hs-identifier hs-var">n4</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-816"></span><span>
</span><span id="line-817"></span><span class="hs-comment">{-
HsSyn records exactly where the user put parens, with HsPar.
So generally speaking we print without adding any parens.
However, some code is internally generated, and in some places
parens are absolutely required; so for these places we use
pprParendLExpr (but don't print double parens of course).

For operator applications we don't add parens, because the operator
fixities should do the job, except in debug mode (-dppr-debug) so we
can see the structure of the parse tree.
-}</span><span>
</span><span id="line-828"></span><span>
</span><span id="line-829"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Commands (in arrow abstractions)}
*                                                                      *
************************************************************************

We re-use HsExpr to represent these.
-}</span><span>
</span><span id="line-838"></span><span>
</span><span id="line-839"></span><span class="hs-comment">-- | Located Haskell Command (for arrow syntax)</span><span>
</span><span id="line-840"></span><span class="hs-keyword">type</span><span> </span><span id="LHsCmd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-var">LHsCmd</span></a></span></span><span> </span><span id="local-6989586621681074136"><span class="annot"><a href="#local-6989586621681074136"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074136"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmd"><span class="hs-identifier hs-type">HsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074136"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-841"></span><span>
</span><span id="line-842"></span><span class="hs-comment">-- | Haskell Command (e.g. a &quot;statement&quot; in an Arrow proc block)</span><span>
</span><span id="line-843"></span><span class="hs-keyword">data</span><span> </span><span id="HsCmd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmd"><span class="hs-identifier hs-var">HsCmd</span></a></span></span><span> </span><span id="local-6989586621681074134"><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-844"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.Annlarrowtail',</span><span>
</span><span id="line-845"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.Annrarrowtail','GHC.Parser.Annotation.AnnLarrowtail',</span><span>
</span><span id="line-846"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnRarrowtail'</span><span>
</span><span id="line-847"></span><span>
</span><span id="line-848"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-849"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsCmdArrApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdArrApp"><span class="hs-identifier hs-var">HsCmdArrApp</span></a></span></span><span>          </span><span class="hs-comment">-- Arrow tail, or arrow application (f -&lt; arg)</span><span>
</span><span id="line-850"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdArrApp"><span class="hs-identifier hs-type">XCmdArrApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- type of the arrow expressions f,</span><span>
</span><span id="line-851"></span><span>                         </span><span class="hs-comment">-- of the form a t t', where arg :: t</span><span>
</span><span id="line-852"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- arrow expression, f</span><span>
</span><span id="line-853"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- input expression, arg</span><span>
</span><span id="line-854"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrAppType"><span class="hs-identifier hs-type">HsArrAppType</span></a></span><span>     </span><span class="hs-comment">-- higher-order (-&lt;&lt;) or first-order (-&lt;)</span><span>
</span><span id="line-855"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>             </span><span class="hs-comment">-- True =&gt; right-to-left (f -&lt; arg)</span><span>
</span><span id="line-856"></span><span>                         </span><span class="hs-comment">-- False =&gt; left-to-right (arg &gt;- f)</span><span>
</span><span id="line-857"></span><span>
</span><span id="line-858"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpenB' @'(|'@,</span><span>
</span><span id="line-859"></span><span>  </span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnCloseB' @'|)'@</span><span>
</span><span id="line-860"></span><span>
</span><span id="line-861"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-862"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdArrForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdArrForm"><span class="hs-identifier hs-var">HsCmdArrForm</span></a></span></span><span>         </span><span class="hs-comment">-- Command formation,  (| e cmd1 .. cmdn |)</span><span>
</span><span id="line-863"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdArrForm"><span class="hs-identifier hs-type">XCmdArrForm</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-864"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- The operator.</span><span>
</span><span id="line-865"></span><span>                         </span><span class="hs-comment">-- After type-checking, a type abstraction to be</span><span>
</span><span id="line-866"></span><span>                         </span><span class="hs-comment">-- applied to the type of the local environment tuple</span><span>
</span><span id="line-867"></span><span>        </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span>    </span><span class="hs-comment">-- Whether the operator appeared prefix or infix when</span><span>
</span><span id="line-868"></span><span>                         </span><span class="hs-comment">-- parsed.</span><span>
</span><span id="line-869"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- fixity (filled in by the renamer), for forms that</span><span>
</span><span id="line-870"></span><span>                         </span><span class="hs-comment">-- were converted from OpApp's by the renamer</span><span>
</span><span id="line-871"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmdTop"><span class="hs-identifier hs-type">LHsCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- argument commands</span><span>
</span><span id="line-872"></span><span>
</span><span id="line-873"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdApp"><span class="hs-identifier hs-var">HsCmdApp</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdApp"><span class="hs-identifier hs-type">XCmdApp</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-874"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-875"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-876"></span><span>
</span><span id="line-877"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdLam"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdLam"><span class="hs-identifier hs-var">HsCmdLam</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdLam"><span class="hs-identifier hs-type">XCmdLam</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-878"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- kappa</span><span>
</span><span id="line-879"></span><span>       </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-880"></span><span>       </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnRarrow',</span><span>
</span><span id="line-881"></span><span>
</span><span id="line-882"></span><span>       </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-883"></span><span>
</span><span id="line-884"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdPar"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdPar"><span class="hs-identifier hs-var">HsCmdPar</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdPar"><span class="hs-identifier hs-type">XCmdPar</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-885"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- parenthesised command</span><span>
</span><span id="line-886"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span><span>
</span><span id="line-887"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose' @')'@</span><span>
</span><span id="line-888"></span><span>
</span><span id="line-889"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-890"></span><span>
</span><span id="line-891"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdCase"><span class="hs-identifier hs-var">HsCmdCase</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdCase"><span class="hs-identifier hs-type">XCmdCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-892"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-893"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- bodies are HsCmd's</span><span>
</span><span id="line-894"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnCase',</span><span>
</span><span id="line-895"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOf','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-896"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-897"></span><span>
</span><span id="line-898"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-899"></span><span>
</span><span id="line-900"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdLamCase"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdLamCase"><span class="hs-identifier hs-var">HsCmdLamCase</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdLamCase"><span class="hs-identifier hs-type">XCmdLamCase</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-901"></span><span>                 </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- bodies are HsCmd's</span><span>
</span><span id="line-902"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span><span>
</span><span id="line-903"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnCase','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-904"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-905"></span><span>
</span><span id="line-906"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-907"></span><span>
</span><span id="line-908"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdIf"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdIf"><span class="hs-identifier hs-var">HsCmdIf</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdIf"><span class="hs-identifier hs-type">XCmdIf</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-909"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- cond function</span><span>
</span><span id="line-910"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>            </span><span class="hs-comment">-- predicate</span><span>
</span><span id="line-911"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- then part</span><span>
</span><span id="line-912"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>             </span><span class="hs-comment">-- else part</span><span>
</span><span id="line-913"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf',</span><span>
</span><span id="line-914"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-915"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnThen','GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-916"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnElse',</span><span>
</span><span id="line-917"></span><span>
</span><span id="line-918"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-919"></span><span>
</span><span id="line-920"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdLet"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdLet"><span class="hs-identifier hs-var">HsCmdLet</span></a></span></span><span>    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdLet"><span class="hs-identifier hs-type">XCmdLet</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-921"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- let(rec)</span><span>
</span><span id="line-922"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-923"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet',</span><span>
</span><span id="line-924"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-925"></span><span>    </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose' @'}'@,'GHC.Parser.Annotation.AnnIn'</span><span>
</span><span id="line-926"></span><span>
</span><span id="line-927"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-928"></span><span>
</span><span id="line-929"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsCmdDo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdDo"><span class="hs-identifier hs-var">HsCmdDo</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdDo"><span class="hs-identifier hs-type">XCmdDo</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>                     </span><span class="hs-comment">-- Type of the whole expression</span><span>
</span><span id="line-930"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdLStmt"><span class="hs-identifier hs-type">CmdLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-931"></span><span>    </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDo',</span><span>
</span><span id="line-932"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnOpen', 'GHC.Parser.Annotation.AnnSemi',</span><span>
</span><span id="line-933"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-934"></span><span>    </span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-935"></span><span>
</span><span id="line-936"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-937"></span><span>
</span><span id="line-938"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XCmd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XCmd"><span class="hs-identifier hs-var">XCmd</span></a></span></span><span>        </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXCmd"><span class="hs-identifier hs-type">XXCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074134"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- Note [Trees that Grow] extension point</span><span>
</span><span id="line-939"></span><span>
</span><span id="line-940"></span><span>
</span><span id="line-941"></span><span class="hs-comment">-- | Haskell Array Application Type</span><span>
</span><span id="line-942"></span><span class="hs-keyword">data</span><span> </span><span id="HsArrAppType"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrAppType"><span class="hs-identifier hs-var">HsArrAppType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="HsHigherOrderApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsHigherOrderApp"><span class="hs-identifier hs-var">HsHigherOrderApp</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="HsFirstOrderApp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsFirstOrderApp"><span class="hs-identifier hs-var">HsFirstOrderApp</span></a></span></span><span>
</span><span id="line-943"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681074078"><span id="local-6989586621681074080"><span id="local-6989586621681074082"><span id="local-6989586621681074084"><span id="local-6989586621681074086"><span id="local-6989586621681074088"><span id="local-6989586621681074090"><span id="local-6989586621681074092"><span id="local-6989586621681074094"><span id="local-6989586621681074096"><span id="local-6989586621681074098"><span id="local-6989586621681074100"><span id="local-6989586621681074102"><span id="local-6989586621681074104"><span class="annot"><span class="annottext">Typeable HsArrAppType
HsArrAppType -&gt; DataType
HsArrAppType -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsArrAppType)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; HsArrAppType -&gt; m HsArrAppType
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; HsArrAppType -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; HsArrAppType -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; HsArrAppType -&gt; HsArrAppType
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsArrAppType)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c HsArrAppType)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c HsArrAppType)
dataTypeOf :: HsArrAppType -&gt; DataType
$cdataTypeOf :: HsArrAppType -&gt; DataType
toConstr :: HsArrAppType -&gt; Constr
$ctoConstr :: HsArrAppType -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c HsArrAppType
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; HsArrAppType -&gt; c HsArrAppType
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-944"></span><span>
</span><span id="line-945"></span><span>
</span><span id="line-946"></span><span class="hs-comment">{- | Top-level command, introducing a new arrow.
This may occur inside a proc (where the stack is empty) or as an
argument of a command-forming operator.
-}</span><span>
</span><span id="line-950"></span><span>
</span><span id="line-951"></span><span class="hs-comment">-- | Located Haskell Top-level Command</span><span>
</span><span id="line-952"></span><span class="hs-keyword">type</span><span> </span><span id="LHsCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmdTop"><span class="hs-identifier hs-var">LHsCmdTop</span></a></span></span><span> </span><span id="local-6989586621681074076"><span class="annot"><a href="#local-6989586621681074076"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074076"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdTop"><span class="hs-identifier hs-type">HsCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074076"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-953"></span><span>
</span><span id="line-954"></span><span class="hs-comment">-- | Haskell Top-level Command</span><span>
</span><span id="line-955"></span><span class="hs-keyword">data</span><span> </span><span id="HsCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdTop"><span class="hs-identifier hs-var">HsCmdTop</span></a></span></span><span> </span><span id="local-6989586621681074074"><span class="annot"><a href="#local-6989586621681074074"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-956"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsCmdTop"><span class="hs-identifier hs-var">HsCmdTop</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCmdTop"><span class="hs-identifier hs-type">XCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074074"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-957"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074074"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-958"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XCmdTop"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XCmdTop"><span class="hs-identifier hs-var">XCmdTop</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXCmdTop"><span class="hs-identifier hs-type">XXCmdTop</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074074"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Note [Trees that Grow] extension point</span><span>
</span><span id="line-959"></span><span>
</span><span id="line-960"></span><span class="hs-comment">-----------------------</span><span>
</span><span id="line-961"></span><span>
</span><span id="line-962"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Record binds}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-969"></span><span>
</span><span id="line-970"></span><span class="hs-comment">-- | Haskell Record Bindings</span><span>
</span><span id="line-971"></span><span class="hs-keyword">type</span><span> </span><span id="HsRecordBinds"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsRecordBinds"><span class="hs-identifier hs-var">HsRecordBinds</span></a></span></span><span> </span><span id="local-6989586621681074069"><span class="annot"><a href="#local-6989586621681074069"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#HsRecFields"><span class="hs-identifier hs-type">HsRecFields</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074069"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074069"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-972"></span><span>
</span><span id="line-973"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{@Match@, @GRHSs@, and @GRHS@ datatypes}
*                                                                      *
************************************************************************

@Match@es are sets of pattern bindings and right hand sides for
functions, patterns or case branches. For example, if a function @g@
is defined as:
\begin{verbatim}
g (x,y) = y
g ((x:ys),y) = y+1,
\end{verbatim}
then \tr{g} has two @Match@es: @(x,y) = y@ and @((x:ys),y) = y+1@.

It is always the case that each element of an @[Match]@ list has the
same number of @pats@s inside it.  This corresponds to saying that
a function defined by pattern matching must have the same number of
patterns in each equation.
-}</span><span>
</span><span id="line-994"></span><span>
</span><span id="line-995"></span><span class="hs-keyword">data</span><span> </span><span id="MatchGroup"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-var">MatchGroup</span></a></span></span><span> </span><span id="local-6989586621681074791"><span class="annot"><a href="#local-6989586621681074791"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681074790"><span class="annot"><a href="#local-6989586621681074790"><span class="hs-identifier hs-type">body</span></a></span></span><span>
</span><span id="line-996"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="MG"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MG"><span class="hs-identifier hs-var">MG</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="mg_ext"><span class="annot"><span class="annottext">forall p body. MatchGroup p body -&gt; XMG p body
</span><a href="Language.Haskell.Syntax.Expr.html#mg_ext"><span class="hs-identifier hs-var hs-var">mg_ext</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMG"><span class="hs-identifier hs-type">XMG</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074790"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-comment">-- Post-typechecker, types of args and result</span><span>
</span><span id="line-997"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="mg_alts"><span class="annot"><span class="annottext">forall p body. MatchGroup p body -&gt; XRec p [LMatch p body]
</span><a href="Language.Haskell.Syntax.Expr.html#mg_alts"><span class="hs-identifier hs-var hs-var">mg_alts</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-type">LMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074790"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- The alternatives</span><span>
</span><span id="line-998"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="mg_origin"><span class="annot"><span class="annottext">forall p body. MatchGroup p body -&gt; Origin
</span><a href="Language.Haskell.Syntax.Expr.html#mg_origin"><span class="hs-identifier hs-var hs-var">mg_origin</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html#Origin"><span class="hs-identifier hs-type">Origin</span></a></span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-999"></span><span>     </span><span class="hs-comment">-- The type is the type of the entire group</span><span>
</span><span id="line-1000"></span><span>     </span><span class="hs-comment">--      t1 -&gt; ... -&gt; tn -&gt; tr</span><span>
</span><span id="line-1001"></span><span>     </span><span class="hs-comment">-- where there are n patterns</span><span>
</span><span id="line-1002"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XMatchGroup"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XMatchGroup"><span class="hs-identifier hs-var">XMatchGroup</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXMatchGroup"><span class="hs-identifier hs-type">XXMatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074790"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1003"></span><span>
</span><span id="line-1004"></span><span class="hs-keyword">data</span><span> </span><span id="MatchGroupTc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroupTc"><span class="hs-identifier hs-var">MatchGroupTc</span></a></span></span><span>
</span><span id="line-1005"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="MatchGroupTc"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroupTc"><span class="hs-identifier hs-var">MatchGroupTc</span></a></span></span><span>
</span><span id="line-1006"></span><span>       </span><span class="hs-special">{</span><span> </span><span id="mg_arg_tys"><span class="annot"><span class="annottext">MatchGroupTc -&gt; [Scaled Type]
</span><a href="Language.Haskell.Syntax.Expr.html#mg_arg_tys"><span class="hs-identifier hs-var hs-var">mg_arg_tys</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Scaled"><span class="hs-identifier hs-type">Scaled</span></a></span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- Types of the arguments, t1..tn</span><span>
</span><span id="line-1007"></span><span>       </span><span class="hs-special">,</span><span> </span><span id="mg_res_ty"><span class="annot"><span class="annottext">MatchGroupTc -&gt; Type
</span><a href="Language.Haskell.Syntax.Expr.html#mg_res_ty"><span class="hs-identifier hs-var hs-var">mg_res_ty</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.TyCo.Rep.html#Type"><span class="hs-identifier hs-type">Type</span></a></span><span>    </span><span class="hs-comment">-- Type of the result, tr</span><span>
</span><span id="line-1008"></span><span>       </span><span class="hs-special">}</span><span> </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681074021"><span id="local-6989586621681074023"><span id="local-6989586621681074025"><span id="local-6989586621681074027"><span id="local-6989586621681074029"><span id="local-6989586621681074031"><span id="local-6989586621681074033"><span id="local-6989586621681074035"><span id="local-6989586621681074037"><span id="local-6989586621681074039"><span id="local-6989586621681074041"><span id="local-6989586621681074043"><span id="local-6989586621681074048"><span id="local-6989586621681074055"><span class="annot"><span class="annottext">Typeable MatchGroupTc
MatchGroupTc -&gt; DataType
MatchGroupTc -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; MatchGroupTc -&gt; MatchGroupTc
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MatchGroupTc -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; MatchGroupTc -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MatchGroupTc -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MatchGroupTc -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c MatchGroupTc
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; MatchGroupTc -&gt; c MatchGroupTc
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c MatchGroupTc)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c MatchGroupTc)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; MatchGroupTc -&gt; m MatchGroupTc
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MatchGroupTc -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; MatchGroupTc -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; MatchGroupTc -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; MatchGroupTc -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MatchGroupTc -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MatchGroupTc -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MatchGroupTc -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; MatchGroupTc -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; MatchGroupTc -&gt; MatchGroupTc
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; MatchGroupTc -&gt; MatchGroupTc
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c MatchGroupTc)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c MatchGroupTc)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c MatchGroupTc)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c MatchGroupTc)
dataTypeOf :: MatchGroupTc -&gt; DataType
$cdataTypeOf :: MatchGroupTc -&gt; DataType
toConstr :: MatchGroupTc -&gt; Constr
$ctoConstr :: MatchGroupTc -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c MatchGroupTc
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c MatchGroupTc
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; MatchGroupTc -&gt; c MatchGroupTc
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; MatchGroupTc -&gt; c MatchGroupTc
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1009"></span><span>
</span><span id="line-1010"></span><span class="hs-comment">-- | Located Match</span><span>
</span><span id="line-1011"></span><span class="hs-keyword">type</span><span> </span><span id="LMatch"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LMatch"><span class="hs-identifier hs-var">LMatch</span></a></span></span><span> </span><span id="local-6989586621681074019"><span class="annot"><a href="#local-6989586621681074019"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681074018"><span class="annot"><a href="#local-6989586621681074018"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074019"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074019"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074018"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1012"></span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a</span><span>
</span><span id="line-1013"></span><span class="hs-comment">--   list</span><span>
</span><span id="line-1014"></span><span>
</span><span id="line-1015"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1016"></span><span class="hs-keyword">data</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span id="local-6989586621681074775"><span class="annot"><a href="#local-6989586621681074775"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681074774"><span class="annot"><a href="#local-6989586621681074774"><span class="hs-identifier hs-type">body</span></a></span></span><span>
</span><span id="line-1017"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Match"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-var">Match</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-1018"></span><span>        </span><span id="m_ext"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; XCMatch p body
</span><a href="Language.Haskell.Syntax.Expr.html#m_ext"><span class="hs-identifier hs-var hs-var">m_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCMatch"><span class="hs-identifier hs-type">XCMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074775"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074774"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1019"></span><span>        </span><span id="m_ctxt"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; HsMatchContext (NoGhcTc p)
</span><a href="Language.Haskell.Syntax.Expr.html#m_ctxt"><span class="hs-identifier hs-var hs-var">m_ctxt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#NoGhcTc"><span class="hs-identifier hs-type">NoGhcTc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074775"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-1020"></span><span>          </span><span class="hs-comment">-- See note [m_ctxt in Match]</span><span>
</span><span id="line-1021"></span><span>        </span><span id="m_pats"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; [LPat p]
</span><a href="Language.Haskell.Syntax.Expr.html#m_pats"><span class="hs-identifier hs-var hs-var">m_pats</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074775"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- The patterns</span><span>
</span><span id="line-1022"></span><span>        </span><span id="m_grhss"><span class="annot"><span class="annottext">forall p body. Match p body -&gt; GRHSs p body
</span><a href="Language.Haskell.Syntax.Expr.html#m_grhss"><span class="hs-identifier hs-var hs-var">m_grhss</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-type">GRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074775"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074774"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1023"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-1024"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XMatch"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XMatch"><span class="hs-identifier hs-var">XMatch</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXMatch"><span class="hs-identifier hs-type">XXMatch</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074775"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074774"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1025"></span><span>
</span><span id="line-1026"></span><span class="hs-comment">{-
Note [m_ctxt in Match]
~~~~~~~~~~~~~~~~~~~~~~

A Match can occur in a number of contexts, such as a FunBind, HsCase, HsLam and
so on.

In order to simplify tooling processing and pretty print output, the provenance
is captured in an HsMatchContext.

This is particularly important for the exact print annotations for a
multi-equation FunBind.

The parser initially creates a FunBind with a single Match in it for
every function definition it sees.

These are then grouped together by getMonoBind into a single FunBind,
where all the Matches are combined.

In the process, all the original FunBind fun_id's bar one are
discarded, including the locations.

This causes a problem for source to source conversions via exact print
annotations, so the original fun_ids and infix flags are preserved in
the Match, when it originates from a FunBind.

Example infix function definition requiring individual exact print
annotations

    (&amp;&amp;&amp;  ) [] [] =  []
    xs    &amp;&amp;&amp;   [] =  xs
    (  &amp;&amp;&amp;  ) [] ys =  ys



-}</span><span>
</span><span id="line-1062"></span><span>
</span><span id="line-1063"></span><span>
</span><span id="line-1064"></span><span id="local-6989586621681074758"><span id="local-6989586621681074759"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isInfixMatch"><span class="hs-identifier hs-type">isInfixMatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Match"><span class="hs-identifier hs-type">Match</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074759"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074758"><span class="hs-identifier hs-type">body</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span></span><span>
</span><span id="line-1065"></span><span id="isInfixMatch"><span class="annot"><span class="annottext">isInfixMatch :: forall id body. Match id body -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isInfixMatch"><span class="hs-identifier hs-var hs-var">isInfixMatch</span></a></span></span><span> </span><span id="local-6989586621681074009"><span class="annot"><span class="annottext">Match id body
</span><a href="#local-6989586621681074009"><span class="hs-identifier hs-var">match</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">forall p body. Match p body -&gt; HsMatchContext (NoGhcTc p)
</span><a href="Language.Haskell.Syntax.Expr.html#m_ctxt"><span class="hs-identifier hs-var">m_ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">Match id body
</span><a href="#local-6989586621681074009"><span class="hs-identifier hs-var">match</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1066"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-type">FunRhs</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">mc_fixity :: forall p. HsMatchContext p -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fixity"><span class="hs-identifier hs-var">mc_fixity</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">LexicalFixity
</span><a href="GHC.Types.Fixity.html#Infix"><span class="hs-identifier hs-var">Infix</span></a></span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1067"></span><span>  </span><span class="annot"><span class="annottext">HsMatchContext (NoGhcTc id)
</span><span class="hs-identifier">_</span></span><span>                          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1068"></span><span>
</span><span id="line-1069"></span><span class="hs-comment">-- | Guarded Right-Hand Sides</span><span>
</span><span id="line-1070"></span><span class="hs-comment">--</span><span>
</span><span id="line-1071"></span><span class="hs-comment">-- GRHSs are used both for pattern bindings and for Matches</span><span>
</span><span id="line-1072"></span><span class="hs-comment">--</span><span>
</span><span id="line-1073"></span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-1074"></span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-1075"></span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-1076"></span><span class="hs-comment">--        'GHC.Parser.Annotation.AnnRarrow','GHC.Parser.Annotation.AnnSemi'</span><span>
</span><span id="line-1077"></span><span>
</span><span id="line-1078"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1079"></span><span class="hs-keyword">data</span><span> </span><span id="GRHSs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-var">GRHSs</span></a></span></span><span> </span><span id="local-6989586621681074753"><span class="annot"><a href="#local-6989586621681074753"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681074752"><span class="annot"><a href="#local-6989586621681074752"><span class="hs-identifier hs-type">body</span></a></span></span><span>
</span><span id="line-1080"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="GRHSs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-var">GRHSs</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-1081"></span><span>      </span><span id="grhssExt"><span class="annot"><span class="annottext">forall p body. GRHSs p body -&gt; XCGRHSs p body
</span><a href="Language.Haskell.Syntax.Expr.html#grhssExt"><span class="hs-identifier hs-var hs-var">grhssExt</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCGRHSs"><span class="hs-identifier hs-type">XCGRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074753"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074752"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1082"></span><span>      </span><span id="grhssGRHSs"><span class="annot"><span class="annottext">forall p body. GRHSs p body -&gt; [LGRHS p body]
</span><a href="Language.Haskell.Syntax.Expr.html#grhssGRHSs"><span class="hs-identifier hs-var hs-var">grhssGRHSs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LGRHS"><span class="hs-identifier hs-type">LGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074753"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074752"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>     </span><span class="hs-comment">-- ^ Guarded RHSs</span><span>
</span><span id="line-1083"></span><span>      </span><span id="grhssLocalBinds"><span class="annot"><span class="annottext">forall p body. GRHSs p body -&gt; HsLocalBinds p
</span><a href="Language.Haskell.Syntax.Expr.html#grhssLocalBinds"><span class="hs-identifier hs-var hs-var">grhssLocalBinds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074753"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-comment">-- ^ The where clause</span><span>
</span><span id="line-1084"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-1085"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XGRHSs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XGRHSs"><span class="hs-identifier hs-var">XGRHSs</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXGRHSs"><span class="hs-identifier hs-type">XXGRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074753"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074752"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1086"></span><span>
</span><span id="line-1087"></span><span class="hs-comment">-- | Located Guarded Right-Hand Side</span><span>
</span><span id="line-1088"></span><span class="hs-keyword">type</span><span> </span><span id="LGRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LGRHS"><span class="hs-identifier hs-var">LGRHS</span></a></span></span><span> </span><span id="local-6989586621681073999"><span class="annot"><a href="#local-6989586621681073999"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681073998"><span class="annot"><a href="#local-6989586621681073998"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073999"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHS"><span class="hs-identifier hs-type">GRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073999"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073998"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1089"></span><span>
</span><span id="line-1090"></span><span class="hs-comment">-- | Guarded Right Hand Side.</span><span>
</span><span id="line-1091"></span><span class="hs-keyword">data</span><span> </span><span id="GRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHS"><span class="hs-identifier hs-var">GRHS</span></a></span></span><span> </span><span id="local-6989586621681073996"><span class="annot"><a href="#local-6989586621681073996"><span class="hs-identifier hs-type">p</span></a></span></span><span> </span><span id="local-6989586621681073995"><span class="annot"><a href="#local-6989586621681073995"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="GRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHS"><span class="hs-identifier hs-var">GRHS</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCGRHS"><span class="hs-identifier hs-type">XCGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073996"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073995"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1092"></span><span>                        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GuardLStmt"><span class="hs-identifier hs-type">GuardLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073996"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- Guards</span><span>
</span><span id="line-1093"></span><span>                        </span><span class="annot"><a href="#local-6989586621681073995"><span class="hs-identifier hs-type">body</span></a></span><span>           </span><span class="hs-comment">-- Right hand side</span><span>
</span><span id="line-1094"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span id="XGRHS"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XGRHS"><span class="hs-identifier hs-var">XGRHS</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXGRHS"><span class="hs-identifier hs-type">XXGRHS</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073996"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073995"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1095"></span><span>
</span><span id="line-1096"></span><span class="hs-comment">-- We know the list must have at least one @Match@ in it.</span><span>
</span><span id="line-1097"></span><span>
</span><span id="line-1098"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Do stmts and list comprehensions}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1105"></span><span>
</span><span id="line-1106"></span><span class="hs-comment">-- | Located @do@ block Statement</span><span>
</span><span id="line-1107"></span><span class="hs-keyword">type</span><span> </span><span id="LStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-var">LStmt</span></a></span></span><span> </span><span id="local-6989586621681073988"><span class="annot"><a href="#local-6989586621681073988"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681073987"><span class="annot"><a href="#local-6989586621681073987"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073988"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-type">StmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073988"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073988"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073987"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1108"></span><span>
</span><span id="line-1109"></span><span class="hs-comment">-- | Located Statement with separate Left and Right id's</span><span>
</span><span id="line-1110"></span><span class="hs-keyword">type</span><span> </span><span id="LStmtLR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmtLR"><span class="hs-identifier hs-var">LStmtLR</span></a></span></span><span> </span><span id="local-6989586621681073986"><span class="annot"><a href="#local-6989586621681073986"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681073985"><span class="annot"><a href="#local-6989586621681073985"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span id="local-6989586621681073984"><span class="annot"><a href="#local-6989586621681073984"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073986"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-type">StmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073986"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073985"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073984"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1111"></span><span>
</span><span id="line-1112"></span><span class="hs-comment">-- | @do@ block Statement</span><span>
</span><span id="line-1113"></span><span class="hs-keyword">type</span><span> </span><span id="Stmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-var">Stmt</span></a></span></span><span> </span><span id="local-6989586621681073982"><span class="annot"><a href="#local-6989586621681073982"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span id="local-6989586621681073981"><span class="annot"><a href="#local-6989586621681073981"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-type">StmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073982"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073982"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073981"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1114"></span><span>
</span><span id="line-1115"></span><span class="hs-comment">-- | Command Located Statement</span><span>
</span><span id="line-1116"></span><span class="hs-keyword">type</span><span> </span><span id="CmdLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdLStmt"><span class="hs-identifier hs-var">CmdLStmt</span></a></span></span><span>   </span><span id="local-6989586621681073980"><span class="annot"><a href="#local-6989586621681073980"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073980"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681073980"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1117"></span><span>
</span><span id="line-1118"></span><span class="hs-comment">-- | Command Statement</span><span>
</span><span id="line-1119"></span><span class="hs-keyword">type</span><span> </span><span id="CmdStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CmdStmt"><span class="hs-identifier hs-var">CmdStmt</span></a></span></span><span>    </span><span id="local-6989586621681073978"><span class="annot"><a href="#local-6989586621681073978"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681073978"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsCmd"><span class="hs-identifier hs-type">LHsCmd</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681073978"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1120"></span><span>
</span><span id="line-1121"></span><span class="hs-comment">-- | Expression Located Statement</span><span>
</span><span id="line-1122"></span><span class="hs-keyword">type</span><span> </span><span id="ExprLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-var">ExprLStmt</span></a></span></span><span>  </span><span id="local-6989586621681073977"><span class="annot"><a href="#local-6989586621681073977"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073977"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073977"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1123"></span><span>
</span><span id="line-1124"></span><span class="hs-comment">-- | Expression Statement</span><span>
</span><span id="line-1125"></span><span class="hs-keyword">type</span><span> </span><span id="ExprStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprStmt"><span class="hs-identifier hs-var">ExprStmt</span></a></span></span><span>   </span><span id="local-6989586621681073975"><span class="annot"><a href="#local-6989586621681073975"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681073975"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073975"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1126"></span><span>
</span><span id="line-1127"></span><span class="hs-comment">-- | Guard Located Statement</span><span>
</span><span id="line-1128"></span><span class="hs-keyword">type</span><span> </span><span id="GuardLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GuardLStmt"><span class="hs-identifier hs-var">GuardLStmt</span></a></span></span><span> </span><span id="local-6989586621681073974"><span class="annot"><a href="#local-6989586621681073974"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073974"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073974"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1129"></span><span>
</span><span id="line-1130"></span><span class="hs-comment">-- | Guard Statement</span><span>
</span><span id="line-1131"></span><span class="hs-keyword">type</span><span> </span><span id="GuardStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GuardStmt"><span class="hs-identifier hs-var">GuardStmt</span></a></span></span><span>  </span><span id="local-6989586621681073972"><span class="annot"><a href="#local-6989586621681073972"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681073972"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073972"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1132"></span><span>
</span><span id="line-1133"></span><span class="hs-comment">-- | Ghci Located Statement</span><span>
</span><span id="line-1134"></span><span class="hs-keyword">type</span><span> </span><span id="GhciLStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GhciLStmt"><span class="hs-identifier hs-var">GhciLStmt</span></a></span></span><span>  </span><span id="local-6989586621681073970"><span class="annot"><a href="#local-6989586621681073970"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmt"><span class="hs-identifier hs-type">LStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073970"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073970"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1135"></span><span>
</span><span id="line-1136"></span><span class="hs-comment">-- | Ghci Statement</span><span>
</span><span id="line-1137"></span><span class="hs-keyword">type</span><span> </span><span id="GhciStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GhciStmt"><span class="hs-identifier hs-var">GhciStmt</span></a></span></span><span>   </span><span id="local-6989586621681073968"><span class="annot"><a href="#local-6989586621681073968"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#Stmt"><span class="hs-identifier hs-type">Stmt</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681073968"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073968"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1138"></span><span>
</span><span id="line-1139"></span><span class="hs-comment">-- The SyntaxExprs in here are used *only* for do-notation and monad</span><span>
</span><span id="line-1140"></span><span class="hs-comment">-- comprehensions, which have rebindable syntax. Otherwise they are unused.</span><span>
</span><span id="line-1141"></span><span class="hs-comment">-- | Exact print annotations when in qualifier lists or guards</span><span>
</span><span id="line-1142"></span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVbar',</span><span>
</span><span id="line-1143"></span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnComma','GHC.Parser.Annotation.AnnThen',</span><span>
</span><span id="line-1144"></span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnBy','GHC.Parser.Annotation.AnnBy',</span><span>
</span><span id="line-1145"></span><span class="hs-comment">--         'GHC.Parser.Annotation.AnnGroup','GHC.Parser.Annotation.AnnUsing'</span><span>
</span><span id="line-1146"></span><span>
</span><span id="line-1147"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1148"></span><span class="hs-keyword">data</span><span> </span><span id="StmtLR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtLR"><span class="hs-identifier hs-var">StmtLR</span></a></span></span><span> </span><span id="local-6989586621681074742"><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681074741"><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span id="local-6989586621681074740"><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span></span><span> </span><span class="hs-comment">-- body should always be (LHs**** idR)</span><span>
</span><span id="line-1149"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="LastStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LastStmt"><span class="hs-identifier hs-var">LastStmt</span></a></span></span><span>  </span><span class="hs-comment">-- Always the last Stmt in ListComp, MonadComp,</span><span>
</span><span id="line-1150"></span><span>              </span><span class="hs-comment">-- and (after the renamer, see GHC.Rename.Expr.checkLastStmt) DoExpr, MDoExpr</span><span>
</span><span id="line-1151"></span><span>              </span><span class="hs-comment">-- Not used for GhciStmtCtxt, PatGuard, which scope over other stuff</span><span>
</span><span id="line-1152"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLastStmt"><span class="hs-identifier hs-type">XLastStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1153"></span><span>          </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1154"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- Whether return was stripped</span><span>
</span><span id="line-1155"></span><span>            </span><span class="hs-comment">-- Just True &lt;=&gt; return with a dollar was stripped by ApplicativeDo</span><span>
</span><span id="line-1156"></span><span>            </span><span class="hs-comment">-- Just False &lt;=&gt; return without a dollar was stripped by ApplicativeDo</span><span>
</span><span id="line-1157"></span><span>            </span><span class="hs-comment">-- Nothing &lt;=&gt; Nothing was stripped</span><span>
</span><span id="line-1158"></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- The return operator</span><span>
</span><span id="line-1159"></span><span>            </span><span class="hs-comment">-- The return operator is used only for MonadComp</span><span>
</span><span id="line-1160"></span><span>            </span><span class="hs-comment">-- For ListComp we use the baked-in 'return'</span><span>
</span><span id="line-1161"></span><span>            </span><span class="hs-comment">-- For DoExpr, MDoExpr, we don't apply a 'return' at all</span><span>
</span><span id="line-1162"></span><span>            </span><span class="hs-comment">-- See Note [Monad Comprehensions]</span><span>
</span><span id="line-1163"></span><span>            </span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLarrow'</span><span>
</span><span id="line-1164"></span><span>
</span><span id="line-1165"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1166"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BindStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#BindStmt"><span class="hs-identifier hs-var">BindStmt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBindStmt"><span class="hs-identifier hs-type">XBindStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1167"></span><span>             </span><span class="hs-comment">-- ^ Post renaming has optional fail and bind / (&gt;&gt;=) operator.</span><span>
</span><span id="line-1168"></span><span>             </span><span class="hs-comment">-- Post typechecking, also has multiplicity of the argument</span><span>
</span><span id="line-1169"></span><span>             </span><span class="hs-comment">-- and the result type of the function passed to bind;</span><span>
</span><span id="line-1170"></span><span>             </span><span class="hs-comment">-- that is, (P, S) in (&gt;&gt;=) :: Q -&gt; (R # P -&gt; S) -&gt; T</span><span>
</span><span id="line-1171"></span><span>             </span><span class="hs-comment">-- See Note [The type of bind in Stmts]</span><span>
</span><span id="line-1172"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1173"></span><span>             </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1174"></span><span>
</span><span id="line-1175"></span><span>  </span><span class="hs-comment">-- | 'ApplicativeStmt' represents an applicative expression built with</span><span>
</span><span id="line-1176"></span><span>  </span><span class="hs-comment">-- '&lt;$&gt;' and '&lt;*&gt;'.  It is generated by the renamer, and is desugared into the</span><span>
</span><span id="line-1177"></span><span>  </span><span class="hs-comment">-- appropriate applicative expression by the desugarer, but it is intended</span><span>
</span><span id="line-1178"></span><span>  </span><span class="hs-comment">-- to be invisible in error messages.</span><span>
</span><span id="line-1179"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1180"></span><span>  </span><span class="hs-comment">-- For full details, see Note [ApplicativeDo] in &quot;GHC.Rename.Expr&quot;</span><span>
</span><span id="line-1181"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1182"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ApplicativeStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeStmt"><span class="hs-identifier hs-var">ApplicativeStmt</span></a></span></span><span>
</span><span id="line-1183"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApplicativeStmt"><span class="hs-identifier hs-type">XApplicativeStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Post typecheck, Type of the body</span><span>
</span><span id="line-1184"></span><span>             </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span>
</span><span id="line-1185"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArg"><span class="hs-identifier hs-type">ApplicativeArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1186"></span><span>                      </span><span class="hs-comment">-- [(&lt;$&gt;, e1), (&lt;*&gt;, e2), ..., (&lt;*&gt;, en)]</span><span>
</span><span id="line-1187"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- 'join', if necessary</span><span>
</span><span id="line-1188"></span><span>
</span><span id="line-1189"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BodyStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#BodyStmt"><span class="hs-identifier hs-var">BodyStmt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XBodyStmt"><span class="hs-identifier hs-type">XBodyStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Post typecheck, element type</span><span>
</span><span id="line-1190"></span><span>                                      </span><span class="hs-comment">-- of the RHS (used for arrows)</span><span>
</span><span id="line-1191"></span><span>             </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span>              </span><span class="hs-comment">-- See Note [BodyStmt]</span><span>
</span><span id="line-1192"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The (&gt;&gt;) operator</span><span>
</span><span id="line-1193"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- The `guard` operator; used only in MonadComp</span><span>
</span><span id="line-1194"></span><span>                               </span><span class="hs-comment">-- See notes [Monad Comprehensions]</span><span>
</span><span id="line-1195"></span><span>
</span><span id="line-1196"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet'</span><span>
</span><span id="line-1197"></span><span>  </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnOpen' @'{'@,'GHC.Parser.Annotation.AnnClose' @'}'@,</span><span>
</span><span id="line-1198"></span><span>
</span><span id="line-1199"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1200"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LetStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LetStmt"><span class="hs-identifier hs-var">LetStmt</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XLetStmt"><span class="hs-identifier hs-type">XLetStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-type">HsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1201"></span><span>
</span><span id="line-1202"></span><span>  </span><span class="hs-comment">-- ParStmts only occur in a list/monad comprehension</span><span>
</span><span id="line-1203"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmt"><span class="hs-identifier hs-var">ParStmt</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParStmt"><span class="hs-identifier hs-type">XParStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- Post typecheck,</span><span>
</span><span id="line-1204"></span><span>                                        </span><span class="hs-comment">-- S in (&gt;&gt;=) :: Q -&gt; (R -&gt; S) -&gt; T</span><span>
</span><span id="line-1205"></span><span>             </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtBlock"><span class="hs-identifier hs-type">ParStmtBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1206"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>               </span><span class="hs-comment">-- Polymorphic `mzip` for monad comprehensions</span><span>
</span><span id="line-1207"></span><span>             </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- The `&gt;&gt;=` operator</span><span>
</span><span id="line-1208"></span><span>                                        </span><span class="hs-comment">-- See notes [Monad Comprehensions]</span><span>
</span><span id="line-1209"></span><span>            </span><span class="hs-comment">-- After renaming, the ids are the binders</span><span>
</span><span id="line-1210"></span><span>            </span><span class="hs-comment">-- bound by the stmts and used after themp</span><span>
</span><span id="line-1211"></span><span>
</span><span id="line-1212"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TransStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmt"><span class="hs-identifier hs-var">TransStmt</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-1213"></span><span>      </span><span id="trS_ext"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; XTransStmt idL idR body
</span><a href="Language.Haskell.Syntax.Expr.html#trS_ext"><span class="hs-identifier hs-var hs-var">trS_ext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTransStmt"><span class="hs-identifier hs-type">XTransStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- Post typecheck,</span><span>
</span><span id="line-1214"></span><span>                                            </span><span class="hs-comment">-- R in (&gt;&gt;=) :: Q -&gt; (R -&gt; S) -&gt; T</span><span>
</span><span id="line-1215"></span><span>      </span><span id="trS_form"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; TransForm
</span><a href="Language.Haskell.Syntax.Expr.html#trS_form"><span class="hs-identifier hs-var hs-var">trS_form</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransForm"><span class="hs-identifier hs-type">TransForm</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1216"></span><span>      </span><span id="trS_stmts"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [ExprLStmt idL]
</span><a href="Language.Haskell.Syntax.Expr.html#trS_stmts"><span class="hs-identifier hs-var hs-var">trS_stmts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>   </span><span class="hs-comment">-- Stmts to the *left* of the 'group'</span><span>
</span><span id="line-1217"></span><span>                                      </span><span class="hs-comment">-- which generates the tuples to be grouped</span><span>
</span><span id="line-1218"></span><span>
</span><span id="line-1219"></span><span>      </span><span id="trS_bndrs"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [(IdP idR, IdP idR)]
</span><a href="Language.Haskell.Syntax.Expr.html#trS_bndrs"><span class="hs-identifier hs-var hs-var">trS_bndrs</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- See Note [TransStmt binder map]</span><span>
</span><span id="line-1220"></span><span>
</span><span id="line-1221"></span><span>      </span><span id="trS_using"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; LHsExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_using"><span class="hs-identifier hs-var hs-var">trS_using</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-1222"></span><span>      </span><span id="trS_by"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; Maybe (LHsExpr idR)
</span><a href="Language.Haskell.Syntax.Expr.html#trS_by"><span class="hs-identifier hs-var hs-var">trS_by</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>  </span><span class="hs-comment">-- &quot;by e&quot; (optional)</span><span>
</span><span id="line-1223"></span><span>        </span><span class="hs-comment">-- Invariant: if trS_form = GroupBy, then grp_by = Just e</span><span>
</span><span id="line-1224"></span><span>
</span><span id="line-1225"></span><span>      </span><span id="trS_ret"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_ret"><span class="hs-identifier hs-var hs-var">trS_ret</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>      </span><span class="hs-comment">-- The monomorphic 'return' function for</span><span>
</span><span id="line-1226"></span><span>                                      </span><span class="hs-comment">-- the inner monad comprehensions</span><span>
</span><span id="line-1227"></span><span>      </span><span id="trS_bind"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_bind"><span class="hs-identifier hs-var hs-var">trS_bind</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>     </span><span class="hs-comment">-- The '(&gt;&gt;=)' operator</span><span>
</span><span id="line-1228"></span><span>      </span><span id="trS_fmap"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; HsExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#trS_fmap"><span class="hs-identifier hs-var hs-var">trS_fmap</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span>          </span><span class="hs-comment">-- The polymorphic 'fmap' function for desugaring</span><span>
</span><span id="line-1229"></span><span>                                      </span><span class="hs-comment">-- Only for 'group' forms</span><span>
</span><span id="line-1230"></span><span>                                      </span><span class="hs-comment">-- Just a simple HsExpr, because it's</span><span>
</span><span id="line-1231"></span><span>                                      </span><span class="hs-comment">-- too polymorphic for tcSyntaxOp</span><span>
</span><span id="line-1232"></span><span>    </span><span class="hs-special">}</span><span>                                 </span><span class="hs-comment">-- See Note [Monad Comprehensions]</span><span>
</span><span id="line-1233"></span><span>
</span><span id="line-1234"></span><span>  </span><span class="hs-comment">-- Recursive statement (see Note [How RecStmt works] below)</span><span>
</span><span id="line-1235"></span><span>  </span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRec'</span><span>
</span><span id="line-1236"></span><span>
</span><span id="line-1237"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-1238"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecStmt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecStmt"><span class="hs-identifier hs-var">RecStmt</span></a></span></span><span>
</span><span id="line-1239"></span><span>     </span><span class="hs-special">{</span><span> </span><span id="recS_ext"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; XRecStmt idL idR body
</span><a href="Language.Haskell.Syntax.Expr.html#recS_ext"><span class="hs-identifier hs-var hs-var">recS_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRecStmt"><span class="hs-identifier hs-type">XRecStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span>
</span><span id="line-1240"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_stmts"><span class="annot"><span class="annottext">forall idL idR body.
StmtLR idL idR body -&gt; XRec idR [LStmtLR idL idR body]
</span><a href="Language.Haskell.Syntax.Expr.html#recS_stmts"><span class="hs-identifier hs-var hs-var">recS_stmts</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LStmtLR"><span class="hs-identifier hs-type">LStmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1241"></span><span>     </span><span class="hs-comment">-- Assume XRec is the same for idL and idR, pick one arbitrarily</span><span>
</span><span id="line-1242"></span><span>
</span><span id="line-1243"></span><span>        </span><span class="hs-comment">-- The next two fields are only valid after renaming</span><span>
</span><span id="line-1244"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_later_ids"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [IdP idR]
</span><a href="Language.Haskell.Syntax.Expr.html#recS_later_ids"><span class="hs-identifier hs-var hs-var">recS_later_ids</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1245"></span><span>                         </span><span class="hs-comment">-- The ids are a subset of the variables bound by the</span><span>
</span><span id="line-1246"></span><span>                         </span><span class="hs-comment">-- stmts that are used in stmts that follow the RecStmt</span><span>
</span><span id="line-1247"></span><span>
</span><span id="line-1248"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_rec_ids"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; [IdP idR]
</span><a href="Language.Haskell.Syntax.Expr.html#recS_rec_ids"><span class="hs-identifier hs-var hs-var">recS_rec_ids</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1249"></span><span>                         </span><span class="hs-comment">-- Ditto, but these variables are the &quot;recursive&quot; ones,</span><span>
</span><span id="line-1250"></span><span>                         </span><span class="hs-comment">-- that are used before they are bound in the stmts of</span><span>
</span><span id="line-1251"></span><span>                         </span><span class="hs-comment">-- the RecStmt.</span><span>
</span><span id="line-1252"></span><span>        </span><span class="hs-comment">-- An Id can be in both groups</span><span>
</span><span id="line-1253"></span><span>        </span><span class="hs-comment">-- Both sets of Ids are (now) treated monomorphically</span><span>
</span><span id="line-1254"></span><span>        </span><span class="hs-comment">-- See Note [How RecStmt works] for why they are separate</span><span>
</span><span id="line-1255"></span><span>
</span><span id="line-1256"></span><span>        </span><span class="hs-comment">-- Rebindable syntax</span><span>
</span><span id="line-1257"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_bind_fn"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#recS_bind_fn"><span class="hs-identifier hs-var hs-var">recS_bind_fn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-comment">-- The bind function</span><span>
</span><span id="line-1258"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_ret_fn"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#recS_ret_fn"><span class="hs-identifier hs-var hs-var">recS_ret_fn</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-comment">-- The return function</span><span>
</span><span id="line-1259"></span><span>     </span><span class="hs-special">,</span><span> </span><span id="recS_mfix_fn"><span class="annot"><span class="annottext">forall idL idR body. StmtLR idL idR body -&gt; SyntaxExpr idR
</span><a href="Language.Haskell.Syntax.Expr.html#recS_mfix_fn"><span class="hs-identifier hs-var hs-var">recS_mfix_fn</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-comment">-- The mfix function</span><span>
</span><span id="line-1260"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-1261"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XStmtLR"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XStmtLR"><span class="hs-identifier hs-var">XStmtLR</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXStmtLR"><span class="hs-identifier hs-type">XXStmtLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074742"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074741"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074740"><span class="hs-identifier hs-type">body</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1262"></span><span>
</span><span id="line-1263"></span><span class="hs-keyword">data</span><span> </span><span id="TransForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransForm"><span class="hs-identifier hs-var">TransForm</span></a></span></span><span>   </span><span class="hs-comment">-- The 'f' below is the 'using' function, 'e' is the by function</span><span>
</span><span id="line-1264"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ThenForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThenForm"><span class="hs-identifier hs-var">ThenForm</span></a></span></span><span>     </span><span class="hs-comment">-- then f               or    then f by e             (depending on trS_by)</span><span>
</span><span id="line-1265"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GroupForm"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GroupForm"><span class="hs-identifier hs-var">GroupForm</span></a></span></span><span>    </span><span class="hs-comment">-- then group using f   or    then group by e using f (depending on trS_by)</span><span>
</span><span id="line-1266"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681073902"><span id="local-6989586621681073904"><span id="local-6989586621681073906"><span id="local-6989586621681073908"><span id="local-6989586621681073910"><span id="local-6989586621681073912"><span id="local-6989586621681073914"><span id="local-6989586621681073916"><span id="local-6989586621681073918"><span id="local-6989586621681073920"><span id="local-6989586621681073922"><span id="local-6989586621681073924"><span id="local-6989586621681073926"><span id="local-6989586621681073928"><span class="annot"><span class="annottext">Typeable TransForm
TransForm -&gt; DataType
TransForm -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TransForm -&gt; m TransForm
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TransForm -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TransForm -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TransForm -&gt; TransForm
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TransForm)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TransForm)
dataTypeOf :: TransForm -&gt; DataType
$cdataTypeOf :: TransForm -&gt; DataType
toConstr :: TransForm -&gt; Constr
$ctoConstr :: TransForm -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TransForm
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TransForm -&gt; c TransForm
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1267"></span><span>
</span><span id="line-1268"></span><span class="hs-comment">-- | Parenthesised Statement Block</span><span>
</span><span id="line-1269"></span><span class="hs-keyword">data</span><span> </span><span id="ParStmtBlock"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtBlock"><span class="hs-identifier hs-var">ParStmtBlock</span></a></span></span><span> </span><span id="local-6989586621681073901"><span class="annot"><a href="#local-6989586621681073901"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681073900"><span class="annot"><a href="#local-6989586621681073900"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-1270"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ParStmtBlock"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtBlock"><span class="hs-identifier hs-var">ParStmtBlock</span></a></span></span><span>
</span><span id="line-1271"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XParStmtBlock"><span class="hs-identifier hs-type">XParStmtBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073901"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073900"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1272"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073901"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1273"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073900"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>          </span><span class="hs-comment">-- The variables to be returned</span><span>
</span><span id="line-1274"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073900"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- The return operator</span><span>
</span><span id="line-1275"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XParStmtBlock"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XParStmtBlock"><span class="hs-identifier hs-var">XParStmtBlock</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXParStmtBlock"><span class="hs-identifier hs-type">XXParStmtBlock</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073901"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073900"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1276"></span><span>
</span><span id="line-1277"></span><span class="hs-comment">-- | The fail operator</span><span>
</span><span id="line-1278"></span><span class="hs-comment">--</span><span>
</span><span id="line-1279"></span><span class="hs-comment">-- This is used for `.. &lt;-` &quot;bind statements&quot; in do notation, including</span><span>
</span><span id="line-1280"></span><span class="hs-comment">-- non-monadic &quot;binds&quot; in applicative.</span><span>
</span><span id="line-1281"></span><span class="hs-comment">--</span><span>
</span><span id="line-1282"></span><span class="hs-comment">-- The fail operator is 'Just expr' if it potentially fail monadically. if the</span><span>
</span><span id="line-1283"></span><span class="hs-comment">-- pattern match cannot fail, or shouldn't fail monadically (regular incomplete</span><span>
</span><span id="line-1284"></span><span class="hs-comment">-- pattern exception), it is 'Nothing'.</span><span>
</span><span id="line-1285"></span><span class="hs-comment">--</span><span>
</span><span id="line-1286"></span><span class="hs-comment">-- See Note [Monad fail : Rebindable syntax, overloaded strings] for the type of</span><span>
</span><span id="line-1287"></span><span class="hs-comment">-- expression in the 'Just' case, and why it is so.</span><span>
</span><span id="line-1288"></span><span class="hs-comment">--</span><span>
</span><span id="line-1289"></span><span class="hs-comment">-- See Note [Failing pattern matches in Stmts] for which contexts for</span><span>
</span><span id="line-1290"></span><span class="hs-comment">-- '@BindStmt@'s should use the monadic fail and which shouldn't.</span><span>
</span><span id="line-1291"></span><span class="hs-keyword">type</span><span> </span><span id="FailOperator"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FailOperator"><span class="hs-identifier hs-var">FailOperator</span></a></span></span><span> </span><span id="local-6989586621681073894"><span class="annot"><a href="#local-6989586621681073894"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SyntaxExpr"><span class="hs-identifier hs-type">SyntaxExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073894"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1292"></span><span>
</span><span id="line-1293"></span><span class="hs-comment">-- | Applicative Argument</span><span>
</span><span id="line-1294"></span><span class="hs-keyword">data</span><span> </span><span id="ApplicativeArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArg"><span class="hs-identifier hs-var">ApplicativeArg</span></a></span></span><span> </span><span id="local-6989586621681074684"><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span></span><span>
</span><span id="line-1295"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ApplicativeArgOne"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArgOne"><span class="hs-identifier hs-var">ApplicativeArgOne</span></a></span></span><span>      </span><span class="hs-comment">-- A single statement (BindStmt or BodyStmt)</span><span>
</span><span id="line-1296"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="xarg_app_arg_one"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; XApplicativeArgOne idL
</span><a href="Language.Haskell.Syntax.Expr.html#xarg_app_arg_one"><span class="hs-identifier hs-var hs-var">xarg_app_arg_one</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApplicativeArgOne"><span class="hs-identifier hs-type">XApplicativeArgOne</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span>
</span><span id="line-1297"></span><span>      </span><span class="hs-comment">-- ^ The fail operator, after renaming</span><span>
</span><span id="line-1298"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-1299"></span><span>      </span><span class="hs-comment">-- The fail operator is needed if this is a BindStmt</span><span>
</span><span id="line-1300"></span><span>      </span><span class="hs-comment">-- where the pattern can fail. E.g.:</span><span>
</span><span id="line-1301"></span><span>      </span><span class="hs-comment">-- (Just a) &lt;- stmt</span><span>
</span><span id="line-1302"></span><span>      </span><span class="hs-comment">-- The fail operator will be invoked if the pattern</span><span>
</span><span id="line-1303"></span><span>      </span><span class="hs-comment">-- match fails.</span><span>
</span><span id="line-1304"></span><span>      </span><span class="hs-comment">-- It is also used for guards in MonadComprehensions.</span><span>
</span><span id="line-1305"></span><span>      </span><span class="hs-comment">-- The fail operator is Nothing</span><span>
</span><span id="line-1306"></span><span>      </span><span class="hs-comment">-- if the pattern match can't fail</span><span>
</span><span id="line-1307"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="app_arg_pattern"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Expr.html#app_arg_pattern"><span class="hs-identifier hs-var hs-var">app_arg_pattern</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-comment">-- WildPat if it was a BodyStmt (see below)</span><span>
</span><span id="line-1308"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="arg_expr"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; LHsExpr idL
</span><a href="Language.Haskell.Syntax.Expr.html#arg_expr"><span class="hs-identifier hs-var hs-var">arg_expr</span></a></span></span><span>          </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span>
</span><span id="line-1309"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="is_body_stmt"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#is_body_stmt"><span class="hs-identifier hs-var hs-var">is_body_stmt</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1310"></span><span>      </span><span class="hs-comment">-- ^ True &lt;=&gt; was a BodyStmt,</span><span>
</span><span id="line-1311"></span><span>      </span><span class="hs-comment">-- False &lt;=&gt; was a BindStmt.</span><span>
</span><span id="line-1312"></span><span>      </span><span class="hs-comment">-- See Note [Applicative BodyStmt]</span><span>
</span><span id="line-1313"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-1314"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ApplicativeArgMany"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArgMany"><span class="hs-identifier hs-var">ApplicativeArgMany</span></a></span></span><span>     </span><span class="hs-comment">-- do { stmts; return vars }</span><span>
</span><span id="line-1315"></span><span>    </span><span class="hs-special">{</span><span> </span><span id="xarg_app_arg_many"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; XApplicativeArgMany idL
</span><a href="Language.Haskell.Syntax.Expr.html#xarg_app_arg_many"><span class="hs-identifier hs-var hs-var">xarg_app_arg_many</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XApplicativeArgMany"><span class="hs-identifier hs-type">XApplicativeArgMany</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span>
</span><span id="line-1316"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="app_stmts"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; [ExprLStmt idL]
</span><a href="Language.Haskell.Syntax.Expr.html#app_stmts"><span class="hs-identifier hs-var hs-var">app_stmts</span></a></span></span><span>         </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExprLStmt"><span class="hs-identifier hs-type">ExprLStmt</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- stmts</span><span>
</span><span id="line-1317"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="final_expr"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; HsExpr idL
</span><a href="Language.Haskell.Syntax.Expr.html#final_expr"><span class="hs-identifier hs-var hs-var">final_expr</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span>    </span><span class="hs-comment">-- return (v1,..,vn), or just (v1,..,vn)</span><span>
</span><span id="line-1318"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="bv_pattern"><span class="annot"><span class="annottext">forall idL. ApplicativeArg idL -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Expr.html#bv_pattern"><span class="hs-identifier hs-var hs-var">bv_pattern</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span>      </span><span class="hs-comment">-- (v1,...,vn)</span><span>
</span><span id="line-1319"></span><span>    </span><span class="hs-special">,</span><span> </span><span id="stmt_context"><span class="annot"><span class="annottext">forall idL.
ApplicativeArg idL -&gt; HsStmtContext (ApplicativeArgStmCtxPass idL)
</span><a href="Language.Haskell.Syntax.Expr.html#stmt_context"><span class="hs-identifier hs-var hs-var">stmt_context</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArgStmCtxPass"><span class="hs-identifier hs-type">ApplicativeArgStmCtxPass</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1320"></span><span>      </span><span class="hs-comment">-- ^ context of the do expression, used in pprArg</span><span>
</span><span id="line-1321"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-1322"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XApplicativeArg"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XApplicativeArg"><span class="hs-identifier hs-var">XApplicativeArg</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXApplicativeArg"><span class="hs-identifier hs-type">XXApplicativeArg</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074684"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1323"></span><span>
</span><span id="line-1324"></span><span class="hs-keyword">type</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="ApplicativeArgStmCtxPass"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ApplicativeArgStmCtxPass"><span class="hs-identifier hs-var">ApplicativeArgStmCtxPass</span></a></span></span><span> </span><span id="local-6989586621681073880"><span class="annot"><a href="#local-6989586621681073880"><span class="hs-identifier hs-type">idL</span></a></span></span><span>
</span><span id="line-1325"></span><span>
</span><span id="line-1326"></span><span class="hs-comment">{-
Note [The type of bind in Stmts]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Some Stmts, notably BindStmt, keep the (&gt;&gt;=) bind operator.
We do NOT assume that it has type
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
In some cases (see #303, #1537) it might have a more
exotic type, such as
    (&gt;&gt;=) :: m i j a -&gt; (a -&gt; m j k b) -&gt; m i k b
So we must be careful not to make assumptions about the type.
In particular, the monad may not be uniform throughout.

Note [TransStmt binder map]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
The [(idR,idR)] in a TransStmt behaves as follows:

  * Before renaming: []

  * After renaming:
          [ (x27,x27), ..., (z35,z35) ]
    These are the variables
       bound by the stmts to the left of the 'group'
       and used either in the 'by' clause,
                or     in the stmts following the 'group'
    Each item is a pair of identical variables.

  * After typechecking:
          [ (x27:Int, x27:[Int]), ..., (z35:Bool, z35:[Bool]) ]
    Each pair has the same unique, but different *types*.

Note [BodyStmt]
~~~~~~~~~~~~~~~
BodyStmts are a bit tricky, because what they mean
depends on the context.  Consider the following contexts:

        A do expression of type (m res_ty)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E any_ty:   do { ....; E; ... }
                E :: m any_ty
          Translation: E &gt;&gt; ...

        A list comprehensions of type [elt_ty]
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E Bool:   [ .. | .... E ]
                        [ .. | ..., E, ... ]
                        [ .. | .... | ..., E | ... ]
                E :: Bool
          Translation: if E then fail else ...

        A guard list, guarding a RHS of type rhs_ty
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E BooParStmtBlockl:   f x | ..., E, ... = ...rhs...
                E :: Bool
          Translation: if E then fail else ...

        A monad comprehension of type (m res_ty)
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        * BodyStmt E Bool:   [ .. | .... E ]
                E :: Bool
          Translation: guard E &gt;&gt; ...

Array comprehensions are handled like list comprehensions.

Note [How RecStmt works]
~~~~~~~~~~~~~~~~~~~~~~~~
Example:
   HsDo [ BindStmt x ex

        , RecStmt { recS_rec_ids   = [a, c]
                  , recS_stmts     = [ BindStmt b (return (a,c))
                                     , LetStmt a = ...b...
                                     , BindStmt c ec ]
                  , recS_later_ids = [a, b]

        , return (a b) ]

Here, the RecStmt binds a,b,c; but
  - Only a,b are used in the stmts *following* the RecStmt,
  - Only a,c are used in the stmts *inside* the RecStmt
        *before* their bindings

Why do we need *both* rec_ids and later_ids?  For monads they could be
combined into a single set of variables, but not for arrows.  That
follows from the types of the respective feedback operators:

        mfix :: MonadFix m =&gt; (a -&gt; m a) -&gt; m a
        loop :: ArrowLoop a =&gt; a (b,d) (c,d) -&gt; a b c

* For mfix, the 'a' covers the union of the later_ids and the rec_ids
* For 'loop', 'c' is the later_ids and 'd' is the rec_ids

Note [Typing a RecStmt]
~~~~~~~~~~~~~~~~~~~~~~~
A (RecStmt stmts) types as if you had written

  (v1,..,vn, _, ..., _) &lt;- mfix (\~(_, ..., _, r1, ..., rm) -&gt;
                                 do { stmts
                                    ; return (v1,..vn, r1, ..., rm) })

where v1..vn are the later_ids
      r1..rm are the rec_ids

Note [Monad Comprehensions]
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Monad comprehensions require separate functions like 'return' and
'&gt;&gt;=' for desugaring. These functions are stored in the statements
used in monad comprehensions. For example, the 'return' of the 'LastStmt'
expression is used to lift the body of the monad comprehension:

  [ body | stmts ]
   =&gt;
  stmts &gt;&gt;= \bndrs -&gt; return body

In transform and grouping statements ('then ..' and 'then group ..') the
'return' function is required for nested monad comprehensions, for example:

  [ body | stmts, then f, rest ]
   =&gt;
  f [ env | stmts ] &gt;&gt;= \bndrs -&gt; [ body | rest ]

BodyStmts require the 'Control.Monad.guard' function for boolean
expressions:

  [ body | exp, stmts ]
   =&gt;
  guard exp &gt;&gt; [ body | stmts ]

Parallel statements require the 'Control.Monad.Zip.mzip' function:

  [ body | stmts1 | stmts2 | .. ]
   =&gt;
  mzip stmts1 (mzip stmts2 (..)) &gt;&gt;= \(bndrs1, (bndrs2, ..)) -&gt; return body

In any other context than 'MonadComp', the fields for most of these
'SyntaxExpr's stay bottom.


Note [Applicative BodyStmt]

(#12143) For the purposes of ApplicativeDo, we treat any BodyStmt
as if it was a BindStmt with a wildcard pattern.  For example,

  do
    x &lt;- A
    B
    return x

is transformed as if it were

  do
    x &lt;- A
    _ &lt;- B
    return x

so it transforms to

  (\(x,_) -&gt; x) &lt;$&gt; A &lt;*&gt; B

But we have to remember when we treat a BodyStmt like a BindStmt,
because in error messages we want to emit the original syntax the user
wrote, not our internal representation.  So ApplicativeArgOne has a
Bool flag that is True when the original statement was a BodyStmt, so
that we can pretty-print it correctly.
-}</span><span>
</span><span id="line-1490"></span><span>
</span><span id="line-1491"></span><span>
</span><span id="line-1492"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Template Haskell quotation brackets
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1499"></span><span>
</span><span id="line-1500"></span><span class="hs-comment">-- | Haskell Splice</span><span>
</span><span id="line-1501"></span><span class="hs-keyword">data</span><span> </span><span id="HsSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplice"><span class="hs-identifier hs-var">HsSplice</span></a></span></span><span> </span><span id="local-6989586621681073879"><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-1502"></span><span>   </span><span class="hs-glyph">=</span><span> </span><span id="HsTypedSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTypedSplice"><span class="hs-identifier hs-var">HsTypedSplice</span></a></span></span><span>       </span><span class="hs-comment">--  $$z  or $$(f 4)</span><span>
</span><span id="line-1503"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypedSplice"><span class="hs-identifier hs-type">XTypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1504"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SpliceDecoration"><span class="hs-identifier hs-type">SpliceDecoration</span></a></span><span> </span><span class="hs-comment">-- Whether $$( ) variant found, for pretty printing</span><span>
</span><span id="line-1505"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- A unique name to identify this splice point</span><span>
</span><span id="line-1506"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- See Note [Pending Splices]</span><span>
</span><span id="line-1507"></span><span>
</span><span id="line-1508"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="HsUntypedSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsUntypedSplice"><span class="hs-identifier hs-var">HsUntypedSplice</span></a></span></span><span>     </span><span class="hs-comment">--  $z  or $(f 4)</span><span>
</span><span id="line-1509"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XUntypedSplice"><span class="hs-identifier hs-type">XUntypedSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1510"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SpliceDecoration"><span class="hs-identifier hs-type">SpliceDecoration</span></a></span><span> </span><span class="hs-comment">-- Whether $( ) variant found, for pretty printing</span><span>
</span><span id="line-1511"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- A unique name to identify this splice point</span><span>
</span><span id="line-1512"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>     </span><span class="hs-comment">-- See Note [Pending Splices]</span><span>
</span><span id="line-1513"></span><span>
</span><span id="line-1514"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="HsQuasiQuote"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsQuasiQuote"><span class="hs-identifier hs-var">HsQuasiQuote</span></a></span></span><span>        </span><span class="hs-comment">-- See Note [Quasi-quote overview] in GHC.Tc.Gen.Splice</span><span>
</span><span id="line-1515"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XQuasiQuote"><span class="hs-identifier hs-type">XQuasiQuote</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1516"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- Splice point</span><span>
</span><span id="line-1517"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>         </span><span class="hs-comment">-- Quoter</span><span>
</span><span id="line-1518"></span><span>        </span><span class="annot"><a href="GHC.Types.SrcLoc.html#SrcSpan"><span class="hs-identifier hs-type">SrcSpan</span></a></span><span>          </span><span class="hs-comment">-- The span of the enclosed string</span><span>
</span><span id="line-1519"></span><span>        </span><span class="annot"><a href="GHC.Data.FastString.html#FastString"><span class="hs-identifier hs-type">FastString</span></a></span><span>       </span><span class="hs-comment">-- The enclosed string</span><span>
</span><span id="line-1520"></span><span>
</span><span id="line-1521"></span><span>   </span><span class="hs-comment">-- AZ:TODO: use XSplice instead of HsSpliced</span><span>
</span><span id="line-1522"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="HsSpliced"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSpliced"><span class="hs-identifier hs-var">HsSpliced</span></a></span></span><span>  </span><span class="hs-comment">-- See Note [Delaying modFinalizers in untyped splices] in</span><span>
</span><span id="line-1523"></span><span>                </span><span class="hs-comment">-- GHC.Rename.Splice.</span><span>
</span><span id="line-1524"></span><span>                </span><span class="hs-comment">-- This is the result of splicing a splice. It is produced by</span><span>
</span><span id="line-1525"></span><span>                </span><span class="hs-comment">-- the renamer and consumed by the typechecker. It lives only</span><span>
</span><span id="line-1526"></span><span>                </span><span class="hs-comment">-- between the two.</span><span>
</span><span id="line-1527"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpliced"><span class="hs-identifier hs-type">XSpliced</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1528"></span><span>        </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThModFinalizers"><span class="hs-identifier hs-type">ThModFinalizers</span></a></span><span>     </span><span class="hs-comment">-- TH finalizers produced by the splice.</span><span>
</span><span id="line-1529"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplicedThing"><span class="hs-identifier hs-type">HsSplicedThing</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- The result of splicing</span><span>
</span><span id="line-1530"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="XSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XSplice"><span class="hs-identifier hs-var">XSplice</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXSplice"><span class="hs-identifier hs-type">XXSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073879"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- Note [Trees that Grow] extension point</span><span>
</span><span id="line-1531"></span><span>
</span><span id="line-1532"></span><span class="hs-comment">-- | A splice can appear with various decorations wrapped around it. This data</span><span>
</span><span id="line-1533"></span><span class="hs-comment">-- type captures explicitly how it was originally written, for use in the pretty</span><span>
</span><span id="line-1534"></span><span class="hs-comment">-- printer.</span><span>
</span><span id="line-1535"></span><span class="hs-keyword">data</span><span> </span><span id="SpliceDecoration"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SpliceDecoration"><span class="hs-identifier hs-var">SpliceDecoration</span></a></span></span><span>
</span><span id="line-1536"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="DollarSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DollarSplice"><span class="hs-identifier hs-var">DollarSplice</span></a></span></span><span>  </span><span class="hs-comment">-- ^ $splice or $$splice</span><span>
</span><span id="line-1537"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BareSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#BareSplice"><span class="hs-identifier hs-var">BareSplice</span></a></span></span><span>    </span><span class="hs-comment">-- ^ bare splice</span><span>
</span><span id="line-1538"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621681073835"><span id="local-6989586621681073837"><span id="local-6989586621681073839"><span id="local-6989586621681073841"><span id="local-6989586621681073843"><span id="local-6989586621681073845"><span id="local-6989586621681073847"><span id="local-6989586621681073849"><span id="local-6989586621681073851"><span id="local-6989586621681073853"><span id="local-6989586621681073855"><span id="local-6989586621681073857"><span id="local-6989586621681073859"><span id="local-6989586621681073861"><span class="annot"><span class="annottext">Typeable SpliceDecoration
SpliceDecoration -&gt; DataType
SpliceDecoration -&gt; Constr
(forall b. Data b =&gt; b -&gt; b)
-&gt; SpliceDecoration -&gt; SpliceDecoration
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SpliceDecoration)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; SpliceDecoration -&gt; m SpliceDecoration
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; SpliceDecoration -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; SpliceDecoration -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SpliceDecoration -&gt; SpliceDecoration
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; SpliceDecoration -&gt; SpliceDecoration
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SpliceDecoration)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c SpliceDecoration)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c SpliceDecoration)
dataTypeOf :: SpliceDecoration -&gt; DataType
$cdataTypeOf :: SpliceDecoration -&gt; DataType
toConstr :: SpliceDecoration -&gt; Constr
$ctoConstr :: SpliceDecoration -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c SpliceDecoration
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; SpliceDecoration -&gt; c SpliceDecoration
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681073831"><span id="local-6989586621681073833"><span class="annot"><span class="annottext">SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
$c/= :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
== :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
$c== :: SpliceDecoration -&gt; SpliceDecoration -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621681073824"><span id="local-6989586621681073826"><span id="local-6989586621681073828"><span class="annot"><span class="annottext">Int -&gt; SpliceDecoration -&gt; ShowS
[SpliceDecoration] -&gt; ShowS
SpliceDecoration -&gt; String
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [SpliceDecoration] -&gt; ShowS
$cshowList :: [SpliceDecoration] -&gt; ShowS
show :: SpliceDecoration -&gt; String
$cshow :: SpliceDecoration -&gt; String
showsPrec :: Int -&gt; SpliceDecoration -&gt; ShowS
$cshowsPrec :: Int -&gt; SpliceDecoration -&gt; ShowS
</span><a href="../../base-4.16.4.0/src/GHC-Show.html#Show"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></a></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-1539"></span><span>
</span><span id="line-1540"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SpliceDecoration"><span class="hs-identifier hs-type">SpliceDecoration</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1541"></span><span>  </span><span id="local-6989586621681073819"><span class="annot"><span class="annottext">ppr :: SpliceDecoration -&gt; SDoc
</span><a href="#local-6989586621681073819"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span id="local-6989586621681073818"><span class="annot"><span class="annottext">SpliceDecoration
</span><a href="#local-6989586621681073818"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">forall a. Show a =&gt; a -&gt; String
</span><a href="../../base-4.16.4.0/src/GHC-Show.html#show"><span class="hs-identifier hs-var">show</span></a></span><span> </span><span class="annot"><span class="annottext">SpliceDecoration
</span><a href="#local-6989586621681073818"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1542"></span><span>
</span><span id="line-1543"></span><span>
</span><span id="line-1544"></span><span id="local-6989586621681074663"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isTypedSplice"><span class="hs-identifier hs-type">isTypedSplice</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplice"><span class="hs-identifier hs-type">HsSplice</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074663"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1545"></span><span id="isTypedSplice"><span class="annot"><span class="annottext">isTypedSplice :: forall id. HsSplice id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isTypedSplice"><span class="hs-identifier hs-var hs-var">isTypedSplice</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsTypedSplice"><span class="hs-identifier hs-type">HsTypedSplice</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1546"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isTypedSplice"><span class="hs-identifier hs-var">isTypedSplice</span></a></span><span> </span><span class="annot"><span class="annottext">HsSplice id
</span><span class="hs-identifier">_</span></span><span>                  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>   </span><span class="hs-comment">-- Quasi-quotes are untyped splices</span><span>
</span><span id="line-1547"></span><span>
</span><span id="line-1548"></span><span class="hs-comment">-- | Finalizers produced by a splice with</span><span>
</span><span id="line-1549"></span><span class="hs-comment">-- 'Language.Haskell.TH.Syntax.addModFinalizer'</span><span>
</span><span id="line-1550"></span><span class="hs-comment">--</span><span>
</span><span id="line-1551"></span><span class="hs-comment">-- See Note [Delaying modFinalizers in untyped splices] in GHC.Rename.Splice. For how</span><span>
</span><span id="line-1552"></span><span class="hs-comment">-- this is used.</span><span>
</span><span id="line-1553"></span><span class="hs-comment">--</span><span>
</span><span id="line-1554"></span><span class="hs-keyword">newtype</span><span> </span><span id="ThModFinalizers"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThModFinalizers"><span class="hs-identifier hs-var">ThModFinalizers</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ThModFinalizers"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThModFinalizers"><span class="hs-identifier hs-var">ThModFinalizers</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="../../ghci-9.2.7/src/GHCi-RemoteTypes.html#ForeignRef"><span class="hs-identifier hs-type">ForeignRef</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../template-haskell-2.18.0.0/src/Language-Haskell-TH-Syntax.html#Q"><span class="hs-identifier hs-type">TH.Q</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-1555"></span><span>
</span><span id="line-1556"></span><span class="hs-comment">-- A Data instance which ignores the argument of 'ThModFinalizers'.</span><span>
</span><span id="line-1557"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681073788"><span id="local-6989586621681073790"><span id="local-6989586621681073792"><span id="local-6989586621681073794"><span id="local-6989586621681073796"><span id="local-6989586621681073798"><span id="local-6989586621681073800"><span id="local-6989586621681073802"><span id="local-6989586621681073804"><span id="local-6989586621681073806"><span id="local-6989586621681073811"><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-type">Data</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThModFinalizers"><span class="hs-identifier hs-type">ThModFinalizers</span></a></span></span></span></span></span></span></span></span></span></span></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1558"></span><span>  </span><span id="local-6989586621681073787"><span class="annot"><span class="annottext">gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ThModFinalizers
</span><a href="../../base-4.16.4.0/src/Data-Data.html#gunfold"><span class="hs-identifier hs-var hs-var hs-var hs-var">gunfold</span></a></span></span><span> </span><span class="annot"><span class="annottext">forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681073785"><span class="annot"><span class="annottext">forall r. r -&gt; c r
</span><a href="#local-6989586621681073785"><span class="hs-identifier hs-var">z</span></a></span></span><span> </span><span class="annot"><span class="annottext">Constr
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall r. r -&gt; c r
</span><a href="#local-6989586621681073785"><span class="hs-identifier hs-var">z</span></a></span><span> </span><span class="annot"><span class="annottext">forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#%24"><span class="hs-operator hs-var">$</span></a></span><span> </span><span class="annot"><span class="annottext">[ForeignRef (Q ())] -&gt; ThModFinalizers
</span><a href="Language.Haskell.Syntax.Expr.html#ThModFinalizers"><span class="hs-identifier hs-var">ThModFinalizers</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1559"></span><span>  </span><span id="local-6989586621681073783"><span class="annot"><span class="annottext">toConstr :: ThModFinalizers -&gt; Constr
</span><a href="../../base-4.16.4.0/src/Data-Data.html#toConstr"><span class="hs-identifier hs-var hs-var hs-var hs-var">toConstr</span></a></span></span><span>  </span><span id="local-6989586621681073781"><span class="annot"><span class="annottext">ThModFinalizers
</span><a href="#local-6989586621681073781"><span class="hs-identifier hs-var">a</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DataType -&gt; String -&gt; [String] -&gt; Fixity -&gt; Constr
</span><a href="../../base-4.16.4.0/src/Data-Data.html#mkConstr"><span class="hs-identifier hs-var">mkConstr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Data a =&gt; a -&gt; DataType
</span><a href="../../base-4.16.4.0/src/Data-Data.html#dataTypeOf"><span class="hs-identifier hs-var">dataTypeOf</span></a></span><span> </span><span class="annot"><span class="annottext">ThModFinalizers
</span><a href="#local-6989586621681073781"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;ThModFinalizers&quot;</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Prefix"><span class="hs-identifier hs-var">Data.Prefix</span></a></span><span>
</span><span id="line-1560"></span><span>  </span><span id="local-6989586621681073776"><span class="annot"><span class="annottext">dataTypeOf :: ThModFinalizers -&gt; DataType
</span><a href="#local-6989586621681073776"><span class="hs-identifier hs-var hs-var hs-var hs-var">dataTypeOf</span></a></span></span><span> </span><span id="local-6989586621681073775"><span class="annot"><span class="annottext">ThModFinalizers
</span><a href="#local-6989586621681073775"><span class="hs-identifier hs-var">a</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; [Constr] -&gt; DataType
</span><a href="../../base-4.16.4.0/src/Data-Data.html#mkDataType"><span class="hs-identifier hs-var">mkDataType</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;HsExpr.ThModFinalizers&quot;</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">forall a. Data a =&gt; a -&gt; Constr
</span><a href="../../base-4.16.4.0/src/Data-Data.html#toConstr"><span class="hs-identifier hs-var">toConstr</span></a></span><span> </span><span class="annot"><span class="annottext">ThModFinalizers
</span><a href="#local-6989586621681073775"><span class="hs-identifier hs-var">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1561"></span><span>
</span><span id="line-1562"></span><span class="hs-comment">-- | Haskell Spliced Thing</span><span>
</span><span id="line-1563"></span><span class="hs-comment">--</span><span>
</span><span id="line-1564"></span><span class="hs-comment">-- Values that can result from running a splice.</span><span>
</span><span id="line-1565"></span><span class="hs-keyword">data</span><span> </span><span id="HsSplicedThing"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplicedThing"><span class="hs-identifier hs-var">HsSplicedThing</span></a></span></span><span> </span><span id="local-6989586621681073773"><span class="annot"><a href="#local-6989586621681073773"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-1566"></span><span>    </span><span class="hs-glyph">=</span><span> </span><span id="HsSplicedExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplicedExpr"><span class="hs-identifier hs-var">HsSplicedExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsExpr"><span class="hs-identifier hs-type">HsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073773"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Haskell Spliced Expression</span><span>
</span><span id="line-1567"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="HsSplicedTy"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplicedTy"><span class="hs-identifier hs-var">HsSplicedTy</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsType"><span class="hs-identifier hs-type">HsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073773"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- ^ Haskell Spliced Type</span><span>
</span><span id="line-1568"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="HsSplicedPat"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsSplicedPat"><span class="hs-identifier hs-var">HsSplicedPat</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#Pat"><span class="hs-identifier hs-type">Pat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073773"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^ Haskell Spliced Pattern</span><span>
</span><span id="line-1569"></span><span>
</span><span id="line-1570"></span><span>
</span><span id="line-1571"></span><span class="hs-comment">-- See Note [Pending Splices]</span><span>
</span><span id="line-1572"></span><span class="hs-keyword">type</span><span> </span><span id="SplicePointName"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#SplicePointName"><span class="hs-identifier hs-var">SplicePointName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.Name.html#Name"><span class="hs-identifier hs-type">Name</span></a></span><span>
</span><span id="line-1573"></span><span>
</span><span id="line-1574"></span><span class="hs-keyword">data</span><span> </span><span id="UntypedSpliceFlavour"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#UntypedSpliceFlavour"><span class="hs-identifier hs-var">UntypedSpliceFlavour</span></a></span></span><span>
</span><span id="line-1575"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UntypedExpSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#UntypedExpSplice"><span class="hs-identifier hs-var">UntypedExpSplice</span></a></span></span><span>
</span><span id="line-1576"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UntypedPatSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#UntypedPatSplice"><span class="hs-identifier hs-var">UntypedPatSplice</span></a></span></span><span>
</span><span id="line-1577"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UntypedTypeSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#UntypedTypeSplice"><span class="hs-identifier hs-var">UntypedTypeSplice</span></a></span></span><span>
</span><span id="line-1578"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UntypedDeclSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#UntypedDeclSplice"><span class="hs-identifier hs-var">UntypedDeclSplice</span></a></span></span><span>
</span><span id="line-1579"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681073733"><span id="local-6989586621681073735"><span id="local-6989586621681073737"><span id="local-6989586621681073739"><span id="local-6989586621681073741"><span id="local-6989586621681073743"><span id="local-6989586621681073745"><span id="local-6989586621681073747"><span id="local-6989586621681073749"><span id="local-6989586621681073751"><span id="local-6989586621681073753"><span id="local-6989586621681073755"><span id="local-6989586621681073757"><span id="local-6989586621681073759"><span class="annot"><span class="annottext">Typeable UntypedSpliceFlavour
UntypedSpliceFlavour -&gt; DataType
UntypedSpliceFlavour -&gt; Constr
(forall b. Data b =&gt; b -&gt; b)
-&gt; UntypedSpliceFlavour -&gt; UntypedSpliceFlavour
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; UntypedSpliceFlavour -&gt; u
forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; UntypedSpliceFlavour -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; UntypedSpliceFlavour -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; UntypedSpliceFlavour -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c UntypedSpliceFlavour
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; UntypedSpliceFlavour
-&gt; c UntypedSpliceFlavour
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c UntypedSpliceFlavour)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c UntypedSpliceFlavour)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; UntypedSpliceFlavour -&gt; m UntypedSpliceFlavour
gmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; UntypedSpliceFlavour -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; UntypedSpliceFlavour -&gt; u
gmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; UntypedSpliceFlavour -&gt; [u]
$cgmapQ :: forall u.
(forall d. Data d =&gt; d -&gt; u) -&gt; UntypedSpliceFlavour -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; UntypedSpliceFlavour -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; UntypedSpliceFlavour -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; UntypedSpliceFlavour -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; UntypedSpliceFlavour -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; UntypedSpliceFlavour -&gt; UntypedSpliceFlavour
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; UntypedSpliceFlavour -&gt; UntypedSpliceFlavour
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c UntypedSpliceFlavour)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c UntypedSpliceFlavour)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c UntypedSpliceFlavour)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c UntypedSpliceFlavour)
dataTypeOf :: UntypedSpliceFlavour -&gt; DataType
$cdataTypeOf :: UntypedSpliceFlavour -&gt; DataType
toConstr :: UntypedSpliceFlavour -&gt; Constr
$ctoConstr :: UntypedSpliceFlavour -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c UntypedSpliceFlavour
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c UntypedSpliceFlavour
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; UntypedSpliceFlavour
-&gt; c UntypedSpliceFlavour
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; UntypedSpliceFlavour
-&gt; c UntypedSpliceFlavour
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-1580"></span><span>
</span><span id="line-1581"></span><span class="hs-comment">-- | Haskell Bracket</span><span>
</span><span id="line-1582"></span><span class="hs-keyword">data</span><span> </span><span id="HsBracket"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracket"><span class="hs-identifier hs-var">HsBracket</span></a></span></span><span> </span><span id="local-6989586621681073732"><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-1583"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ExpBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ExpBr"><span class="hs-identifier hs-var">ExpBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XExpBr"><span class="hs-identifier hs-type">XExpBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- [|  expr  |]</span><span>
</span><span id="line-1584"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatBr"><span class="hs-identifier hs-var">PatBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatBr"><span class="hs-identifier hs-type">XPatBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- [p| pat   |]</span><span>
</span><span id="line-1585"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DecBrL"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DecBrL"><span class="hs-identifier hs-var">DecBrL</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDecBrL"><span class="hs-identifier hs-type">XDecBrL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#LHsDecl"><span class="hs-identifier hs-type">LHsDecl</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">]</span><span>   </span><span class="hs-comment">-- [d| decls |]; result of parser</span><span>
</span><span id="line-1586"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DecBrG"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DecBrG"><span class="hs-identifier hs-var">DecBrG</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XDecBrG"><span class="hs-identifier hs-type">XDecBrG</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Decls.html#HsGroup"><span class="hs-identifier hs-type">HsGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- [d| decls |]; result of renamer</span><span>
</span><span id="line-1587"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TypBr"><span class="hs-identifier hs-var">TypBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypBr"><span class="hs-identifier hs-type">XTypBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsType"><span class="hs-identifier hs-type">LHsType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- [t| type  |]</span><span>
</span><span id="line-1588"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#VarBr"><span class="hs-identifier hs-var">VarBr</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarBr"><span class="hs-identifier hs-type">XVarBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>   </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1589"></span><span>                                </span><span class="hs-comment">-- True: 'x, False: ''T</span><span>
</span><span id="line-1590"></span><span>                                </span><span class="hs-comment">-- (The Bool flag is used only in pprHsBracket)</span><span>
</span><span id="line-1591"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TExpBr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TExpBr"><span class="hs-identifier hs-var">TExpBr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTExpBr"><span class="hs-identifier hs-type">XTExpBr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- [||  expr  ||]</span><span>
</span><span id="line-1592"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XBracket"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#XBracket"><span class="hs-identifier hs-var">XBracket</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXBracket"><span class="hs-identifier hs-type">XXBracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073732"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>           </span><span class="hs-comment">-- Note [Trees that Grow] extension point</span><span>
</span><span id="line-1593"></span><span>
</span><span id="line-1594"></span><span id="local-6989586621681074657"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isTypedBracket"><span class="hs-identifier hs-type">isTypedBracket</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsBracket"><span class="hs-identifier hs-type">HsBracket</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074657"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1595"></span><span id="isTypedBracket"><span class="annot"><span class="annottext">isTypedBracket :: forall id. HsBracket id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isTypedBracket"><span class="hs-identifier hs-var hs-var">isTypedBracket</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TExpBr"><span class="hs-identifier hs-type">TExpBr</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1596"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isTypedBracket"><span class="hs-identifier hs-var">isTypedBracket</span></a></span><span> </span><span class="annot"><span class="annottext">HsBracket id
</span><span class="hs-identifier">_</span></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1597"></span><span>
</span><span id="line-1598"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Enumerations and list comprehensions}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1605"></span><span>
</span><span id="line-1606"></span><span class="hs-comment">-- | Arithmetic Sequence Information</span><span>
</span><span id="line-1607"></span><span class="hs-keyword">data</span><span> </span><span id="ArithSeqInfo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArithSeqInfo"><span class="hs-identifier hs-var">ArithSeqInfo</span></a></span></span><span> </span><span id="local-6989586621681073711"><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-1608"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="From"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#From"><span class="hs-identifier hs-var">From</span></a></span></span><span>            </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1609"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FromThen"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FromThen"><span class="hs-identifier hs-var">FromThen</span></a></span></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1610"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1611"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FromTo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FromTo"><span class="hs-identifier hs-var">FromTo</span></a></span></span><span>          </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1612"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1613"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FromThenTo"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FromThenTo"><span class="hs-identifier hs-var">FromThenTo</span></a></span></span><span>      </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1614"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1615"></span><span>                    </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073711"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1616"></span><span class="hs-comment">-- AZ: Should ArithSeqInfo have a TTG extension?</span><span>
</span><span id="line-1617"></span><span>
</span><span id="line-1618"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{HsMatchCtxt}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-1625"></span><span>
</span><span id="line-1626"></span><span class="hs-comment">-- | Haskell Match Context</span><span>
</span><span id="line-1627"></span><span class="hs-comment">--</span><span>
</span><span id="line-1628"></span><span class="hs-comment">-- Context of a pattern match. This is more subtle than it would seem. See Note</span><span>
</span><span id="line-1629"></span><span class="hs-comment">-- [Varieties of pattern matches].</span><span>
</span><span id="line-1630"></span><span class="hs-keyword">data</span><span> </span><span id="HsMatchContext"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-var">HsMatchContext</span></a></span></span><span> </span><span id="local-6989586621681074755"><span class="annot"><a href="#local-6989586621681074755"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-1631"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="FunRhs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-var">FunRhs</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="mc_fun"><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; LIdP p
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fun"><span class="hs-identifier hs-var hs-var">mc_fun</span></a></span></span><span>        </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074755"><span class="hs-identifier hs-type">p</span></a></span><span>    </span><span class="hs-comment">-- ^ function binder of @f@</span><span>
</span><span id="line-1632"></span><span>           </span><span class="hs-special">,</span><span> </span><span id="mc_fixity"><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; LexicalFixity
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fixity"><span class="hs-identifier hs-var hs-var">mc_fixity</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#LexicalFixity"><span class="hs-identifier hs-type">LexicalFixity</span></a></span><span> </span><span class="hs-comment">-- ^ fixing of @f@</span><span>
</span><span id="line-1633"></span><span>           </span><span class="hs-special">,</span><span> </span><span id="mc_strictness"><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; SrcStrictness
</span><a href="Language.Haskell.Syntax.Expr.html#mc_strictness"><span class="hs-identifier hs-var hs-var">mc_strictness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Core.DataCon.html#SrcStrictness"><span class="hs-identifier hs-type">SrcStrictness</span></a></span><span> </span><span class="hs-comment">-- ^ was @f@ banged?</span><span>
</span><span id="line-1634"></span><span>                                            </span><span class="hs-comment">-- See Note [FunBind vs PatBind]</span><span>
</span><span id="line-1635"></span><span>           </span><span class="hs-special">}</span><span>
</span><span id="line-1636"></span><span>                                </span><span class="hs-comment">-- ^A pattern matching on an argument of a</span><span>
</span><span id="line-1637"></span><span>                                </span><span class="hs-comment">-- function binding</span><span>
</span><span id="line-1638"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LambdaExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LambdaExpr"><span class="hs-identifier hs-var">LambdaExpr</span></a></span></span><span>                  </span><span class="hs-comment">-- ^Patterns of a lambda</span><span>
</span><span id="line-1639"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CaseAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span></span><span>                     </span><span class="hs-comment">-- ^Patterns and guards on a case alternative</span><span>
</span><span id="line-1640"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IfAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#IfAlt"><span class="hs-identifier hs-var">IfAlt</span></a></span></span><span>                       </span><span class="hs-comment">-- ^Guards of a multi-way if alternative</span><span>
</span><span id="line-1641"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowMatchCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowMatchCtxt"><span class="hs-identifier hs-var">ArrowMatchCtxt</span></a></span></span><span>              </span><span class="hs-comment">-- ^A pattern match inside arrow notation</span><span>
</span><span id="line-1642"></span><span>      </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrowMatchContext"><span class="hs-identifier hs-type">HsArrowMatchContext</span></a></span><span>
</span><span id="line-1643"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBindRhs"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatBindRhs"><span class="hs-identifier hs-var">PatBindRhs</span></a></span></span><span>                  </span><span class="hs-comment">-- ^A pattern binding  eg [y] &lt;- e = e</span><span>
</span><span id="line-1644"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBindGuards"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatBindGuards"><span class="hs-identifier hs-var">PatBindGuards</span></a></span></span><span>               </span><span class="hs-comment">-- ^Guards of pattern bindings, e.g.,</span><span>
</span><span id="line-1645"></span><span>                                </span><span class="hs-comment">--    (Just b) | Just _ &lt;- x = e</span><span>
</span><span id="line-1646"></span><span>                                </span><span class="hs-comment">--             | otherwise   = e'</span><span>
</span><span id="line-1647"></span><span>
</span><span id="line-1648"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecUpd"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#RecUpd"><span class="hs-identifier hs-var">RecUpd</span></a></span></span><span>                      </span><span class="hs-comment">-- ^Record update [used only in GHC.HsToCore.Expr to</span><span>
</span><span id="line-1649"></span><span>                                </span><span class="hs-comment">--    tell matchWrapper what sort of</span><span>
</span><span id="line-1650"></span><span>                                </span><span class="hs-comment">--    runtime error message to generate]</span><span>
</span><span id="line-1651"></span><span>
</span><span id="line-1652"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="StmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtCtxt"><span class="hs-identifier hs-var">StmtCtxt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074755"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^Pattern of a do-stmt, list comprehension,</span><span>
</span><span id="line-1653"></span><span>                                </span><span class="hs-comment">-- pattern guard, etc</span><span>
</span><span id="line-1654"></span><span>
</span><span id="line-1655"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ThPatSplice"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThPatSplice"><span class="hs-identifier hs-var">ThPatSplice</span></a></span></span><span>            </span><span class="hs-comment">-- ^A Template Haskell pattern splice</span><span>
</span><span id="line-1656"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ThPatQuote"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ThPatQuote"><span class="hs-identifier hs-var">ThPatQuote</span></a></span></span><span>             </span><span class="hs-comment">-- ^A Template Haskell pattern quotation [p| (a,b) |]</span><span>
</span><span id="line-1657"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSyn"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span></span><span>                 </span><span class="hs-comment">-- ^A pattern synonym declaration</span><span>
</span><span id="line-1658"></span><span>
</span><span id="line-1659"></span><span id="local-6989586621681074649"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isPatSynCtxt"><span class="hs-identifier hs-type">isPatSynCtxt</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074649"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1660"></span><span id="isPatSynCtxt"><span class="annot"><span class="annottext">isPatSynCtxt :: forall p. HsMatchContext p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isPatSynCtxt"><span class="hs-identifier hs-var hs-var">isPatSynCtxt</span></a></span></span><span> </span><span id="local-6989586621681073692"><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073692"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1661"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073692"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1662"></span><span>    </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1663"></span><span>    </span><span class="annot"><span class="annottext">HsMatchContext p
</span><span class="hs-identifier">_</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1664"></span><span>
</span><span id="line-1665"></span><span class="hs-comment">-- | Haskell Statement Context.</span><span>
</span><span id="line-1666"></span><span class="hs-keyword">data</span><span> </span><span id="HsStmtContext"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-var">HsStmtContext</span></a></span></span><span> </span><span id="local-6989586621681073691"><span class="annot"><a href="#local-6989586621681073691"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-1667"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ListComp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span></span><span>
</span><span id="line-1668"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MonadComp"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span></span><span>
</span><span id="line-1669"></span><span>
</span><span id="line-1670"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DoExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-var">DoExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Unit.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- ^[ModuleName.]do { ... }</span><span>
</span><span id="line-1671"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MDoExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-var">MDoExpr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Unit.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span class="hs-special">)</span><span>       </span><span class="hs-comment">-- ^[ModuleName.]mdo { ... }  ie recursive do-expression</span><span>
</span><span id="line-1672"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowExpr"><span class="hs-identifier hs-var">ArrowExpr</span></a></span></span><span>                        </span><span class="hs-comment">-- ^do-notation in an arrow-command context</span><span>
</span><span id="line-1673"></span><span>
</span><span id="line-1674"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GhciStmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span></span><span>                     </span><span class="hs-comment">-- ^A command-line Stmt in GHCi pat &lt;- rhs</span><span>
</span><span id="line-1675"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatGuard"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatGuard"><span class="hs-identifier hs-var">PatGuard</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073691"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>      </span><span class="hs-comment">-- ^Pattern guard for specified thing</span><span>
</span><span id="line-1676"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParStmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-var">ParStmtCtxt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073691"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- ^A branch of a parallel stmt</span><span>
</span><span id="line-1677"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TransStmtCtxt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-var">TransStmtCtxt</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073691"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-comment">-- ^A branch of a transform stmt</span><span>
</span><span id="line-1678"></span><span>
</span><span id="line-1679"></span><span class="hs-comment">-- | Haskell arrow match context.</span><span>
</span><span id="line-1680"></span><span class="hs-keyword">data</span><span> </span><span id="HsArrowMatchContext"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrowMatchContext"><span class="hs-identifier hs-var">HsArrowMatchContext</span></a></span></span><span>
</span><span id="line-1681"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ProcExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ProcExpr"><span class="hs-identifier hs-var">ProcExpr</span></a></span></span><span>     </span><span class="hs-comment">-- ^ A proc expression</span><span>
</span><span id="line-1682"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ArrowCaseAlt"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowCaseAlt"><span class="hs-identifier hs-var">ArrowCaseAlt</span></a></span></span><span> </span><span class="hs-comment">-- ^ A case alternative inside arrow notation</span><span>
</span><span id="line-1683"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KappaExpr"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#KappaExpr"><span class="hs-identifier hs-var">KappaExpr</span></a></span></span><span>    </span><span class="hs-comment">-- ^ An arrow kappa abstraction</span><span>
</span><span id="line-1684"></span><span>
</span><span id="line-1685"></span><span id="local-6989586621681074647"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#qualifiedDoModuleName_maybe"><span class="hs-identifier hs-type">qualifiedDoModuleName_maybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074647"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Unit.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span></span><span>
</span><span id="line-1686"></span><span id="qualifiedDoModuleName_maybe"><span class="annot"><span class="annottext">qualifiedDoModuleName_maybe :: forall p. HsStmtContext p -&gt; Maybe ModuleName
</span><a href="Language.Haskell.Syntax.Expr.html#qualifiedDoModuleName_maybe"><span class="hs-identifier hs-var hs-var">qualifiedDoModuleName_maybe</span></a></span></span><span> </span><span id="local-6989586621681073677"><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073677"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073677"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1687"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span> </span><span id="local-6989586621681073676"><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073676"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073676"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1688"></span><span>  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span> </span><span id="local-6989586621681073675"><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073675"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073675"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1689"></span><span>  </span><span class="annot"><span class="annottext">HsStmtContext p
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">forall a. Maybe a
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>
</span><span id="line-1690"></span><span>
</span><span id="line-1691"></span><span id="local-6989586621681074644"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-type">isComprehensionContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074644"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1692"></span><span class="hs-comment">-- Uses comprehension syntax [ e | quals ]</span><span>
</span><span id="line-1693"></span><span id="isComprehensionContext"><span class="annot"><span class="annottext">isComprehensionContext :: forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var hs-var">isComprehensionContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1694"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1695"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-type">ParStmtCtxt</span></a></span><span> </span><span id="local-6989586621681073673"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073673"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073673"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1696"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-type">TransStmtCtxt</span></a></span><span> </span><span id="local-6989586621681073672"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073672"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073672"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1697"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isComprehensionContext"><span class="hs-identifier hs-var">isComprehensionContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1698"></span><span>
</span><span id="line-1699"></span><span class="hs-comment">-- | Is this a monadic context?</span><span>
</span><span id="line-1700"></span><span id="local-6989586621681073671"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-type">isMonadStmtContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073671"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1701"></span><span id="isMonadStmtContext"><span class="annot"><span class="annottext">isMonadStmtContext :: forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var hs-var">isMonadStmtContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1702"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1703"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1704"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1705"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-type">ParStmtCtxt</span></a></span><span> </span><span id="local-6989586621681073669"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073669"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073669"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1706"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-type">TransStmtCtxt</span></a></span><span> </span><span id="local-6989586621681073668"><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073668"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="#local-6989586621681073668"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1707"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadStmtContext"><span class="hs-identifier hs-var">isMonadStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span> </span><span class="hs-comment">-- ListComp, PatGuard, ArrowExpr</span><span>
</span><span id="line-1708"></span><span>
</span><span id="line-1709"></span><span id="local-6989586621681073667"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-type">isMonadCompContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073667"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span></span><span>
</span><span id="line-1710"></span><span id="isMonadCompContext"><span class="annot"><span class="annottext">isMonadCompContext :: forall id. HsStmtContext id -&gt; Bool
</span><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var hs-var">isMonadCompContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1711"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#isMonadCompContext"><span class="hs-identifier hs-var">isMonadCompContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext id
</span><span class="hs-identifier">_</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1712"></span><span>
</span><span id="line-1713"></span><span id="local-6989586621681074640"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-type">matchSeparator</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074640"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-1714"></span><span id="matchSeparator"><span class="annot"><span class="annottext">matchSeparator :: forall p. HsMatchContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var hs-var">matchSeparator</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-type">FunRhs</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;=&quot;</span></span><span>
</span><span id="line-1715"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;-&gt;&quot;</span></span><span>
</span><span id="line-1716"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#IfAlt"><span class="hs-identifier hs-var">IfAlt</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;-&gt;&quot;</span></span><span>
</span><span id="line-1717"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#LambdaExpr"><span class="hs-identifier hs-var">LambdaExpr</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;-&gt;&quot;</span></span><span>
</span><span id="line-1718"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowMatchCtxt"><span class="hs-identifier hs-type">ArrowMatchCtxt</span></a></span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;-&gt;&quot;</span></span><span>
</span><span id="line-1719"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatBindRhs"><span class="hs-identifier hs-var">PatBindRhs</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;=&quot;</span></span><span>
</span><span id="line-1720"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatBindGuards"><span class="hs-identifier hs-var">PatBindGuards</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;=&quot;</span></span><span>
</span><span id="line-1721"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtCtxt"><span class="hs-identifier hs-type">StmtCtxt</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&lt;-&quot;</span></span><span>
</span><span id="line-1722"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#RecUpd"><span class="hs-identifier hs-var">RecUpd</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;=&quot;</span></span><span> </span><span class="hs-comment">-- This can be printed by the pattern</span><span>
</span><span id="line-1723"></span><span>                                       </span><span class="hs-comment">-- match checker trace</span><span>
</span><span id="line-1724"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#ThPatSplice"><span class="hs-identifier hs-var">ThPatSplice</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unused&quot;</span></span><span>
</span><span id="line-1725"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#ThPatQuote"><span class="hs-identifier hs-var">ThPatQuote</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unused&quot;</span></span><span>
</span><span id="line-1726"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#matchSeparator"><span class="hs-identifier hs-var">matchSeparator</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. String -&gt; a
</span><a href="GHC.Utils.Panic.Plain.html#panic"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;unused&quot;</span></span><span>
</span><span id="line-1727"></span><span>
</span><span id="line-1728"></span><span id="local-6989586621681074637"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContext"><span class="hs-identifier hs-type">pprMatchContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074637"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074637"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1729"></span><span>                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074637"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-1730"></span><span id="pprMatchContext"><span class="annot"><span class="annottext">pprMatchContext :: forall p.
(Outputable (IdP p), UnXRec p) =&gt;
HsMatchContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprMatchContext"><span class="hs-identifier hs-var hs-var">pprMatchContext</span></a></span></span><span> </span><span id="local-6989586621681073656"><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073656"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span>
</span><span id="line-1731"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">forall p. HsMatchContext p -&gt; Bool
</span><a href="#local-6989586621681073655"><span class="hs-identifier hs-var">want_an</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073656"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;an&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall p.
(Outputable (IdP p), UnXRec p) =&gt;
HsMatchContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073656"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1732"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;a&quot;</span></span><span>  </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall p.
(Outputable (IdP p), UnXRec p) =&gt;
HsMatchContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073656"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1733"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1734"></span><span>    </span><span id="local-6989586621681073655"><span class="annot"><span class="annottext">want_an :: HsMatchContext p -&gt; Bool
</span><a href="#local-6989586621681073655"><span class="hs-identifier hs-var hs-var">want_an</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-type">FunRhs</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>  </span><span class="hs-comment">-- Use &quot;an&quot; in front</span><span>
</span><span id="line-1735"></span><span>    </span><span class="annot"><a href="#local-6989586621681073655"><span class="hs-identifier hs-var">want_an</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowMatchCtxt"><span class="hs-identifier hs-type">ArrowMatchCtxt</span></a></span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="Language.Haskell.Syntax.Expr.html#ProcExpr"><span class="hs-identifier hs-var">ProcExpr</span></a></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1736"></span><span>    </span><span class="annot"><a href="#local-6989586621681073655"><span class="hs-identifier hs-var">want_an</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowMatchCtxt"><span class="hs-identifier hs-type">ArrowMatchCtxt</span></a></span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="Language.Haskell.Syntax.Expr.html#KappaExpr"><span class="hs-identifier hs-var">KappaExpr</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1737"></span><span>    </span><span class="annot"><a href="#local-6989586621681073655"><span class="hs-identifier hs-var">want_an</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><span class="hs-identifier">_</span></span><span>                          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1738"></span><span>
</span><span id="line-1739"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-type">pprMatchContextNoun</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681073652"><span class="annot"><a href="#local-6989586621681073652"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073652"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073652"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1740"></span><span>                    </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsMatchContext"><span class="hs-identifier hs-type">HsMatchContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681073652"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-1741"></span><span id="pprMatchContextNoun"><span class="annot"><span class="annottext">pprMatchContextNoun :: forall p.
(Outputable (IdP p), UnXRec p) =&gt;
HsMatchContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var hs-var">pprMatchContextNoun</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#FunRhs"><span class="hs-identifier hs-type">FunRhs</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">mc_fun :: forall p. HsMatchContext p -&gt; LIdP p
</span><a href="Language.Haskell.Syntax.Expr.html#mc_fun"><span class="hs-identifier hs-var">mc_fun</span></a></span><span class="hs-glyph">=</span><span id="local-6989586621681073645"><span class="annot"><span class="annottext">LIdP p
</span><a href="#local-6989586621681073645"><span class="hs-identifier hs-var">fun</span></a></span></span><span class="hs-special">}</span><span class="hs-special">)</span><span>
</span><span id="line-1742"></span><span>                                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;equation for&quot;</span></span><span>
</span><span id="line-1743"></span><span>                                      </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#quotes"><span class="hs-identifier hs-var">quotes</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681073652"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><span class="annottext">LIdP p
</span><a href="#local-6989586621681073645"><span class="hs-identifier hs-var">fun</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1744"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#CaseAlt"><span class="hs-identifier hs-var">CaseAlt</span></a></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;case alternative&quot;</span></span><span>
</span><span id="line-1745"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#IfAlt"><span class="hs-identifier hs-var">IfAlt</span></a></span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;multi-way if alternative&quot;</span></span><span>
</span><span id="line-1746"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#RecUpd"><span class="hs-identifier hs-var">RecUpd</span></a></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;record-update construct&quot;</span></span><span>
</span><span id="line-1747"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#ThPatSplice"><span class="hs-identifier hs-var">ThPatSplice</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Template Haskell pattern splice&quot;</span></span><span>
</span><span id="line-1748"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#ThPatQuote"><span class="hs-identifier hs-var">ThPatQuote</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;Template Haskell pattern quotation&quot;</span></span><span>
</span><span id="line-1749"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatBindRhs"><span class="hs-identifier hs-var">PatBindRhs</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern binding&quot;</span></span><span>
</span><span id="line-1750"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatBindGuards"><span class="hs-identifier hs-var">PatBindGuards</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern binding guards&quot;</span></span><span>
</span><span id="line-1751"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#LambdaExpr"><span class="hs-identifier hs-var">LambdaExpr</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;lambda abstraction&quot;</span></span><span>
</span><span id="line-1752"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ArrowMatchCtxt"><span class="hs-identifier hs-type">ArrowMatchCtxt</span></a></span><span> </span><span id="local-6989586621681073642"><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="#local-6989586621681073642"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprArrowMatchContextNoun"><span class="hs-identifier hs-var">pprArrowMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="#local-6989586621681073642"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-1753"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#StmtCtxt"><span class="hs-identifier hs-type">StmtCtxt</span></a></span><span> </span><span id="local-6989586621681073640"><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073640"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern binding in&quot;</span></span><span>
</span><span id="line-1754"></span><span>                                      </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprAStmtContext"><span class="hs-identifier hs-var">pprAStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073640"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1755"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprMatchContextNoun"><span class="hs-identifier hs-var">pprMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="Language.Haskell.Syntax.Expr.html#PatSyn"><span class="hs-identifier hs-var">PatSyn</span></a></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern synonym declaration&quot;</span></span><span>
</span><span id="line-1756"></span><span>
</span><span id="line-1757"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprArrowMatchContextNoun"><span class="hs-identifier hs-type">pprArrowMatchContextNoun</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsArrowMatchContext"><span class="hs-identifier hs-type">HsArrowMatchContext</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-1758"></span><span id="pprArrowMatchContextNoun"><span class="annot"><span class="annottext">pprArrowMatchContextNoun :: HsArrowMatchContext -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprArrowMatchContextNoun"><span class="hs-identifier hs-var hs-var">pprArrowMatchContextNoun</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="Language.Haskell.Syntax.Expr.html#ProcExpr"><span class="hs-identifier hs-var">ProcExpr</span></a></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;arrow proc pattern&quot;</span></span><span>
</span><span id="line-1759"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprArrowMatchContextNoun"><span class="hs-identifier hs-var">pprArrowMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="Language.Haskell.Syntax.Expr.html#ArrowCaseAlt"><span class="hs-identifier hs-var">ArrowCaseAlt</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;case alternative within arrow notation&quot;</span></span><span>
</span><span id="line-1760"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprArrowMatchContextNoun"><span class="hs-identifier hs-var">pprArrowMatchContextNoun</span></a></span><span> </span><span class="annot"><span class="annottext">HsArrowMatchContext
</span><a href="Language.Haskell.Syntax.Expr.html#KappaExpr"><span class="hs-identifier hs-var">KappaExpr</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;arrow kappa abstraction&quot;</span></span><span>
</span><span id="line-1761"></span><span>
</span><span id="line-1762"></span><span class="hs-comment">-----------------</span><span>
</span><span id="line-1763"></span><span id="local-6989586621681074629"><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprAStmtContext"><span class="hs-identifier hs-type">pprAStmtContext</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-type">pprStmtContext</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074629"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074629"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1764"></span><span>                                </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#HsStmtContext"><span class="hs-identifier hs-type">HsStmtContext</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681074629"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-1765"></span><span id="pprAStmtContext"><span class="annot"><span class="annottext">pprAStmtContext :: forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprAStmtContext"><span class="hs-identifier hs-var hs-var">pprAStmtContext</span></a></span></span><span> </span><span id="local-6989586621681073632"><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073632"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073631"><span class="hs-identifier hs-var">article</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073632"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1766"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1767"></span><span>    </span><span id="local-6989586621681073630"><span class="annot"><span class="annottext">pp_an :: SDoc
</span><a href="#local-6989586621681073630"><span class="hs-identifier hs-var hs-var">pp_an</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;an&quot;</span></span><span>
</span><span id="line-1768"></span><span>    </span><span id="local-6989586621681073629"><span class="annot"><span class="annottext">pp_a :: SDoc
</span><a href="#local-6989586621681073629"><span class="hs-identifier hs-var hs-var">pp_a</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;a&quot;</span></span><span>
</span><span id="line-1769"></span><span>    </span><span id="local-6989586621681073631"><span class="annot"><span class="annottext">article :: SDoc
</span><a href="#local-6989586621681073631"><span class="hs-identifier hs-var hs-var">article</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073632"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1770"></span><span>                  </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073630"><span class="hs-identifier hs-var">pp_an</span></a></span><span>
</span><span id="line-1771"></span><span>                  </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073630"><span class="hs-identifier hs-var">pp_an</span></a></span><span>
</span><span id="line-1772"></span><span>                  </span><span class="annot"><span class="annottext">HsStmtContext p
</span><span class="hs-identifier">_</span></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073629"><span class="hs-identifier hs-var">pp_a</span></a></span><span>
</span><span id="line-1773"></span><span>
</span><span id="line-1774"></span><span>
</span><span id="line-1775"></span><span class="hs-comment">-----------------</span><span>
</span><span id="line-1776"></span><span id="pprStmtContext"><span class="annot"><span class="annottext">pprStmtContext :: forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var hs-var">pprStmtContext</span></a></span></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="Language.Haskell.Syntax.Expr.html#GhciStmtCtxt"><span class="hs-identifier hs-var">GhciStmtCtxt</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;interactive GHCi command&quot;</span></span><span>
</span><span id="line-1777"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#DoExpr"><span class="hs-identifier hs-type">DoExpr</span></a></span><span> </span><span id="local-6989586621681073616"><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073616"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName -&gt; SDoc -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#prependQualified"><span class="hs-identifier hs-var">prependQualified</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073616"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;'do' block&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1778"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MDoExpr"><span class="hs-identifier hs-type">MDoExpr</span></a></span><span> </span><span id="local-6989586621681073614"><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073614"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName -&gt; SDoc -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#prependQualified"><span class="hs-identifier hs-var">prependQualified</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="#local-6989586621681073614"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;'mdo' block&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-1779"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="Language.Haskell.Syntax.Expr.html#ArrowExpr"><span class="hs-identifier hs-var">ArrowExpr</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;'do' block in an arrow command&quot;</span></span><span>
</span><span id="line-1780"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="Language.Haskell.Syntax.Expr.html#ListComp"><span class="hs-identifier hs-var">ListComp</span></a></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;list comprehension&quot;</span></span><span>
</span><span id="line-1781"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="Language.Haskell.Syntax.Expr.html#MonadComp"><span class="hs-identifier hs-var">MonadComp</span></a></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;monad comprehension&quot;</span></span><span>
</span><span id="line-1782"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#PatGuard"><span class="hs-identifier hs-type">PatGuard</span></a></span><span> </span><span id="local-6989586621681073613"><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073613"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern guard for&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%24%24"><span class="hs-operator hs-var">$$</span></a></span><span> </span><span class="annot"><span class="annottext">forall p.
(Outputable (IdP p), UnXRec p) =&gt;
HsMatchContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprMatchContext"><span class="hs-identifier hs-var">pprMatchContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsMatchContext p
</span><a href="#local-6989586621681073613"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1783"></span><span>
</span><span id="line-1784"></span><span class="hs-comment">-- Drop the inner contexts when reporting errors, else we get</span><span>
</span><span id="line-1785"></span><span class="hs-comment">--     Unexpected transform statement</span><span>
</span><span id="line-1786"></span><span class="hs-comment">--     in a transformed branch of</span><span>
</span><span id="line-1787"></span><span class="hs-comment">--          transformed branch of</span><span>
</span><span id="line-1788"></span><span class="hs-comment">--          transformed branch of monad comprehension</span><span>
</span><span id="line-1789"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#ParStmtCtxt"><span class="hs-identifier hs-type">ParStmtCtxt</span></a></span><span> </span><span id="local-6989586621681073612"><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073612"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1790"></span><span>  </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ifPprDebug"><span class="hs-identifier hs-var">ifPprDebug</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;parallel branch of&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprAStmtContext"><span class="hs-identifier hs-var">pprAStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073612"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1791"></span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073612"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1792"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#TransStmtCtxt"><span class="hs-identifier hs-type">TransStmtCtxt</span></a></span><span> </span><span id="local-6989586621681073609"><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073609"><span class="hs-identifier hs-var">c</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1793"></span><span>  </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ifPprDebug"><span class="hs-identifier hs-var">ifPprDebug</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[SDoc] -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#sep"><span class="hs-identifier hs-var">sep</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;transformed branch of&quot;</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprAStmtContext"><span class="hs-identifier hs-var">pprAStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073609"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1794"></span><span>             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p. (Outputable (IdP p), UnXRec p) =&gt; HsStmtContext p -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#pprStmtContext"><span class="hs-identifier hs-var">pprStmtContext</span></a></span><span> </span><span class="annot"><span class="annottext">HsStmtContext p
</span><a href="#local-6989586621681073609"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1795"></span><span>
</span><span id="line-1796"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#prependQualified"><span class="hs-identifier hs-type">prependQualified</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="annot"><a href="GHC.Unit.Module.Name.html#ModuleName"><span class="hs-identifier hs-type">ModuleName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span><span>
</span><span id="line-1797"></span><span id="prependQualified"><span class="annot"><span class="annottext">prependQualified :: Maybe ModuleName -&gt; SDoc -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Expr.html#prependQualified"><span class="hs-identifier hs-var hs-var">prependQualified</span></a></span></span><span> </span><span class="annot"><span class="annottext">Maybe ModuleName
</span><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Nothing"><span class="hs-identifier hs-var">Nothing</span></a></span><span>  </span><span id="local-6989586621681073608"><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073608"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073608"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1798"></span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#prependQualified"><span class="hs-identifier hs-var">prependQualified</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Just"><span class="hs-identifier hs-type">Just</span></a></span><span> </span><span class="annot"><span class="annottext">ModuleName
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621681073607"><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073607"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;qualified&quot;</span></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="#local-6989586621681073607"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1799"></span></pre></body></html>