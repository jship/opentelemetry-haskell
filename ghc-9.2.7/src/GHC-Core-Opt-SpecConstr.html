<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/SpecConstr.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>ToDo [Oct 2013]
<a name="line-3"></a>~~~~~~~~~~~~~~~
<a name="line-4"></a>1. Nuke ForceSpecConstr for good (it is subsumed by GHC.Types.SPEC in ghc-prim)
<a name="line-5"></a>2. Nuke NoSpecConstr
<a name="line-6"></a>
<a name="line-7"></a>
<a name="line-8"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-9"></a>
<a name="line-10"></a>\section[SpecConstr]{Specialise over constructors}
<a name="line-11"></a>-}</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.SpecConstr</span><span class='hs-layout'>(</span>
<a name="line-18"></a>        <span class='hs-varid'>specConstrProgram</span><span class='hs-layout'>,</span>
<a name="line-19"></a>        <span class='hs-conid'>SpecConstrAnnotation</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-20"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-21"></a>
<a name="line-22"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-23"></a>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Subst</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unfold</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FVs</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>exprsFreeVarsList</span> <span class='hs-layout'>)</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.Monad</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Literal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>litIsLifted</span> <span class='hs-layout'>)</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module.ModGuts</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.WorkWrap.Utils</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isWorkerSmallEnough</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkWorkerArgs</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span> <span class='hs-varid'>hiding</span><span class='hs-layout'>(</span> <span class='hs-varid'>substCo</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Rules</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>     <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-varid'>substTy</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>   <span class='hs-layout'>(</span><span class='hs-conid'>TyCon</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyConUnique</span><span class='hs-layout'>,</span> <span class='hs-varid'>tyConName</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Ppr</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>pprParendExpr</span> <span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Make</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>mkImpossibleExpr</span> <span class='hs-layout'>)</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span> <span class='hs-layout'>(</span> <span class='hs-conid'>DynFlags</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>GeneralFlag</span><span class='hs-layout'>(</span> <span class='hs-conid'>Opt_SpecConstrKeen</span> <span class='hs-layout'>)</span>
<a name="line-50"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>gopt</span><span class='hs-layout'>,</span> <span class='hs-varid'>hasPprDebug</span> <span class='hs-layout'>)</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>orElse</span><span class='hs-layout'>,</span> <span class='hs-varid'>catMaybes</span><span class='hs-layout'>,</span> <span class='hs-varid'>isJust</span><span class='hs-layout'>,</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>)</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Cpr</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Serialized</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>deserializeWithData</span> <span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Pair</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.Supply</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.FM</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Monad</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>zipWithM</span> <span class='hs-layout'>)</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span> <span class='hs-layout'>(</span><span class='hs-varid'>nubBy</span><span class='hs-layout'>,</span> <span class='hs-varid'>sortBy</span><span class='hs-layout'>,</span> <span class='hs-varid'>partition</span><span class='hs-layout'>)</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span> <span class='hs-layout'>(</span> <span class='hs-varid'>specTyConKey</span> <span class='hs-layout'>)</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module</span>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Exts</span><span class='hs-layout'>(</span> <span class='hs-conid'>SpecConstrAnnotation</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Ord</span><span class='hs-layout'>(</span> <span class='hs-varid'>comparing</span> <span class='hs-layout'>)</span>
<a name="line-70"></a>
<a name="line-71"></a><span class='hs-comment'>{-
<a name="line-72"></a>-----------------------------------------------------
<a name="line-73"></a>                        Game plan
<a name="line-74"></a>-----------------------------------------------------
<a name="line-75"></a>
<a name="line-76"></a>Consider
<a name="line-77"></a>        drop n []     = []
<a name="line-78"></a>        drop 0 xs     = []
<a name="line-79"></a>        drop n (x:xs) = drop (n-1) xs
<a name="line-80"></a>
<a name="line-81"></a>After the first time round, we could pass n unboxed.  This happens in
<a name="line-82"></a>numerical code too.  Here's what it looks like in Core:
<a name="line-83"></a>
<a name="line-84"></a>        drop n xs = case xs of
<a name="line-85"></a>                      []     -&gt; []
<a name="line-86"></a>                      (y:ys) -&gt; case n of
<a name="line-87"></a>                                  I# n# -&gt; case n# of
<a name="line-88"></a>                                             0 -&gt; []
<a name="line-89"></a>                                             _ -&gt; drop (I# (n# -# 1#)) xs
<a name="line-90"></a>
<a name="line-91"></a>Notice that the recursive call has an explicit constructor as argument.
<a name="line-92"></a>Noticing this, we can make a specialised version of drop
<a name="line-93"></a>
<a name="line-94"></a>        RULE: drop (I# n#) xs ==&gt; drop' n# xs
<a name="line-95"></a>
<a name="line-96"></a>        drop' n# xs = let n = I# n# in ...orig RHS...
<a name="line-97"></a>
<a name="line-98"></a>Now the simplifier will apply the specialisation in the rhs of drop', giving
<a name="line-99"></a>
<a name="line-100"></a>        drop' n# xs = case xs of
<a name="line-101"></a>                      []     -&gt; []
<a name="line-102"></a>                      (y:ys) -&gt; case n# of
<a name="line-103"></a>                                  0 -&gt; []
<a name="line-104"></a>                                  _ -&gt; drop' (n# -# 1#) xs
<a name="line-105"></a>
<a name="line-106"></a>Much better!
<a name="line-107"></a>
<a name="line-108"></a>We'd also like to catch cases where a parameter is carried along unchanged,
<a name="line-109"></a>but evaluated each time round the loop:
<a name="line-110"></a>
<a name="line-111"></a>        f i n = if i&gt;0 || i&gt;n then i else f (i*2) n
<a name="line-112"></a>
<a name="line-113"></a>Here f isn't strict in n, but we'd like to avoid evaluating it each iteration.
<a name="line-114"></a>In Core, by the time we've w/wd (f is strict in i) we get
<a name="line-115"></a>
<a name="line-116"></a>        f i# n = case i# &gt;# 0 of
<a name="line-117"></a>                   False -&gt; I# i#
<a name="line-118"></a>                   True  -&gt; case n of { I# n# -&gt;
<a name="line-119"></a>                            case i# &gt;# n# of
<a name="line-120"></a>                                False -&gt; I# i#
<a name="line-121"></a>                                True  -&gt; f (i# *# 2#) n
<a name="line-122"></a>
<a name="line-123"></a>At the call to f, we see that the argument, n is known to be (I# n#),
<a name="line-124"></a>and n is evaluated elsewhere in the body of f, so we can play the same
<a name="line-125"></a>trick as above.
<a name="line-126"></a>
<a name="line-127"></a>
<a name="line-128"></a>Note [Reboxing]
<a name="line-129"></a>~~~~~~~~~~~~~~~
<a name="line-130"></a>We must be careful not to allocate the same constructor twice.  Consider
<a name="line-131"></a>        f p = (...(case p of (a,b) -&gt; e)...p...,
<a name="line-132"></a>               ...let t = (r,s) in ...t...(f t)...)
<a name="line-133"></a>At the recursive call to f, we can see that t is a pair.  But we do NOT want
<a name="line-134"></a>to make a specialised copy:
<a name="line-135"></a>        f' a b = let p = (a,b) in (..., ...)
<a name="line-136"></a>because now t is allocated by the caller, then r and s are passed to the
<a name="line-137"></a>recursive call, which allocates the (r,s) pair again.
<a name="line-138"></a>
<a name="line-139"></a>This happens if
<a name="line-140"></a>  (a) the argument p is used in other than a case-scrutinisation way.
<a name="line-141"></a>  (b) the argument to the call is not a 'fresh' tuple; you have to
<a name="line-142"></a>        look into its unfolding to see that it's a tuple
<a name="line-143"></a>
<a name="line-144"></a>Hence the "OR" part of Note [Good arguments] below.
<a name="line-145"></a>
<a name="line-146"></a>ALTERNATIVE 2: pass both boxed and unboxed versions.  This no longer saves
<a name="line-147"></a>allocation, but does perhaps save evals. In the RULE we'd have
<a name="line-148"></a>something like
<a name="line-149"></a>
<a name="line-150"></a>  f (I# x#) = f' (I# x#) x#
<a name="line-151"></a>
<a name="line-152"></a>If at the call site the (I# x) was an unfolding, then we'd have to
<a name="line-153"></a>rely on CSE to eliminate the duplicate allocation.... This alternative
<a name="line-154"></a>doesn't look attractive enough to pursue.
<a name="line-155"></a>
<a name="line-156"></a>ALTERNATIVE 3: ignore the reboxing problem.  The trouble is that
<a name="line-157"></a>the conservative reboxing story prevents many useful functions from being
<a name="line-158"></a>specialised.  Example:
<a name="line-159"></a>        foo :: Maybe Int -&gt; Int -&gt; Int
<a name="line-160"></a>        foo   (Just m) 0 = 0
<a name="line-161"></a>        foo x@(Just m) n = foo x (n-m)
<a name="line-162"></a>Here the use of 'x' will clearly not require boxing in the specialised function.
<a name="line-163"></a>
<a name="line-164"></a>The strictness analyser has the same problem, in fact.  Example:
<a name="line-165"></a>        f p@(a,b) = ...
<a name="line-166"></a>If we pass just 'a' and 'b' to the worker, it might need to rebox the
<a name="line-167"></a>pair to create (a,b).  A more sophisticated analysis might figure out
<a name="line-168"></a>precisely the cases in which this could happen, but the strictness
<a name="line-169"></a>analyser does no such analysis; it just passes 'a' and 'b', and hopes
<a name="line-170"></a>for the best.
<a name="line-171"></a>
<a name="line-172"></a>So my current choice is to make SpecConstr similarly aggressive, and
<a name="line-173"></a>ignore the bad potential of reboxing.
<a name="line-174"></a>
<a name="line-175"></a>
<a name="line-176"></a>Note [Good arguments]
<a name="line-177"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-178"></a>So we look for
<a name="line-179"></a>
<a name="line-180"></a>* A self-recursive function.  Ignore mutual recursion for now,
<a name="line-181"></a>  because it's less common, and the code is simpler for self-recursion.
<a name="line-182"></a>
<a name="line-183"></a>* EITHER
<a name="line-184"></a>
<a name="line-185"></a>   a) At a recursive call, one or more parameters is an explicit
<a name="line-186"></a>      constructor application
<a name="line-187"></a>        AND
<a name="line-188"></a>      That same parameter is scrutinised by a case somewhere in
<a name="line-189"></a>      the RHS of the function
<a name="line-190"></a>
<a name="line-191"></a>  OR
<a name="line-192"></a>
<a name="line-193"></a>    b) At a recursive call, one or more parameters has an unfolding
<a name="line-194"></a>       that is an explicit constructor application
<a name="line-195"></a>        AND
<a name="line-196"></a>      That same parameter is scrutinised by a case somewhere in
<a name="line-197"></a>      the RHS of the function
<a name="line-198"></a>        AND
<a name="line-199"></a>      Those are the only uses of the parameter (see Note [Reboxing])
<a name="line-200"></a>
<a name="line-201"></a>
<a name="line-202"></a>What to abstract over
<a name="line-203"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-204"></a>There's a bit of a complication with type arguments.  If the call
<a name="line-205"></a>site looks like
<a name="line-206"></a>
<a name="line-207"></a>        f p = ...f ((:) [a] x xs)...
<a name="line-208"></a>
<a name="line-209"></a>then our specialised function look like
<a name="line-210"></a>
<a name="line-211"></a>        f_spec x xs = let p = (:) [a] x xs in ....as before....
<a name="line-212"></a>
<a name="line-213"></a>This only makes sense if either
<a name="line-214"></a>  a) the type variable 'a' is in scope at the top of f, or
<a name="line-215"></a>  b) the type variable 'a' is an argument to f (and hence fs)
<a name="line-216"></a>
<a name="line-217"></a>Actually, (a) may hold for value arguments too, in which case
<a name="line-218"></a>we may not want to pass them.  Suppose 'x' is in scope at f's
<a name="line-219"></a>defn, but xs is not.  Then we'd like
<a name="line-220"></a>
<a name="line-221"></a>        f_spec xs = let p = (:) [a] x xs in ....as before....
<a name="line-222"></a>
<a name="line-223"></a>Similarly (b) may hold too.  If x is already an argument at the
<a name="line-224"></a>call, no need to pass it again.
<a name="line-225"></a>
<a name="line-226"></a>Finally, if 'a' is not in scope at the call site, we could abstract
<a name="line-227"></a>it as we do the term variables:
<a name="line-228"></a>
<a name="line-229"></a>        f_spec a x xs = let p = (:) [a] x xs in ...as before...
<a name="line-230"></a>
<a name="line-231"></a>So the grand plan is:
<a name="line-232"></a>
<a name="line-233"></a>        * abstract the call site to a constructor-only pattern
<a name="line-234"></a>          e.g.  C x (D (f p) (g q))  ==&gt;  C s1 (D s2 s3)
<a name="line-235"></a>
<a name="line-236"></a>        * Find the free variables of the abstracted pattern
<a name="line-237"></a>
<a name="line-238"></a>        * Pass these variables, less any that are in scope at
<a name="line-239"></a>          the fn defn.  But see Note [Shadowing] below.
<a name="line-240"></a>
<a name="line-241"></a>
<a name="line-242"></a>NOTICE that we only abstract over variables that are not in scope,
<a name="line-243"></a>so we're in no danger of shadowing variables used in "higher up"
<a name="line-244"></a>in f_spec's RHS.
<a name="line-245"></a>
<a name="line-246"></a>
<a name="line-247"></a>Note [Shadowing]
<a name="line-248"></a>~~~~~~~~~~~~~~~~
<a name="line-249"></a>In this pass we gather up usage information that may mention variables
<a name="line-250"></a>that are bound between the usage site and the definition site; or (more
<a name="line-251"></a>seriously) may be bound to something different at the definition site.
<a name="line-252"></a>For example:
<a name="line-253"></a>
<a name="line-254"></a>        f x = letrec g y v = let x = ...
<a name="line-255"></a>                             in ...(g (a,b) x)...
<a name="line-256"></a>
<a name="line-257"></a>Since 'x' is in scope at the call site, we may make a rewrite rule that
<a name="line-258"></a>looks like
<a name="line-259"></a>        RULE forall a,b. g (a,b) x = ...
<a name="line-260"></a>But this rule will never match, because it's really a different 'x' at
<a name="line-261"></a>the call site -- and that difference will be manifest by the time the
<a name="line-262"></a>simplifier gets to it.  [A worry: the simplifier doesn't *guarantee*
<a name="line-263"></a>no-shadowing, so perhaps it may not be distinct?]
<a name="line-264"></a>
<a name="line-265"></a>Anyway, the rule isn't actually wrong, it's just not useful.  One possibility
<a name="line-266"></a>is to run deShadowBinds before running SpecConstr, but instead we run the
<a name="line-267"></a>simplifier.  That gives the simplest possible program for SpecConstr to
<a name="line-268"></a>chew on; and it virtually guarantees no shadowing.
<a name="line-269"></a>
<a name="line-270"></a>Note [Specialising for constant parameters]
<a name="line-271"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-272"></a>This one is about specialising on a *constant* (but not necessarily
<a name="line-273"></a>constructor) argument
<a name="line-274"></a>
<a name="line-275"></a>    foo :: Int -&gt; (Int -&gt; Int) -&gt; Int
<a name="line-276"></a>    foo 0 f = 0
<a name="line-277"></a>    foo m f = foo (f m) (+1)
<a name="line-278"></a>
<a name="line-279"></a>It produces
<a name="line-280"></a>
<a name="line-281"></a>    lvl_rmV :: GHC.Base.Int -&gt; GHC.Base.Int
<a name="line-282"></a>    lvl_rmV =
<a name="line-283"></a>      \ (ds_dlk :: GHC.Base.Int) -&gt;
<a name="line-284"></a>        case ds_dlk of wild_alH { GHC.Base.I# x_alG -&gt;
<a name="line-285"></a>        GHC.Base.I# (GHC.Prim.+# x_alG 1)
<a name="line-286"></a>
<a name="line-287"></a>    T.$wfoo :: GHC.Prim.Int# -&gt; (GHC.Base.Int -&gt; GHC.Base.Int) -&gt;
<a name="line-288"></a>    GHC.Prim.Int#
<a name="line-289"></a>    T.$wfoo =
<a name="line-290"></a>      \ (ww_sme :: GHC.Prim.Int#) (w_smg :: GHC.Base.Int -&gt; GHC.Base.Int) -&gt;
<a name="line-291"></a>        case ww_sme of ds_Xlw {
<a name="line-292"></a>          __DEFAULT -&gt;
<a name="line-293"></a>        case w_smg (GHC.Base.I# ds_Xlw) of w1_Xmo { GHC.Base.I# ww1_Xmz -&gt;
<a name="line-294"></a>        T.$wfoo ww1_Xmz lvl_rmV
<a name="line-295"></a>        };
<a name="line-296"></a>          0 -&gt; 0
<a name="line-297"></a>        }
<a name="line-298"></a>
<a name="line-299"></a>The recursive call has lvl_rmV as its argument, so we could create a specialised copy
<a name="line-300"></a>with that argument baked in; that is, not passed at all.   Now it can perhaps be inlined.
<a name="line-301"></a>
<a name="line-302"></a>When is this worth it?  Call the constant 'lvl'
<a name="line-303"></a>- If 'lvl' has an unfolding that is a constructor, see if the corresponding
<a name="line-304"></a>  parameter is scrutinised anywhere in the body.
<a name="line-305"></a>
<a name="line-306"></a>- If 'lvl' has an unfolding that is a inlinable function, see if the corresponding
<a name="line-307"></a>  parameter is applied (...to enough arguments...?)
<a name="line-308"></a>
<a name="line-309"></a>  Also do this is if the function has RULES?
<a name="line-310"></a>
<a name="line-311"></a>Also
<a name="line-312"></a>
<a name="line-313"></a>Note [Specialising for lambda parameters]
<a name="line-314"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-315"></a>    foo :: Int -&gt; (Int -&gt; Int) -&gt; Int
<a name="line-316"></a>    foo 0 f = 0
<a name="line-317"></a>    foo m f = foo (f m) (\n -&gt; n-m)
<a name="line-318"></a>
<a name="line-319"></a>This is subtly different from the previous one in that we get an
<a name="line-320"></a>explicit lambda as the argument:
<a name="line-321"></a>
<a name="line-322"></a>    T.$wfoo :: GHC.Prim.Int# -&gt; (GHC.Base.Int -&gt; GHC.Base.Int) -&gt;
<a name="line-323"></a>    GHC.Prim.Int#
<a name="line-324"></a>    T.$wfoo =
<a name="line-325"></a>      \ (ww_sm8 :: GHC.Prim.Int#) (w_sma :: GHC.Base.Int -&gt; GHC.Base.Int) -&gt;
<a name="line-326"></a>        case ww_sm8 of ds_Xlr {
<a name="line-327"></a>          __DEFAULT -&gt;
<a name="line-328"></a>        case w_sma (GHC.Base.I# ds_Xlr) of w1_Xmf { GHC.Base.I# ww1_Xmq -&gt;
<a name="line-329"></a>        T.$wfoo
<a name="line-330"></a>          ww1_Xmq
<a name="line-331"></a>          (\ (n_ad3 :: GHC.Base.Int) -&gt;
<a name="line-332"></a>             case n_ad3 of wild_alB { GHC.Base.I# x_alA -&gt;
<a name="line-333"></a>             GHC.Base.I# (GHC.Prim.-# x_alA ds_Xlr)
<a name="line-334"></a>             })
<a name="line-335"></a>        };
<a name="line-336"></a>          0 -&gt; 0
<a name="line-337"></a>        }
<a name="line-338"></a>
<a name="line-339"></a>I wonder if SpecConstr couldn't be extended to handle this? After all,
<a name="line-340"></a>lambda is a sort of constructor for functions and perhaps it already
<a name="line-341"></a>has most of the necessary machinery?
<a name="line-342"></a>
<a name="line-343"></a>Furthermore, there's an immediate win, because you don't need to allocate the lambda
<a name="line-344"></a>at the call site; and if perchance it's called in the recursive call, then you
<a name="line-345"></a>may avoid allocating it altogether.  Just like for constructors.
<a name="line-346"></a>
<a name="line-347"></a>Looks cool, but probably rare...but it might be easy to implement.
<a name="line-348"></a>
<a name="line-349"></a>
<a name="line-350"></a>Note [SpecConstr for casts]
<a name="line-351"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-352"></a>Consider
<a name="line-353"></a>    data family T a :: *
<a name="line-354"></a>    data instance T Int = T Int
<a name="line-355"></a>
<a name="line-356"></a>    foo n = ...
<a name="line-357"></a>       where
<a name="line-358"></a>         go (T 0) = 0
<a name="line-359"></a>         go (T n) = go (T (n-1))
<a name="line-360"></a>
<a name="line-361"></a>The recursive call ends up looking like
<a name="line-362"></a>        go (T (I# ...) `cast` g)
<a name="line-363"></a>So we want to spot the constructor application inside the cast.
<a name="line-364"></a>That's why we have the Cast case in argToPat
<a name="line-365"></a>
<a name="line-366"></a>Note [Local recursive groups]
<a name="line-367"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-368"></a>For a *local* recursive group, we can see all the calls to the
<a name="line-369"></a>function, so we seed the specialisation loop from the calls in the
<a name="line-370"></a>body, not from the calls in the RHS.  Consider:
<a name="line-371"></a>
<a name="line-372"></a>  bar m n = foo n (n,n) (n,n) (n,n) (n,n)
<a name="line-373"></a>   where
<a name="line-374"></a>     foo n p q r s
<a name="line-375"></a>       | n == 0    = m
<a name="line-376"></a>       | n &gt; 3000  = case p of { (p1,p2) -&gt; foo (n-1) (p2,p1) q r s }
<a name="line-377"></a>       | n &gt; 2000  = case q of { (q1,q2) -&gt; foo (n-1) p (q2,q1) r s }
<a name="line-378"></a>       | n &gt; 1000  = case r of { (r1,r2) -&gt; foo (n-1) p q (r2,r1) s }
<a name="line-379"></a>       | otherwise = case s of { (s1,s2) -&gt; foo (n-1) p q r (s2,s1) }
<a name="line-380"></a>
<a name="line-381"></a>If we start with the RHSs of 'foo', we get lots and lots of specialisations,
<a name="line-382"></a>most of which are not needed.  But if we start with the (single) call
<a name="line-383"></a>in the rhs of 'bar' we get exactly one fully-specialised copy, and all
<a name="line-384"></a>the recursive calls go to this fully-specialised copy. Indeed, the original
<a name="line-385"></a>function is later collected as dead code.  This is very important in
<a name="line-386"></a>specialising the loops arising from stream fusion, for example in NDP where
<a name="line-387"></a>we were getting literally hundreds of (mostly unused) specialisations of
<a name="line-388"></a>a local function.
<a name="line-389"></a>
<a name="line-390"></a>In a case like the above we end up never calling the original un-specialised
<a name="line-391"></a>function.  (Although we still leave its code around just in case.)
<a name="line-392"></a>
<a name="line-393"></a>However, if we find any boring calls in the body, including *unsaturated*
<a name="line-394"></a>ones, such as
<a name="line-395"></a>      letrec foo x y = ....foo...
<a name="line-396"></a>      in map foo xs
<a name="line-397"></a>then we will end up calling the un-specialised function, so then we *should*
<a name="line-398"></a>use the calls in the un-specialised RHS as seeds.  We call these
<a name="line-399"></a>"boring call patterns", and callsToPats reports if it finds any of these.
<a name="line-400"></a>
<a name="line-401"></a>Note [Seeding top-level recursive groups]
<a name="line-402"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-403"></a>This seeding is done in the binding for seed_calls in specRec.
<a name="line-404"></a>
<a name="line-405"></a>1. If all the bindings in a top-level recursive group are local (not
<a name="line-406"></a>   exported), then all the calls are in the rest of the top-level
<a name="line-407"></a>   bindings.  This means we can specialise with those call patterns
<a name="line-408"></a>   ONLY, and NOT with the RHSs of the recursive group (exactly like
<a name="line-409"></a>   Note [Local recursive groups])
<a name="line-410"></a>
<a name="line-411"></a>2. But if any of the bindings are exported, the function may be called
<a name="line-412"></a>   with any old arguments, so (for lack of anything better) we specialise
<a name="line-413"></a>   based on
<a name="line-414"></a>     (a) the call patterns in the RHS
<a name="line-415"></a>     (b) the call patterns in the rest of the top-level bindings
<a name="line-416"></a>   NB: before Apr 15 we used (a) only, but Dimitrios had an example
<a name="line-417"></a>       where (b) was crucial, so I added that.
<a name="line-418"></a>       Adding (b) also improved nofib allocation results:
<a name="line-419"></a>                  multiplier: 4%   better
<a name="line-420"></a>                  minimax:    2.8% better
<a name="line-421"></a>
<a name="line-422"></a>Actually in case (2), instead of using the calls from the RHS, it
<a name="line-423"></a>would be better to specialise in the importing module.  We'd need to
<a name="line-424"></a>add an INLINABLE pragma to the function, and then it can be
<a name="line-425"></a>specialised in the importing scope, just as is done for type classes
<a name="line-426"></a>in GHC.Core.Opt.Specialise.specImports. This remains to be done (#10346).
<a name="line-427"></a>
<a name="line-428"></a>Note [Top-level recursive groups]
<a name="line-429"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-430"></a>To get the call usage information from "the rest of the top level
<a name="line-431"></a>bindings" (c.f. Note [Seeding top-level recursive groups]), we work
<a name="line-432"></a>backwards through the top-level bindings so we see the usage before we
<a name="line-433"></a>get to the binding of the function.  Before we can collect the usage
<a name="line-434"></a>though, we go through all the bindings and add them to the
<a name="line-435"></a>environment. This is necessary because usage is only tracked for
<a name="line-436"></a>functions in the environment.  These two passes are called
<a name="line-437"></a>   'go' and 'goEnv'
<a name="line-438"></a>in specConstrProgram.  (Looks a bit revolting to me.)
<a name="line-439"></a>
<a name="line-440"></a>Note [Do not specialise diverging functions]
<a name="line-441"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-442"></a>Specialising a function that just diverges is a waste of code.
<a name="line-443"></a>Furthermore, it broke GHC (simpl014) thus:
<a name="line-444"></a>   {-# STR Sb #-}
<a name="line-445"></a>   f = \x. case x of (a,b) -&gt; f x
<a name="line-446"></a>If we specialise f we get
<a name="line-447"></a>   f = \x. case x of (a,b) -&gt; fspec a b
<a name="line-448"></a>But fspec doesn't have decent strictness info.  As it happened,
<a name="line-449"></a>(f x) :: IO t, so the state hack applied and we eta expanded fspec,
<a name="line-450"></a>and hence f.  But now f's strictness is less than its arity, which
<a name="line-451"></a>breaks an invariant.
<a name="line-452"></a>
<a name="line-453"></a>
<a name="line-454"></a>Note [Forcing specialisation]
<a name="line-455"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-456"></a>With stream fusion and in other similar cases, we want to fully
<a name="line-457"></a>specialise some (but not necessarily all!) loops regardless of their
<a name="line-458"></a>size and the number of specialisations.
<a name="line-459"></a>
<a name="line-460"></a>We allow a library to do this, in one of two ways (one which is
<a name="line-461"></a>deprecated):
<a name="line-462"></a>
<a name="line-463"></a>  1) Add a parameter of type GHC.Types.SPEC (from ghc-prim) to the loop body.
<a name="line-464"></a>
<a name="line-465"></a>  2) (Deprecated) Annotate a type with ForceSpecConstr from GHC.Exts,
<a name="line-466"></a>     and then add *that* type as a parameter to the loop body
<a name="line-467"></a>
<a name="line-468"></a>The reason #2 is deprecated is because it requires GHCi, which isn't
<a name="line-469"></a>available for things like a cross compiler using stage1.
<a name="line-470"></a>
<a name="line-471"></a>Here's a (simplified) example from the `vector` package. You may bring
<a name="line-472"></a>the special 'force specialization' type into scope by saying:
<a name="line-473"></a>
<a name="line-474"></a>  import GHC.Types (SPEC(..))
<a name="line-475"></a>
<a name="line-476"></a>or by defining your own type (again, deprecated):
<a name="line-477"></a>
<a name="line-478"></a>  data SPEC = SPEC | SPEC2
<a name="line-479"></a>  {-# ANN type SPEC ForceSpecConstr #-}
<a name="line-480"></a>
<a name="line-481"></a>(Note this is the exact same definition of GHC.Types.SPEC, just
<a name="line-482"></a>without the annotation.)
<a name="line-483"></a>
<a name="line-484"></a>After that, you say:
<a name="line-485"></a>
<a name="line-486"></a>  foldl :: (a -&gt; b -&gt; a) -&gt; a -&gt; Stream b -&gt; a
<a name="line-487"></a>  {-# INLINE foldl #-}
<a name="line-488"></a>  foldl f z (Stream step s _) = foldl_loop SPEC z s
<a name="line-489"></a>    where
<a name="line-490"></a>      foldl_loop !sPEC z s = case step s of
<a name="line-491"></a>                              Yield x s' -&gt; foldl_loop sPEC (f z x) s'
<a name="line-492"></a>                              Skip       -&gt; foldl_loop sPEC z s'
<a name="line-493"></a>                              Done       -&gt; z
<a name="line-494"></a>
<a name="line-495"></a>SpecConstr will spot the SPEC parameter and always fully specialise
<a name="line-496"></a>foldl_loop. Note that
<a name="line-497"></a>
<a name="line-498"></a>  * We have to prevent the SPEC argument from being removed by
<a name="line-499"></a>    w/w which is why (a) SPEC is a sum type, and (b) we have to seq on
<a name="line-500"></a>    the SPEC argument.
<a name="line-501"></a>
<a name="line-502"></a>  * And lastly, the SPEC argument is ultimately eliminated by
<a name="line-503"></a>    SpecConstr itself so there is no runtime overhead.
<a name="line-504"></a>
<a name="line-505"></a>This is all quite ugly; we ought to come up with a better design.
<a name="line-506"></a>
<a name="line-507"></a>ForceSpecConstr arguments are spotted in scExpr' and scTopBinds which then set
<a name="line-508"></a>sc_force to True when calling specLoop. This flag does four things:
<a name="line-509"></a>
<a name="line-510"></a>  * Ignore specConstrThreshold, to specialise functions of arbitrary size
<a name="line-511"></a>        (see scTopBind)
<a name="line-512"></a>  * Ignore specConstrCount, to make arbitrary numbers of specialisations
<a name="line-513"></a>        (see specialise)
<a name="line-514"></a>  * Specialise even for arguments that are not scrutinised in the loop
<a name="line-515"></a>        (see argToPat; #4448)
<a name="line-516"></a>  * Only specialise on recursive types a finite number of times
<a name="line-517"></a>        (see is_too_recursive; #5550; Note [Limit recursive specialisation])
<a name="line-518"></a>
<a name="line-519"></a>The flag holds only for specialising a single binding group, and NOT
<a name="line-520"></a>for nested bindings.  (So really it should be passed around explicitly
<a name="line-521"></a>and not stored in ScEnv.)  #14379 turned out to be caused by
<a name="line-522"></a>   f SPEC x = let g1 x = ...
<a name="line-523"></a>              in ...
<a name="line-524"></a>We force-specialise f (because of the SPEC), but that generates a specialised
<a name="line-525"></a>copy of g1 (as well as the original).  Alas g1 has a nested binding g2; and
<a name="line-526"></a>in each copy of g1 we get an unspecialised and specialised copy of g2; and so
<a name="line-527"></a>on. Result, exponential.  So the force-spec flag now only applies to one
<a name="line-528"></a>level of bindings at a time.
<a name="line-529"></a>
<a name="line-530"></a>Mechanism for this one-level-only thing:
<a name="line-531"></a>
<a name="line-532"></a> - Switch it on at the call to specRec, in scExpr and scTopBinds
<a name="line-533"></a> - Switch it off when doing the RHSs;
<a name="line-534"></a>   this can be done very conveniently in decreaseSpecCount
<a name="line-535"></a>
<a name="line-536"></a>What alternatives did I consider?
<a name="line-537"></a>
<a name="line-538"></a>* Annotating the loop itself doesn't work because (a) it is local and
<a name="line-539"></a>  (b) it will be w/w'ed and having w/w propagating annotations somehow
<a name="line-540"></a>  doesn't seem like a good idea. The types of the loop arguments
<a name="line-541"></a>  really seem to be the most persistent thing.
<a name="line-542"></a>
<a name="line-543"></a>* Annotating the types that make up the loop state doesn't work,
<a name="line-544"></a>  either, because (a) it would prevent us from using types like Either
<a name="line-545"></a>  or tuples here, (b) we don't want to restrict the set of types that
<a name="line-546"></a>  can be used in Stream states and (c) some types are fixed by the
<a name="line-547"></a>  user (e.g., the accumulator here) but we still want to specialise as
<a name="line-548"></a>  much as possible.
<a name="line-549"></a>
<a name="line-550"></a>Alternatives to ForceSpecConstr
<a name="line-551"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-552"></a>Instead of giving the loop an extra argument of type SPEC, we
<a name="line-553"></a>also considered *wrapping* arguments in SPEC, thus
<a name="line-554"></a>  data SPEC a = SPEC a | SPEC2
<a name="line-555"></a>
<a name="line-556"></a>  loop = \arg -&gt; case arg of
<a name="line-557"></a>                     SPEC state -&gt;
<a name="line-558"></a>                        case state of (x,y) -&gt; ... loop (SPEC (x',y')) ...
<a name="line-559"></a>                        S2 -&gt; error ...
<a name="line-560"></a>The idea is that a SPEC argument says "specialise this argument
<a name="line-561"></a>regardless of whether the function case-analyses it".  But this
<a name="line-562"></a>doesn't work well:
<a name="line-563"></a>  * SPEC must still be a sum type, else the strictness analyser
<a name="line-564"></a>    eliminates it
<a name="line-565"></a>  * But that means that 'loop' won't be strict in its real payload
<a name="line-566"></a>This loss of strictness in turn screws up specialisation, because
<a name="line-567"></a>we may end up with calls like
<a name="line-568"></a>   loop (SPEC (case z of (p,q) -&gt; (q,p)))
<a name="line-569"></a>Without the SPEC, if 'loop' were strict, the case would move out
<a name="line-570"></a>and we'd see loop applied to a pair. But if 'loop' isn't strict
<a name="line-571"></a>this doesn't look like a specialisable call.
<a name="line-572"></a>
<a name="line-573"></a>Note [Limit recursive specialisation]
<a name="line-574"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-575"></a>It is possible for ForceSpecConstr to cause an infinite loop of specialisation.
<a name="line-576"></a>Because there is no limit on the number of specialisations, a recursive call with
<a name="line-577"></a>a recursive constructor as an argument (for example, list cons) will generate
<a name="line-578"></a>a specialisation for that constructor. If the resulting specialisation also
<a name="line-579"></a>contains a recursive call with the constructor, this could proceed indefinitely.
<a name="line-580"></a>
<a name="line-581"></a>For example, if ForceSpecConstr is on:
<a name="line-582"></a>  loop :: [Int] -&gt; [Int] -&gt; [Int]
<a name="line-583"></a>  loop z []         = z
<a name="line-584"></a>  loop z (x:xs)     = loop (x:z) xs
<a name="line-585"></a>this example will create a specialisation for the pattern
<a name="line-586"></a>  loop (a:b) c      = loop' a b c
<a name="line-587"></a>
<a name="line-588"></a>  loop' a b []      = (a:b)
<a name="line-589"></a>  loop' a b (x:xs)  = loop (x:(a:b)) xs
<a name="line-590"></a>and a new pattern is found:
<a name="line-591"></a>  loop (a:(b:c)) d  = loop'' a b c d
<a name="line-592"></a>which can continue indefinitely.
<a name="line-593"></a>
<a name="line-594"></a>Roman's suggestion to fix this was to stop after a couple of times on recursive types,
<a name="line-595"></a>but still specialising on non-recursive types as much as possible.
<a name="line-596"></a>
<a name="line-597"></a>To implement this, we count the number of times we have gone round the
<a name="line-598"></a>"specialise recursively" loop ('go' in 'specRec').  Once have gone round
<a name="line-599"></a>more than N times (controlled by -fspec-constr-recursive=N) we check
<a name="line-600"></a>
<a name="line-601"></a>  - If sc_force is off, and sc_count is (Just max) then we don't
<a name="line-602"></a>    need to do anything: trim_pats will limit the number of specs
<a name="line-603"></a>
<a name="line-604"></a>  - Otherwise check if any function has now got more than (sc_count env)
<a name="line-605"></a>    specialisations.  If sc_count is "no limit" then we arbitrarily
<a name="line-606"></a>    choose 10 as the limit (ugh).
<a name="line-607"></a>
<a name="line-608"></a>See #5550.   Also #13623, where this test had become over-aggressive,
<a name="line-609"></a>and we lost a wonderful specialisation that we really wanted!
<a name="line-610"></a>
<a name="line-611"></a>Note [NoSpecConstr]
<a name="line-612"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-613"></a>The ignoreDataCon stuff allows you to say
<a name="line-614"></a>    {-# ANN type T NoSpecConstr #-}
<a name="line-615"></a>to mean "don't specialise on arguments of this type".  It was added
<a name="line-616"></a>before we had ForceSpecConstr.  Lacking ForceSpecConstr we specialised
<a name="line-617"></a>regardless of size; and then we needed a way to turn that *off*.  Now
<a name="line-618"></a>that we have ForceSpecConstr, this NoSpecConstr is probably redundant.
<a name="line-619"></a>(Used only for PArray, TODO: remove?)
<a name="line-620"></a>
<a name="line-621"></a>-----------------------------------------------------
<a name="line-622"></a>                Stuff not yet handled
<a name="line-623"></a>-----------------------------------------------------
<a name="line-624"></a>
<a name="line-625"></a>Here are notes arising from Roman's work that I don't want to lose.
<a name="line-626"></a>
<a name="line-627"></a>Example 1
<a name="line-628"></a>~~~~~~~~~
<a name="line-629"></a>    data T a = T !a
<a name="line-630"></a>
<a name="line-631"></a>    foo :: Int -&gt; T Int -&gt; Int
<a name="line-632"></a>    foo 0 t = 0
<a name="line-633"></a>    foo x t | even x    = case t of { T n -&gt; foo (x-n) t }
<a name="line-634"></a>            | otherwise = foo (x-1) t
<a name="line-635"></a>
<a name="line-636"></a>SpecConstr does no specialisation, because the second recursive call
<a name="line-637"></a>looks like a boxed use of the argument.  A pity.
<a name="line-638"></a>
<a name="line-639"></a>    $wfoo_sFw :: GHC.Prim.Int# -&gt; T.T GHC.Base.Int -&gt; GHC.Prim.Int#
<a name="line-640"></a>    $wfoo_sFw =
<a name="line-641"></a>      \ (ww_sFo [Just L] :: GHC.Prim.Int#) (w_sFq [Just L] :: T.T GHC.Base.Int) -&gt;
<a name="line-642"></a>         case ww_sFo of ds_Xw6 [Just L] {
<a name="line-643"></a>           __DEFAULT -&gt;
<a name="line-644"></a>                case GHC.Prim.remInt# ds_Xw6 2 of wild1_aEF [Dead Just A] {
<a name="line-645"></a>                  __DEFAULT -&gt; $wfoo_sFw (GHC.Prim.-# ds_Xw6 1) w_sFq;
<a name="line-646"></a>                  0 -&gt;
<a name="line-647"></a>                    case w_sFq of wild_Xy [Just L] { T.T n_ad5 [Just U(L)] -&gt;
<a name="line-648"></a>                    case n_ad5 of wild1_aET [Just A] { GHC.Base.I# y_aES [Just L] -&gt;
<a name="line-649"></a>                    $wfoo_sFw (GHC.Prim.-# ds_Xw6 y_aES) wild_Xy
<a name="line-650"></a>                    } } };
<a name="line-651"></a>           0 -&gt; 0
<a name="line-652"></a>
<a name="line-653"></a>Example 2
<a name="line-654"></a>~~~~~~~~~
<a name="line-655"></a>    data a :*: b = !a :*: !b
<a name="line-656"></a>    data T a = T !a
<a name="line-657"></a>
<a name="line-658"></a>    foo :: (Int :*: T Int) -&gt; Int
<a name="line-659"></a>    foo (0 :*: t) = 0
<a name="line-660"></a>    foo (x :*: t) | even x    = case t of { T n -&gt; foo ((x-n) :*: t) }
<a name="line-661"></a>                  | otherwise = foo ((x-1) :*: t)
<a name="line-662"></a>
<a name="line-663"></a>Very similar to the previous one, except that the parameters are now in
<a name="line-664"></a>a strict tuple. Before SpecConstr, we have
<a name="line-665"></a>
<a name="line-666"></a>    $wfoo_sG3 :: GHC.Prim.Int# -&gt; T.T GHC.Base.Int -&gt; GHC.Prim.Int#
<a name="line-667"></a>    $wfoo_sG3 =
<a name="line-668"></a>      \ (ww_sFU [Just L] :: GHC.Prim.Int#) (ww_sFW [Just L] :: T.T
<a name="line-669"></a>    GHC.Base.Int) -&gt;
<a name="line-670"></a>        case ww_sFU of ds_Xws [Just L] {
<a name="line-671"></a>          __DEFAULT -&gt;
<a name="line-672"></a>        case GHC.Prim.remInt# ds_Xws 2 of wild1_aEZ [Dead Just A] {
<a name="line-673"></a>          __DEFAULT -&gt;
<a name="line-674"></a>            case ww_sFW of tpl_B2 [Just L] { T.T a_sFo [Just A] -&gt;
<a name="line-675"></a>            $wfoo_sG3 (GHC.Prim.-# ds_Xws 1) tpl_B2             -- $wfoo1
<a name="line-676"></a>            };
<a name="line-677"></a>          0 -&gt;
<a name="line-678"></a>            case ww_sFW of wild_XB [Just A] { T.T n_ad7 [Just S(L)] -&gt;
<a name="line-679"></a>            case n_ad7 of wild1_aFd [Just L] { GHC.Base.I# y_aFc [Just L] -&gt;
<a name="line-680"></a>            $wfoo_sG3 (GHC.Prim.-# ds_Xws y_aFc) wild_XB        -- $wfoo2
<a name="line-681"></a>            } } };
<a name="line-682"></a>          0 -&gt; 0 }
<a name="line-683"></a>
<a name="line-684"></a>We get two specialisations:
<a name="line-685"></a>"SC:$wfoo1" [0] __forall {a_sFB :: GHC.Base.Int sc_sGC :: GHC.Prim.Int#}
<a name="line-686"></a>                  Foo.$wfoo sc_sGC (Foo.T @ GHC.Base.Int a_sFB)
<a name="line-687"></a>                  = Foo.$s$wfoo1 a_sFB sc_sGC ;
<a name="line-688"></a>"SC:$wfoo2" [0] __forall {y_aFp :: GHC.Prim.Int# sc_sGC :: GHC.Prim.Int#}
<a name="line-689"></a>                  Foo.$wfoo sc_sGC (Foo.T @ GHC.Base.Int (GHC.Base.I# y_aFp))
<a name="line-690"></a>                  = Foo.$s$wfoo y_aFp sc_sGC ;
<a name="line-691"></a>
<a name="line-692"></a>But perhaps the first one isn't good.  After all, we know that tpl_B2 is
<a name="line-693"></a>a T (I# x) really, because T is strict and Int has one constructor.  (We can't
<a name="line-694"></a>unbox the strict fields, because T is polymorphic!)
<a name="line-695"></a>
<a name="line-696"></a>************************************************************************
<a name="line-697"></a>*                                                                      *
<a name="line-698"></a>\subsection{Top level wrapper stuff}
<a name="line-699"></a>*                                                                      *
<a name="line-700"></a>************************************************************************
<a name="line-701"></a>-}</span>
<a name="line-702"></a>
<a name="line-703"></a><a name="specConstrProgram"></a><span class='hs-definition'>specConstrProgram</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ModGuts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreM</span> <span class='hs-conid'>ModGuts</span>
<a name="line-704"></a><span class='hs-definition'>specConstrProgram</span> <span class='hs-varid'>guts</span>
<a name="line-705"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-706"></a>      <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-707"></a>      <span class='hs-varid'>us</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueSupplyM</span>
<a name="line-708"></a>      <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>annos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFirstAnnotations</span> <span class='hs-varid'>deserializeWithData</span> <span class='hs-varid'>guts</span>
<a name="line-709"></a>      <span class='hs-varid'>this_mod</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getModule</span>
<a name="line-710"></a>      <span class='hs-keyword'>let</span> <span class='hs-varid'>binds'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reverse</span> <span class='hs-varop'>$</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>initUs</span> <span class='hs-varid'>us</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-711"></a>                    <span class='hs-comment'>-- Note [Top-level recursive groups]</span>
<a name="line-712"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>goEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>initScEnv</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>this_mod</span> <span class='hs-varid'>annos</span><span class='hs-layout'>)</span>
<a name="line-713"></a>                                          <span class='hs-layout'>(</span><span class='hs-varid'>mg_binds</span> <span class='hs-varid'>guts</span><span class='hs-layout'>)</span>
<a name="line-714"></a>                        <span class='hs-comment'>-- binds is identical to (mg_binds guts), except that the</span>
<a name="line-715"></a>                        <span class='hs-comment'>-- binders on the LHS have been replaced by extendBndr</span>
<a name="line-716"></a>                        <span class='hs-comment'>--   (SPJ this seems like overkill; I don't think the binders</span>
<a name="line-717"></a>                        <span class='hs-comment'>--    will change at all; and we don't substitute in the RHSs anyway!!)</span>
<a name="line-718"></a>                    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>nullUsage</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span>
<a name="line-719"></a>
<a name="line-720"></a>      <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>guts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mg_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binds'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-721"></a>  <span class='hs-keyword'>where</span>
<a name="line-722"></a>    <span class='hs-comment'>-- See Note [Top-level recursive groups]</span>
<a name="line-723"></a>    <span class='hs-varid'>goEnv</span> <span class='hs-varid'>env</span> <span class='hs-conid'>[]</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-724"></a>    <span class='hs-varid'>goEnv</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind</span><span class='hs-conop'>:</span><span class='hs-varid'>binds</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bind'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scTopBindEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bind</span>
<a name="line-725"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>env''</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>goEnv</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>binds</span>
<a name="line-726"></a>                                 <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env''</span><span class='hs-layout'>,</span> <span class='hs-varid'>bind'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds'</span><span class='hs-layout'>)</span>
<a name="line-727"></a>
<a name="line-728"></a>    <span class='hs-comment'>-- Arg list of bindings is in reverse order</span>
<a name="line-729"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>   <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
<a name="line-730"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind</span><span class='hs-conop'>:</span><span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bind'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scTopBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-varid'>bind</span>
<a name="line-731"></a>                                 <span class='hs-varid'>binds'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg'</span> <span class='hs-varid'>binds</span>
<a name="line-732"></a>                                 <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>bind'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>binds'</span><span class='hs-layout'>)</span>
<a name="line-733"></a>
<a name="line-734"></a><span class='hs-comment'>{-
<a name="line-735"></a>************************************************************************
<a name="line-736"></a>*                                                                      *
<a name="line-737"></a>\subsection{Environment: goes downwards}
<a name="line-738"></a>*                                                                      *
<a name="line-739"></a>************************************************************************
<a name="line-740"></a>
<a name="line-741"></a>Note [Work-free values only in environment]
<a name="line-742"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-743"></a>The sc_vals field keeps track of in-scope value bindings, so
<a name="line-744"></a>that if we come across (case x of Just y -&gt;...) we can reduce the
<a name="line-745"></a>case from knowing that x is bound to a pair.
<a name="line-746"></a>
<a name="line-747"></a>But only *work-free* values are ok here. For example if the envt had
<a name="line-748"></a>    x -&gt; Just (expensive v)
<a name="line-749"></a>then we do NOT want to expand to
<a name="line-750"></a>     let y = expensive v in ...
<a name="line-751"></a>because the x-binding still exists and we've now duplicated (expensive v).
<a name="line-752"></a>
<a name="line-753"></a>This seldom happens because let-bound constructor applications are
<a name="line-754"></a>ANF-ised, but it can happen as a result of on-the-fly transformations in
<a name="line-755"></a>SpecConstr itself.  Here is #7865:
<a name="line-756"></a>
<a name="line-757"></a>        let {
<a name="line-758"></a>          a'_shr =
<a name="line-759"></a>            case xs_af8 of _ {
<a name="line-760"></a>              [] -&gt; acc_af6;
<a name="line-761"></a>              : ds_dgt [Dmd=&lt;L,A&gt;] ds_dgu [Dmd=&lt;L,A&gt;] -&gt;
<a name="line-762"></a>                (expensive x_af7, x_af7
<a name="line-763"></a>            } } in
<a name="line-764"></a>        let {
<a name="line-765"></a>          ds_sht =
<a name="line-766"></a>            case a'_shr of _ { (p'_afd, q'_afe) -&gt;
<a name="line-767"></a>            TSpecConstr_DoubleInline.recursive
<a name="line-768"></a>              (GHC.Types.: @ GHC.Types.Int x_af7 wild_X6) (q'_afe, p'_afd)
<a name="line-769"></a>            } } in
<a name="line-770"></a>
<a name="line-771"></a>When processed knowing that xs_af8 was bound to a cons, we simplify to
<a name="line-772"></a>   a'_shr = (expensive x_af7, x_af7)
<a name="line-773"></a>and we do NOT want to inline that at the occurrence of a'_shr in ds_sht.
<a name="line-774"></a>(There are other occurrences of a'_shr.)  No no no.
<a name="line-775"></a>
<a name="line-776"></a>It would be possible to do some on-the-fly ANF-ising, so that a'_shr turned
<a name="line-777"></a>into a work-free value again, thus
<a name="line-778"></a>   a1 = expensive x_af7
<a name="line-779"></a>   a'_shr = (a1, x_af7)
<a name="line-780"></a>but that's more work, so until its shown to be important I'm going to
<a name="line-781"></a>leave it for now.
<a name="line-782"></a>
<a name="line-783"></a>Note [Making SpecConstr keener]
<a name="line-784"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-785"></a>Consider this, in (perf/should_run/T9339)
<a name="line-786"></a>   last (filter odd [1..1000])
<a name="line-787"></a>
<a name="line-788"></a>After optimisation, including SpecConstr, we get:
<a name="line-789"></a>   f :: Int# -&gt; Int -&gt; Int
<a name="line-790"></a>   f x y = case remInt# x 2# of
<a name="line-791"></a>             __DEFAULT -&gt; case x of
<a name="line-792"></a>                            __DEFAULT -&gt; f (+# wild_Xp 1#) (I# x)
<a name="line-793"></a>                            1000000# -&gt; ...
<a name="line-794"></a>             0# -&gt; case x of
<a name="line-795"></a>                     __DEFAULT -&gt; f (+# wild_Xp 1#) y
<a name="line-796"></a>                    1000000#   -&gt; y
<a name="line-797"></a>
<a name="line-798"></a>Not good!  We build an (I# x) box every time around the loop.
<a name="line-799"></a>SpecConstr (as described in the paper) does not specialise f, despite
<a name="line-800"></a>the call (f ... (I# x)) because 'y' is not scrutinised in the body.
<a name="line-801"></a>But it is much better to specialise f for the case where the argument
<a name="line-802"></a>is of form (I# x); then we build the box only when returning y, which
<a name="line-803"></a>is on the cold path.
<a name="line-804"></a>
<a name="line-805"></a>Another example:
<a name="line-806"></a>
<a name="line-807"></a>   f x = ...(g x)....
<a name="line-808"></a>
<a name="line-809"></a>Here 'x' is not scrutinised in f's body; but if we did specialise 'f'
<a name="line-810"></a>then the call (g x) might allow 'g' to be specialised in turn.
<a name="line-811"></a>
<a name="line-812"></a>So sc_keen controls whether or not we take account of whether argument is
<a name="line-813"></a>scrutinised in the body.  True &lt;=&gt; ignore that, and specialise whenever
<a name="line-814"></a>the function is applied to a data constructor.
<a name="line-815"></a>-}</span>
<a name="line-816"></a>
<a name="line-817"></a><a name="ScEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SCE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dflags</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span><span class='hs-layout'>,</span>
<a name="line-818"></a>                   <span class='hs-varid'>sc_uf_opts</span>   <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>UnfoldingOpts</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- ^ Unfolding options</span>
<a name="line-819"></a>                   <span class='hs-varid'>sc_module</span>    <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Module</span><span class='hs-layout'>,</span>
<a name="line-820"></a>                   <span class='hs-varid'>sc_size</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- Size threshold</span>
<a name="line-821"></a>                                                <span class='hs-comment'>-- Nothing =&gt; no limit</span>
<a name="line-822"></a>
<a name="line-823"></a>                   <span class='hs-varid'>sc_count</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- Max # of specialisations for any one fn</span>
<a name="line-824"></a>                                                <span class='hs-comment'>-- Nothing =&gt; no limit</span>
<a name="line-825"></a>                                                <span class='hs-comment'>-- See Note [Avoiding exponential blowup]</span>
<a name="line-826"></a>
<a name="line-827"></a>                   <span class='hs-varid'>sc_recursive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- Max # of specialisations over recursive type.</span>
<a name="line-828"></a>                                                <span class='hs-comment'>-- Stops ForceSpecConstr from diverging.</span>
<a name="line-829"></a>
<a name="line-830"></a>                   <span class='hs-varid'>sc_keen</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- Specialise on arguments that are known</span>
<a name="line-831"></a>                                                <span class='hs-comment'>-- constructors, even if they are not</span>
<a name="line-832"></a>                                                <span class='hs-comment'>-- scrutinised in the body.  See</span>
<a name="line-833"></a>                                                <span class='hs-comment'>-- Note [Making SpecConstr keener]</span>
<a name="line-834"></a>
<a name="line-835"></a>                   <span class='hs-varid'>sc_force</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>        <span class='hs-comment'>-- Force specialisation?</span>
<a name="line-836"></a>                                                <span class='hs-comment'>-- See Note [Forcing specialisation]</span>
<a name="line-837"></a>
<a name="line-838"></a>                   <span class='hs-varid'>sc_subst</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Subst</span><span class='hs-layout'>,</span>       <span class='hs-comment'>-- Current substitution</span>
<a name="line-839"></a>                                                <span class='hs-comment'>-- Maps InIds to OutExprs</span>
<a name="line-840"></a>
<a name="line-841"></a>                   <span class='hs-varid'>sc_how_bound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HowBoundEnv</span><span class='hs-layout'>,</span>
<a name="line-842"></a>                        <span class='hs-comment'>-- Binds interesting non-top-level variables</span>
<a name="line-843"></a>                        <span class='hs-comment'>-- Domain is OutVars (*after* applying the substitution)</span>
<a name="line-844"></a>
<a name="line-845"></a>                   <span class='hs-varid'>sc_vals</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValueEnv</span><span class='hs-layout'>,</span>
<a name="line-846"></a>                        <span class='hs-comment'>-- Domain is OutIds (*after* applying the substitution)</span>
<a name="line-847"></a>                        <span class='hs-comment'>-- Used even for top-level bindings (but not imported ones)</span>
<a name="line-848"></a>                        <span class='hs-comment'>-- The range of the ValueEnv is *work-free* values</span>
<a name="line-849"></a>                        <span class='hs-comment'>-- such as (\x. blah), or (Just v)</span>
<a name="line-850"></a>                        <span class='hs-comment'>-- but NOT (Just (expensive v))</span>
<a name="line-851"></a>                        <span class='hs-comment'>-- See Note [Work-free values only in environment]</span>
<a name="line-852"></a>
<a name="line-853"></a>                   <span class='hs-varid'>sc_annotations</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UniqFM</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>SpecConstrAnnotation</span>
<a name="line-854"></a>             <span class='hs-layout'>}</span>
<a name="line-855"></a>
<a name="line-856"></a><a name="HowBoundEnv"></a><span class='hs-comment'>---------------------</span>
<a name="line-857"></a><a name="HowBoundEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HowBoundEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>VarEnv</span> <span class='hs-conid'>HowBound</span>      <span class='hs-comment'>-- Domain is OutVars</span>
<a name="line-858"></a>
<a name="line-859"></a><a name="ValueEnv"></a><span class='hs-comment'>---------------------</span>
<a name="line-860"></a><a name="ValueEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ValueEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IdEnv</span> <span class='hs-conid'>Value</span>             <span class='hs-comment'>-- Domain is OutIds</span>
<a name="line-861"></a><a name="Value"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Value</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ConVal</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- _Saturated_ constructors</span>
<a name="line-862"></a>                                        <span class='hs-comment'>--   The AltCon is never DEFAULT</span>
<a name="line-863"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LambdaVal</span>               <span class='hs-comment'>-- Inlinable lambdas or PAPs</span>
<a name="line-864"></a>
<a name="line-865"></a><a name="instance%20Outputable%20Value"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Value</span> <span class='hs-keyword'>where</span>
<a name="line-866"></a>   <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>con</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>interpp'SP</span> <span class='hs-varid'>args</span>
<a name="line-867"></a>   <span class='hs-varid'>ppr</span> <span class='hs-conid'>LambdaVal</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"&lt;Lambda&gt;"</span>
<a name="line-868"></a>
<a name="line-869"></a><a name="initScEnv"></a><span class='hs-comment'>---------------------</span>
<a name="line-870"></a><span class='hs-definition'>initScEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Module</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqFM</span> <span class='hs-conid'>Name</span> <span class='hs-conid'>SpecConstrAnnotation</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-871"></a><span class='hs-definition'>initScEnv</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>this_mod</span> <span class='hs-varid'>anns</span>
<a name="line-872"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SCE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_dflags</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>,</span>
<a name="line-873"></a>          <span class='hs-varid'>sc_uf_opts</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingOpts</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>,</span>
<a name="line-874"></a>          <span class='hs-varid'>sc_module</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>this_mod</span><span class='hs-layout'>,</span>
<a name="line-875"></a>          <span class='hs-varid'>sc_size</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>specConstrThreshold</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>,</span>
<a name="line-876"></a>          <span class='hs-varid'>sc_count</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>specConstrCount</span>     <span class='hs-varid'>dflags</span><span class='hs-layout'>,</span>
<a name="line-877"></a>          <span class='hs-varid'>sc_recursive</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>specConstrRecursive</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>,</span>
<a name="line-878"></a>          <span class='hs-varid'>sc_keen</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_SpecConstrKeen</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>,</span>
<a name="line-879"></a>          <span class='hs-varid'>sc_force</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span>
<a name="line-880"></a>          <span class='hs-varid'>sc_subst</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptySubst</span><span class='hs-layout'>,</span>
<a name="line-881"></a>          <span class='hs-varid'>sc_how_bound</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>,</span>
<a name="line-882"></a>          <span class='hs-varid'>sc_vals</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>,</span>
<a name="line-883"></a>          <span class='hs-varid'>sc_annotations</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anns</span> <span class='hs-layout'>}</span>
<a name="line-884"></a>
<a name="line-885"></a><a name="HowBound"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HowBound</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecFun</span>  <span class='hs-comment'>-- These are the recursive functions for which</span>
<a name="line-886"></a>                        <span class='hs-comment'>-- we seek interesting call patterns</span>
<a name="line-887"></a>
<a name="line-888"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecArg</span>  <span class='hs-comment'>-- These are those functions' arguments, or their sub-components;</span>
<a name="line-889"></a>                        <span class='hs-comment'>-- we gather occurrence information for these</span>
<a name="line-890"></a>
<a name="line-891"></a><a name="instance%20Outputable%20HowBound"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>HowBound</span> <span class='hs-keyword'>where</span>
<a name="line-892"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>RecFun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"RecFun"</span>
<a name="line-893"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>RecArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"RecArg"</span>
<a name="line-894"></a>
<a name="line-895"></a><a name="scForce"></a><span class='hs-definition'>scForce</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-896"></a><span class='hs-definition'>scForce</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_force</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-layout'>}</span>
<a name="line-897"></a>
<a name="line-898"></a><a name="lookupHowBound"></a><span class='hs-definition'>lookupHowBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>HowBound</span>
<a name="line-899"></a><span class='hs-definition'>lookupHowBound</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_how_bound</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span>
<a name="line-900"></a>
<a name="line-901"></a><a name="scSubstId"></a><span class='hs-definition'>scSubstId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-902"></a><span class='hs-definition'>scSubstId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupIdSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span>
<a name="line-903"></a>
<a name="line-904"></a><a name="scSubstTy"></a><span class='hs-definition'>scSubstTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-905"></a><span class='hs-definition'>scSubstTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-906"></a>
<a name="line-907"></a><a name="scSubstCo"></a><span class='hs-definition'>scSubstCo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span>
<a name="line-908"></a><span class='hs-definition'>scSubstCo</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-909"></a>
<a name="line-910"></a><a name="zapScSubst"></a><span class='hs-definition'>zapScSubst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-911"></a><span class='hs-definition'>zapScSubst</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapSubstEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-912"></a>
<a name="line-913"></a><a name="extendScInScope"></a><span class='hs-definition'>extendScInScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-914"></a>        <span class='hs-comment'>-- Bring the quantified variables into scope</span>
<a name="line-915"></a><span class='hs-definition'>extendScInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>qvars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendInScopeList</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>qvars</span> <span class='hs-layout'>}</span>
<a name="line-916"></a>
<a name="line-917"></a>        <span class='hs-comment'>-- Extend the substitution</span>
<a name="line-918"></a><a name="extendScSubst"></a><span class='hs-definition'>extendScSubst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-919"></a><span class='hs-definition'>extendScSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-varid'>expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>var</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>}</span>
<a name="line-920"></a>
<a name="line-921"></a><a name="extendScSubstList"></a><span class='hs-definition'>extendScSubstList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>,</span><span class='hs-conid'>OutExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-922"></a><span class='hs-definition'>extendScSubstList</span> <span class='hs-varid'>env</span> <span class='hs-varid'>prs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSubstList</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>prs</span> <span class='hs-layout'>}</span>
<a name="line-923"></a>
<a name="line-924"></a><a name="extendHowBound"></a><span class='hs-definition'>extendHowBound</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>HowBound</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-925"></a><span class='hs-definition'>extendHowBound</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>how_bound</span>
<a name="line-926"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_how_bound</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnvList</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_how_bound</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-927"></a>                            <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span><span class='hs-varid'>how_bound</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>
<a name="line-928"></a>
<a name="line-929"></a><a name="extendBndrsWith"></a><span class='hs-definition'>extendBndrsWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HowBound</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-930"></a><span class='hs-definition'>extendBndrsWith</span> <span class='hs-varid'>how_bound</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-931"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_how_bound</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hb_env'</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-932"></a>  <span class='hs-keyword'>where</span>
<a name="line-933"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substBndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-934"></a>    <span class='hs-varid'>hb_env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_how_bound</span> <span class='hs-varid'>env</span> <span class='hs-varop'>`extendVarEnvList`</span>
<a name="line-935"></a>                    <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span><span class='hs-varid'>how_bound</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs'</span><span class='hs-keyglyph'>]</span>
<a name="line-936"></a>
<a name="line-937"></a><a name="extendBndrWith"></a><span class='hs-definition'>extendBndrWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HowBound</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span>
<a name="line-938"></a><span class='hs-definition'>extendBndrWith</span> <span class='hs-varid'>how_bound</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-939"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_how_bound</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hb_env'</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span>
<a name="line-940"></a>  <span class='hs-keyword'>where</span>
<a name="line-941"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substBndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span>
<a name="line-942"></a>    <span class='hs-varid'>hb_env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_how_bound</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>how_bound</span>
<a name="line-943"></a>
<a name="line-944"></a><a name="extendRecBndrs"></a><span class='hs-definition'>extendRecBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-945"></a><span class='hs-definition'>extendRecBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>subst'</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span>
<a name="line-946"></a>                      <span class='hs-keyword'>where</span>
<a name="line-947"></a>                        <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substRecBndrs</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-948"></a>
<a name="line-949"></a><a name="extendBndr"></a><span class='hs-definition'>extendBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span>
<a name="line-950"></a><span class='hs-definition'>extendBndr</span>  <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>subst'</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span>
<a name="line-951"></a>                      <span class='hs-keyword'>where</span>
<a name="line-952"></a>                        <span class='hs-layout'>(</span><span class='hs-varid'>subst'</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substBndr</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr</span>
<a name="line-953"></a>
<a name="line-954"></a><a name="extendValEnv"></a><span class='hs-definition'>extendValEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Value</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-955"></a><span class='hs-definition'>extendValEnv</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>  <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-956"></a><span class='hs-definition'>extendValEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>cv</span><span class='hs-layout'>)</span>
<a name="line-957"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>valueIsWorkFree</span> <span class='hs-varid'>cv</span>      <span class='hs-comment'>-- Don't duplicate work!!  #7865</span>
<a name="line-958"></a> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_vals</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_vals</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>}</span>
<a name="line-959"></a><span class='hs-definition'>extendValEnv</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-960"></a>
<a name="line-961"></a><a name="extendCaseBndrs"></a><span class='hs-definition'>extendCaseBndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AltCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-962"></a><span class='hs-comment'>-- When we encounter</span>
<a name="line-963"></a><span class='hs-comment'>--      case scrut of b</span>
<a name="line-964"></a><span class='hs-comment'>--          C x y -&gt; ...</span>
<a name="line-965"></a><span class='hs-comment'>-- we want to bind b, to (C x y)</span>
<a name="line-966"></a><span class='hs-comment'>-- NB1: Extends only the sc_vals part of the envt</span>
<a name="line-967"></a><span class='hs-comment'>-- NB2: Kill the dead-ness info on the pattern binders x,y, since</span>
<a name="line-968"></a><span class='hs-comment'>--      they are potentially made alive by the [b -&gt; C x y] binding</span>
<a name="line-969"></a><span class='hs-definition'>extendCaseBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>con</span> <span class='hs-varid'>alt_bndrs</span>
<a name="line-970"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env2</span><span class='hs-layout'>,</span> <span class='hs-varid'>alt_bndrs'</span><span class='hs-layout'>)</span>
<a name="line-971"></a> <span class='hs-keyword'>where</span>
<a name="line-972"></a>   <span class='hs-varid'>live_case_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadBinder</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span>
<a name="line-973"></a>   <span class='hs-varid'>env1</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>stripTicksTopE</span> <span class='hs-layout'>(</span><span class='hs-varid'>const</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut</span>
<a name="line-974"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendValEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-varid'>cval</span>
<a name="line-975"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>  <span class='hs-comment'>-- See Note [Add scrutinee to ValueEnv too]</span>
<a name="line-976"></a>   <span class='hs-varid'>env2</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>live_case_bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendValEnv</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>cval</span>
<a name="line-977"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env1</span>
<a name="line-978"></a>
<a name="line-979"></a>   <span class='hs-varid'>alt_bndrs'</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>Var</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span><span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>live_case_bndr</span> <span class='hs-layout'>}</span>
<a name="line-980"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>zap</span> <span class='hs-varid'>alt_bndrs</span>
<a name="line-981"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-982"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>alt_bndrs</span>
<a name="line-983"></a>
<a name="line-984"></a>   <span class='hs-varid'>cval</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>con</span> <span class='hs-keyword'>of</span>
<a name="line-985"></a>                <span class='hs-conid'>DEFAULT</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-986"></a>                <span class='hs-conid'>LitAlt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-varid'>con</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-987"></a>                <span class='hs-conid'>DataAlt</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-varid'>con</span> <span class='hs-varid'>vanilla_args</span><span class='hs-layout'>)</span>
<a name="line-988"></a>                      <span class='hs-keyword'>where</span>
<a name="line-989"></a>                        <span class='hs-varid'>vanilla_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConAppArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>case_bndr</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span>
<a name="line-990"></a>                                       <span class='hs-varid'>varsToCoreExprs</span> <span class='hs-varid'>alt_bndrs</span>
<a name="line-991"></a>
<a name="line-992"></a>   <span class='hs-varid'>zap</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span>                <span class='hs-comment'>-- See NB2 above</span>
<a name="line-993"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zapIdOccInfo</span> <span class='hs-varid'>v</span>
<a name="line-994"></a>
<a name="line-995"></a>
<a name="line-996"></a><a name="decreaseSpecCount"></a><span class='hs-definition'>decreaseSpecCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-997"></a><span class='hs-comment'>-- See Note [Avoiding exponential blowup]</span>
<a name="line-998"></a><span class='hs-definition'>decreaseSpecCount</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n_specs</span>
<a name="line-999"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_force</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>   <span class='hs-comment'>-- See Note [Forcing specialisation]</span>
<a name="line-1000"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>sc_count</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sc_count</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>of</span>
<a name="line-1001"></a>                       <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-1002"></a>                       <span class='hs-conid'>Just</span> <span class='hs-varid'>n</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-varop'>`div`</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_specs</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1003"></a>        <span class='hs-comment'>-- The "+1" takes account of the original function;</span>
<a name="line-1004"></a>        <span class='hs-comment'>-- See Note [Avoiding exponential blowup]</span>
<a name="line-1005"></a>
<a name="line-1006"></a><a name="ignoreType"></a><span class='hs-comment'>---------------------------------------------------</span>
<a name="line-1007"></a><span class='hs-comment'>-- See Note [Forcing specialisation]</span>
<a name="line-1008"></a><span class='hs-definition'>ignoreType</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1009"></a><a name="ignoreDataCon"></a><span class='hs-definition'>ignoreDataCon</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1010"></a><a name="forceSpecBndr"></a><span class='hs-definition'>forceSpecBndr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Var</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1011"></a>
<a name="line-1012"></a><span class='hs-definition'>ignoreDataCon</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ignoreTyCon</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTyCon</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-1013"></a>
<a name="line-1014"></a><span class='hs-definition'>ignoreType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1015"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-1016"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>tycon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>ignoreTyCon</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tycon</span>
<a name="line-1017"></a>      <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1018"></a>
<a name="line-1019"></a><a name="ignoreTyCon"></a><span class='hs-definition'>ignoreTyCon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1020"></a><span class='hs-definition'>ignoreTyCon</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tycon</span>
<a name="line-1021"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupUFM</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_annotations</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>NoSpecConstr</span>
<a name="line-1022"></a>
<a name="line-1023"></a><span class='hs-definition'>forceSpecBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forceSpecFunTy</span> <span class='hs-varid'>env</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>splitForAllTyCoVars</span> <span class='hs-varop'>.</span> <span class='hs-varid'>varType</span> <span class='hs-varop'>$</span> <span class='hs-varid'>var</span>
<a name="line-1024"></a>
<a name="line-1025"></a><a name="forceSpecFunTy"></a><span class='hs-definition'>forceSpecFunTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1026"></a><span class='hs-definition'>forceSpecFunTy</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>forceSpecArgTy</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>.</span> <span class='hs-varid'>splitFunTys</span>
<a name="line-1027"></a>
<a name="line-1028"></a><a name="forceSpecArgTy"></a><span class='hs-definition'>forceSpecArgTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1029"></a><span class='hs-definition'>forceSpecArgTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1030"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>coreView</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>forceSpecArgTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty'</span>
<a name="line-1031"></a>
<a name="line-1032"></a><span class='hs-definition'>forceSpecArgTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1033"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tycon</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1034"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>tycon</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>funTyCon</span>
<a name="line-1035"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConUnique</span> <span class='hs-varid'>tycon</span> <span class='hs-varop'>==</span> <span class='hs-varid'>specTyConKey</span>
<a name="line-1036"></a>        <span class='hs-varop'>||</span> <span class='hs-varid'>lookupUFM</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_annotations</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConName</span> <span class='hs-varid'>tycon</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>ForceSpecConstr</span>
<a name="line-1037"></a>        <span class='hs-varop'>||</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>forceSpecArgTy</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-1038"></a>
<a name="line-1039"></a><span class='hs-definition'>forceSpecArgTy</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1040"></a>
<a name="line-1041"></a><span class='hs-comment'>{-
<a name="line-1042"></a>Note [Add scrutinee to ValueEnv too]
<a name="line-1043"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1044"></a>Consider this:
<a name="line-1045"></a>   case x of y
<a name="line-1046"></a>     (a,b) -&gt; case b of c
<a name="line-1047"></a>                I# v -&gt; ...(f y)...
<a name="line-1048"></a>By the time we get to the call (f y), the ValueEnv
<a name="line-1049"></a>will have a binding for y, and for c
<a name="line-1050"></a>    y -&gt; (a,b)
<a name="line-1051"></a>    c -&gt; I# v
<a name="line-1052"></a>BUT that's not enough!  Looking at the call (f y) we
<a name="line-1053"></a>see that y is pair (a,b), but we also need to know what 'b' is.
<a name="line-1054"></a>So in extendCaseBndrs we must *also* add the binding
<a name="line-1055"></a>   b -&gt; I# v
<a name="line-1056"></a>else we lose a useful specialisation for f.  This is necessary even
<a name="line-1057"></a>though the simplifier has systematically replaced uses of 'x' with 'y'
<a name="line-1058"></a>and 'b' with 'c' in the code.  The use of 'b' in the ValueEnv came
<a name="line-1059"></a>from outside the case.  See #4908 for the live example.
<a name="line-1060"></a>
<a name="line-1061"></a>Note [Avoiding exponential blowup]
<a name="line-1062"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1063"></a>The sc_count field of the ScEnv says how many times we are prepared to
<a name="line-1064"></a>duplicate a single function.  But we must take care with recursive
<a name="line-1065"></a>specialisations.  Consider
<a name="line-1066"></a>
<a name="line-1067"></a>        let $j1 = let $j2 = let $j3 = ...
<a name="line-1068"></a>                            in
<a name="line-1069"></a>                            ...$j3...
<a name="line-1070"></a>                  in
<a name="line-1071"></a>                  ...$j2...
<a name="line-1072"></a>        in
<a name="line-1073"></a>        ...$j1...
<a name="line-1074"></a>
<a name="line-1075"></a>If we specialise $j1 then in each specialisation (as well as the original)
<a name="line-1076"></a>we can specialise $j2, and similarly $j3.  Even if we make just *one*
<a name="line-1077"></a>specialisation of each, because we also have the original we'll get 2^n
<a name="line-1078"></a>copies of $j3, which is not good.
<a name="line-1079"></a>
<a name="line-1080"></a>So when recursively specialising we divide the sc_count by the number of
<a name="line-1081"></a>copies we are making at this level, including the original.
<a name="line-1082"></a>
<a name="line-1083"></a>
<a name="line-1084"></a>************************************************************************
<a name="line-1085"></a>*                                                                      *
<a name="line-1086"></a>\subsection{Usage information: flows upwards}
<a name="line-1087"></a>*                                                                      *
<a name="line-1088"></a>************************************************************************
<a name="line-1089"></a>-}</span>
<a name="line-1090"></a>
<a name="line-1091"></a><a name="ScUsage"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ScUsage</span>
<a name="line-1092"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span>
<a name="line-1093"></a>        <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CallEnv</span><span class='hs-layout'>,</span>           <span class='hs-comment'>-- Calls</span>
<a name="line-1094"></a>                                        <span class='hs-comment'>-- The functions are a subset of the</span>
<a name="line-1095"></a>                                        <span class='hs-comment'>--      RecFuns in the ScEnv</span>
<a name="line-1096"></a>
<a name="line-1097"></a>        <span class='hs-varid'>scu_occs</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>IdEnv</span> <span class='hs-conid'>ArgOcc</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- Information on argument occurrences</span>
<a name="line-1098"></a>     <span class='hs-layout'>}</span>                                  <span class='hs-comment'>-- The domain is OutIds</span>
<a name="line-1099"></a>
<a name="line-1100"></a><a name="CallEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CallEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IdEnv</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Call</span><span class='hs-keyglyph'>]</span>
<a name="line-1101"></a><a name="Call"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Call</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Call</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>ValueEnv</span>
<a name="line-1102"></a>        <span class='hs-comment'>-- The arguments of the call, together with the</span>
<a name="line-1103"></a>        <span class='hs-comment'>-- env giving the constructor bindings at the call site</span>
<a name="line-1104"></a>        <span class='hs-comment'>-- We keep the function mainly for debug output</span>
<a name="line-1105"></a>
<a name="line-1106"></a><a name="instance%20Outputable%20ScUsage"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ScUsage</span> <span class='hs-keyword'>where</span>
<a name="line-1107"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>calls</span><span class='hs-layout'>,</span> <span class='hs-varid'>scu_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1108"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"SCU"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"calls ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>calls</span>
<a name="line-1109"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"occs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>occs</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1110"></a>
<a name="line-1111"></a><a name="instance%20Outputable%20Call"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Call</span> <span class='hs-keyword'>where</span>
<a name="line-1112"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Call</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>args</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fn</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>fsep</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>pprParendExpr</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-1113"></a>
<a name="line-1114"></a><a name="nullUsage"></a><span class='hs-definition'>nullUsage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScUsage</span>
<a name="line-1115"></a><span class='hs-definition'>nullUsage</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>scu_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-layout'>}</span>
<a name="line-1116"></a>
<a name="line-1117"></a><a name="combineCalls"></a><span class='hs-definition'>combineCalls</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CallEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallEnv</span>
<a name="line-1118"></a><span class='hs-definition'>combineCalls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv_C</span> <span class='hs-layout'>(</span><span class='hs-varop'>++</span><span class='hs-layout'>)</span>
<a name="line-1119"></a>
<a name="line-1120"></a><a name="combineUsage"></a><span class='hs-definition'>combineUsage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScUsage</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>
<a name="line-1121"></a><span class='hs-definition'>combineUsage</span> <span class='hs-varid'>u1</span> <span class='hs-varid'>u2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineCalls</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_calls</span> <span class='hs-varid'>u1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_calls</span> <span class='hs-varid'>u2</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-1122"></a>                           <span class='hs-varid'>scu_occs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>plusVarEnv_C</span> <span class='hs-varid'>combineOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_occs</span> <span class='hs-varid'>u1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_occs</span> <span class='hs-varid'>u2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1123"></a>
<a name="line-1124"></a><a name="combineUsages"></a><span class='hs-definition'>combineUsages</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ScUsage</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>
<a name="line-1125"></a><span class='hs-definition'>combineUsages</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nullUsage</span>
<a name="line-1126"></a><span class='hs-definition'>combineUsages</span> <span class='hs-varid'>us</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr1</span> <span class='hs-varid'>combineUsage</span> <span class='hs-varid'>us</span>
<a name="line-1127"></a>
<a name="line-1128"></a><a name="lookupOccs"></a><span class='hs-definition'>lookupOccs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScUsage</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1129"></a><span class='hs-definition'>lookupOccs</span> <span class='hs-layout'>(</span><span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_calls</span><span class='hs-layout'>,</span> <span class='hs-varid'>scu_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_occs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-1130"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span><span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_calls</span><span class='hs-layout'>,</span> <span class='hs-varid'>scu_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>delVarEnvList</span> <span class='hs-varid'>sc_occs</span> <span class='hs-varid'>bndrs</span><span class='hs-layout'>}</span><span class='hs-layout'>,</span>
<a name="line-1131"></a>     <span class='hs-keyglyph'>[</span><span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>sc_occs</span> <span class='hs-varid'>b</span> <span class='hs-varop'>`orElse`</span> <span class='hs-conid'>NoOcc</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bndrs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1132"></a>
<a name="line-1133"></a><a name="ArgOcc"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArgOcc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoOcc</span>     <span class='hs-comment'>-- Doesn't occur at all; or a type argument</span>
<a name="line-1134"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnkOcc</span>    <span class='hs-comment'>-- Used in some unknown way</span>
<a name="line-1135"></a>
<a name="line-1136"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ScrutOcc</span>  <span class='hs-comment'>-- See Note [ScrutOcc]</span>
<a name="line-1137"></a>                 <span class='hs-layout'>(</span><span class='hs-conid'>DataConEnv</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- How the sub-components are used</span>
<a name="line-1138"></a>
<a name="line-1139"></a><a name="DataConEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>DataConEnv</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UniqFM</span> <span class='hs-conid'>DataCon</span> <span class='hs-varid'>a</span>     <span class='hs-comment'>-- Keyed by DataCon</span>
<a name="line-1140"></a>
<a name="line-1141"></a><span class='hs-comment'>{- Note  [ScrutOcc]
<a name="line-1142"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-1143"></a>An occurrence of ScrutOcc indicates that the thing, or a `cast` version of the thing,
<a name="line-1144"></a>is *only* taken apart or applied.
<a name="line-1145"></a>
<a name="line-1146"></a>  Functions, literal: ScrutOcc emptyUFM
<a name="line-1147"></a>  Data constructors:  ScrutOcc subs,
<a name="line-1148"></a>
<a name="line-1149"></a>where (subs :: UniqFM [ArgOcc]) gives usage of the *pattern-bound* components,
<a name="line-1150"></a>The domain of the UniqFM is the Unique of the data constructor
<a name="line-1151"></a>
<a name="line-1152"></a>The [ArgOcc] is the occurrences of the *pattern-bound* components
<a name="line-1153"></a>of the data structure.  E.g.
<a name="line-1154"></a>        data T a = forall b. MkT a b (b-&gt;a)
<a name="line-1155"></a>A pattern binds b, x::a, y::b, z::b-&gt;a, but not 'a'!
<a name="line-1156"></a>
<a name="line-1157"></a>-}</span>
<a name="line-1158"></a>
<a name="line-1159"></a><a name="instance%20Outputable%20ArgOcc"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ArgOcc</span> <span class='hs-keyword'>where</span>
<a name="line-1160"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"scrut-occ"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xs</span>
<a name="line-1161"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>UnkOcc</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unk-occ"</span>
<a name="line-1162"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>NoOcc</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"no-occ"</span>
<a name="line-1163"></a>
<a name="line-1164"></a><a name="evalScrutOcc"></a><span class='hs-definition'>evalScrutOcc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgOcc</span>
<a name="line-1165"></a><span class='hs-definition'>evalScrutOcc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>emptyUFM</span>
<a name="line-1166"></a>
<a name="line-1167"></a><a name="combineOcc"></a><span class='hs-comment'>-- Experimentally, this version of combineOcc makes ScrutOcc "win", so</span>
<a name="line-1168"></a><span class='hs-comment'>-- that if the thing is scrutinised anywhere then we get to see that</span>
<a name="line-1169"></a><span class='hs-comment'>-- in the overall result, even if it's also used in a boxed way</span>
<a name="line-1170"></a><span class='hs-comment'>-- This might be too aggressive; see Note [Reboxing] Alternative 3</span>
<a name="line-1171"></a><span class='hs-definition'>combineOcc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ArgOcc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgOcc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgOcc</span>
<a name="line-1172"></a><span class='hs-definition'>combineOcc</span> <span class='hs-conid'>NoOcc</span>         <span class='hs-varid'>occ</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span>
<a name="line-1173"></a><span class='hs-definition'>combineOcc</span> <span class='hs-varid'>occ</span>           <span class='hs-conid'>NoOcc</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>occ</span>
<a name="line-1174"></a><span class='hs-definition'>combineOcc</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ScrutOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>plusUFM_C</span> <span class='hs-varid'>combineOccs</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<a name="line-1175"></a><span class='hs-definition'>combineOcc</span> <span class='hs-conid'>UnkOcc</span>        <span class='hs-layout'>(</span><span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>ys</span>
<a name="line-1176"></a><span class='hs-definition'>combineOcc</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>xs</span><span class='hs-layout'>)</span> <span class='hs-conid'>UnkOcc</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>xs</span>
<a name="line-1177"></a><span class='hs-definition'>combineOcc</span> <span class='hs-conid'>UnkOcc</span>        <span class='hs-conid'>UnkOcc</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnkOcc</span>
<a name="line-1178"></a>
<a name="line-1179"></a><a name="combineOccs"></a><span class='hs-definition'>combineOccs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span>
<a name="line-1180"></a><span class='hs-definition'>combineOccs</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWithEqual</span> <span class='hs-str'>"combineOccs"</span> <span class='hs-varid'>combineOcc</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>ys</span>
<a name="line-1181"></a>
<a name="line-1182"></a><a name="setScrutOcc"></a><span class='hs-definition'>setScrutOcc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgOcc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>
<a name="line-1183"></a><span class='hs-comment'>-- _Overwrite_ the occurrence info for the scrutinee, if the scrutinee</span>
<a name="line-1184"></a><span class='hs-comment'>-- is a variable, and an interesting variable</span>
<a name="line-1185"></a><span class='hs-definition'>setScrutOcc</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>occ</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setScrutOcc</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-varid'>e</span> <span class='hs-varid'>occ</span>
<a name="line-1186"></a><span class='hs-definition'>setScrutOcc</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-varid'>occ</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setScrutOcc</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-varid'>e</span> <span class='hs-varid'>occ</span>
<a name="line-1187"></a><span class='hs-definition'>setScrutOcc</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>    <span class='hs-varid'>occ</span>
<a name="line-1188"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>RecArg</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupHowBound</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_occs</span> <span class='hs-varid'>usg</span><span class='hs-layout'>)</span> <span class='hs-varid'>v</span> <span class='hs-varid'>occ</span> <span class='hs-layout'>}</span>
<a name="line-1189"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usg</span>
<a name="line-1190"></a><span class='hs-definition'>setScrutOcc</span> <span class='hs-sel'>_env</span> <span class='hs-varid'>usg</span> <span class='hs-sel'>_other</span> <span class='hs-sel'>_occ</span>        <span class='hs-comment'>-- Catch-all</span>
<a name="line-1191"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usg</span>
<a name="line-1192"></a>
<a name="line-1193"></a><span class='hs-comment'>{-
<a name="line-1194"></a>************************************************************************
<a name="line-1195"></a>*                                                                      *
<a name="line-1196"></a>\subsection{The main recursive function}
<a name="line-1197"></a>*                                                                      *
<a name="line-1198"></a>************************************************************************
<a name="line-1199"></a>
<a name="line-1200"></a>The main recursive function gathers up usage information, and
<a name="line-1201"></a>creates specialised versions of functions.
<a name="line-1202"></a>-}</span>
<a name="line-1203"></a>
<a name="line-1204"></a><a name="scExpr"></a><span class='hs-definition'>scExpr</span><span class='hs-layout'>,</span> <span class='hs-varid'>scExpr'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1205"></a>        <span class='hs-comment'>-- The unique supply is needed when we invent</span>
<a name="line-1206"></a>        <span class='hs-comment'>-- a new name for the specialised function and its args</span>
<a name="line-1207"></a>
<a name="line-1208"></a><span class='hs-definition'>scExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-1209"></a>
<a name="line-1210"></a><a name="scExpr'"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scSubstId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-keyword'>of</span>
<a name="line-1211"></a>                            <span class='hs-conid'>Var</span> <span class='hs-varid'>v'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarUsage</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v'</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v'</span><span class='hs-layout'>)</span>
<a name="line-1212"></a>                            <span class='hs-varid'>e'</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>scExpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapScSubst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>e'</span>
<a name="line-1213"></a>
<a name="line-1214"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>nullUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>(</span><span class='hs-varid'>scSubstTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1215"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>nullUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>scSubstCo</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1216"></a><span class='hs-definition'>scExpr'</span> <span class='hs-keyword'>_</span>   <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>nullUsage</span><span class='hs-layout'>,</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1217"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-1218"></a>                              <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-1219"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-1220"></a>                              <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkCast</span> <span class='hs-varid'>e'</span> <span class='hs-layout'>(</span><span class='hs-varid'>scSubstCo</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1221"></a>                              <span class='hs-comment'>-- Important to use mkCast here</span>
<a name="line-1222"></a>                              <span class='hs-comment'>-- See Note [SpecConstr call patterns]</span>
<a name="line-1223"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>collectArgs</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-1224"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span>
<a name="line-1225"></a>                              <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>e</span>
<a name="line-1226"></a>                              <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>b'</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-1227"></a>
<a name="line-1228"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>b</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-1229"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>scrut_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span>
<a name="line-1230"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isValue</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_vals</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>scrut'</span> <span class='hs-keyword'>of</span>
<a name="line-1231"></a>                <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>sc_con_app</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>scrut'</span>
<a name="line-1232"></a>                <span class='hs-sel'>_other</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>sc_vanilla</span> <span class='hs-varid'>scrut_usg</span> <span class='hs-varid'>scrut'</span>
<a name="line-1233"></a>        <span class='hs-layout'>}</span>
<a name="line-1234"></a>  <span class='hs-keyword'>where</span>
<a name="line-1235"></a>    <span class='hs-varid'>sc_con_app</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span> <span class='hs-varid'>scrut'</span>  <span class='hs-comment'>-- Known constructor; simplify</span>
<a name="line-1236"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findAlt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>alts</span>
<a name="line-1237"></a>                                  <span class='hs-varop'>`orElse`</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>DEFAULT</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkImpossibleExpr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1238"></a>                <span class='hs-varid'>alt_env'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendScSubstList</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>bs</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>trimConArgs</span> <span class='hs-varid'>con</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-1239"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>alt_env'</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span>
<a name="line-1240"></a>
<a name="line-1241"></a>    <span class='hs-varid'>sc_vanilla</span> <span class='hs-varid'>scrut_usg</span> <span class='hs-varid'>scrut'</span> <span class='hs-comment'>-- Normal case</span>
<a name="line-1242"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt_env</span><span class='hs-layout'>,</span><span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendBndrWith</span> <span class='hs-conid'>RecArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>b</span>
<a name="line-1243"></a>                        <span class='hs-comment'>-- Record RecArg for the components</span>
<a name="line-1244"></a>
<a name="line-1245"></a>          <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>alt_usgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>alt_occs</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>
<a name="line-1246"></a>                <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzip3M</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_alt</span> <span class='hs-varid'>alt_env</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>b'</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span>
<a name="line-1247"></a>
<a name="line-1248"></a>          <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>scrut_occ</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>combineOcc</span> <span class='hs-conid'>NoOcc</span> <span class='hs-varid'>alt_occs</span>
<a name="line-1249"></a>                <span class='hs-varid'>scrut_usg'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setScrutOcc</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut_usg</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>scrut_occ</span>
<a name="line-1250"></a>                <span class='hs-comment'>-- The combined usage of the scrutinee is given</span>
<a name="line-1251"></a>                <span class='hs-comment'>-- by scrut_occ, which is passed to scScrut, which</span>
<a name="line-1252"></a>                <span class='hs-comment'>-- in turn treats a bare-variable scrutinee specially</span>
<a name="line-1253"></a>
<a name="line-1254"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr</span> <span class='hs-varid'>combineUsage</span> <span class='hs-varid'>scrut_usg'</span> <span class='hs-varid'>alt_usgs</span><span class='hs-layout'>,</span>
<a name="line-1255"></a>                    <span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>b'</span> <span class='hs-layout'>(</span><span class='hs-varid'>scSubstTy</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1256"></a>
<a name="line-1257"></a>    <span class='hs-varid'>sc_alt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>b'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1258"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendBndrsWith</span> <span class='hs-conid'>RecArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bs</span>
<a name="line-1259"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>env2</span><span class='hs-layout'>,</span> <span class='hs-varid'>bs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendCaseBndrs</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>b'</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bs1</span>
<a name="line-1260"></a>          <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env2</span> <span class='hs-varid'>rhs</span>
<a name="line-1261"></a>          <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b_occ</span><span class='hs-conop'>:</span><span class='hs-varid'>arg_occs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupOccs</span> <span class='hs-varid'>usg</span> <span class='hs-layout'>(</span><span class='hs-varid'>b'</span><span class='hs-conop'>:</span><span class='hs-varid'>bs2</span><span class='hs-layout'>)</span>
<a name="line-1262"></a>                <span class='hs-varid'>scrut_occ</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>con</span> <span class='hs-keyword'>of</span>
<a name="line-1263"></a>                               <span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScrutOcc</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitUFM</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>arg_occs</span><span class='hs-layout'>)</span>
<a name="line-1264"></a>                               <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>emptyUFM</span>
<a name="line-1265"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg'</span><span class='hs-layout'>,</span> <span class='hs-varid'>b_occ</span> <span class='hs-varop'>`combineOcc`</span> <span class='hs-varid'>scrut_occ</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bs2</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1266"></a>
<a name="line-1267"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1268"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span>        <span class='hs-comment'>-- Type-lets may be created by doBeta</span>
<a name="line-1269"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scExpr'</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendScSubst</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span>
<a name="line-1270"></a>
<a name="line-1271"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1272"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-1273"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rhs_info</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scRecRhs</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr'</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1274"></a>
<a name="line-1275"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>body_env2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendHowBound</span> <span class='hs-varid'>body_env</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>bndr'</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>RecFun</span>
<a name="line-1276"></a>                           <span class='hs-comment'>-- Note [Local let bindings]</span>
<a name="line-1277"></a>              <span class='hs-varid'>rhs'</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ri_new_rhs</span> <span class='hs-varid'>rhs_info</span>
<a name="line-1278"></a>              <span class='hs-varid'>body_env3</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendValEnv</span> <span class='hs-varid'>body_env2</span> <span class='hs-varid'>bndr'</span> <span class='hs-layout'>(</span><span class='hs-varid'>isValue</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_vals</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-1279"></a>
<a name="line-1280"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>body_env3</span> <span class='hs-varid'>body</span>
<a name="line-1281"></a>
<a name="line-1282"></a>          <span class='hs-comment'>-- NB: For non-recursive bindings we inherit sc_force flag from</span>
<a name="line-1283"></a>          <span class='hs-comment'>-- the parent function (see Note [Forcing specialisation])</span>
<a name="line-1284"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>specs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>specNonRec</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body_usg</span> <span class='hs-varid'>rhs_info</span>
<a name="line-1285"></a>
<a name="line-1286"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scu_calls</span> <span class='hs-varid'>body_usg</span> <span class='hs-varop'>`delVarEnv`</span> <span class='hs-varid'>bndr'</span> <span class='hs-layout'>}</span>
<a name="line-1287"></a>                    <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>spec_usg</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- Note [spec_usg includes rhs_usg]</span>
<a name="line-1288"></a>                  <span class='hs-varid'>mkLets</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>b</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ruleInfoBinds</span> <span class='hs-varid'>rhs_info</span> <span class='hs-varid'>specs</span><span class='hs-keyglyph'>]</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-1289"></a>        <span class='hs-layout'>}</span>
<a name="line-1290"></a>
<a name="line-1291"></a>
<a name="line-1292"></a><span class='hs-comment'>-- A *local* recursive group: see Note [Local recursive groups]</span>
<a name="line-1293"></a><span class='hs-definition'>scExpr'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1294"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span><span class='hs-varid'>rhss</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>prs</span>
<a name="line-1295"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>rhs_env1</span><span class='hs-layout'>,</span><span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendRecBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-1296"></a>              <span class='hs-varid'>rhs_env2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendHowBound</span> <span class='hs-varid'>rhs_env1</span> <span class='hs-varid'>bndrs'</span> <span class='hs-conid'>RecFun</span>
<a name="line-1297"></a>              <span class='hs-varid'>force_spec</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>forceSpecBndr</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs'</span>
<a name="line-1298"></a>                <span class='hs-comment'>-- Note [Forcing specialisation]</span>
<a name="line-1299"></a>
<a name="line-1300"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>rhs_infos</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>scRecRhs</span> <span class='hs-varid'>rhs_env2</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs'</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>rhss</span><span class='hs-layout'>)</span>
<a name="line-1301"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>rhs_env2</span> <span class='hs-varid'>body</span>
<a name="line-1302"></a>
<a name="line-1303"></a>        <span class='hs-comment'>-- NB: start specLoop from body_usg</span>
<a name="line-1304"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>specs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>specRec</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-layout'>(</span><span class='hs-varid'>scForce</span> <span class='hs-varid'>rhs_env2</span> <span class='hs-varid'>force_spec</span><span class='hs-layout'>)</span>
<a name="line-1305"></a>                                       <span class='hs-varid'>body_usg</span> <span class='hs-varid'>rhs_infos</span>
<a name="line-1306"></a>                <span class='hs-comment'>-- Do not unconditionally generate specialisations from rhs_usgs</span>
<a name="line-1307"></a>                <span class='hs-comment'>-- Instead use them only if we find an unspecialised call</span>
<a name="line-1308"></a>                <span class='hs-comment'>-- See Note [Local recursive groups]</span>
<a name="line-1309"></a>
<a name="line-1310"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_usg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spec_usg</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>body_usg</span>  <span class='hs-comment'>-- Note [spec_usg includes rhs_usg]</span>
<a name="line-1311"></a>              <span class='hs-varid'>bind'</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWithEqual</span> <span class='hs-str'>"scExpr'"</span> <span class='hs-varid'>ruleInfoBinds</span> <span class='hs-varid'>rhs_infos</span> <span class='hs-varid'>specs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1312"></a>                        <span class='hs-comment'>-- zipWithEqual: length of returned [SpecInfo]</span>
<a name="line-1313"></a>                        <span class='hs-comment'>-- should be the same as incoming [RhsInfo]</span>
<a name="line-1314"></a>
<a name="line-1315"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>all_usg</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scu_calls</span> <span class='hs-varid'>all_usg</span> <span class='hs-varop'>`delVarEnvList`</span> <span class='hs-varid'>bndrs'</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span>
<a name="line-1316"></a>                  <span class='hs-conid'>Let</span> <span class='hs-varid'>bind'</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1317"></a>
<a name="line-1318"></a><span class='hs-comment'>{-
<a name="line-1319"></a>Note [Local let bindings]
<a name="line-1320"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1321"></a>It is not uncommon to find this
<a name="line-1322"></a>
<a name="line-1323"></a>   let $j = \x. &lt;blah&gt; in ...$j True...$j True...
<a name="line-1324"></a>
<a name="line-1325"></a>Here $j is an arbitrary let-bound function, but it often comes up for
<a name="line-1326"></a>join points.  We might like to specialise $j for its call patterns.
<a name="line-1327"></a>Notice the difference from a letrec, where we look for call patterns
<a name="line-1328"></a>in the *RHS* of the function.  Here we look for call patterns in the
<a name="line-1329"></a>*body* of the let.
<a name="line-1330"></a>
<a name="line-1331"></a>At one point I predicated this on the RHS mentioning the outer
<a name="line-1332"></a>recursive function, but that's not essential and might even be
<a name="line-1333"></a>harmful.  I'm not sure.
<a name="line-1334"></a>-}</span>
<a name="line-1335"></a>
<a name="line-1336"></a><a name="scApp"></a><span class='hs-definition'>scApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>InExpr</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-1337"></a>
<a name="line-1338"></a><span class='hs-definition'>scApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Function is a variable</span>
<a name="line-1339"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1340"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>args_w_usgs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-1341"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_usgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>args_w_usgs</span>
<a name="line-1342"></a>              <span class='hs-varid'>arg_usg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineUsages</span> <span class='hs-varid'>arg_usgs</span>
<a name="line-1343"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>scSubstId</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-keyword'>of</span>
<a name="line-1344"></a>            <span class='hs-varid'>fn'</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>scExpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>zapScSubst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>doBeta</span> <span class='hs-varid'>fn'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>
<a name="line-1345"></a>                        <span class='hs-comment'>-- Do beta-reduction and try again</span>
<a name="line-1346"></a>
<a name="line-1347"></a>            <span class='hs-conid'>Var</span> <span class='hs-varid'>fn'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_usg</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>mkVarUsage</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>,</span>
<a name="line-1348"></a>                               <span class='hs-varid'>mkApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fn'</span><span class='hs-layout'>)</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>
<a name="line-1349"></a>
<a name="line-1350"></a>            <span class='hs-varid'>other_fn'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>other_fn'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1351"></a>                <span class='hs-comment'>-- NB: doing this ignores any usage info from the substituted</span>
<a name="line-1352"></a>                <span class='hs-comment'>--     function, but I don't think that matters.  If it does</span>
<a name="line-1353"></a>                <span class='hs-comment'>--     we can fix it.</span>
<a name="line-1354"></a>  <span class='hs-keyword'>where</span>
<a name="line-1355"></a>    <span class='hs-varid'>doBeta</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OutExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutExpr</span>
<a name="line-1356"></a>    <span class='hs-comment'>-- ToDo: adjust for System IF</span>
<a name="line-1357"></a>    <span class='hs-varid'>doBeta</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span> <span class='hs-conop'>:</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>doBeta</span> <span class='hs-varid'>body</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-1358"></a>    <span class='hs-varid'>doBeta</span> <span class='hs-varid'>fn</span>              <span class='hs-varid'>args</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>args</span>
<a name="line-1359"></a>
<a name="line-1360"></a><span class='hs-comment'>-- The function is almost always a variable, but not always.</span>
<a name="line-1361"></a><span class='hs-comment'>-- In particular, if this pass follows float-in,</span>
<a name="line-1362"></a><span class='hs-comment'>-- which it may, we can get</span>
<a name="line-1363"></a><span class='hs-comment'>--      (let f = ...f... in f) arg1 arg2</span>
<a name="line-1364"></a><span class='hs-definition'>scApp</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>other_fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-1365"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_usg</span><span class='hs-layout'>,</span>   <span class='hs-varid'>fn'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>other_fn</span>
<a name="line-1366"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_usgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-1367"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>combineUsages</span> <span class='hs-varid'>arg_usgs</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>fn_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>fn'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1368"></a>
<a name="line-1369"></a><a name="mkVarUsage"></a><span class='hs-comment'>----------------------</span>
<a name="line-1370"></a><span class='hs-definition'>mkVarUsage</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>
<a name="line-1371"></a><span class='hs-definition'>mkVarUsage</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>args</span>
<a name="line-1372"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupHowBound</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-keyword'>of</span>
<a name="line-1373"></a>        <span class='hs-conid'>Just</span> <span class='hs-conid'>RecFun</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarEnv</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Call</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>args</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_vals</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1374"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>scu_occs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-layout'>}</span>
<a name="line-1375"></a>        <span class='hs-conid'>Just</span> <span class='hs-conid'>RecArg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SCU</span> <span class='hs-layout'>{</span> <span class='hs-varid'>scu_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-1376"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>scu_occs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitVarEnv</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg_occ</span> <span class='hs-layout'>}</span>
<a name="line-1377"></a>        <span class='hs-conid'>Nothing</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>nullUsage</span>
<a name="line-1378"></a>  <span class='hs-keyword'>where</span>
<a name="line-1379"></a>    <span class='hs-comment'>-- I rather think we could use UnkOcc all the time</span>
<a name="line-1380"></a>    <span class='hs-varid'>arg_occ</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnkOcc</span>
<a name="line-1381"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evalScrutOcc</span>
<a name="line-1382"></a>
<a name="line-1383"></a><a name="scTopBindEnv"></a><span class='hs-comment'>----------------------</span>
<a name="line-1384"></a><span class='hs-definition'>scTopBindEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBind</span><span class='hs-layout'>)</span>
<a name="line-1385"></a><span class='hs-definition'>scTopBindEnv</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span>
<a name="line-1386"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_env1</span><span class='hs-layout'>,</span><span class='hs-varid'>bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendRecBndrs</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndrs</span>
<a name="line-1387"></a>              <span class='hs-varid'>rhs_env2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendHowBound</span> <span class='hs-varid'>rhs_env1</span> <span class='hs-varid'>bndrs</span> <span class='hs-conid'>RecFun</span>
<a name="line-1388"></a>
<a name="line-1389"></a>              <span class='hs-varid'>prs'</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zip</span> <span class='hs-varid'>bndrs'</span> <span class='hs-varid'>rhss</span>
<a name="line-1390"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_env2</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-varid'>prs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1391"></a>  <span class='hs-keyword'>where</span>
<a name="line-1392"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span><span class='hs-varid'>rhss</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>prs</span>
<a name="line-1393"></a>
<a name="line-1394"></a><span class='hs-definition'>scTopBindEnv</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1395"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>env1</span><span class='hs-layout'>,</span> <span class='hs-varid'>bndr'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendBndr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr</span>
<a name="line-1396"></a>              <span class='hs-varid'>env2</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendValEnv</span> <span class='hs-varid'>env1</span> <span class='hs-varid'>bndr'</span> <span class='hs-layout'>(</span><span class='hs-varid'>isValue</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_vals</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1397"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>env2</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr'</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1398"></a>
<a name="line-1399"></a><a name="scTopBind"></a><span class='hs-comment'>----------------------</span>
<a name="line-1400"></a><span class='hs-definition'>scTopBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBind</span><span class='hs-layout'>)</span>
<a name="line-1401"></a>
<a name="line-1402"></a><span class='hs-comment'>{-
<a name="line-1403"></a>scTopBind _ usage _
<a name="line-1404"></a>  | pprTrace "scTopBind_usage" (ppr (scu_calls usage)) False
<a name="line-1405"></a>  = error "false"
<a name="line-1406"></a>-}</span>
<a name="line-1407"></a>
<a name="line-1408"></a><span class='hs-definition'>scTopBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body_usage</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>prs</span><span class='hs-layout'>)</span>
<a name="line-1409"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>threshold</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sc_size</span> <span class='hs-varid'>env</span>
<a name="line-1410"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>force_spec</span>
<a name="line-1411"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>all</span> <span class='hs-layout'>(</span><span class='hs-varid'>couldBeSmallEnoughToInline</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_uf_opts</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>threshold</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhss</span><span class='hs-layout'>)</span>
<a name="line-1412"></a>                <span class='hs-comment'>-- No specialisation</span>
<a name="line-1413"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "scTopBind: nospec" (ppr bndrs) $</span>
<a name="line-1414"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_usgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhss'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhss</span>
<a name="line-1415"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>combineUsages</span> <span class='hs-varid'>rhs_usgs</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>rhss'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1416"></a>
<a name="line-1417"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Do specialisation</span>
<a name="line-1418"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>rhs_infos</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>scRecRhs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>prs</span>
<a name="line-1419"></a>
<a name="line-1420"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usage</span><span class='hs-layout'>,</span> <span class='hs-varid'>specs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>specRec</span> <span class='hs-conid'>TopLevel</span> <span class='hs-layout'>(</span><span class='hs-varid'>scForce</span> <span class='hs-varid'>env</span> <span class='hs-varid'>force_spec</span><span class='hs-layout'>)</span>
<a name="line-1421"></a>                                         <span class='hs-varid'>body_usage</span> <span class='hs-varid'>rhs_infos</span>
<a name="line-1422"></a>
<a name="line-1423"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usage</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>spec_usage</span><span class='hs-layout'>,</span>
<a name="line-1424"></a>                  <span class='hs-conid'>Rec</span> <span class='hs-layout'>(</span><span class='hs-varid'>concat</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>ruleInfoBinds</span> <span class='hs-varid'>rhs_infos</span> <span class='hs-varid'>specs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1425"></a>  <span class='hs-keyword'>where</span>
<a name="line-1426"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span><span class='hs-varid'>rhss</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>prs</span>
<a name="line-1427"></a>    <span class='hs-varid'>force_spec</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>forceSpecBndr</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndrs</span>
<a name="line-1428"></a>      <span class='hs-comment'>-- Note [Forcing specialisation]</span>
<a name="line-1429"></a>
<a name="line-1430"></a><span class='hs-definition'>scTopBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>usage</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Oddly, we don't seem to specialise top-level non-rec functions</span>
<a name="line-1431"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_usg'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs</span>
<a name="line-1432"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usage</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>rhs_usg'</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>bndr</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1433"></a>
<a name="line-1434"></a><a name="scRecRhs"></a><span class='hs-comment'>----------------------</span>
<a name="line-1435"></a><span class='hs-definition'>scRecRhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>OutId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InExpr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-conid'>RhsInfo</span>
<a name="line-1436"></a><span class='hs-definition'>scRecRhs</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1437"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_bndrs</span><span class='hs-layout'>,</span><span class='hs-varid'>body</span><span class='hs-layout'>)</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>rhs</span>
<a name="line-1438"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>body_env</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_bndrs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendBndrsWith</span> <span class='hs-conid'>RecArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_bndrs</span>
<a name="line-1439"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>body_env</span> <span class='hs-varid'>body</span>
<a name="line-1440"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg_occs</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupOccs</span> <span class='hs-varid'>body_usg</span> <span class='hs-varid'>arg_bndrs'</span>
<a name="line-1441"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>RI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ri_rhs_usg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_usg</span>
<a name="line-1442"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>ri_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>ri_new_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>arg_bndrs'</span> <span class='hs-varid'>body'</span>
<a name="line-1443"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>ri_lam_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ri_lam_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span>
<a name="line-1444"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>ri_arg_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_occs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1445"></a>                <span class='hs-comment'>-- The arg_occs says how the visible,</span>
<a name="line-1446"></a>                <span class='hs-comment'>-- lambda-bound binders of the RHS are used</span>
<a name="line-1447"></a>                <span class='hs-comment'>-- (including the TyVar binders)</span>
<a name="line-1448"></a>                <span class='hs-comment'>-- Two pats are the same if they match both ways</span>
<a name="line-1449"></a>
<a name="line-1450"></a><a name="ruleInfoBinds"></a><span class='hs-comment'>----------------------</span>
<a name="line-1451"></a><span class='hs-definition'>ruleInfoBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RhsInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SpecInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1452"></a><span class='hs-definition'>ruleInfoBinds</span> <span class='hs-layout'>(</span><span class='hs-conid'>RI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ri_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>ri_new_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1453"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>specs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1454"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span><span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>os_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>os_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>specs</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>++</span>
<a name="line-1455"></a>              <span class='hs-comment'>-- First the specialised bindings</span>
<a name="line-1456"></a>
<a name="line-1457"></a>    <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>fn</span> <span class='hs-varop'>`addIdSpecialisations`</span> <span class='hs-varid'>rules</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1458"></a>              <span class='hs-comment'>-- And now the original binding</span>
<a name="line-1459"></a>  <span class='hs-keyword'>where</span>
<a name="line-1460"></a>    <span class='hs-varid'>rules</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>r</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>os_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>r</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>specs</span><span class='hs-keyglyph'>]</span>
<a name="line-1461"></a>
<a name="line-1462"></a><span class='hs-comment'>{-
<a name="line-1463"></a>************************************************************************
<a name="line-1464"></a>*                                                                      *
<a name="line-1465"></a>                The specialiser itself
<a name="line-1466"></a>*                                                                      *
<a name="line-1467"></a>************************************************************************
<a name="line-1468"></a>-}</span>
<a name="line-1469"></a>
<a name="line-1470"></a><a name="RhsInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>RhsInfo</span>
<a name="line-1471"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ri_fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span>                 <span class='hs-comment'>-- The binder</span>
<a name="line-1472"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ri_new_rhs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span>          <span class='hs-comment'>-- The specialised RHS (in current envt)</span>
<a name="line-1473"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ri_rhs_usg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScUsage</span>          <span class='hs-comment'>-- Usage info from specialising RHS</span>
<a name="line-1474"></a>
<a name="line-1475"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ri_lam_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- The *original* RHS (\xs.body)</span>
<a name="line-1476"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ri_lam_body</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InExpr</span>        <span class='hs-comment'>--   Note [Specialise original body]</span>
<a name="line-1477"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>ri_arg_occs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- Info on how the xs occur in body</span>
<a name="line-1478"></a>    <span class='hs-layout'>}</span>
<a name="line-1479"></a>
<a name="line-1480"></a><a name="SpecInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SpecInfo</span>       <span class='hs-comment'>-- Info about specialisations for a particular Id</span>
<a name="line-1481"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_specs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>OneSpec</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- The specialisations we have generated</span>
<a name="line-1482"></a>
<a name="line-1483"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>si_n_specs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>              <span class='hs-comment'>-- Length of si_specs; used for numbering them</span>
<a name="line-1484"></a>
<a name="line-1485"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>ScUsage</span>  <span class='hs-comment'>-- Just cs  =&gt; we have not yet used calls in the</span>
<a name="line-1486"></a>       <span class='hs-layout'>}</span>                                <span class='hs-comment'>--             from calls in the *original* RHS as</span>
<a name="line-1487"></a>                                        <span class='hs-comment'>--             seeds for new specialisations;</span>
<a name="line-1488"></a>                                        <span class='hs-comment'>--             if you decide to do so, here is the</span>
<a name="line-1489"></a>                                        <span class='hs-comment'>--             RHS usage (which has not yet been</span>
<a name="line-1490"></a>                                        <span class='hs-comment'>--             unleashed)</span>
<a name="line-1491"></a>                                        <span class='hs-comment'>-- Nothing =&gt; we have</span>
<a name="line-1492"></a>                                        <span class='hs-comment'>-- See Note [Local recursive groups]</span>
<a name="line-1493"></a>                                        <span class='hs-comment'>-- See Note [spec_usg includes rhs_usg]</span>
<a name="line-1494"></a>
<a name="line-1495"></a>        <span class='hs-comment'>-- One specialisation: Rule plus definition</span>
<a name="line-1496"></a><a name="OneSpec"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>OneSpec</span> <span class='hs-keyglyph'>=</span>
<a name="line-1497"></a>  <span class='hs-conid'>OS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>os_pat</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CallPat</span>    <span class='hs-comment'>-- Call pattern that generated this specialisation</span>
<a name="line-1498"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>os_rule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreRule</span>   <span class='hs-comment'>-- Rule connecting original id with the specialisation</span>
<a name="line-1499"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>os_id</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutId</span>      <span class='hs-comment'>-- Spec id</span>
<a name="line-1500"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>os_rhs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OutExpr</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- Spec rhs</span>
<a name="line-1501"></a>
<a name="line-1502"></a><a name="noSpecInfo"></a><span class='hs-definition'>noSpecInfo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SpecInfo</span>
<a name="line-1503"></a><span class='hs-definition'>noSpecInfo</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>si_n_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span><span class='hs-layout'>,</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-1504"></a>
<a name="line-1505"></a><a name="specNonRec"></a><span class='hs-comment'>----------------------</span>
<a name="line-1506"></a><span class='hs-definition'>specNonRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span>
<a name="line-1507"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>         <span class='hs-comment'>-- Body usage</span>
<a name="line-1508"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RhsInfo</span>         <span class='hs-comment'>-- Structure info usage info for un-specialised RHS</span>
<a name="line-1509"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>SpecInfo</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- Usage from RHSs (specialised and not)</span>
<a name="line-1510"></a>                                               <span class='hs-comment'>--     plus details of specialisations</span>
<a name="line-1511"></a>
<a name="line-1512"></a><span class='hs-definition'>specNonRec</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body_usg</span> <span class='hs-varid'>rhs_info</span>
<a name="line-1513"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>specialise</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_calls</span> <span class='hs-varid'>body_usg</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs_info</span>
<a name="line-1514"></a>               <span class='hs-layout'>(</span><span class='hs-varid'>noSpecInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ri_rhs_usg</span> <span class='hs-varid'>rhs_info</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1515"></a>
<a name="line-1516"></a><a name="specRec"></a><span class='hs-comment'>----------------------</span>
<a name="line-1517"></a><span class='hs-definition'>specRec</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScEnv</span>
<a name="line-1518"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>                         <span class='hs-comment'>-- Body usage</span>
<a name="line-1519"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>RhsInfo</span><span class='hs-keyglyph'>]</span>                       <span class='hs-comment'>-- Structure info and usage info for un-specialised RHSs</span>
<a name="line-1520"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>SpecInfo</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Usage from all RHSs (specialised and not)</span>
<a name="line-1521"></a>                                           <span class='hs-comment'>--     plus details of specialisations</span>
<a name="line-1522"></a>
<a name="line-1523"></a><span class='hs-definition'>specRec</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body_usg</span> <span class='hs-varid'>rhs_infos</span>
<a name="line-1524"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>1</span> <span class='hs-varid'>seed_calls</span> <span class='hs-varid'>nullUsage</span> <span class='hs-varid'>init_spec_infos</span>
<a name="line-1525"></a>  <span class='hs-keyword'>where</span>
<a name="line-1526"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>seed_calls</span><span class='hs-layout'>,</span> <span class='hs-varid'>init_spec_infos</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Note [Seeding top-level recursive groups]</span>
<a name="line-1527"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span>
<a name="line-1528"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>isExportedId</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ri_fn</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs_infos</span>   <span class='hs-comment'>-- Seed from body and RHSs</span>
<a name="line-1529"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>all_calls</span><span class='hs-layout'>,</span>     <span class='hs-keyglyph'>[</span><span class='hs-varid'>noSpecInfo</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rhs_infos</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1530"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                              <span class='hs-comment'>-- Seed from body only</span>
<a name="line-1531"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>calls_in_body</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>noSpecInfo</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ri_rhs_usg</span> <span class='hs-varid'>ri</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1532"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ri</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rhs_infos</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1533"></a>
<a name="line-1534"></a>    <span class='hs-varid'>calls_in_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scu_calls</span> <span class='hs-varid'>body_usg</span>
<a name="line-1535"></a>    <span class='hs-varid'>calls_in_rhss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>combineCalls</span> <span class='hs-varop'>.</span> <span class='hs-varid'>scu_calls</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ri_rhs_usg</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-varid'>rhs_infos</span>
<a name="line-1536"></a>    <span class='hs-varid'>all_calls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>calls_in_rhss</span> <span class='hs-varop'>`combineCalls`</span> <span class='hs-varid'>calls_in_body</span>
<a name="line-1537"></a>
<a name="line-1538"></a>    <span class='hs-comment'>-- Loop, specialising, until you get no new specialisations</span>
<a name="line-1539"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>   <span class='hs-comment'>-- Which iteration of the "until no new specialisations"</span>
<a name="line-1540"></a>                <span class='hs-comment'>-- loop we are on; first iteration is 1</span>
<a name="line-1541"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallEnv</span>   <span class='hs-comment'>-- Seed calls</span>
<a name="line-1542"></a>                    <span class='hs-comment'>-- Two accumulating parameters:</span>
<a name="line-1543"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ScUsage</span>      <span class='hs-comment'>-- Usage from earlier specialisations</span>
<a name="line-1544"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>SpecInfo</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Details of specialisations so far</span>
<a name="line-1545"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>SpecInfo</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1546"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>n_iter</span> <span class='hs-varid'>seed_calls</span> <span class='hs-varid'>usg_so_far</span> <span class='hs-varid'>spec_infos</span>
<a name="line-1547"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyVarEnv</span> <span class='hs-varid'>seed_calls</span>
<a name="line-1548"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "specRec1" (vcat [ ppr (map ri_fn rhs_infos)</span>
<a name="line-1549"></a>        <span class='hs-comment'>--                           , ppr seed_calls</span>
<a name="line-1550"></a>        <span class='hs-comment'>--                           , ppr body_usg ]) $</span>
<a name="line-1551"></a>        <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg_so_far</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_infos</span><span class='hs-layout'>)</span>
<a name="line-1552"></a>
<a name="line-1553"></a>      <span class='hs-comment'>-- Limit recursive specialisation</span>
<a name="line-1554"></a>      <span class='hs-comment'>-- See Note [Limit recursive specialisation]</span>
<a name="line-1555"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n_iter</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>sc_recursive</span> <span class='hs-varid'>env</span>  <span class='hs-comment'>-- Too many iterations of the 'go' loop</span>
<a name="line-1556"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>sc_force</span> <span class='hs-varid'>env</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_count</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1557"></a>           <span class='hs-comment'>-- If both of these are false, the sc_count</span>
<a name="line-1558"></a>           <span class='hs-comment'>-- threshold will prevent non-termination</span>
<a name="line-1559"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>&gt;</span> <span class='hs-varid'>the_limit</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>si_n_specs</span><span class='hs-layout'>)</span> <span class='hs-varid'>spec_infos</span>
<a name="line-1560"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "specRec2" (ppr (map (map os_pat . si_specs) spec_infos)) $</span>
<a name="line-1561"></a>        <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>usg_so_far</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_infos</span><span class='hs-layout'>)</span>
<a name="line-1562"></a>
<a name="line-1563"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1564"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "specRec3" (vcat [ text "bndrs" &lt;+&gt; ppr (map ri_fn rhs_infos)</span>
<a name="line-1565"></a>        <span class='hs-comment'>--                           , text "iteration" &lt;+&gt; int n_iter</span>
<a name="line-1566"></a>        <span class='hs-comment'>--                          , text "spec_infos" &lt;+&gt; ppr (map (map os_pat . si_specs) spec_infos)</span>
<a name="line-1567"></a>        <span class='hs-comment'>--                    ]) $</span>
<a name="line-1568"></a>        <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>specs_w_usg</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWithM</span> <span class='hs-layout'>(</span><span class='hs-varid'>specialise</span> <span class='hs-varid'>env</span> <span class='hs-varid'>seed_calls</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs_infos</span> <span class='hs-varid'>spec_infos</span>
<a name="line-1569"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>extra_usg_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_spec_infos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>specs_w_usg</span>
<a name="line-1570"></a>                  <span class='hs-varid'>extra_usg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineUsages</span> <span class='hs-varid'>extra_usg_s</span>
<a name="line-1571"></a>                  <span class='hs-varid'>all_usg</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>usg_so_far</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>extra_usg</span>
<a name="line-1572"></a>            <span class='hs-layout'>;</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_iter</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>scu_calls</span> <span class='hs-varid'>extra_usg</span><span class='hs-layout'>)</span> <span class='hs-varid'>all_usg</span> <span class='hs-varid'>new_spec_infos</span> <span class='hs-layout'>}</span>
<a name="line-1573"></a>
<a name="line-1574"></a>    <span class='hs-comment'>-- See Note [Limit recursive specialisation]</span>
<a name="line-1575"></a>    <span class='hs-varid'>the_limit</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sc_count</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>of</span>
<a name="line-1576"></a>                  <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-num'>10</span>    <span class='hs-comment'>-- Ugh!</span>
<a name="line-1577"></a>                  <span class='hs-conid'>Just</span> <span class='hs-varid'>max</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>max</span>
<a name="line-1578"></a>
<a name="line-1579"></a>
<a name="line-1580"></a><a name="specialise"></a><span class='hs-comment'>----------------------</span>
<a name="line-1581"></a><span class='hs-definition'>specialise</span>
<a name="line-1582"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span>
<a name="line-1583"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallEnv</span>                     <span class='hs-comment'>-- Info on newly-discovered calls to this function</span>
<a name="line-1584"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>RhsInfo</span>
<a name="line-1585"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SpecInfo</span>                    <span class='hs-comment'>-- Original RHS plus patterns dealt with</span>
<a name="line-1586"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>SpecInfo</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- New specialised versions and their usage</span>
<a name="line-1587"></a>
<a name="line-1588"></a><span class='hs-comment'>-- See Note [spec_usg includes rhs_usg]</span>
<a name="line-1589"></a>
<a name="line-1590"></a><span class='hs-comment'>-- Note: this only generates *specialised* bindings</span>
<a name="line-1591"></a><span class='hs-comment'>-- The original binding is added by ruleInfoBinds</span>
<a name="line-1592"></a><span class='hs-comment'>--</span>
<a name="line-1593"></a><span class='hs-comment'>-- Note: the rhs here is the optimised version of the original rhs</span>
<a name="line-1594"></a><span class='hs-comment'>-- So when we make a specialised copy of the RHS, we're starting</span>
<a name="line-1595"></a><span class='hs-comment'>-- from an RHS whose nested functions have been optimised already.</span>
<a name="line-1596"></a>
<a name="line-1597"></a><span class='hs-definition'>specialise</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bind_calls</span> <span class='hs-layout'>(</span><span class='hs-conid'>RI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ri_fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fn</span><span class='hs-layout'>,</span> <span class='hs-varid'>ri_lam_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_bndrs</span>
<a name="line-1598"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>ri_lam_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-varid'>ri_arg_occs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_occs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1599"></a>               <span class='hs-varid'>spec_info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>specs</span><span class='hs-layout'>,</span> <span class='hs-varid'>si_n_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spec_count</span>
<a name="line-1600"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mb_unspec</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1601"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDeadEndId</span> <span class='hs-varid'>fn</span>  <span class='hs-comment'>-- Note [Do not specialise diverging functions]</span>
<a name="line-1602"></a>                    <span class='hs-comment'>-- and do not generate specialisation seeds from its RHS</span>
<a name="line-1603"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "specialise bot" (ppr fn) $</span>
<a name="line-1604"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>nullUsage</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_info</span><span class='hs-layout'>)</span>
<a name="line-1605"></a>
<a name="line-1606"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNeverActive</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [Transfer activation]</span>
<a name="line-1607"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>null</span> <span class='hs-varid'>arg_bndrs</span>                     <span class='hs-comment'>-- Only specialise functions</span>
<a name="line-1608"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "specialise inactive" (ppr fn) $</span>
<a name="line-1609"></a>    <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_unspec</span> <span class='hs-keyword'>of</span>    <span class='hs-comment'>-- Behave as if there was a single, boring call</span>
<a name="line-1610"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs_usg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_info</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1611"></a>                         <span class='hs-comment'>-- See Note [spec_usg includes rhs_usg]</span>
<a name="line-1612"></a>      <span class='hs-conid'>Nothing</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>nullUsage</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_info</span><span class='hs-layout'>)</span>
<a name="line-1613"></a>
<a name="line-1614"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>all_calls</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>bind_calls</span> <span class='hs-varid'>fn</span>
<a name="line-1615"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "specialise entry {" (ppr fn &lt;+&gt; ppr all_calls) $</span>
<a name="line-1616"></a>    <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>boring_call</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_pats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>callsToNewPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>spec_info</span> <span class='hs-varid'>arg_occs</span> <span class='hs-varid'>all_calls</span>
<a name="line-1617"></a>
<a name="line-1618"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>n_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>new_pats</span>
<a name="line-1619"></a><span class='hs-comment'>--        ; if (not (null new_pats) || isJust mb_unspec) then</span>
<a name="line-1620"></a><span class='hs-comment'>--            pprTrace "specialise" (vcat [ ppr fn &lt;+&gt; text "with" &lt;+&gt; int n_pats &lt;+&gt; text "good patterns"</span>
<a name="line-1621"></a><span class='hs-comment'>--                                        , text "mb_unspec" &lt;+&gt; ppr (isJust mb_unspec)</span>
<a name="line-1622"></a><span class='hs-comment'>--                                        , text "arg_occs" &lt;+&gt; ppr arg_occs</span>
<a name="line-1623"></a><span class='hs-comment'>--                                        , text "good pats" &lt;+&gt; ppr new_pats])  $</span>
<a name="line-1624"></a><span class='hs-comment'>--               return ()</span>
<a name="line-1625"></a><span class='hs-comment'>--          else return ()</span>
<a name="line-1626"></a>
<a name="line-1627"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>spec_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>decreaseSpecCount</span> <span class='hs-varid'>env</span> <span class='hs-varid'>n_pats</span>
<a name="line-1628"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usgs</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_specs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapAndUnzipM</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_one</span> <span class='hs-varid'>spec_env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg_bndrs</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1629"></a>                                                 <span class='hs-layout'>(</span><span class='hs-varid'>new_pats</span> <span class='hs-varop'>`zip`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>spec_count</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1630"></a>                <span class='hs-comment'>-- See Note [Specialise original body]</span>
<a name="line-1631"></a>
<a name="line-1632"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>spec_usg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>combineUsages</span> <span class='hs-varid'>spec_usgs</span>
<a name="line-1633"></a>
<a name="line-1634"></a>              <span class='hs-comment'>-- If there were any boring calls among the seeds (= all_calls), then those</span>
<a name="line-1635"></a>              <span class='hs-comment'>-- calls will call the un-specialised function.  So we should use the seeds</span>
<a name="line-1636"></a>              <span class='hs-comment'>-- from the _unspecialised_ function's RHS, which are in mb_unspec, by returning</span>
<a name="line-1637"></a>              <span class='hs-comment'>-- then in new_usg.</span>
<a name="line-1638"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>new_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>mb_unspec'</span><span class='hs-layout'>)</span>
<a name="line-1639"></a>                  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_unspec</span> <span class='hs-keyword'>of</span>
<a name="line-1640"></a>                      <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs_usg</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>boring_call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usg</span> <span class='hs-varop'>`combineUsage`</span> <span class='hs-varid'>rhs_usg</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nothing</span><span class='hs-layout'>)</span>
<a name="line-1641"></a>                      <span class='hs-keyword'>_</span>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usg</span><span class='hs-layout'>,</span>                      <span class='hs-varid'>mb_unspec</span><span class='hs-layout'>)</span>
<a name="line-1642"></a>
<a name="line-1643"></a><span class='hs-comment'>--        ; pprTrace "specialise return }"</span>
<a name="line-1644"></a><span class='hs-comment'>--             (vcat [ ppr fn</span>
<a name="line-1645"></a><span class='hs-comment'>--                   , text "boring_call:" &lt;+&gt; ppr boring_call</span>
<a name="line-1646"></a><span class='hs-comment'>--                   , text "new calls:" &lt;+&gt; ppr (scu_calls new_usg)]) $</span>
<a name="line-1647"></a><span class='hs-comment'>--          return ()</span>
<a name="line-1648"></a>
<a name="line-1649"></a>          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_usg</span><span class='hs-layout'>,</span> <span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_specs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>specs</span>
<a name="line-1650"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>si_n_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spec_count</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n_pats</span>
<a name="line-1651"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>si_mb_unspec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mb_unspec'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1652"></a>
<a name="line-1653"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- No new seeds, so return nullUsage</span>
<a name="line-1654"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>nullUsage</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_info</span><span class='hs-layout'>)</span>
<a name="line-1655"></a>
<a name="line-1656"></a>
<a name="line-1657"></a>
<a name="line-1658"></a>
<a name="line-1659"></a><a name="spec_one"></a><span class='hs-comment'>---------------------</span>
<a name="line-1660"></a><span class='hs-definition'>spec_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span>
<a name="line-1661"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OutId</span>       <span class='hs-comment'>-- Function</span>
<a name="line-1662"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InVar</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Lambda-binders of RHS; should match patterns</span>
<a name="line-1663"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InExpr</span>      <span class='hs-comment'>-- Body of the original function</span>
<a name="line-1664"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>CallPat</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span>
<a name="line-1665"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>ScUsage</span><span class='hs-layout'>,</span> <span class='hs-conid'>OneSpec</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Rule and binding</span>
<a name="line-1666"></a>
<a name="line-1667"></a><span class='hs-comment'>-- spec_one creates a specialised copy of the function, together</span>
<a name="line-1668"></a><span class='hs-comment'>-- with a rule for using it.  I'm very proud of how short this</span>
<a name="line-1669"></a><span class='hs-comment'>-- function is, considering what it does :-).</span>
<a name="line-1670"></a>
<a name="line-1671"></a><span class='hs-comment'>{-
<a name="line-1672"></a>  Example
<a name="line-1673"></a>
<a name="line-1674"></a>     In-scope: a, x::a
<a name="line-1675"></a>     f = /\b \y::[(a,b)] -&gt; ....f (b,c) ((:) (a,(b,c)) (x,v) (h w))...
<a name="line-1676"></a>          [c::*, v::(b,c) are presumably bound by the (...) part]
<a name="line-1677"></a>  ==&gt;
<a name="line-1678"></a>     f_spec = /\ b c \ v::(b,c) hw::[(a,(b,c))] -&gt;
<a name="line-1679"></a>                  (...entire body of f...) [b -&gt; (b,c),
<a name="line-1680"></a>                                            y -&gt; ((:) (a,(b,c)) (x,v) hw)]
<a name="line-1681"></a>
<a name="line-1682"></a>     RULE:  forall b::* c::*,           -- Note, *not* forall a, x
<a name="line-1683"></a>                   v::(b,c),
<a name="line-1684"></a>                   hw::[(a,(b,c))] .
<a name="line-1685"></a>
<a name="line-1686"></a>            f (b,c) ((:) (a,(b,c)) (x,v) hw) = f_spec b c v hw
<a name="line-1687"></a>-}</span>
<a name="line-1688"></a>
<a name="line-1689"></a><span class='hs-definition'>spec_one</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg_bndrs</span> <span class='hs-varid'>body</span> <span class='hs-layout'>(</span><span class='hs-varid'>call_pat</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>qvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>rule_number</span><span class='hs-layout'>)</span>
<a name="line-1690"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>spec_uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-1691"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>spec_env</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendScSubstList</span> <span class='hs-layout'>(</span><span class='hs-varid'>extendScInScope</span> <span class='hs-varid'>env</span> <span class='hs-varid'>qvars</span><span class='hs-layout'>)</span>
<a name="line-1692"></a>                                             <span class='hs-layout'>(</span><span class='hs-varid'>arg_bndrs</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>
<a name="line-1693"></a>              <span class='hs-varid'>fn_name</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idName</span> <span class='hs-varid'>fn</span>
<a name="line-1694"></a>              <span class='hs-varid'>fn_loc</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nameSrcSpan</span> <span class='hs-varid'>fn_name</span>
<a name="line-1695"></a>              <span class='hs-varid'>fn_occ</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nameOccName</span> <span class='hs-varid'>fn_name</span>
<a name="line-1696"></a>              <span class='hs-varid'>spec_occ</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSpecOcc</span> <span class='hs-varid'>fn_occ</span>
<a name="line-1697"></a>              <span class='hs-comment'>-- We use fn_occ rather than fn in the rule_name string</span>
<a name="line-1698"></a>              <span class='hs-comment'>-- as we don't want the uniq to end up in the rule, and</span>
<a name="line-1699"></a>              <span class='hs-comment'>-- hence in the ABI, as that can cause spurious ABI</span>
<a name="line-1700"></a>              <span class='hs-comment'>-- changes (#4012).</span>
<a name="line-1701"></a>              <span class='hs-varid'>rule_name</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFastString</span> <span class='hs-layout'>(</span><span class='hs-str'>"SC:"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>occNameString</span> <span class='hs-varid'>fn_occ</span> <span class='hs-varop'>++</span> <span class='hs-varid'>show</span> <span class='hs-varid'>rule_number</span><span class='hs-layout'>)</span>
<a name="line-1702"></a>              <span class='hs-varid'>spec_name</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInternalName</span> <span class='hs-varid'>spec_uniq</span> <span class='hs-varid'>spec_occ</span> <span class='hs-varid'>fn_loc</span>
<a name="line-1703"></a><span class='hs-comment'>--      ; pprTrace "{spec_one" (ppr (sc_count env) &lt;+&gt; ppr fn</span>
<a name="line-1704"></a><span class='hs-comment'>--                              &lt;+&gt; ppr pats &lt;+&gt; text "--&gt;" &lt;+&gt; ppr spec_name) $</span>
<a name="line-1705"></a><span class='hs-comment'>--        return ()</span>
<a name="line-1706"></a>
<a name="line-1707"></a>        <span class='hs-comment'>-- Specialise the body</span>
<a name="line-1708"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usg</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scExpr</span> <span class='hs-varid'>spec_env</span> <span class='hs-varid'>body</span>
<a name="line-1709"></a>
<a name="line-1710"></a><span class='hs-comment'>--      ; pprTrace "done spec_one}" (ppr fn) $</span>
<a name="line-1711"></a><span class='hs-comment'>--        return ()</span>
<a name="line-1712"></a>
<a name="line-1713"></a>                <span class='hs-comment'>-- And build the results</span>
<a name="line-1714"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_lam_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>spec_call_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkWorkerArgs</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1715"></a>                                                             <span class='hs-varid'>qvars</span> <span class='hs-varid'>body_ty</span>
<a name="line-1716"></a>                <span class='hs-comment'>-- Usual w/w hack to avoid generating</span>
<a name="line-1717"></a>                <span class='hs-comment'>-- a spec_rhs of unlifted type and no args</span>
<a name="line-1718"></a>
<a name="line-1719"></a>              <span class='hs-varid'>spec_lam_args_str</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>handOutStrictnessInformation</span> <span class='hs-layout'>(</span><span class='hs-varid'>fst</span> <span class='hs-layout'>(</span><span class='hs-varid'>splitStrictSig</span> <span class='hs-varid'>spec_str</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>spec_lam_args</span>
<a name="line-1720"></a>                <span class='hs-comment'>-- Annotate the variables with the strictness information from</span>
<a name="line-1721"></a>                <span class='hs-comment'>-- the function (see Note [Strictness information in worker binders])</span>
<a name="line-1722"></a>
<a name="line-1723"></a>              <span class='hs-varid'>spec_join_arity</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>spec_lam_args</span><span class='hs-layout'>)</span>
<a name="line-1724"></a>                              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1725"></a>              <span class='hs-varid'>spec_id</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLocalId</span> <span class='hs-varid'>spec_name</span> <span class='hs-conid'>Many</span>
<a name="line-1726"></a>                                     <span class='hs-layout'>(</span><span class='hs-varid'>mkLamTypes</span> <span class='hs-varid'>spec_lam_args</span> <span class='hs-varid'>body_ty</span><span class='hs-layout'>)</span>
<a name="line-1727"></a>                             <span class='hs-comment'>-- See Note [Transfer strictness]</span>
<a name="line-1728"></a>                             <span class='hs-varop'>`setIdStrictness`</span> <span class='hs-varid'>spec_str</span>
<a name="line-1729"></a>                             <span class='hs-varop'>`setIdCprInfo`</span> <span class='hs-varid'>topCprSig</span>
<a name="line-1730"></a>                             <span class='hs-varop'>`setIdArity`</span> <span class='hs-varid'>count</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>spec_lam_args</span>
<a name="line-1731"></a>                             <span class='hs-varop'>`asJoinId_maybe`</span> <span class='hs-varid'>spec_join_arity</span>
<a name="line-1732"></a>              <span class='hs-varid'>spec_str</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>calcSpecStrictness</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>spec_lam_args</span> <span class='hs-varid'>pats</span>
<a name="line-1733"></a>
<a name="line-1734"></a>
<a name="line-1735"></a>                <span class='hs-comment'>-- Conditionally use result of new worker-wrapper transform</span>
<a name="line-1736"></a>              <span class='hs-varid'>spec_rhs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkLams</span> <span class='hs-varid'>spec_lam_args_str</span> <span class='hs-varid'>spec_body</span>
<a name="line-1737"></a>              <span class='hs-varid'>body_ty</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprType</span> <span class='hs-varid'>spec_body</span>
<a name="line-1738"></a>              <span class='hs-varid'>rule_rhs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarApps</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>spec_id</span><span class='hs-layout'>)</span> <span class='hs-varid'>spec_call_args</span>
<a name="line-1739"></a>              <span class='hs-varid'>inline_act</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>fn</span>
<a name="line-1740"></a>              <span class='hs-varid'>this_mod</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_module</span> <span class='hs-varid'>spec_env</span>
<a name="line-1741"></a>              <span class='hs-varid'>rule</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkRule</span> <span class='hs-varid'>this_mod</span> <span class='hs-conid'>True</span> <span class='hs-comment'>{- Auto -}</span> <span class='hs-conid'>True</span> <span class='hs-comment'>{- Local -}</span>
<a name="line-1742"></a>                                  <span class='hs-varid'>rule_name</span> <span class='hs-varid'>inline_act</span> <span class='hs-varid'>fn_name</span> <span class='hs-varid'>qvars</span> <span class='hs-varid'>pats</span> <span class='hs-varid'>rule_rhs</span>
<a name="line-1743"></a>                           <span class='hs-comment'>-- See Note [Transfer activation]</span>
<a name="line-1744"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>spec_usg</span><span class='hs-layout'>,</span> <span class='hs-conid'>OS</span> <span class='hs-layout'>{</span> <span class='hs-varid'>os_pat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>call_pat</span><span class='hs-layout'>,</span> <span class='hs-varid'>os_rule</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rule</span>
<a name="line-1745"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>os_id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spec_id</span>
<a name="line-1746"></a>                               <span class='hs-layout'>,</span> <span class='hs-varid'>os_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>spec_rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1747"></a>
<a name="line-1748"></a>
<a name="line-1749"></a><a name="handOutStrictnessInformation"></a><span class='hs-comment'>-- See Note [Strictness information in worker binders]</span>
<a name="line-1750"></a><span class='hs-definition'>handOutStrictnessInformation</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span>
<a name="line-1751"></a><span class='hs-definition'>handOutStrictnessInformation</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1752"></a>  <span class='hs-keyword'>where</span>
<a name="line-1753"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1754"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>vs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vs</span>
<a name="line-1755"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>d</span><span class='hs-conop'>:</span><span class='hs-varid'>dmds</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdDemandInfo</span> <span class='hs-varid'>v</span> <span class='hs-varid'>d</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>vs</span>
<a name="line-1756"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>dmds</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-conop'>:</span><span class='hs-varid'>vs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span> <span class='hs-conop'>:</span> <span class='hs-varid'>go</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>vs</span>
<a name="line-1757"></a>
<a name="line-1758"></a><a name="calcSpecStrictness"></a><span class='hs-definition'>calcSpecStrictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span>                     <span class='hs-comment'>-- The original function</span>
<a name="line-1759"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- Call pattern</span>
<a name="line-1760"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>StrictSig</span>              <span class='hs-comment'>-- Strictness of specialised thing</span>
<a name="line-1761"></a><span class='hs-comment'>-- See Note [Transfer strictness]</span>
<a name="line-1762"></a><span class='hs-definition'>calcSpecStrictness</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>qvars</span> <span class='hs-varid'>pats</span>
<a name="line-1763"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClosedStrictSig</span> <span class='hs-varid'>spec_dmds</span> <span class='hs-varid'>div</span>
<a name="line-1764"></a>  <span class='hs-keyword'>where</span>
<a name="line-1765"></a>    <span class='hs-varid'>spec_dmds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>dmd_env</span> <span class='hs-varid'>qv</span> <span class='hs-varop'>`orElse`</span> <span class='hs-varid'>topDmd</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>qv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>qvars</span><span class='hs-layout'>,</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>qv</span> <span class='hs-keyglyph'>]</span>
<a name="line-1766"></a>    <span class='hs-conid'>StrictSig</span> <span class='hs-layout'>(</span><span class='hs-conid'>DmdType</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>div</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idStrictness</span> <span class='hs-varid'>fn</span>
<a name="line-1767"></a>
<a name="line-1768"></a>    <span class='hs-varid'>dmd_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>emptyVarEnv</span> <span class='hs-varid'>dmds</span> <span class='hs-varid'>pats</span>
<a name="line-1769"></a>
<a name="line-1770"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Demand</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdEnv</span>
<a name="line-1771"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ds</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>pats</span>
<a name="line-1772"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ds</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>pats</span>
<a name="line-1773"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>d</span><span class='hs-conop'>:</span><span class='hs-varid'>ds</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>pat</span> <span class='hs-conop'>:</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>go_one</span> <span class='hs-varid'>env</span> <span class='hs-varid'>d</span> <span class='hs-varid'>pat</span><span class='hs-layout'>)</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>pats</span>
<a name="line-1774"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>      <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1775"></a>
<a name="line-1776"></a>    <span class='hs-varid'>go_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DmdEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DmdEnv</span>
<a name="line-1777"></a>    <span class='hs-varid'>go_one</span> <span class='hs-varid'>env</span> <span class='hs-varid'>d</span>          <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv_C</span> <span class='hs-varid'>plusDmd</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span> <span class='hs-varid'>d</span>
<a name="line-1778"></a>    <span class='hs-varid'>go_one</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-sel'>_n</span> <span class='hs-conop'>:*</span> <span class='hs-varid'>cd</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span> <span class='hs-comment'>-- NB: _n does not have to be strict</span>
<a name="line-1779"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectArgs</span> <span class='hs-varid'>e</span>
<a name="line-1780"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>viewProd</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>cd</span>
<a name="line-1781"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ds</span> <span class='hs-varid'>args</span>
<a name="line-1782"></a>    <span class='hs-varid'>go_one</span> <span class='hs-varid'>env</span> <span class='hs-keyword'>_</span>               <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-1783"></a>
<a name="line-1784"></a><span class='hs-comment'>{-
<a name="line-1785"></a>Note [spec_usg includes rhs_usg]
<a name="line-1786"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1787"></a>In calls to 'specialise', the returned ScUsage must include the rhs_usg in
<a name="line-1788"></a>the passed-in SpecInfo, unless there are no calls at all to the function.
<a name="line-1789"></a>
<a name="line-1790"></a>The caller can, indeed must, assume this.  They should not combine in rhs_usg
<a name="line-1791"></a>themselves, or they'll get rhs_usg twice -- and that can lead to an exponential
<a name="line-1792"></a>blowup of duplicates in the CallEnv.  This is what gave rise to the massive
<a name="line-1793"></a>performance loss in #8852.
<a name="line-1794"></a>
<a name="line-1795"></a>Note [Specialise original body]
<a name="line-1796"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1797"></a>The RhsInfo for a binding keeps the *original* body of the binding.  We
<a name="line-1798"></a>must specialise that, *not* the result of applying specExpr to the RHS
<a name="line-1799"></a>(which is also kept in RhsInfo). Otherwise we end up specialising a
<a name="line-1800"></a>specialised RHS, and that can lead directly to exponential behaviour.
<a name="line-1801"></a>
<a name="line-1802"></a>Note [Transfer activation]
<a name="line-1803"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1804"></a>  This note is for SpecConstr, but exactly the same thing
<a name="line-1805"></a>  happens in the overloading specialiser; see
<a name="line-1806"></a>  Note [Auto-specialisation and RULES] in GHC.Core.Opt.Specialise.
<a name="line-1807"></a>
<a name="line-1808"></a>In which phase should the specialise-constructor rules be active?
<a name="line-1809"></a>Originally I made them always-active, but Manuel found that this
<a name="line-1810"></a>defeated some clever user-written rules.  Then I made them active only
<a name="line-1811"></a>in FinalPhase; after all, currently, the specConstr transformation is
<a name="line-1812"></a>only run after the simplifier has reached FinalPhase, but that meant
<a name="line-1813"></a>that specialisations didn't fire inside wrappers; see test
<a name="line-1814"></a>simplCore/should_compile/spec-inline.
<a name="line-1815"></a>
<a name="line-1816"></a>So now I just use the inline-activation of the parent Id, as the
<a name="line-1817"></a>activation for the specialisation RULE, just like the main specialiser;
<a name="line-1818"></a>
<a name="line-1819"></a>This in turn means there is no point in specialising NOINLINE things,
<a name="line-1820"></a>so we test for that.
<a name="line-1821"></a>
<a name="line-1822"></a>Note [Transfer strictness]
<a name="line-1823"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1824"></a>We must transfer strictness information from the original function to
<a name="line-1825"></a>the specialised one.  Suppose, for example
<a name="line-1826"></a>
<a name="line-1827"></a>  f has strictness     SSx
<a name="line-1828"></a>        and a RULE     f (a:as) b = f_spec a as b
<a name="line-1829"></a>
<a name="line-1830"></a>Now we want f_spec to have strictness  LLSx, otherwise we'll use call-by-need
<a name="line-1831"></a>when calling f_spec instead of call-by-value.  And that can result in
<a name="line-1832"></a>unbounded worsening in space (cf the classic foldl vs foldl')
<a name="line-1833"></a>
<a name="line-1834"></a>See #3437 for a good example.
<a name="line-1835"></a>
<a name="line-1836"></a>The function calcSpecStrictness performs the calculation.
<a name="line-1837"></a>
<a name="line-1838"></a>Note [Strictness information in worker binders]
<a name="line-1839"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1840"></a>
<a name="line-1841"></a>After having calculated the strictness annotation for the worker (see Note
<a name="line-1842"></a>[Transfer strictness] above), we also want to have this information attached to
<a name="line-1843"></a>the worker’s arguments, for the benefit of later passes. The function
<a name="line-1844"></a>handOutStrictnessInformation decomposes the strictness annotation calculated by
<a name="line-1845"></a>calcSpecStrictness and attaches them to the variables.
<a name="line-1846"></a>
<a name="line-1847"></a>************************************************************************
<a name="line-1848"></a>*                                                                      *
<a name="line-1849"></a>\subsection{Argument analysis}
<a name="line-1850"></a>*                                                                      *
<a name="line-1851"></a>************************************************************************
<a name="line-1852"></a>
<a name="line-1853"></a>This code deals with analysing call-site arguments to see whether
<a name="line-1854"></a>they are constructor applications.
<a name="line-1855"></a>
<a name="line-1856"></a>Note [Free type variables of the qvar types]
<a name="line-1857"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1858"></a>In a call (f @a x True), that we want to specialise, what variables should
<a name="line-1859"></a>we quantify over.  Clearly over 'a' and 'x', but what about any type variables
<a name="line-1860"></a>free in x's type?  In fact we don't need to worry about them because (f @a)
<a name="line-1861"></a>can only be a well-typed application if its type is compatible with x, so any
<a name="line-1862"></a>variables free in x's type must be free in (f @a), and hence either be gathered
<a name="line-1863"></a>via 'a' itself, or be in scope at f's defn.  Hence we just take
<a name="line-1864"></a>  (exprsFreeVars pats).
<a name="line-1865"></a>
<a name="line-1866"></a>BUT phantom type synonyms can mess this reasoning up,
<a name="line-1867"></a>  eg   x::T b   with  type T b = Int
<a name="line-1868"></a>So we apply expandTypeSynonyms to the bound Ids.
<a name="line-1869"></a>See # 5458.  Yuk.
<a name="line-1870"></a>
<a name="line-1871"></a>Note [SpecConstr call patterns]
<a name="line-1872"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1873"></a>A "call patterns" that we collect is going to become the LHS of a RULE.
<a name="line-1874"></a>It's important that it doesn't have
<a name="line-1875"></a>     e |&gt; Refl
<a name="line-1876"></a>or
<a name="line-1877"></a>    e |&gt; g1 |&gt; g2
<a name="line-1878"></a>because both of these will be optimised by Simplify.simplRule. In the
<a name="line-1879"></a>former case such optimisation benign, because the rule will match more
<a name="line-1880"></a>terms; but in the latter we may lose a binding of 'g1' or 'g2', and
<a name="line-1881"></a>end up with a rule LHS that doesn't bind the template variables
<a name="line-1882"></a>(#10602).
<a name="line-1883"></a>
<a name="line-1884"></a>The simplifier eliminates such things, but SpecConstr itself constructs
<a name="line-1885"></a>new terms by substituting.  So the 'mkCast' in the Cast case of scExpr
<a name="line-1886"></a>is very important!
<a name="line-1887"></a>
<a name="line-1888"></a>Note [Choosing patterns]
<a name="line-1889"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1890"></a>If we get lots of patterns we may not want to make a specialisation
<a name="line-1891"></a>for each of them (code bloat), so we choose as follows, implemented
<a name="line-1892"></a>by trim_pats.
<a name="line-1893"></a>
<a name="line-1894"></a>* The flag -fspec-constr-count-N sets the sc_count field
<a name="line-1895"></a>  of the ScEnv to (Just n).  This limits the total number
<a name="line-1896"></a>  of specialisations for a given function to N.
<a name="line-1897"></a>
<a name="line-1898"></a>* -fno-spec-constr-count sets the sc_count field to Nothing,
<a name="line-1899"></a>  which switches of the limit.
<a name="line-1900"></a>
<a name="line-1901"></a>* The ghastly ForceSpecConstr trick also switches of the limit
<a name="line-1902"></a>  for a particular function
<a name="line-1903"></a>
<a name="line-1904"></a>* Otherwise we sort the patterns to choose the most general
<a name="line-1905"></a>  ones first; more general =&gt; more widely applicable.
<a name="line-1906"></a>
<a name="line-1907"></a>Note [SpecConstr and casts]
<a name="line-1908"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1909"></a>Consider (#14270) a call like
<a name="line-1910"></a>
<a name="line-1911"></a>    let f = e
<a name="line-1912"></a>    in ... f (K @(a |&gt; co)) ...
<a name="line-1913"></a>
<a name="line-1914"></a>where 'co' is a coercion variable not in scope at f's definition site.
<a name="line-1915"></a>If we aren't caereful we'll get
<a name="line-1916"></a>
<a name="line-1917"></a>    let $sf a co = e (K @(a |&gt; co))
<a name="line-1918"></a>        RULE "SC:f" forall a co.  f (K @(a |&gt; co)) = $sf a co
<a name="line-1919"></a>        f = e
<a name="line-1920"></a>    in ...
<a name="line-1921"></a>
<a name="line-1922"></a>But alas, when we match the call we won't bind 'co', because type-matching
<a name="line-1923"></a>(for good reasons) discards casts).
<a name="line-1924"></a>
<a name="line-1925"></a>I don't know how to solve this, so for now I'm just discarding any
<a name="line-1926"></a>call patterns that
<a name="line-1927"></a>  * Mentions a coercion variable in a type argument
<a name="line-1928"></a>  * That is not in scope at the binding of the function
<a name="line-1929"></a>
<a name="line-1930"></a>I think this is very rare.
<a name="line-1931"></a>
<a name="line-1932"></a>It is important (e.g. #14936) that this /only/ applies to
<a name="line-1933"></a>coercions mentioned in casts.  We don't want to be discombobulated
<a name="line-1934"></a>by casts in terms!  For example, consider
<a name="line-1935"></a>   f ((e1,e2) |&gt; sym co)
<a name="line-1936"></a>where, say,
<a name="line-1937"></a>   f  :: Foo -&gt; blah
<a name="line-1938"></a>   co :: Foo ~R (Int,Int)
<a name="line-1939"></a>
<a name="line-1940"></a>Here we definitely do want to specialise for that pair!  We do not
<a name="line-1941"></a>match on the structure of the coercion; instead we just match on a
<a name="line-1942"></a>coercion variable, so the RULE looks like
<a name="line-1943"></a>
<a name="line-1944"></a>   forall (x::Int, y::Int, co :: (Int,Int) ~R Foo)
<a name="line-1945"></a>     f ((x,y) |&gt; co) = $sf x y co
<a name="line-1946"></a>
<a name="line-1947"></a>Often the body of f looks like
<a name="line-1948"></a>   f arg = ...(case arg |&gt; co' of
<a name="line-1949"></a>                (x,y) -&gt; blah)...
<a name="line-1950"></a>
<a name="line-1951"></a>so that the specialised f will turn into
<a name="line-1952"></a>   $sf x y co = let arg = (x,y) |&gt; co
<a name="line-1953"></a>                in ...(case arg&gt;| co' of
<a name="line-1954"></a>                         (x,y) -&gt; blah)....
<a name="line-1955"></a>
<a name="line-1956"></a>which will simplify to not use 'co' at all.  But we can't guarantee
<a name="line-1957"></a>that co will end up unused, so we still pass it.  Absence analysis
<a name="line-1958"></a>may remove it later.
<a name="line-1959"></a>
<a name="line-1960"></a>Note that this /also/ discards the call pattern if we have a cast in a
<a name="line-1961"></a>/term/, although in fact Rules.match does make a very flaky and
<a name="line-1962"></a>fragile attempt to match coercions.  e.g. a call like
<a name="line-1963"></a>    f (Maybe Age) (Nothing |&gt; co) blah
<a name="line-1964"></a>    where co :: Maybe Int ~ Maybe Age
<a name="line-1965"></a>will be discarded.  It's extremely fragile to match on the form of a
<a name="line-1966"></a>coercion, so I think it's better just not to try.  A more complicated
<a name="line-1967"></a>alternative would be to discard calls that mention coercion variables
<a name="line-1968"></a>only in kind-casts, but I'm doing the simple thing for now.
<a name="line-1969"></a>-}</span>
<a name="line-1970"></a>
<a name="line-1971"></a><a name="CallPat"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CallPat</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Var</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Quantified variables and arguments</span>
<a name="line-1972"></a>                                        <span class='hs-comment'>-- See Note [SpecConstr call patterns]</span>
<a name="line-1973"></a>
<a name="line-1974"></a><a name="callsToNewPats"></a><span class='hs-definition'>callsToNewPats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-1975"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SpecInfo</span>
<a name="line-1976"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Call</span><span class='hs-keyglyph'>]</span>
<a name="line-1977"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CallPat</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1978"></a>        <span class='hs-comment'>-- Result has no duplicate patterns,</span>
<a name="line-1979"></a>        <span class='hs-comment'>-- nor ones mentioned in done_pats</span>
<a name="line-1980"></a>        <span class='hs-comment'>-- Bool indicates that there was at least one boring pattern</span>
<a name="line-1981"></a><span class='hs-definition'>callsToNewPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>spec_info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>done_specs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>bndr_occs</span> <span class='hs-varid'>calls</span>
<a name="line-1982"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>mb_pats</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>callToPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr_occs</span><span class='hs-layout'>)</span> <span class='hs-varid'>calls</span>
<a name="line-1983"></a>
<a name="line-1984"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>have_boring_call</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isNothing</span> <span class='hs-varid'>mb_pats</span>
<a name="line-1985"></a>
<a name="line-1986"></a>              <span class='hs-varid'>good_pats</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CallPat</span><span class='hs-keyglyph'>]</span>
<a name="line-1987"></a>              <span class='hs-varid'>good_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>catMaybes</span> <span class='hs-varid'>mb_pats</span>
<a name="line-1988"></a>
<a name="line-1989"></a>              <span class='hs-comment'>-- Remove patterns we have already done</span>
<a name="line-1990"></a>              <span class='hs-varid'>new_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-varid'>is_done</span> <span class='hs-varid'>good_pats</span>
<a name="line-1991"></a>              <span class='hs-varid'>is_done</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>samePat</span> <span class='hs-varid'>p</span> <span class='hs-varop'>.</span> <span class='hs-varid'>os_pat</span><span class='hs-layout'>)</span> <span class='hs-varid'>done_specs</span>
<a name="line-1992"></a>
<a name="line-1993"></a>              <span class='hs-comment'>-- Remove duplicates</span>
<a name="line-1994"></a>              <span class='hs-varid'>non_dups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nubBy</span> <span class='hs-varid'>samePat</span> <span class='hs-varid'>new_pats</span>
<a name="line-1995"></a>
<a name="line-1996"></a>              <span class='hs-comment'>-- Remove ones that have too many worker variables</span>
<a name="line-1997"></a>              <span class='hs-varid'>small_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-varid'>too_big</span> <span class='hs-varid'>non_dups</span>
<a name="line-1998"></a>              <span class='hs-varid'>too_big</span> <span class='hs-layout'>(</span><span class='hs-varid'>vars</span><span class='hs-layout'>,</span><span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWorkerSmallEnough</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>valArgCount</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>vars</span><span class='hs-layout'>)</span>
<a name="line-1999"></a>                  <span class='hs-comment'>-- We are about to construct w/w pair in 'spec_one'.</span>
<a name="line-2000"></a>                  <span class='hs-comment'>-- Omit specialisation leading to high arity workers.</span>
<a name="line-2001"></a>                  <span class='hs-comment'>-- See Note [Limit w/w arity] in GHC.Core.Opt.WorkWrap.Utils</span>
<a name="line-2002"></a>
<a name="line-2003"></a>                <span class='hs-comment'>-- Discard specialisations if there are too many of them</span>
<a name="line-2004"></a>              <span class='hs-varid'>trimmed_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trim_pats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>spec_info</span> <span class='hs-varid'>small_pats</span>
<a name="line-2005"></a>
<a name="line-2006"></a><span class='hs-comment'>--        ; pprTrace "callsToPats" (vcat [ text "calls to" &lt;+&gt; ppr fn &lt;&gt; colon &lt;+&gt; ppr calls</span>
<a name="line-2007"></a><span class='hs-comment'>--                                       , text "done_specs:" &lt;+&gt; ppr (map os_pat done_specs)</span>
<a name="line-2008"></a><span class='hs-comment'>--                                       , text "good_pats:" &lt;+&gt; ppr good_pats ]) $</span>
<a name="line-2009"></a><span class='hs-comment'>--          return ()</span>
<a name="line-2010"></a>
<a name="line-2011"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>have_boring_call</span><span class='hs-layout'>,</span> <span class='hs-varid'>trimmed_pats</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2012"></a>
<a name="line-2013"></a>
<a name="line-2014"></a><a name="trim_pats"></a><span class='hs-definition'>trim_pats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SpecInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CallPat</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CallPat</span><span class='hs-keyglyph'>]</span>
<a name="line-2015"></a><span class='hs-comment'>-- See Note [Choosing patterns]</span>
<a name="line-2016"></a><span class='hs-definition'>trim_pats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>(</span><span class='hs-conid'>SI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>si_n_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>done_spec_count</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>pats</span>
<a name="line-2017"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sc_force</span> <span class='hs-varid'>env</span>
<a name="line-2018"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>isNothing</span> <span class='hs-varid'>mb_scc</span>
<a name="line-2019"></a>    <span class='hs-varop'>||</span> <span class='hs-varid'>n_remaining</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>n_pats</span>
<a name="line-2020"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "trim_pats: no-trim" (ppr (sc_force env) $$ ppr mb_scc $$ ppr n_remaining $$ ppr n_pats)</span>
<a name="line-2021"></a>    <span class='hs-varid'>pats</span>          <span class='hs-comment'>-- No need to trim</span>
<a name="line-2022"></a>
<a name="line-2023"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2024"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emit_trace</span> <span class='hs-varop'>$</span>  <span class='hs-comment'>-- Need to trim, so keep the best ones</span>
<a name="line-2025"></a>    <span class='hs-varid'>take</span> <span class='hs-varid'>n_remaining</span> <span class='hs-varid'>sorted_pats</span>
<a name="line-2026"></a>
<a name="line-2027"></a>  <span class='hs-keyword'>where</span>
<a name="line-2028"></a>    <span class='hs-varid'>n_pats</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>pats</span>
<a name="line-2029"></a>    <span class='hs-varid'>spec_count'</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_pats</span> <span class='hs-varop'>+</span> <span class='hs-varid'>done_spec_count</span>
<a name="line-2030"></a>    <span class='hs-varid'>n_remaining</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>max_specs</span> <span class='hs-comment'>-</span> <span class='hs-varid'>done_spec_count</span>
<a name="line-2031"></a>    <span class='hs-varid'>mb_scc</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sc_count</span> <span class='hs-varid'>env</span>
<a name="line-2032"></a>    <span class='hs-conid'>Just</span> <span class='hs-varid'>max_specs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mb_scc</span>
<a name="line-2033"></a>
<a name="line-2034"></a>    <span class='hs-varid'>sorted_pats</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span>
<a name="line-2035"></a>                  <span class='hs-varid'>sortBy</span> <span class='hs-layout'>(</span><span class='hs-varid'>comparing</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2036"></a>                  <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>pat</span><span class='hs-layout'>,</span> <span class='hs-varid'>pat_cons</span> <span class='hs-varid'>pat</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pat</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pats</span><span class='hs-keyglyph'>]</span>
<a name="line-2037"></a>     <span class='hs-comment'>-- Sort in order of increasing number of constructors</span>
<a name="line-2038"></a>     <span class='hs-comment'>-- (i.e. decreasing generality) and pick the initial</span>
<a name="line-2039"></a>     <span class='hs-comment'>-- segment of this list</span>
<a name="line-2040"></a>
<a name="line-2041"></a>    <span class='hs-varid'>pat_cons</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CallPat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-2042"></a>    <span class='hs-comment'>-- How many data constructors of literals are in</span>
<a name="line-2043"></a>    <span class='hs-comment'>-- the pattern.  More data-cons =&gt; less general</span>
<a name="line-2044"></a>    <span class='hs-varid'>pat_cons</span> <span class='hs-layout'>(</span><span class='hs-varid'>qs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ps</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-varop'>.</span> <span class='hs-varid'>n_cons</span><span class='hs-layout'>)</span> <span class='hs-num'>0</span> <span class='hs-varid'>ps</span>
<a name="line-2045"></a>       <span class='hs-keyword'>where</span>
<a name="line-2046"></a>          <span class='hs-varid'>q_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>qs</span>
<a name="line-2047"></a>          <span class='hs-varid'>n_cons</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>q_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-2048"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>            <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-2049"></a>          <span class='hs-varid'>n_cons</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_cons</span> <span class='hs-varid'>e</span>
<a name="line-2050"></a>          <span class='hs-varid'>n_cons</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_cons</span> <span class='hs-varid'>e1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n_cons</span> <span class='hs-varid'>e2</span>
<a name="line-2051"></a>          <span class='hs-varid'>n_cons</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-2052"></a>          <span class='hs-varid'>n_cons</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-2053"></a>
<a name="line-2054"></a>    <span class='hs-varid'>emit_trace</span> <span class='hs-varid'>result</span>
<a name="line-2055"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>debugIsOn</span> <span class='hs-varop'>||</span> <span class='hs-varid'>hasPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_dflags</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-2056"></a>         <span class='hs-comment'>-- Suppress this scary message for ordinary users!  #5125</span>
<a name="line-2057"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprTrace</span> <span class='hs-str'>"SpecConstr"</span> <span class='hs-varid'>msg</span> <span class='hs-varid'>result</span>
<a name="line-2058"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2059"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>result</span>
<a name="line-2060"></a>    <span class='hs-varid'>msg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Function"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fn</span><span class='hs-layout'>)</span>
<a name="line-2061"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>nest</span> <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"has"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-2062"></a>                               <span class='hs-varid'>speakNOf</span> <span class='hs-varid'>spec_count'</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"call pattern"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-2063"></a>                               <span class='hs-varid'>text</span> <span class='hs-str'>"but the limit is"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>max_specs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-2064"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Use -fspec-constr-count=n to set the bound"</span>
<a name="line-2065"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"done_spec_count ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>done_spec_count</span>
<a name="line-2066"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Keeping "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>n_remaining</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>", out of"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>n_pats</span>
<a name="line-2067"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Discarding:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>drop</span> <span class='hs-varid'>n_remaining</span> <span class='hs-varid'>sorted_pats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-2068"></a>
<a name="line-2069"></a>
<a name="line-2070"></a><a name="callToPats"></a><span class='hs-definition'>callToPats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Call</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>CallPat</span><span class='hs-layout'>)</span>
<a name="line-2071"></a>        <span class='hs-comment'>-- The [Var] is the variables to quantify over in the rule</span>
<a name="line-2072"></a>        <span class='hs-comment'>--      Type variables come first, since they may scope</span>
<a name="line-2073"></a>        <span class='hs-comment'>--      over the following term variables</span>
<a name="line-2074"></a>        <span class='hs-comment'>-- The [CoreExpr] are the argument patterns for the rule</span>
<a name="line-2075"></a><span class='hs-definition'>callToPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>bndr_occs</span> <span class='hs-varid'>call</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Call</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span> <span class='hs-varid'>con_env</span><span class='hs-layout'>)</span>
<a name="line-2076"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`ltLength`</span> <span class='hs-varid'>bndr_occs</span>      <span class='hs-comment'>-- Check saturated</span>
<a name="line-2077"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span>
<a name="line-2078"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2079"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>in_scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substInScope</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_subst</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-2080"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>interesting</span><span class='hs-layout'>,</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>argsToPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>con_env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>bndr_occs</span>
<a name="line-2081"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pat_fvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprsFreeVarsList</span> <span class='hs-varid'>pats</span>
<a name="line-2082"></a>                <span class='hs-comment'>-- To get determinism we need the list of free variables in</span>
<a name="line-2083"></a>                <span class='hs-comment'>-- deterministic order. Otherwise we end up creating</span>
<a name="line-2084"></a>                <span class='hs-comment'>-- lambdas with different argument orders. See</span>
<a name="line-2085"></a>                <span class='hs-comment'>-- determinism/simplCore/should_compile/spec-inline-determ.hs</span>
<a name="line-2086"></a>                <span class='hs-comment'>-- for an example. For explanation of determinism</span>
<a name="line-2087"></a>                <span class='hs-comment'>-- considerations See Note [Unique Determinism] in GHC.Types.Unique.</span>
<a name="line-2088"></a>
<a name="line-2089"></a>              <span class='hs-varid'>in_scope_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getInScopeVars</span> <span class='hs-varid'>in_scope</span>
<a name="line-2090"></a>              <span class='hs-varid'>is_in_scope</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>in_scope_vars</span>
<a name="line-2091"></a>              <span class='hs-varid'>qvars</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-varid'>is_in_scope</span> <span class='hs-varid'>pat_fvs</span>
<a name="line-2092"></a>                <span class='hs-comment'>-- Quantify over variables that are not in scope</span>
<a name="line-2093"></a>                <span class='hs-comment'>-- at the call site</span>
<a name="line-2094"></a>                <span class='hs-comment'>-- See Note [Free type variables of the qvar types]</span>
<a name="line-2095"></a>                <span class='hs-comment'>-- See Note [Shadowing] at the top</span>
<a name="line-2096"></a>
<a name="line-2097"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>ktvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ids</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partition</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>qvars</span>
<a name="line-2098"></a>              <span class='hs-varid'>qvars'</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scopedSort</span> <span class='hs-varid'>ktvs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>map</span> <span class='hs-varid'>sanitise</span> <span class='hs-varid'>ids</span>
<a name="line-2099"></a>                <span class='hs-comment'>-- Order into kind variables, type variables, term variables</span>
<a name="line-2100"></a>                <span class='hs-comment'>-- The kind of a type variable may mention a kind variable</span>
<a name="line-2101"></a>                <span class='hs-comment'>-- and the type of a term variable may mention a type variable</span>
<a name="line-2102"></a>
<a name="line-2103"></a>              <span class='hs-varid'>sanitise</span> <span class='hs-varid'>id</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updateIdTypeAndMult</span> <span class='hs-varid'>expandTypeSynonyms</span> <span class='hs-varid'>id</span>
<a name="line-2104"></a>                <span class='hs-comment'>-- See Note [Free type variables of the qvar types]</span>
<a name="line-2105"></a>
<a name="line-2106"></a>              <span class='hs-comment'>-- Bad coercion variables: see Note [SpecConstr and casts]</span>
<a name="line-2107"></a>              <span class='hs-varid'>bad_covars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoVarSet</span>
<a name="line-2108"></a>              <span class='hs-varid'>bad_covars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapUnionVarSet</span> <span class='hs-varid'>get_bad_covars</span> <span class='hs-varid'>pats</span>
<a name="line-2109"></a>              <span class='hs-varid'>get_bad_covars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreArg</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoVarSet</span>
<a name="line-2110"></a>              <span class='hs-varid'>get_bad_covars</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-2111"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterVarSet</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>v</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_in_scope</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2112"></a>                  <span class='hs-varid'>tyCoVarsOfType</span> <span class='hs-varid'>ty</span>
<a name="line-2113"></a>              <span class='hs-varid'>get_bad_covars</span> <span class='hs-keyword'>_</span>
<a name="line-2114"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyVarSet</span>
<a name="line-2115"></a>
<a name="line-2116"></a>        <span class='hs-layout'>;</span> <span class='hs-comment'>-- pprTrace "callToPats"  (ppr args $$ ppr bndr_occs) $</span>
<a name="line-2117"></a>          <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>bad_covars</span><span class='hs-layout'>)</span>
<a name="line-2118"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"SpecConstr: bad covars:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bad_covars</span>
<a name="line-2119"></a>                <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>call</span> <span class='hs-layout'>)</span>
<a name="line-2120"></a>          <span class='hs-keyword'>if</span> <span class='hs-varid'>interesting</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>bad_covars</span>
<a name="line-2121"></a>          <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>qvars'</span><span class='hs-layout'>,</span> <span class='hs-varid'>pats</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2122"></a>          <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-2123"></a>
<a name="line-2124"></a>    <span class='hs-comment'>-- argToPat takes an actual argument, and returns an abstracted</span>
<a name="line-2125"></a>    <span class='hs-comment'>-- version, consisting of just the "constructor skeleton" of the</span>
<a name="line-2126"></a>    <span class='hs-comment'>-- argument, with non-constructor sub-expression replaced by new</span>
<a name="line-2127"></a>    <span class='hs-comment'>-- placeholder variables.  For example:</span>
<a name="line-2128"></a>    <span class='hs-comment'>--    C a (D (f x) (g y))  ==&gt;  C p1 (D p2 p3)</span>
<a name="line-2129"></a>
<a name="line-2130"></a><a name="argToPat"></a><span class='hs-definition'>argToPat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span>
<a name="line-2131"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeSet</span>                  <span class='hs-comment'>-- What's in scope at the fn defn site</span>
<a name="line-2132"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ValueEnv</span>                    <span class='hs-comment'>-- ValueEnv at the call site</span>
<a name="line-2133"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreArg</span>                     <span class='hs-comment'>-- A call arg (or component thereof)</span>
<a name="line-2134"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgOcc</span>
<a name="line-2135"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreArg</span><span class='hs-layout'>)</span>
<a name="line-2136"></a>
<a name="line-2137"></a><span class='hs-comment'>-- Returns (interesting, pat),</span>
<a name="line-2138"></a><span class='hs-comment'>-- where pat is the pattern derived from the argument</span>
<a name="line-2139"></a><span class='hs-comment'>--            interesting=True if the pattern is non-trivial (not a variable or type)</span>
<a name="line-2140"></a><span class='hs-comment'>-- E.g.         x:xs         --&gt; (True, x:xs)</span>
<a name="line-2141"></a><span class='hs-comment'>--              f xs         --&gt; (False, w)        where w is a fresh wildcard</span>
<a name="line-2142"></a><span class='hs-comment'>--              (f xs, 'c')  --&gt; (True, (w, 'c'))  where w is a fresh wildcard</span>
<a name="line-2143"></a><span class='hs-comment'>--              \x. x+y      --&gt; (True, \x. x+y)</span>
<a name="line-2144"></a><span class='hs-comment'>--              lvl7         --&gt; (True, lvl7)      if lvl7 is bound</span>
<a name="line-2145"></a><span class='hs-comment'>--                                                 somewhere further out</span>
<a name="line-2146"></a>
<a name="line-2147"></a><span class='hs-definition'>argToPat</span> <span class='hs-sel'>_env</span> <span class='hs-sel'>_in_scope</span> <span class='hs-sel'>_val_env</span> <span class='hs-varid'>arg</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-sel'>_arg_occ</span>
<a name="line-2148"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-2149"></a>
<a name="line-2150"></a><span class='hs-definition'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2151"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2152"></a>        <span class='hs-comment'>-- Note [Tick annotations in call patterns]</span>
<a name="line-2153"></a>        <span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-2154"></a>        <span class='hs-comment'>-- Ignore Notes.  In particular, we want to ignore any InlineMe notes</span>
<a name="line-2155"></a>        <span class='hs-comment'>-- Perhaps we should not ignore profiling notes, but I'm going to</span>
<a name="line-2156"></a>        <span class='hs-comment'>-- ride roughshod over them all for now.</span>
<a name="line-2157"></a>        <span class='hs-comment'>--- See Note [Tick annotations in RULE matching] in GHC.Core.Rules</span>
<a name="line-2158"></a>
<a name="line-2159"></a><span class='hs-definition'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2160"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2161"></a>        <span class='hs-comment'>-- See Note [Matching lets] in "GHC.Core.Rules"</span>
<a name="line-2162"></a>        <span class='hs-comment'>-- Look through let expressions</span>
<a name="line-2163"></a>        <span class='hs-comment'>-- e.g.         f (let v = rhs in (v,w))</span>
<a name="line-2164"></a>        <span class='hs-comment'>-- Here we can specialise for f (v,w)</span>
<a name="line-2165"></a>        <span class='hs-comment'>-- because the rule-matcher will look through the let.</span>
<a name="line-2166"></a>
<a name="line-2167"></a><span class='hs-comment'>{- Disabled; see Note [Matching cases] in "GHC.Core.Rules"
<a name="line-2168"></a>argToPat env in_scope val_env (Case scrut _ _ [(_, _, rhs)]) arg_occ
<a name="line-2169"></a>  | exprOkForSpeculation scrut  -- See Note [Matching cases] in "GHC.Core.Rules"
<a name="line-2170"></a>  = argToPat env in_scope val_env rhs arg_occ
<a name="line-2171"></a>-}</span>
<a name="line-2172"></a>
<a name="line-2173"></a><span class='hs-definition'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2174"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>ignoreType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-2175"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>interesting</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2176"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-varid'>interesting</span> <span class='hs-keyword'>then</span>
<a name="line-2177"></a>                <span class='hs-varid'>wildCardPat</span> <span class='hs-varid'>ty2</span>
<a name="line-2178"></a>          <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span>
<a name="line-2179"></a>        <span class='hs-layout'>{</span> <span class='hs-comment'>-- Make a wild-card pattern for the coercion</span>
<a name="line-2180"></a>          <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-2181"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysTvName</span> <span class='hs-varid'>uniq</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"sg"</span><span class='hs-layout'>)</span>
<a name="line-2182"></a>              <span class='hs-varid'>co_var</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoVar</span> <span class='hs-varid'>co_name</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoercionType</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-2183"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>interesting</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>arg'</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCoVarCo</span> <span class='hs-varid'>co_var</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-2184"></a>  <span class='hs-keyword'>where</span>
<a name="line-2185"></a>    <span class='hs-conid'>Pair</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionKind</span> <span class='hs-varid'>co</span>
<a name="line-2186"></a>
<a name="line-2187"></a>
<a name="line-2188"></a>
<a name="line-2189"></a><span class='hs-comment'>{-      Disabling lambda specialisation for now
<a name="line-2190"></a>        It's fragile, and the spec_loop can be infinite
<a name="line-2191"></a>argToPat in_scope val_env arg arg_occ
<a name="line-2192"></a>  | is_value_lam arg
<a name="line-2193"></a>  = return (True, arg)
<a name="line-2194"></a>  where
<a name="line-2195"></a>    is_value_lam (Lam v e)         -- Spot a value lambda, even if
<a name="line-2196"></a>        | isId v       = True      -- it is inside a type lambda
<a name="line-2197"></a>        | otherwise    = is_value_lam e
<a name="line-2198"></a>    is_value_lam other = False
<a name="line-2199"></a>-}</span>
<a name="line-2200"></a>
<a name="line-2201"></a>  <span class='hs-comment'>-- Check for a constructor application</span>
<a name="line-2202"></a>  <span class='hs-comment'>-- NB: this *precedes* the Var case, so that we catch nullary constrs</span>
<a name="line-2203"></a><span class='hs-definition'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2204"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isValue</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>arg</span>
<a name="line-2205"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>ignoreDataCon</span> <span class='hs-varid'>env</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- See Note [NoSpecConstr]</span>
<a name="line-2206"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>arg_occs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_scrut</span> <span class='hs-varid'>dc</span>
<a name="line-2207"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>  <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty_args</span><span class='hs-layout'>,</span> <span class='hs-varid'>rest_args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAtList</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConUnivTyVars</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span>
<a name="line-2208"></a>        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>argsToPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>rest_args</span> <span class='hs-varid'>arg_occs</span>
<a name="line-2209"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span>
<a name="line-2210"></a>                  <span class='hs-varid'>mkConApp</span> <span class='hs-varid'>dc</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty_args</span> <span class='hs-varop'>++</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2211"></a>  <span class='hs-keyword'>where</span>
<a name="line-2212"></a>    <span class='hs-varid'>mb_scrut</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg_occ</span> <span class='hs-keyword'>of</span>
<a name="line-2213"></a>                    <span class='hs-conid'>ScrutOcc</span> <span class='hs-varid'>bs</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>occs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupUFM</span> <span class='hs-varid'>bs</span> <span class='hs-varid'>dc</span>
<a name="line-2214"></a>                                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>occs</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See Note [Reboxing]</span>
<a name="line-2215"></a>                    <span class='hs-sel'>_other</span>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sc_force</span> <span class='hs-varid'>env</span> <span class='hs-varop'>||</span> <span class='hs-varid'>sc_keen</span> <span class='hs-varid'>env</span>
<a name="line-2216"></a>                                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>UnkOcc</span><span class='hs-layout'>)</span>
<a name="line-2217"></a>                                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2218"></a>                                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-2219"></a>
<a name="line-2220"></a>  <span class='hs-comment'>-- Check if the argument is a variable that</span>
<a name="line-2221"></a>  <span class='hs-comment'>--    (a) is used in an interesting way in the function body</span>
<a name="line-2222"></a>  <span class='hs-comment'>--    (b) we know what its value is</span>
<a name="line-2223"></a>  <span class='hs-comment'>-- In that case it counts as "interesting"</span>
<a name="line-2224"></a><span class='hs-definition'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_occ</span>
<a name="line-2225"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sc_force</span> <span class='hs-varid'>env</span> <span class='hs-varop'>||</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg_occ</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>UnkOcc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span><span class='hs-layout'>;</span> <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- (a)</span>
<a name="line-2226"></a>    <span class='hs-varid'>is_value</span><span class='hs-layout'>,</span>                                                            <span class='hs-comment'>-- (b)</span>
<a name="line-2227"></a>       <span class='hs-comment'>-- Ignoring sc_keen here to avoid gratuitously incurring Note [Reboxing]</span>
<a name="line-2228"></a>       <span class='hs-comment'>-- So sc_keen focused just on f (I# x), where we have freshly-allocated</span>
<a name="line-2229"></a>       <span class='hs-comment'>-- box that we can eliminate in the caller</span>
<a name="line-2230"></a>    <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>ignoreType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2231"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-2232"></a>  <span class='hs-keyword'>where</span>
<a name="line-2233"></a>    <span class='hs-varid'>is_value</span>
<a name="line-2234"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isLocalId</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`elemInScopeSet`</span> <span class='hs-varid'>in_scope</span>
<a name="line-2235"></a>                        <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-2236"></a>                <span class='hs-comment'>-- Local variables have values in val_env</span>
<a name="line-2237"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isValueUnfolding</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-2238"></a>                <span class='hs-comment'>-- Imports have unfoldings</span>
<a name="line-2239"></a>
<a name="line-2240"></a><span class='hs-comment'>--      I'm really not sure what this comment means</span>
<a name="line-2241"></a><span class='hs-comment'>--      And by not wild-carding we tend to get forall'd</span>
<a name="line-2242"></a><span class='hs-comment'>--      variables that are in scope, which in turn can</span>
<a name="line-2243"></a><span class='hs-comment'>--      expose the weakness in let-matching</span>
<a name="line-2244"></a><span class='hs-comment'>--      See Note [Matching lets] in GHC.Core.Rules</span>
<a name="line-2245"></a>
<a name="line-2246"></a>  <span class='hs-comment'>-- Check for a variable bound inside the function.</span>
<a name="line-2247"></a>  <span class='hs-comment'>-- Don't make a wild-card, because we may usefully share</span>
<a name="line-2248"></a>  <span class='hs-comment'>--    e.g.  f a = let x = ... in f (x,x)</span>
<a name="line-2249"></a>  <span class='hs-comment'>-- NB: this case follows the lambda and con-app cases!!</span>
<a name="line-2250"></a><span class='hs-comment'>-- argToPat _in_scope _val_env (Var v) _arg_occ</span>
<a name="line-2251"></a><span class='hs-comment'>--   = return (False, Var v)</span>
<a name="line-2252"></a>        <span class='hs-comment'>-- SLPJ : disabling this to avoid proliferation of versions</span>
<a name="line-2253"></a>        <span class='hs-comment'>-- also works badly when thinking about seeding the loop</span>
<a name="line-2254"></a>        <span class='hs-comment'>-- from the body of the let</span>
<a name="line-2255"></a>        <span class='hs-comment'>--       f x y = letrec g z = ... in g (x,y)</span>
<a name="line-2256"></a>        <span class='hs-comment'>-- We don't want to specialise for that *particular* x,y</span>
<a name="line-2257"></a>
<a name="line-2258"></a>  <span class='hs-comment'>-- The default case: make a wild-card</span>
<a name="line-2259"></a>  <span class='hs-comment'>-- We use this for coercions too</span>
<a name="line-2260"></a><span class='hs-definition'>argToPat</span> <span class='hs-sel'>_env</span> <span class='hs-sel'>_in_scope</span> <span class='hs-sel'>_val_env</span> <span class='hs-varid'>arg</span> <span class='hs-sel'>_arg_occ</span>
<a name="line-2261"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wildCardPat</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprType</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-2262"></a>
<a name="line-2263"></a><a name="wildCardPat"></a><span class='hs-definition'>wildCardPat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreArg</span><span class='hs-layout'>)</span>
<a name="line-2264"></a><span class='hs-definition'>wildCardPat</span> <span class='hs-varid'>ty</span>
<a name="line-2265"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uniq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getUniqueM</span>
<a name="line-2266"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSysLocalOrCoVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsLit</span> <span class='hs-str'>"sc"</span><span class='hs-layout'>)</span> <span class='hs-varid'>uniq</span> <span class='hs-conid'>Many</span> <span class='hs-varid'>ty</span>
<a name="line-2267"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>varToCoreExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2268"></a>
<a name="line-2269"></a><a name="argsToPats"></a><span class='hs-definition'>argsToPats</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ScEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InScopeSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ValueEnv</span>
<a name="line-2270"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgOcc</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Should be same length</span>
<a name="line-2271"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UniqSM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2272"></a><span class='hs-definition'>argsToPats</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span> <span class='hs-varid'>args</span> <span class='hs-varid'>occs</span>
<a name="line-2273"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWithM</span> <span class='hs-layout'>(</span><span class='hs-varid'>argToPat</span> <span class='hs-varid'>env</span> <span class='hs-varid'>in_scope</span> <span class='hs-varid'>val_env</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-varid'>occs</span>
<a name="line-2274"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>interesting_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unzip</span> <span class='hs-varid'>stuff</span>
<a name="line-2275"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>or</span> <span class='hs-varid'>interesting_s</span><span class='hs-layout'>,</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2276"></a>
<a name="line-2277"></a><a name="isValue"></a><span class='hs-definition'>isValue</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ValueEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Value</span>
<a name="line-2278"></a><span class='hs-definition'>isValue</span> <span class='hs-sel'>_env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-2279"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>litIsLifted</span> <span class='hs-varid'>lit</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-2280"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitAlt</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-2281"></a>
<a name="line-2282"></a><span class='hs-definition'>isValue</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-2283"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cval</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>v</span>
<a name="line-2284"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cval</span>  <span class='hs-comment'>-- You might think we could look in the idUnfolding here</span>
<a name="line-2285"></a>               <span class='hs-comment'>-- but that doesn't take account of which branch of a</span>
<a name="line-2286"></a>               <span class='hs-comment'>-- case we are in, which is the whole point</span>
<a name="line-2287"></a>
<a name="line-2288"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isLocalId</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isCheapUnfolding</span> <span class='hs-varid'>unf</span>
<a name="line-2289"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isValue</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>unfoldingTemplate</span> <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>
<a name="line-2290"></a>  <span class='hs-keyword'>where</span>
<a name="line-2291"></a>    <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>v</span>
<a name="line-2292"></a>        <span class='hs-comment'>-- However we do want to consult the unfolding</span>
<a name="line-2293"></a>        <span class='hs-comment'>-- as well, for let-bound constructors!</span>
<a name="line-2294"></a>
<a name="line-2295"></a><span class='hs-definition'>isValue</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-2296"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isValue</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>of</span>
<a name="line-2297"></a>                  <span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>LambdaVal</span>
<a name="line-2298"></a>                  <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-2299"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>LambdaVal</span>
<a name="line-2300"></a>
<a name="line-2301"></a><span class='hs-definition'>isValue</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-2302"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-2303"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isValue</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-2304"></a>
<a name="line-2305"></a><span class='hs-definition'>isValue</span> <span class='hs-sel'>_env</span> <span class='hs-varid'>expr</span>       <span class='hs-comment'>-- Maybe it's a constructor application</span>
<a name="line-2306"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>args</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectArgsTicks</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>tickishIsCode</span><span class='hs-layout'>)</span> <span class='hs-varid'>expr</span>
<a name="line-2307"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>isDataConWorkId_maybe</span> <span class='hs-varid'>fun</span> <span class='hs-keyword'>of</span>
<a name="line-2308"></a>
<a name="line-2309"></a>        <span class='hs-conid'>Just</span> <span class='hs-varid'>con</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>args</span> <span class='hs-varop'>`lengthAtLeast`</span> <span class='hs-varid'>dataConRepArity</span> <span class='hs-varid'>con</span>
<a name="line-2310"></a>                <span class='hs-comment'>-- Check saturated; might be &gt; because the</span>
<a name="line-2311"></a>                <span class='hs-comment'>--                  arity excludes type args</span>
<a name="line-2312"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataAlt</span> <span class='hs-varid'>con</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-2313"></a>
<a name="line-2314"></a>        <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>valArgCount</span> <span class='hs-varid'>args</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>fun</span>
<a name="line-2315"></a>                <span class='hs-comment'>-- Under-applied function</span>
<a name="line-2316"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-conid'>LambdaVal</span>        <span class='hs-comment'>-- Partial application</span>
<a name="line-2317"></a>
<a name="line-2318"></a>        <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-2319"></a>
<a name="line-2320"></a><span class='hs-definition'>isValue</span> <span class='hs-sel'>_env</span> <span class='hs-sel'>_expr</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-2321"></a>
<a name="line-2322"></a><a name="valueIsWorkFree"></a><span class='hs-definition'>valueIsWorkFree</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Value</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2323"></a><span class='hs-definition'>valueIsWorkFree</span> <span class='hs-conid'>LambdaVal</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2324"></a><span class='hs-definition'>valueIsWorkFree</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConVal</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>exprIsWorkFree</span> <span class='hs-varid'>args</span>
<a name="line-2325"></a>
<a name="line-2326"></a><a name="samePat"></a><span class='hs-definition'>samePat</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CallPat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallPat</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2327"></a><span class='hs-definition'>samePat</span> <span class='hs-layout'>(</span><span class='hs-varid'>vs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>as1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>vs2</span><span class='hs-layout'>,</span> <span class='hs-varid'>as2</span><span class='hs-layout'>)</span>
<a name="line-2328"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all2</span> <span class='hs-varid'>same</span> <span class='hs-varid'>as1</span> <span class='hs-varid'>as2</span>
<a name="line-2329"></a>  <span class='hs-keyword'>where</span>
<a name="line-2330"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v2</span><span class='hs-layout'>)</span>
<a name="line-2331"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v1</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>vs1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v2</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>vs2</span>
<a name="line-2332"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v2</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>vs2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2333"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>v1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>v2</span>
<a name="line-2334"></a>
<a name="line-2335"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span>    <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>l1</span><span class='hs-varop'>==</span><span class='hs-varid'>l2</span>
<a name="line-2336"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>a1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f2</span> <span class='hs-varid'>a2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>same</span> <span class='hs-varid'>f1</span> <span class='hs-varid'>f2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>same</span> <span class='hs-varid'>a1</span> <span class='hs-varid'>a2</span>
<a name="line-2337"></a>
<a name="line-2338"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>     <span class='hs-comment'>-- Note [Ignore type differences]</span>
<a name="line-2339"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2340"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e1</span><span class='hs-layout'>)</span> <span class='hs-varid'>e2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span>  <span class='hs-comment'>-- Ignore casts and notes</span>
<a name="line-2341"></a>    <span class='hs-varid'>same</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e1</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>e2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span>
<a name="line-2342"></a>    <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span>
<a name="line-2343"></a>    <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e2</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span>
<a name="line-2344"></a>
<a name="line-2345"></a>    <span class='hs-varid'>same</span> <span class='hs-varid'>e1</span> <span class='hs-varid'>e2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WARN</span><span class='hs-layout'>(</span> <span class='hs-varid'>bad</span> <span class='hs-varid'>e1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>bad</span> <span class='hs-varid'>e2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>e2</span><span class='hs-layout'>)</span>
<a name="line-2346"></a>                 <span class='hs-conid'>False</span>  <span class='hs-comment'>-- Let, lambda, case should not occur</span>
<a name="line-2347"></a>    <span class='hs-varid'>bad</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2348"></a>    <span class='hs-varid'>bad</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2349"></a>    <span class='hs-varid'>bad</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2350"></a>    <span class='hs-varid'>bad</span> <span class='hs-sel'>_other</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2351"></a>
<a name="line-2352"></a><span class='hs-comment'>{-
<a name="line-2353"></a>Note [Ignore type differences]
<a name="line-2354"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2355"></a>We do not want to generate specialisations where the call patterns
<a name="line-2356"></a>differ only in their type arguments!  Not only is it utterly useless,
<a name="line-2357"></a>but it also means that (with polymorphic recursion) we can generate
<a name="line-2358"></a>an infinite number of specialisations. Example is Data.Sequence.adjustTree,
<a name="line-2359"></a>I think.
<a name="line-2360"></a>-}</span>
</pre></body>
</html>
