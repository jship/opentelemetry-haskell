<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Types/Tickish.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE DataKinds #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE DeriveDataTypeable #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE StandaloneDeriving #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Types.Tickish</span> <span class='hs-layout'>(</span>
<a name="line-9"></a>  <span class='hs-conid'>GenTickish</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-10"></a>  <span class='hs-conid'>CoreTickish</span><span class='hs-layout'>,</span> <span class='hs-conid'>StgTickish</span><span class='hs-layout'>,</span> <span class='hs-conid'>CmmTickish</span><span class='hs-layout'>,</span>
<a name="line-11"></a>  <span class='hs-conid'>XTickishId</span><span class='hs-layout'>,</span>
<a name="line-12"></a>  <span class='hs-varid'>tickishCounts</span><span class='hs-layout'>,</span>
<a name="line-13"></a>  <span class='hs-conid'>TickishScoping</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-14"></a>  <span class='hs-varid'>tickishScoped</span><span class='hs-layout'>,</span>
<a name="line-15"></a>  <span class='hs-varid'>tickishScopesLike</span><span class='hs-layout'>,</span>
<a name="line-16"></a>  <span class='hs-varid'>tickishFloatable</span><span class='hs-layout'>,</span>
<a name="line-17"></a>  <span class='hs-varid'>tickishCanSplit</span><span class='hs-layout'>,</span>
<a name="line-18"></a>  <span class='hs-varid'>mkNoCount</span><span class='hs-layout'>,</span>
<a name="line-19"></a>  <span class='hs-varid'>mkNoScope</span><span class='hs-layout'>,</span>
<a name="line-20"></a>  <span class='hs-varid'>tickishIsCode</span><span class='hs-layout'>,</span>
<a name="line-21"></a>  <span class='hs-conid'>TickishPlacement</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-22"></a>  <span class='hs-varid'>tickishPlace</span><span class='hs-layout'>,</span>
<a name="line-23"></a>  <span class='hs-varid'>tickishContains</span>
<a name="line-24"></a><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-27"></a>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-29"></a>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module</span>
<a name="line-31"></a>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.CostCentre</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span> <span class='hs-layout'>(</span> <span class='hs-conid'>RealSrcSpan</span><span class='hs-layout'>,</span> <span class='hs-varid'>containsSpan</span> <span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-35"></a>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-37"></a>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Extension</span> <span class='hs-layout'>(</span> <span class='hs-conid'>NoExtField</span> <span class='hs-layout'>)</span>
<a name="line-39"></a>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-43"></a>*                                                                      *
<a name="line-44"></a>              Ticks
<a name="line-45"></a>*                                                                      *
<a name="line-46"></a>************************************************************************
<a name="line-47"></a>-}</span>
<a name="line-48"></a>
<a name="line-49"></a><span class='hs-comment'>-- | Allows attaching extra information to points in expressions</span>
<a name="line-50"></a>
<a name="line-51"></a><a name="TickishPass"></a><span class='hs-comment'>{- | Used as a data type index for the GenTickish annotations.
<a name="line-52"></a>     See Note [Tickish passes]
<a name="line-53"></a> -}</span>
<a name="line-54"></a><a name="TickishPass"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TickishPass</span>
<a name="line-55"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TickishPassCore</span>
<a name="line-56"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TickishPassStg</span>
<a name="line-57"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TickishPassCmm</span>
<a name="line-58"></a>
<a name="line-59"></a><span class='hs-comment'>{-
<a name="line-60"></a>   Note [Tickish passes]
<a name="line-61"></a>
<a name="line-62"></a>   Tickish annotations store different information depending on
<a name="line-63"></a>   where they are used. Here's a summary of the differences
<a name="line-64"></a>   between the passes.
<a name="line-65"></a>
<a name="line-66"></a>   - CoreTickish: Haskell and Core
<a name="line-67"></a>         The tickish annotations store the free variables of
<a name="line-68"></a>         breakpoints.
<a name="line-69"></a>
<a name="line-70"></a>   - StgTickish: Stg
<a name="line-71"></a>         The GHCi bytecode generator (GHC.StgToByteCode) needs
<a name="line-72"></a>         to know the type of each breakpoint in addition to its
<a name="line-73"></a>         free variables. Since we cannot compute the type from
<a name="line-74"></a>         an STG expression, the tickish annotations store the
<a name="line-75"></a>         type of breakpoints in addition to the free variables.
<a name="line-76"></a>
<a name="line-77"></a>   - CmmTickish: Cmm
<a name="line-78"></a>         Breakpoints are unsupported and no free variables or
<a name="line-79"></a>         type are stored.
<a name="line-80"></a> -}</span>
<a name="line-81"></a>
<a name="line-82"></a><a name="XBreakpoint"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>XBreakpoint</span> <span class='hs-layout'>(</span><span class='hs-varid'>pass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TickishPass</span><span class='hs-layout'>)</span>
<a name="line-83"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>XBreakpoint</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCore</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoExtField</span>
<a name="line-84"></a><span class='hs-comment'>-- | Keep track of the type of breakpoints in STG, for GHCi</span>
<a name="line-85"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>XBreakpoint</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassStg</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-86"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>XBreakpoint</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCmm</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoExtField</span>
<a name="line-87"></a>
<a name="line-88"></a><a name="XTickishId"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>XTickishId</span> <span class='hs-layout'>(</span><span class='hs-varid'>pass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TickishPass</span><span class='hs-layout'>)</span>
<a name="line-89"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>XTickishId</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCore</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Id</span>
<a name="line-90"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>XTickishId</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassStg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Id</span>
<a name="line-91"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>XTickishId</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCmm</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoExtField</span>
<a name="line-92"></a>
<a name="line-93"></a><a name="CoreTickish"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoreTickish</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCore</span>
<a name="line-94"></a><a name="StgTickish"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>StgTickish</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassStg</span>
<a name="line-95"></a><a name="CmmTickish"></a><span class='hs-comment'>-- | Tickish in Cmm context (annotations only)</span>
<a name="line-96"></a><a name="CmmTickish"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CmmTickish</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCmm</span>
<a name="line-97"></a>
<a name="line-98"></a><a name="GenTickish"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-99"></a><a name="GenTickish"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-100"></a><a name="GenTickish"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>=</span>
<a name="line-101"></a>    <span class='hs-comment'>-- | An @{-# SCC #-}@ profiling annotation, either automatically</span>
<a name="line-102"></a>    <span class='hs-comment'>-- added by the desugarer as a result of -auto-all, or added by</span>
<a name="line-103"></a>    <span class='hs-comment'>-- the user.</span>
<a name="line-104"></a>    <span class='hs-conid'>ProfNote</span> <span class='hs-layout'>{</span>
<a name="line-105"></a>      <span class='hs-varid'>profNoteCC</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CostCentre</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- ^ the cost centre</span>
<a name="line-106"></a>      <span class='hs-varid'>profNoteCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ^ bump the entry count?</span>
<a name="line-107"></a>      <span class='hs-varid'>profNoteScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>       <span class='hs-comment'>-- ^ scopes over the enclosed expression</span>
<a name="line-108"></a>                                   <span class='hs-comment'>-- (i.e. not just a tick)</span>
<a name="line-109"></a>    <span class='hs-layout'>}</span>
<a name="line-110"></a>
<a name="line-111"></a>  <span class='hs-comment'>-- | A "tick" used by HPC to track the execution of each</span>
<a name="line-112"></a>  <span class='hs-comment'>-- subexpression in the original source code.</span>
<a name="line-113"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HpcTick</span> <span class='hs-layout'>{</span>
<a name="line-114"></a>      <span class='hs-varid'>tickModule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Module</span><span class='hs-layout'>,</span>
<a name="line-115"></a>      <span class='hs-varid'>tickId</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-116"></a>    <span class='hs-layout'>}</span>
<a name="line-117"></a>
<a name="line-118"></a>  <span class='hs-comment'>-- | A breakpoint for the GHCi debugger.  This behaves like an HPC</span>
<a name="line-119"></a>  <span class='hs-comment'>-- tick, but has a list of free variables which will be available</span>
<a name="line-120"></a>  <span class='hs-comment'>-- for inspection in GHCi when the program stops at the breakpoint.</span>
<a name="line-121"></a>  <span class='hs-comment'>--</span>
<a name="line-122"></a>  <span class='hs-comment'>-- NB. we must take account of these Ids when (a) counting free variables,</span>
<a name="line-123"></a>  <span class='hs-comment'>-- and (b) substituting (don't substitute for them)</span>
<a name="line-124"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Breakpoint</span>
<a name="line-125"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>breakpointExt</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XBreakpoint</span> <span class='hs-varid'>pass</span>
<a name="line-126"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>breakpointId</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-127"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>breakpointFVs</span>    <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>XTickishId</span> <span class='hs-varid'>pass</span><span class='hs-keyglyph'>]</span>
<a name="line-128"></a>                                <span class='hs-comment'>-- ^ the order of this list is important:</span>
<a name="line-129"></a>                                <span class='hs-comment'>-- it matches the order of the lists in the</span>
<a name="line-130"></a>                                <span class='hs-comment'>-- appropriate entry in 'GHC.ByteCode.Types.ModBreaks'.</span>
<a name="line-131"></a>                                <span class='hs-comment'>--</span>
<a name="line-132"></a>                                <span class='hs-comment'>-- Careful about substitution!  See</span>
<a name="line-133"></a>                                <span class='hs-comment'>-- Note [substTickish] in "GHC.Core.Subst".</span>
<a name="line-134"></a>    <span class='hs-layout'>}</span>
<a name="line-135"></a>
<a name="line-136"></a>  <span class='hs-comment'>-- | A source note.</span>
<a name="line-137"></a>  <span class='hs-comment'>--</span>
<a name="line-138"></a>  <span class='hs-comment'>-- Source notes are pure annotations: Their presence should neither</span>
<a name="line-139"></a>  <span class='hs-comment'>-- influence compilation nor execution. The semantics are given by</span>
<a name="line-140"></a>  <span class='hs-comment'>-- causality: The presence of a source note means that a local</span>
<a name="line-141"></a>  <span class='hs-comment'>-- change in the referenced source code span will possibly provoke</span>
<a name="line-142"></a>  <span class='hs-comment'>-- the generated code to change. On the flip-side, the functionality</span>
<a name="line-143"></a>  <span class='hs-comment'>-- of annotated code *must* be invariant against changes to all</span>
<a name="line-144"></a>  <span class='hs-comment'>-- source code *except* the spans referenced in the source notes</span>
<a name="line-145"></a>  <span class='hs-comment'>-- (see "Causality of optimized Haskell" paper for details).</span>
<a name="line-146"></a>  <span class='hs-comment'>--</span>
<a name="line-147"></a>  <span class='hs-comment'>-- Therefore extending the scope of any given source note is always</span>
<a name="line-148"></a>  <span class='hs-comment'>-- valid. Note that it is still undesirable though, as this reduces</span>
<a name="line-149"></a>  <span class='hs-comment'>-- their usefulness for debugging and profiling. Therefore we will</span>
<a name="line-150"></a>  <span class='hs-comment'>-- generally try only to make use of this property where it is</span>
<a name="line-151"></a>  <span class='hs-comment'>-- necessary to enable optimizations.</span>
<a name="line-152"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SourceNote</span>
<a name="line-153"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>sourceSpan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RealSrcSpan</span> <span class='hs-comment'>-- ^ Source covered</span>
<a name="line-154"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>sourceName</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span>      <span class='hs-comment'>-- ^ Name for source location</span>
<a name="line-155"></a>                                <span class='hs-comment'>--   (uses same names as CCs)</span>
<a name="line-156"></a>    <span class='hs-layout'>}</span>
<a name="line-157"></a>
<a name="line-158"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCore</span><span class='hs-layout'>)</span>
<a name="line-159"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCore</span><span class='hs-layout'>)</span>
<a name="line-160"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Data</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCore</span><span class='hs-layout'>)</span>
<a name="line-161"></a>
<a name="line-162"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Data</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassStg</span><span class='hs-layout'>)</span>
<a name="line-163"></a>
<a name="line-164"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCmm</span><span class='hs-layout'>)</span>
<a name="line-165"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCmm</span><span class='hs-layout'>)</span>
<a name="line-166"></a><span class='hs-keyword'>deriving</span> <span class='hs-keyword'>instance</span> <span class='hs-conid'>Data</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-chr'>'</span><span class='hs-conid'>TickishPassCmm</span><span class='hs-layout'>)</span>
<a name="line-167"></a>
<a name="line-168"></a>
<a name="line-169"></a><a name="tickishCounts"></a><span class='hs-comment'>-- | A "counting tick" (where tickishCounts is True) is one that</span>
<a name="line-170"></a><span class='hs-comment'>-- counts evaluations in some way.  We cannot discard a counting tick,</span>
<a name="line-171"></a><span class='hs-comment'>-- and the compiler should preserve the number of counting ticks as</span>
<a name="line-172"></a><span class='hs-comment'>-- far as possible.</span>
<a name="line-173"></a><span class='hs-comment'>--</span>
<a name="line-174"></a><span class='hs-comment'>-- However, we still allow the simplifier to increase or decrease</span>
<a name="line-175"></a><span class='hs-comment'>-- sharing, so in practice the actual number of ticks may vary, except</span>
<a name="line-176"></a><span class='hs-comment'>-- that we never change the value from zero to non-zero or vice versa.</span>
<a name="line-177"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-178"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>profNoteCount</span> <span class='hs-varid'>n</span>
<a name="line-179"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-conid'>HpcTick</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-180"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-conid'>Breakpoint</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-181"></a><span class='hs-definition'>tickishCounts</span> <span class='hs-keyword'>_</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-182"></a>
<a name="line-183"></a>
<a name="line-184"></a><a name="TickishScoping"></a><span class='hs-comment'>-- | Specifies the scoping behaviour of ticks. This governs the</span>
<a name="line-185"></a><a name="TickishScoping"></a><span class='hs-comment'>-- behaviour of ticks that care about the covered code and the cost</span>
<a name="line-186"></a><a name="TickishScoping"></a><span class='hs-comment'>-- associated with it. Important for ticks relating to profiling.</span>
<a name="line-187"></a><a name="TickishScoping"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TickishScoping</span> <span class='hs-keyglyph'>=</span>
<a name="line-188"></a>    <span class='hs-comment'>-- | No scoping: The tick does not care about what code it</span>
<a name="line-189"></a>    <span class='hs-comment'>-- covers. Transformations can freely move code inside as well as</span>
<a name="line-190"></a>    <span class='hs-comment'>-- outside without any additional annotation obligations</span>
<a name="line-191"></a>    <span class='hs-conid'>NoScope</span>
<a name="line-192"></a>
<a name="line-193"></a>    <span class='hs-comment'>-- | Soft scoping: We want all code that is covered to stay</span>
<a name="line-194"></a>    <span class='hs-comment'>-- covered.  Note that this scope type does not forbid</span>
<a name="line-195"></a>    <span class='hs-comment'>-- transformations from happening, as long as all results of</span>
<a name="line-196"></a>    <span class='hs-comment'>-- the transformations are still covered by this tick or a copy of</span>
<a name="line-197"></a>    <span class='hs-comment'>-- it. For example</span>
<a name="line-198"></a>    <span class='hs-comment'>--</span>
<a name="line-199"></a>    <span class='hs-comment'>--   let x = tick&lt;...&gt; (let y = foo in bar) in baz</span>
<a name="line-200"></a>    <span class='hs-comment'>--     ===&gt;</span>
<a name="line-201"></a>    <span class='hs-comment'>--   let x = tick&lt;...&gt; bar; y = tick&lt;...&gt; foo in baz</span>
<a name="line-202"></a>    <span class='hs-comment'>--</span>
<a name="line-203"></a>    <span class='hs-comment'>-- Is a valid transformation as far as "bar" and "foo" is</span>
<a name="line-204"></a>    <span class='hs-comment'>-- concerned, because both still are scoped over by the tick.</span>
<a name="line-205"></a>    <span class='hs-comment'>--</span>
<a name="line-206"></a>    <span class='hs-comment'>-- Note though that one might object to the "let" not being</span>
<a name="line-207"></a>    <span class='hs-comment'>-- covered by the tick any more. However, we are generally lax</span>
<a name="line-208"></a>    <span class='hs-comment'>-- with this - constant costs don't matter too much, and given</span>
<a name="line-209"></a>    <span class='hs-comment'>-- that the "let" was effectively merged we can view it as having</span>
<a name="line-210"></a>    <span class='hs-comment'>-- lost its identity anyway.</span>
<a name="line-211"></a>    <span class='hs-comment'>--</span>
<a name="line-212"></a>    <span class='hs-comment'>-- Also note that this scoping behaviour allows floating a tick</span>
<a name="line-213"></a>    <span class='hs-comment'>-- "upwards" in pretty much any situation. For example:</span>
<a name="line-214"></a>    <span class='hs-comment'>--</span>
<a name="line-215"></a>    <span class='hs-comment'>--   case foo of x -&gt; tick&lt;...&gt; bar</span>
<a name="line-216"></a>    <span class='hs-comment'>--     ==&gt;</span>
<a name="line-217"></a>    <span class='hs-comment'>--   tick&lt;...&gt; case foo of x -&gt; bar</span>
<a name="line-218"></a>    <span class='hs-comment'>--</span>
<a name="line-219"></a>    <span class='hs-comment'>-- While this is always legal, we want to make a best effort to</span>
<a name="line-220"></a>    <span class='hs-comment'>-- only make us of this where it exposes transformation</span>
<a name="line-221"></a>    <span class='hs-comment'>-- opportunities.</span>
<a name="line-222"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SoftScope</span>
<a name="line-223"></a>
<a name="line-224"></a>    <span class='hs-comment'>-- | Cost centre scoping: We don't want any costs to move to other</span>
<a name="line-225"></a>    <span class='hs-comment'>-- cost-centre stacks. This means we not only want no code or cost</span>
<a name="line-226"></a>    <span class='hs-comment'>-- to get moved out of their cost centres, but we also object to</span>
<a name="line-227"></a>    <span class='hs-comment'>-- code getting associated with new cost-centre ticks - or</span>
<a name="line-228"></a>    <span class='hs-comment'>-- changing the order in which they get applied.</span>
<a name="line-229"></a>    <span class='hs-comment'>--</span>
<a name="line-230"></a>    <span class='hs-comment'>-- A rule of thumb is that we don't want any code to gain new</span>
<a name="line-231"></a>    <span class='hs-comment'>-- annotations. However, there are notable exceptions, for</span>
<a name="line-232"></a>    <span class='hs-comment'>-- example:</span>
<a name="line-233"></a>    <span class='hs-comment'>--</span>
<a name="line-234"></a>    <span class='hs-comment'>--   let f = \y -&gt; foo in tick&lt;...&gt; ... (f x) ...</span>
<a name="line-235"></a>    <span class='hs-comment'>--     ==&gt;</span>
<a name="line-236"></a>    <span class='hs-comment'>--   tick&lt;...&gt; ... foo[x/y] ...</span>
<a name="line-237"></a>    <span class='hs-comment'>--</span>
<a name="line-238"></a>    <span class='hs-comment'>-- In-lining lambdas like this is always legal, because inlining a</span>
<a name="line-239"></a>    <span class='hs-comment'>-- function does not change the cost-centre stack when the</span>
<a name="line-240"></a>    <span class='hs-comment'>-- function is called.</span>
<a name="line-241"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CostCentreScope</span>
<a name="line-242"></a>
<a name="line-243"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-244"></a>
<a name="line-245"></a><a name="tickishScoped"></a><span class='hs-comment'>-- | Returns the intended scoping rule for a Tickish</span>
<a name="line-246"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TickishScoping</span>
<a name="line-247"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-248"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>profNoteScope</span> <span class='hs-varid'>n</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CostCentreScope</span>
<a name="line-249"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoScope</span>
<a name="line-250"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-conid'>HpcTick</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NoScope</span>
<a name="line-251"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-conid'>Breakpoint</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CostCentreScope</span>
<a name="line-252"></a>   <span class='hs-comment'>-- Breakpoints are scoped: eventually we're going to do call</span>
<a name="line-253"></a>   <span class='hs-comment'>-- stacks, but also this helps prevent the simplifier from moving</span>
<a name="line-254"></a>   <span class='hs-comment'>-- breakpoints around and changing their result type (see #1531).</span>
<a name="line-255"></a><span class='hs-definition'>tickishScoped</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SoftScope</span>
<a name="line-256"></a>
<a name="line-257"></a><a name="tickishScopesLike"></a><span class='hs-comment'>-- | Returns whether the tick scoping rule is at least as permissive</span>
<a name="line-258"></a><span class='hs-comment'>-- as the given scoping rule.</span>
<a name="line-259"></a><span class='hs-definition'>tickishScopesLike</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TickishScoping</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-260"></a><span class='hs-definition'>tickishScopesLike</span> <span class='hs-varid'>t</span> <span class='hs-varid'>scope</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tickishScoped</span> <span class='hs-varid'>t</span> <span class='hs-varop'>`like`</span> <span class='hs-varid'>scope</span>
<a name="line-261"></a>  <span class='hs-keyword'>where</span> <span class='hs-conid'>NoScope</span>         <span class='hs-varop'>`like`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-262"></a>        <span class='hs-keyword'>_</span>               <span class='hs-varop'>`like`</span> <span class='hs-conid'>NoScope</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-263"></a>        <span class='hs-conid'>SoftScope</span>       <span class='hs-varop'>`like`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-264"></a>        <span class='hs-keyword'>_</span>               <span class='hs-varop'>`like`</span> <span class='hs-conid'>SoftScope</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-265"></a>        <span class='hs-conid'>CostCentreScope</span> <span class='hs-varop'>`like`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-266"></a>
<a name="line-267"></a><a name="tickishFloatable"></a><span class='hs-comment'>-- | Returns @True@ for ticks that can be floated upwards easily even</span>
<a name="line-268"></a><span class='hs-comment'>-- where it might change execution counts, such as:</span>
<a name="line-269"></a><span class='hs-comment'>--</span>
<a name="line-270"></a><span class='hs-comment'>--   Just (tick&lt;...&gt; foo)</span>
<a name="line-271"></a><span class='hs-comment'>--     ==&gt;</span>
<a name="line-272"></a><span class='hs-comment'>--   tick&lt;...&gt; (Just foo)</span>
<a name="line-273"></a><span class='hs-comment'>--</span>
<a name="line-274"></a><span class='hs-comment'>-- This is a combination of @tickishSoftScope@ and</span>
<a name="line-275"></a><span class='hs-comment'>-- @tickishCounts@. Note that in principle splittable ticks can become</span>
<a name="line-276"></a><span class='hs-comment'>-- floatable using @mkNoTick@ -- even though there's currently no</span>
<a name="line-277"></a><span class='hs-comment'>-- tickish for which that is the case.</span>
<a name="line-278"></a><span class='hs-definition'>tickishFloatable</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-279"></a><span class='hs-definition'>tickishFloatable</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span> <span class='hs-varop'>`tickishScopesLike`</span> <span class='hs-conid'>SoftScope</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-280"></a>
<a name="line-281"></a><a name="tickishCanSplit"></a><span class='hs-comment'>-- | Returns @True@ for a tick that is both counting /and/ scoping and</span>
<a name="line-282"></a><span class='hs-comment'>-- can be split into its (tick, scope) parts using 'mkNoScope' and</span>
<a name="line-283"></a><span class='hs-comment'>-- 'mkNoTick' respectively.</span>
<a name="line-284"></a><span class='hs-definition'>tickishCanSplit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-285"></a><span class='hs-definition'>tickishCanSplit</span> <span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-varid'>profNoteScope</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span><span class='hs-layout'>,</span> <span class='hs-varid'>profNoteCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span><span class='hs-layout'>}</span>
<a name="line-286"></a>                   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-287"></a><span class='hs-definition'>tickishCanSplit</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-288"></a>
<a name="line-289"></a><a name="mkNoCount"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span>
<a name="line-290"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCounts</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-291"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCanSplit</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoCount: Cannot split!"</span>
<a name="line-292"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>{</span><span class='hs-varid'>profNoteCount</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span><span class='hs-layout'>}</span>
<a name="line-293"></a><span class='hs-definition'>mkNoCount</span> <span class='hs-keyword'>_</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoCount: Undefined split!"</span>
<a name="line-294"></a>
<a name="line-295"></a><a name="mkNoScope"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span>
<a name="line-296"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tickishScoped</span> <span class='hs-varid'>n</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NoScope</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span>
<a name="line-297"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishCanSplit</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoScope: Cannot split!"</span>
<a name="line-298"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>{</span><span class='hs-varid'>profNoteScope</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span><span class='hs-layout'>}</span>
<a name="line-299"></a><span class='hs-definition'>mkNoScope</span> <span class='hs-keyword'>_</span>                               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"mkNoScope: Undefined split!"</span>
<a name="line-300"></a>
<a name="line-301"></a><a name="tickishIsCode"></a><span class='hs-comment'>-- | Return @True@ if this source annotation compiles to some backend</span>
<a name="line-302"></a><span class='hs-comment'>-- code. Without this flag, the tickish is seen as a simple annotation</span>
<a name="line-303"></a><span class='hs-comment'>-- that does not have any associated evaluation code.</span>
<a name="line-304"></a><span class='hs-comment'>--</span>
<a name="line-305"></a><span class='hs-comment'>-- What this means that we are allowed to disregard the tick if doing</span>
<a name="line-306"></a><span class='hs-comment'>-- so means that we can skip generating any code in the first place. A</span>
<a name="line-307"></a><span class='hs-comment'>-- typical example is top-level bindings:</span>
<a name="line-308"></a><span class='hs-comment'>--</span>
<a name="line-309"></a><span class='hs-comment'>--   foo = tick&lt;...&gt; \y -&gt; ...</span>
<a name="line-310"></a><span class='hs-comment'>--     ==&gt;</span>
<a name="line-311"></a><span class='hs-comment'>--   foo = \y -&gt; tick&lt;...&gt; ...</span>
<a name="line-312"></a><span class='hs-comment'>--</span>
<a name="line-313"></a><span class='hs-comment'>-- Here there is just no operational difference between the first and</span>
<a name="line-314"></a><span class='hs-comment'>-- the second version. Therefore code generation should simply</span>
<a name="line-315"></a><span class='hs-comment'>-- translate the code as if it found the latter.</span>
<a name="line-316"></a><span class='hs-definition'>tickishIsCode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-317"></a><span class='hs-definition'>tickishIsCode</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-318"></a><span class='hs-definition'>tickishIsCode</span> <span class='hs-sel'>_tickish</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- all the rest for now</span>
<a name="line-319"></a>
<a name="line-320"></a>
<a name="line-321"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- | Governs the kind of expression that the tick gets placed on when</span>
<a name="line-322"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- annotating for example using @mkTick@. If we find that we want to</span>
<a name="line-323"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- put a tickish on an expression ruled out here, we try to float it</span>
<a name="line-324"></a><a name="TickishPlacement"></a><span class='hs-comment'>-- inwards until we find a suitable expression.</span>
<a name="line-325"></a><a name="TickishPlacement"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TickishPlacement</span> <span class='hs-keyglyph'>=</span>
<a name="line-326"></a>
<a name="line-327"></a>    <span class='hs-comment'>-- | Place ticks exactly on run-time expressions. We can still</span>
<a name="line-328"></a>    <span class='hs-comment'>-- move the tick through pure compile-time constructs such as</span>
<a name="line-329"></a>    <span class='hs-comment'>-- other ticks, casts or type lambdas. This is the most</span>
<a name="line-330"></a>    <span class='hs-comment'>-- restrictive placement rule for ticks, as all tickishs have in</span>
<a name="line-331"></a>    <span class='hs-comment'>-- common that they want to track runtime processes. The only</span>
<a name="line-332"></a>    <span class='hs-comment'>-- legal placement rule for counting ticks.</span>
<a name="line-333"></a>    <span class='hs-conid'>PlaceRuntime</span>
<a name="line-334"></a>
<a name="line-335"></a>    <span class='hs-comment'>-- | As @PlaceRuntime@, but we float the tick through all</span>
<a name="line-336"></a>    <span class='hs-comment'>-- lambdas. This makes sense where there is little difference</span>
<a name="line-337"></a>    <span class='hs-comment'>-- between annotating the lambda and annotating the lambda's code.</span>
<a name="line-338"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PlaceNonLam</span>
<a name="line-339"></a>
<a name="line-340"></a>    <span class='hs-comment'>-- | In addition to floating through lambdas, cost-centre style</span>
<a name="line-341"></a>    <span class='hs-comment'>-- tickishs can also be moved from constructors, non-function</span>
<a name="line-342"></a>    <span class='hs-comment'>-- variables and literals. For example:</span>
<a name="line-343"></a>    <span class='hs-comment'>--</span>
<a name="line-344"></a>    <span class='hs-comment'>--   let x = scc&lt;...&gt; C (scc&lt;...&gt; y) (scc&lt;...&gt; 3) in ...</span>
<a name="line-345"></a>    <span class='hs-comment'>--</span>
<a name="line-346"></a>    <span class='hs-comment'>-- Neither the constructor application, the variable or the</span>
<a name="line-347"></a>    <span class='hs-comment'>-- literal are likely to have any cost worth mentioning. And even</span>
<a name="line-348"></a>    <span class='hs-comment'>-- if y names a thunk, the call would not care about the</span>
<a name="line-349"></a>    <span class='hs-comment'>-- evaluation context. Therefore removing all annotations in the</span>
<a name="line-350"></a>    <span class='hs-comment'>-- above example is safe.</span>
<a name="line-351"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PlaceCostCentre</span>
<a name="line-352"></a>
<a name="line-353"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-354"></a>
<a name="line-355"></a><a name="tickishPlace"></a><span class='hs-comment'>-- | Placement behaviour we want for the ticks</span>
<a name="line-356"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TickishPlacement</span>
<a name="line-357"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-varid'>n</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>ProfNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-358"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>profNoteCount</span> <span class='hs-varid'>n</span>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceRuntime</span>
<a name="line-359"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceCostCentre</span>
<a name="line-360"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-conid'>HpcTick</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceRuntime</span>
<a name="line-361"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-conid'>Breakpoint</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceRuntime</span>
<a name="line-362"></a><span class='hs-definition'>tickishPlace</span> <span class='hs-conid'>SourceNote</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PlaceNonLam</span>
<a name="line-363"></a>
<a name="line-364"></a><a name="tickishContains"></a><span class='hs-comment'>-- | Returns whether one tick "contains" the other one, therefore</span>
<a name="line-365"></a><span class='hs-comment'>-- making the second tick redundant.</span>
<a name="line-366"></a><span class='hs-definition'>tickishContains</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span><span class='hs-layout'>)</span>
<a name="line-367"></a>                <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GenTickish</span> <span class='hs-varid'>pass</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-368"></a><span class='hs-definition'>tickishContains</span> <span class='hs-layout'>(</span><span class='hs-conid'>SourceNote</span> <span class='hs-varid'>sp1</span> <span class='hs-varid'>n1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>SourceNote</span> <span class='hs-varid'>sp2</span> <span class='hs-varid'>n2</span><span class='hs-layout'>)</span>
<a name="line-369"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>containsSpan</span> <span class='hs-varid'>sp1</span> <span class='hs-varid'>sp2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>n1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>n2</span>
<a name="line-370"></a>    <span class='hs-comment'>-- compare the String last</span>
<a name="line-371"></a><span class='hs-definition'>tickishContains</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span>
<a name="line-372"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>t2</span>
</pre></body>
</html>
