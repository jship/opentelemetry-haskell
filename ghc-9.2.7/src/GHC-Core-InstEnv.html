<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/InstEnv.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-4"></a>
<a name="line-5"></a>\section[InstEnv]{Utilities for typechecking instance declarations}
<a name="line-6"></a>
<a name="line-7"></a>The bits common to GHC.Tc.TyCl.Instance and GHC.Tc.Deriv.
<a name="line-8"></a>-}</span>
<a name="line-9"></a>
<a name="line-10"></a><span class='hs-comment'>{-# LANGUAGE CPP, DeriveDataTypeable #-}</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.InstEnv</span> <span class='hs-layout'>(</span>
<a name="line-13"></a>        <span class='hs-conid'>DFunId</span><span class='hs-layout'>,</span> <span class='hs-conid'>InstMatch</span><span class='hs-layout'>,</span> <span class='hs-conid'>ClsInstLookupResult</span><span class='hs-layout'>,</span>
<a name="line-14"></a>        <span class='hs-conid'>OverlapFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>OverlapMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>setOverlapModeMaybe</span><span class='hs-layout'>,</span>
<a name="line-15"></a>        <span class='hs-conid'>ClsInst</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>DFunInstType</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprInstance</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprInstanceHdr</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprInstances</span><span class='hs-layout'>,</span>
<a name="line-16"></a>        <span class='hs-varid'>instanceHead</span><span class='hs-layout'>,</span> <span class='hs-varid'>instanceSig</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkLocalInstance</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkImportedInstance</span><span class='hs-layout'>,</span>
<a name="line-17"></a>        <span class='hs-varid'>instanceDFunId</span><span class='hs-layout'>,</span> <span class='hs-varid'>updateClsInstDFun</span><span class='hs-layout'>,</span> <span class='hs-varid'>instanceRoughTcs</span><span class='hs-layout'>,</span>
<a name="line-18"></a>        <span class='hs-varid'>fuzzyClsInstCmp</span><span class='hs-layout'>,</span> <span class='hs-varid'>orphNamesOfClsInst</span><span class='hs-layout'>,</span>
<a name="line-19"></a>
<a name="line-20"></a>        <span class='hs-conid'>InstEnvs</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>VisibleOrphanModules</span><span class='hs-layout'>,</span> <span class='hs-conid'>InstEnv</span><span class='hs-layout'>,</span>
<a name="line-21"></a>        <span class='hs-varid'>emptyInstEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>extendInstEnv</span><span class='hs-layout'>,</span>
<a name="line-22"></a>        <span class='hs-varid'>deleteFromInstEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>deleteDFunFromInstEnv</span><span class='hs-layout'>,</span>
<a name="line-23"></a>        <span class='hs-varid'>identicalClsInstHead</span><span class='hs-layout'>,</span>
<a name="line-24"></a>        <span class='hs-varid'>extendInstEnvList</span><span class='hs-layout'>,</span> <span class='hs-varid'>lookupUniqueInstEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>lookupInstEnv</span><span class='hs-layout'>,</span> <span class='hs-varid'>instEnvElts</span><span class='hs-layout'>,</span> <span class='hs-varid'>instEnvClasses</span><span class='hs-layout'>,</span>
<a name="line-25"></a>        <span class='hs-varid'>memberInstEnv</span><span class='hs-layout'>,</span>
<a name="line-26"></a>        <span class='hs-varid'>instIsVisible</span><span class='hs-layout'>,</span>
<a name="line-27"></a>        <span class='hs-varid'>classInstances</span><span class='hs-layout'>,</span> <span class='hs-varid'>instanceBindFun</span><span class='hs-layout'>,</span>
<a name="line-28"></a>        <span class='hs-varid'>instanceCantMatch</span><span class='hs-layout'>,</span> <span class='hs-varid'>roughMatchTcs</span><span class='hs-layout'>,</span>
<a name="line-29"></a>        <span class='hs-varid'>isOverlappable</span><span class='hs-layout'>,</span> <span class='hs-varid'>isOverlapping</span><span class='hs-layout'>,</span> <span class='hs-varid'>isIncoherent</span>
<a name="line-30"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-31"></a>
<a name="line-32"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-33"></a>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-35"></a>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcType</span> <span class='hs-comment'>-- InstEnv is really part of the type checker,</span>
<a name="line-37"></a>              <span class='hs-comment'>-- and depends on TcType in many ways</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span> <span class='hs-layout'>(</span> <span class='hs-conid'>IsOrphan</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>isOrphan</span><span class='hs-layout'>,</span> <span class='hs-varid'>chooseOrphanAnchor</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module.Env</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Types</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Class</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Set</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUnique</span><span class='hs-layout'>)</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unify</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique.DFM</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span>        <span class='hs-layout'>(</span> <span class='hs-conid'>Data</span> <span class='hs-layout'>)</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Maybe</span>       <span class='hs-layout'>(</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>)</span>
<a name="line-53"></a>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-57"></a>
<a name="line-58"></a><span class='hs-comment'>{-
<a name="line-59"></a>************************************************************************
<a name="line-60"></a>*                                                                      *
<a name="line-61"></a>           ClsInst: the data type for type-class instances
<a name="line-62"></a>*                                                                      *
<a name="line-63"></a>************************************************************************
<a name="line-64"></a>-}</span>
<a name="line-65"></a>
<a name="line-66"></a><a name="ClsInst"></a><span class='hs-comment'>-- | A type-class instance. Note that there is some tricky laziness at work</span>
<a name="line-67"></a><a name="ClsInst"></a><span class='hs-comment'>-- here. See Note [ClsInst laziness and the rough-match fields] for more</span>
<a name="line-68"></a><a name="ClsInst"></a><span class='hs-comment'>-- details.</span>
<a name="line-69"></a><a name="ClsInst"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ClsInst</span>
<a name="line-70"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Used for "rough matching"; see</span>
<a name="line-71"></a>                <span class='hs-comment'>-- Note [ClsInst laziness and the rough-match fields]</span>
<a name="line-72"></a>                <span class='hs-comment'>-- INVARIANT: is_tcs = roughMatchTcs is_tys</span>
<a name="line-73"></a>               <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>          <span class='hs-comment'>-- ^ Class name</span>
<a name="line-74"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_tcs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>RoughMatchTc</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ^ Top of type args</span>
<a name="line-75"></a>
<a name="line-76"></a>               <span class='hs-comment'>-- | @is_dfun_name = idName . is_dfun@.</span>
<a name="line-77"></a>               <span class='hs-comment'>--</span>
<a name="line-78"></a>               <span class='hs-comment'>-- We use 'is_dfun_name' for the visibility check,</span>
<a name="line-79"></a>               <span class='hs-comment'>-- 'instIsVisible', which needs to know the 'Module' which the</span>
<a name="line-80"></a>               <span class='hs-comment'>-- dictionary is defined in. However, we cannot use the 'Module'</span>
<a name="line-81"></a>               <span class='hs-comment'>-- attached to 'is_dfun' since doing so would mean we would</span>
<a name="line-82"></a>               <span class='hs-comment'>-- potentially pull in an entire interface file unnecessarily.</span>
<a name="line-83"></a>               <span class='hs-comment'>-- This was the cause of #12367.</span>
<a name="line-84"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun_name</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>
<a name="line-85"></a>
<a name="line-86"></a>                <span class='hs-comment'>-- Used for "proper matching"; see Note [Proper-match fields]</span>
<a name="line-87"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_tvs</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Fresh template tyvars for full match</span>
<a name="line-88"></a>                                        <span class='hs-comment'>-- See Note [Template tyvars are fresh]</span>
<a name="line-89"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_cls</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Class</span>         <span class='hs-comment'>-- The real class</span>
<a name="line-90"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- Full arg types (mentioning is_tvs)</span>
<a name="line-91"></a>                <span class='hs-comment'>-- INVARIANT: is_dfun Id has type</span>
<a name="line-92"></a>                <span class='hs-comment'>--      forall is_tvs. (...) =&gt; is_cls is_tys</span>
<a name="line-93"></a>                <span class='hs-comment'>-- (modulo alpha conversion)</span>
<a name="line-94"></a>
<a name="line-95"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunId</span> <span class='hs-comment'>-- See Note [Haddock assumptions]</span>
<a name="line-96"></a>
<a name="line-97"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_flag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>OverlapFlag</span>   <span class='hs-comment'>-- See detailed comments with</span>
<a name="line-98"></a>                                        <span class='hs-comment'>-- the decl of BasicTypes.OverlapFlag</span>
<a name="line-99"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>is_orphan</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-100"></a>    <span class='hs-layout'>}</span>
<a name="line-101"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-102"></a>
<a name="line-103"></a><a name="fuzzyClsInstCmp"></a><span class='hs-comment'>-- | A fuzzy comparison function for class instances, intended for sorting</span>
<a name="line-104"></a><span class='hs-comment'>-- instances before displaying them to the user.</span>
<a name="line-105"></a><span class='hs-definition'>fuzzyClsInstCmp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-106"></a><span class='hs-definition'>fuzzyClsInstCmp</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span>
<a name="line-107"></a>    <span class='hs-varid'>stableNameCmp</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_cls_nm</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_cls_nm</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mappend`</span>
<a name="line-108"></a>    <span class='hs-varid'>mconcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>cmp</span> <span class='hs-layout'>(</span><span class='hs-varid'>zip</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_tcs</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_tcs</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-109"></a>  <span class='hs-keyword'>where</span>
<a name="line-110"></a>    <span class='hs-varid'>cmp</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherTc</span><span class='hs-layout'>,</span>   <span class='hs-conid'>OtherTc</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EQ</span>
<a name="line-111"></a>    <span class='hs-varid'>cmp</span> <span class='hs-layout'>(</span><span class='hs-conid'>OtherTc</span><span class='hs-layout'>,</span>   <span class='hs-conid'>KnownTc</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LT</span>
<a name="line-112"></a>    <span class='hs-varid'>cmp</span> <span class='hs-layout'>(</span><span class='hs-conid'>KnownTc</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>OtherTc</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GT</span>
<a name="line-113"></a>    <span class='hs-varid'>cmp</span> <span class='hs-layout'>(</span><span class='hs-conid'>KnownTc</span> <span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-conid'>KnownTc</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>stableNameCmp</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-114"></a>
<a name="line-115"></a><a name="isOverlappable"></a><span class='hs-definition'>isOverlappable</span><span class='hs-layout'>,</span> <span class='hs-varid'>isOverlapping</span><span class='hs-layout'>,</span> <span class='hs-varid'>isIncoherent</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-116"></a><span class='hs-definition'>isOverlappable</span> <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hasOverlappableFlag</span> <span class='hs-layout'>(</span><span class='hs-varid'>overlapMode</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_flag</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-117"></a><a name="isOverlapping"></a><span class='hs-definition'>isOverlapping</span>  <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hasOverlappingFlag</span>  <span class='hs-layout'>(</span><span class='hs-varid'>overlapMode</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_flag</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-118"></a><a name="isIncoherent"></a><span class='hs-definition'>isIncoherent</span>   <span class='hs-varid'>i</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hasIncoherentFlag</span>   <span class='hs-layout'>(</span><span class='hs-varid'>overlapMode</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_flag</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-119"></a>
<a name="line-120"></a><span class='hs-comment'>{-
<a name="line-121"></a>Note [ClsInst laziness and the rough-match fields]
<a name="line-122"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-123"></a>Suppose we load 'instance A.C B.T' from A.hi, but suppose that the type B.T is
<a name="line-124"></a>otherwise unused in the program. Then it's stupid to load B.hi, the data type
<a name="line-125"></a>declaration for B.T -- and perhaps further instance declarations!
<a name="line-126"></a>
<a name="line-127"></a>We avoid this as follows:
<a name="line-128"></a>
<a name="line-129"></a>* is_cls_nm, is_tcs, is_dfun_name are all Names. We can poke them to our heart's
<a name="line-130"></a>  content.
<a name="line-131"></a>
<a name="line-132"></a>* Proper-match fields. is_dfun, and its related fields is_tvs, is_cls, is_tys
<a name="line-133"></a>  contain TyVars, Class, Type, Class etc, and so are all lazy thunks. When we
<a name="line-134"></a>  poke any of these fields we'll typecheck the DFunId declaration, and hence
<a name="line-135"></a>  pull in interfaces that it refers to. See Note [Proper-match fields].
<a name="line-136"></a>
<a name="line-137"></a>* Rough-match fields. During instance lookup, we use the is_cls_nm :: Name and
<a name="line-138"></a>  is_tcs :: [RoughMatchTc] fields to perform a "rough match", *without* poking
<a name="line-139"></a>  inside the DFunId. The rough-match fields allow us to say "definitely does not
<a name="line-140"></a>  match", based only on Names.  See GHC.Core.Unify
<a name="line-141"></a>  Note [Rough matching in class and family instances]
<a name="line-142"></a>
<a name="line-143"></a>  This laziness is very important; see #12367. Try hard to avoid pulling on
<a name="line-144"></a>  the structured fields unless you really need the instance.
<a name="line-145"></a>
<a name="line-146"></a>* Another place to watch is InstEnv.instIsVisible, which needs the module to
<a name="line-147"></a>  which the ClsInst belongs. We can get this from is_dfun_name.
<a name="line-148"></a>-}</span>
<a name="line-149"></a>
<a name="line-150"></a><span class='hs-comment'>{-
<a name="line-151"></a>Note [Template tyvars are fresh]
<a name="line-152"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-153"></a>The is_tvs field of a ClsInst has *completely fresh* tyvars.
<a name="line-154"></a>That is, they are
<a name="line-155"></a>  * distinct from any other ClsInst
<a name="line-156"></a>  * distinct from any tyvars free in predicates that may
<a name="line-157"></a>    be looked up in the class instance environment
<a name="line-158"></a>Reason for freshness: we use unification when checking for overlap
<a name="line-159"></a>etc, and that requires the tyvars to be distinct.
<a name="line-160"></a>
<a name="line-161"></a>The invariant is checked by the ASSERT in lookupInstEnv'.
<a name="line-162"></a>
<a name="line-163"></a>Note [Proper-match fields]
<a name="line-164"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-165"></a>The is_tvs, is_cls, is_tys fields are simply cached values, pulled
<a name="line-166"></a>out (lazily) from the dfun id. They are cached here simply so
<a name="line-167"></a>that we don't need to decompose the DFunId each time we want
<a name="line-168"></a>to match it.  The hope is that the rough-match fields mean
<a name="line-169"></a>that we often never poke the proper-match fields.
<a name="line-170"></a>
<a name="line-171"></a>However, note that:
<a name="line-172"></a> * is_tvs must be a superset of the free vars of is_tys
<a name="line-173"></a>
<a name="line-174"></a> * is_tvs, is_tys may be alpha-renamed compared to the ones in
<a name="line-175"></a>   the dfun Id
<a name="line-176"></a>
<a name="line-177"></a>Note [Haddock assumptions]
<a name="line-178"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-179"></a>For normal user-written instances, Haddock relies on
<a name="line-180"></a>
<a name="line-181"></a> * the SrcSpan of
<a name="line-182"></a> * the Name of
<a name="line-183"></a> * the is_dfun of
<a name="line-184"></a> * an Instance
<a name="line-185"></a>
<a name="line-186"></a>being equal to
<a name="line-187"></a>
<a name="line-188"></a>  * the SrcSpan of
<a name="line-189"></a>  * the instance head type of
<a name="line-190"></a>  * the InstDecl used to construct the Instance.
<a name="line-191"></a>-}</span>
<a name="line-192"></a>
<a name="line-193"></a><a name="instanceDFunId"></a><span class='hs-definition'>instanceDFunId</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunId</span>
<a name="line-194"></a><span class='hs-definition'>instanceDFunId</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_dfun</span>
<a name="line-195"></a>
<a name="line-196"></a><a name="updateClsInstDFun"></a><span class='hs-definition'>updateClsInstDFun</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunId</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span>
<a name="line-197"></a><span class='hs-definition'>updateClsInstDFun</span> <span class='hs-varid'>tidy_dfun</span> <span class='hs-varid'>ispec</span>
<a name="line-198"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ispec</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tidy_dfun</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-199"></a>
<a name="line-200"></a><a name="instanceRoughTcs"></a><span class='hs-definition'>instanceRoughTcs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>RoughMatchTc</span><span class='hs-keyglyph'>]</span>
<a name="line-201"></a><span class='hs-definition'>instanceRoughTcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_tcs</span>
<a name="line-202"></a>
<a name="line-203"></a><a name="instance%20NamedThing%20ClsInst"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>NamedThing</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyword'>where</span>
<a name="line-204"></a>   <span class='hs-varid'>getName</span> <span class='hs-varid'>ispec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getName</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span>
<a name="line-205"></a>
<a name="line-206"></a><a name="instance%20Outputable%20ClsInst"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyword'>where</span>
<a name="line-207"></a>   <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprInstance</span>
<a name="line-208"></a>
<a name="line-209"></a><a name="pprInstance"></a><span class='hs-definition'>pprInstance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-210"></a><span class='hs-comment'>-- Prints the ClsInst as an instance declaration</span>
<a name="line-211"></a><span class='hs-definition'>pprInstance</span> <span class='hs-varid'>ispec</span>
<a name="line-212"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprInstanceHdr</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span>
<a name="line-213"></a>       <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"--"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprDefinedAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>getName</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span>
<a name="line-214"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>whenPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-215"></a>
<a name="line-216"></a><a name="pprInstanceHdr"></a><span class='hs-comment'>-- * pprInstanceHdr is used in VStudio to populate the ClassView tree</span>
<a name="line-217"></a><span class='hs-definition'>pprInstanceHdr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-218"></a><span class='hs-comment'>-- Prints the ClsInst as an instance declaration</span>
<a name="line-219"></a><span class='hs-definition'>pprInstanceHdr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_flag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flag</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-220"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"instance"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>flag</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprSigmaType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun</span><span class='hs-layout'>)</span>
<a name="line-221"></a>
<a name="line-222"></a><a name="pprInstances"></a><span class='hs-definition'>pprInstances</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-223"></a><span class='hs-definition'>pprInstances</span> <span class='hs-varid'>ispecs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>pprInstance</span> <span class='hs-varid'>ispecs</span><span class='hs-layout'>)</span>
<a name="line-224"></a>
<a name="line-225"></a><a name="instanceHead"></a><span class='hs-definition'>instanceHead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-226"></a><span class='hs-comment'>-- Returns the head, using the fresh tyvars from the ClsInst</span>
<a name="line-227"></a><span class='hs-definition'>instanceHead</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-228"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-229"></a>   <span class='hs-keyword'>where</span>
<a name="line-230"></a>     <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun</span><span class='hs-layout'>)</span>
<a name="line-231"></a>
<a name="line-232"></a><a name="orphNamesOfClsInst"></a><span class='hs-comment'>-- | Collects the names of concrete types and type constructors that make</span>
<a name="line-233"></a><span class='hs-comment'>-- up the head of a class instance. For instance, given `class Foo a b`:</span>
<a name="line-234"></a><span class='hs-comment'>--</span>
<a name="line-235"></a><span class='hs-comment'>-- `instance Foo (Either (Maybe Int) a) Bool` would yield</span>
<a name="line-236"></a><span class='hs-comment'>--      [Either, Maybe, Int, Bool]</span>
<a name="line-237"></a><span class='hs-comment'>--</span>
<a name="line-238"></a><span class='hs-comment'>-- Used in the implementation of ":info" in GHCi.</span>
<a name="line-239"></a><span class='hs-comment'>--</span>
<a name="line-240"></a><span class='hs-comment'>-- The 'tcSplitSigmaTy' is because of</span>
<a name="line-241"></a><span class='hs-comment'>--      instance Foo a =&gt; Baz T where ...</span>
<a name="line-242"></a><span class='hs-comment'>-- The decl is an orphan if Baz and T are both not locally defined,</span>
<a name="line-243"></a><span class='hs-comment'>--      even if Foo *is* locally defined</span>
<a name="line-244"></a><span class='hs-definition'>orphNamesOfClsInst</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>NameSet</span>
<a name="line-245"></a><span class='hs-definition'>orphNamesOfClsInst</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-246"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orphNamesOfTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>`unionNameSet`</span> <span class='hs-varid'>unitNameSet</span> <span class='hs-varid'>cls_nm</span>
<a name="line-247"></a>
<a name="line-248"></a><a name="instanceSig"></a><span class='hs-definition'>instanceSig</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-249"></a><span class='hs-comment'>-- Decomposes the DFunId</span>
<a name="line-250"></a><span class='hs-definition'>instanceSig</span> <span class='hs-varid'>ispec</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-251"></a>
<a name="line-252"></a><a name="mkLocalInstance"></a><span class='hs-definition'>mkLocalInstance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OverlapFlag</span>
<a name="line-253"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-254"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span>
<a name="line-255"></a><span class='hs-comment'>-- Used for local instances, where we can safely pull on the DFunId.</span>
<a name="line-256"></a><span class='hs-comment'>-- Consider using newClsInst instead; this will also warn if</span>
<a name="line-257"></a><span class='hs-comment'>-- the instance is an orphan.</span>
<a name="line-258"></a><span class='hs-definition'>mkLocalInstance</span> <span class='hs-varid'>dfun</span> <span class='hs-varid'>oflag</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-259"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_flag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oflag</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun</span>
<a name="line-260"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-261"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun_name</span>
<a name="line-262"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_name</span>
<a name="line-263"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>roughMatchTcs</span> <span class='hs-varid'>tys</span>
<a name="line-264"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_orphan</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orph</span>
<a name="line-265"></a>            <span class='hs-layout'>}</span>
<a name="line-266"></a>  <span class='hs-keyword'>where</span>
<a name="line-267"></a>    <span class='hs-varid'>cls_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>className</span> <span class='hs-varid'>cls</span>
<a name="line-268"></a>    <span class='hs-varid'>dfun_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idName</span> <span class='hs-varid'>dfun</span>
<a name="line-269"></a>    <span class='hs-varid'>this_mod</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>isExternalName</span> <span class='hs-varid'>dfun_name</span> <span class='hs-layout'>)</span> <span class='hs-varid'>nameModule</span> <span class='hs-varid'>dfun_name</span>
<a name="line-270"></a>    <span class='hs-varid'>is_local</span> <span class='hs-varid'>name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nameIsLocalOrFrom</span> <span class='hs-varid'>this_mod</span> <span class='hs-varid'>name</span>
<a name="line-271"></a>
<a name="line-272"></a>        <span class='hs-comment'>-- Compute orphanhood.  See Note [Orphans] in GHC.Core.InstEnv</span>
<a name="line-273"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>cls_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>fds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTvsFds</span> <span class='hs-varid'>cls</span>
<a name="line-274"></a>    <span class='hs-varid'>arg_names</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>filterNameSet</span> <span class='hs-varid'>is_local</span> <span class='hs-layout'>(</span><span class='hs-varid'>orphNamesOfType</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tys</span><span class='hs-keyglyph'>]</span>
<a name="line-275"></a>
<a name="line-276"></a>    <span class='hs-comment'>-- See Note [When exactly is an instance decl an orphan?]</span>
<a name="line-277"></a>    <span class='hs-varid'>orph</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_local</span> <span class='hs-varid'>cls_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NotOrphan</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameOccName</span> <span class='hs-varid'>cls_name</span><span class='hs-layout'>)</span>
<a name="line-278"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all</span> <span class='hs-varid'>notOrphan</span> <span class='hs-varid'>mb_ns</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>mb_ns</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span> <span class='hs-varid'>head</span> <span class='hs-varid'>mb_ns</span>
<a name="line-279"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IsOrphan</span>
<a name="line-280"></a>
<a name="line-281"></a>    <span class='hs-varid'>notOrphan</span> <span class='hs-conid'>NotOrphan</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-282"></a>    <span class='hs-varid'>notOrphan</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-283"></a>
<a name="line-284"></a>    <span class='hs-varid'>mb_ns</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>IsOrphan</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- One for each fundep; a locally-defined name</span>
<a name="line-285"></a>                           <span class='hs-comment'>-- that is not in the "determined" arguments</span>
<a name="line-286"></a>    <span class='hs-varid'>mb_ns</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>fds</span>   <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>choose_one</span> <span class='hs-varid'>arg_names</span><span class='hs-keyglyph'>]</span>
<a name="line-287"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>do_one</span> <span class='hs-varid'>fds</span>
<a name="line-288"></a>    <span class='hs-varid'>do_one</span> <span class='hs-layout'>(</span><span class='hs-sel'>_ltvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rtvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>choose_one</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ns</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span><span class='hs-varid'>ns</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cls_tvs</span> <span class='hs-varop'>`zip`</span> <span class='hs-varid'>arg_names</span>
<a name="line-289"></a>                                            <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>rtvs</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-290"></a>
<a name="line-291"></a>    <span class='hs-varid'>choose_one</span> <span class='hs-varid'>nss</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>chooseOrphanAnchor</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionNameSets</span> <span class='hs-varid'>nss</span><span class='hs-layout'>)</span>
<a name="line-292"></a>
<a name="line-293"></a><a name="mkImportedInstance"></a><span class='hs-definition'>mkImportedInstance</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Name</span>           <span class='hs-comment'>-- ^ the name of the class</span>
<a name="line-294"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>RoughMatchTc</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ the types which the class was applied to</span>
<a name="line-295"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Name</span>           <span class='hs-comment'>-- ^ the 'Name' of the dictionary binding</span>
<a name="line-296"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunId</span>         <span class='hs-comment'>-- ^ the 'Id' of the dictionary.</span>
<a name="line-297"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OverlapFlag</span>    <span class='hs-comment'>-- ^ may this instance overlap?</span>
<a name="line-298"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IsOrphan</span>       <span class='hs-comment'>-- ^ is this instance an orphan?</span>
<a name="line-299"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span>
<a name="line-300"></a><span class='hs-comment'>-- Used for imported instances, where we get the rough-match stuff</span>
<a name="line-301"></a><span class='hs-comment'>-- from the interface file</span>
<a name="line-302"></a><span class='hs-comment'>-- The bound tyvars of the dfun are guaranteed fresh, because</span>
<a name="line-303"></a><span class='hs-comment'>-- the dfun has been typechecked out of the same interface file</span>
<a name="line-304"></a><span class='hs-definition'>mkImportedInstance</span> <span class='hs-varid'>cls_nm</span> <span class='hs-varid'>mb_tcs</span> <span class='hs-varid'>dfun_name</span> <span class='hs-varid'>dfun</span> <span class='hs-varid'>oflag</span> <span class='hs-varid'>orphan</span>
<a name="line-305"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_flag</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>oflag</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun</span>
<a name="line-306"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span>
<a name="line-307"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_dfun_name</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun_name</span>
<a name="line-308"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mb_tcs</span>
<a name="line-309"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>is_orphan</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orphan</span> <span class='hs-layout'>}</span>
<a name="line-310"></a>  <span class='hs-keyword'>where</span>
<a name="line-311"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun</span><span class='hs-layout'>)</span>
<a name="line-312"></a>
<a name="line-313"></a><span class='hs-comment'>{-
<a name="line-314"></a>Note [When exactly is an instance decl an orphan?]
<a name="line-315"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-316"></a>  (see GHC.Iface.Make.instanceToIfaceInst, which implements this)
<a name="line-317"></a>Roughly speaking, an instance is an orphan if its head (after the =&gt;)
<a name="line-318"></a>mentions nothing defined in this module.
<a name="line-319"></a>
<a name="line-320"></a>Functional dependencies complicate the situation though. Consider
<a name="line-321"></a>
<a name="line-322"></a>  module M where { class C a b | a -&gt; b }
<a name="line-323"></a>
<a name="line-324"></a>and suppose we are compiling module X:
<a name="line-325"></a>
<a name="line-326"></a>  module X where
<a name="line-327"></a>        import M
<a name="line-328"></a>        data T = ...
<a name="line-329"></a>        instance C Int T where ...
<a name="line-330"></a>
<a name="line-331"></a>This instance is an orphan, because when compiling a third module Y we
<a name="line-332"></a>might get a constraint (C Int v), and we'd want to improve v to T.  So
<a name="line-333"></a>we must make sure X's instances are loaded, even if we do not directly
<a name="line-334"></a>use anything from X.
<a name="line-335"></a>
<a name="line-336"></a>More precisely, an instance is an orphan iff
<a name="line-337"></a>
<a name="line-338"></a>  If there are no fundeps, then at least of the names in
<a name="line-339"></a>  the instance head is locally defined.
<a name="line-340"></a>
<a name="line-341"></a>  If there are fundeps, then for every fundep, at least one of the
<a name="line-342"></a>  names free in a *non-determined* part of the instance head is
<a name="line-343"></a>  defined in this module.
<a name="line-344"></a>
<a name="line-345"></a>(Note that these conditions hold trivially if the class is locally
<a name="line-346"></a>defined.)
<a name="line-347"></a>
<a name="line-348"></a>
<a name="line-349"></a>************************************************************************
<a name="line-350"></a>*                                                                      *
<a name="line-351"></a>                InstEnv, ClsInstEnv
<a name="line-352"></a>*                                                                      *
<a name="line-353"></a>************************************************************************
<a name="line-354"></a>
<a name="line-355"></a>A @ClsInstEnv@ all the instances of that class.  The @Id@ inside a
<a name="line-356"></a>ClsInstEnv mapping is the dfun for that instance.
<a name="line-357"></a>
<a name="line-358"></a>If class C maps to a list containing the item ([a,b], [t1,t2,t3], dfun), then
<a name="line-359"></a>
<a name="line-360"></a>        forall a b, C t1 t2 t3  can be constructed by dfun
<a name="line-361"></a>
<a name="line-362"></a>or, to put it another way, we have
<a name="line-363"></a>
<a name="line-364"></a>        instance (...) =&gt; C t1 t2 t3,  witnessed by dfun
<a name="line-365"></a>-}</span>
<a name="line-366"></a>
<a name="line-367"></a><span class='hs-comment'>---------------------------------------------------</span>
<a name="line-368"></a><span class='hs-comment'>{-
<a name="line-369"></a>Note [InstEnv determinism]
<a name="line-370"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-371"></a>We turn InstEnvs into a list in some places that don't directly affect
<a name="line-372"></a>the ABI. That happens when we create output for `:info`.
<a name="line-373"></a>Unfortunately that nondeterminism is nonlocal and it's hard to tell what it
<a name="line-374"></a>affects without following a chain of functions. It's also easy to accidentally
<a name="line-375"></a>make that nondeterminism affect the ABI. Furthermore the envs should be
<a name="line-376"></a>relatively small, so it should be free to use deterministic maps here.
<a name="line-377"></a>Testing with nofib and validate detected no difference between UniqFM and
<a name="line-378"></a>UniqDFM. See also Note [Deterministic UniqFM]
<a name="line-379"></a>-}</span>
<a name="line-380"></a>
<a name="line-381"></a><a name="InstEnv"></a><span class='hs-comment'>-- Internally it's safe to indexable this map by</span>
<a name="line-382"></a><a name="InstEnv"></a><span class='hs-comment'>-- by @Class@, the classes @Name@, the classes @TyCon@</span>
<a name="line-383"></a><a name="InstEnv"></a><span class='hs-comment'>-- or it's @Unique@.</span>
<a name="line-384"></a><a name="InstEnv"></a><span class='hs-comment'>-- This is since:</span>
<a name="line-385"></a><a name="InstEnv"></a><span class='hs-comment'>-- getUnique cls == getUnique (className cls) == getUnique (classTyCon cls)</span>
<a name="line-386"></a><a name="InstEnv"></a><span class='hs-comment'>--</span>
<a name="line-387"></a><a name="InstEnv"></a><span class='hs-comment'>-- We still use Class as key type as it's both the common case</span>
<a name="line-388"></a><a name="InstEnv"></a><span class='hs-comment'>-- and conveys the meaning better. But the implementation of</span>
<a name="line-389"></a><a name="InstEnv"></a><span class='hs-comment'>--InstEnv is a bit more lax internally.</span>
<a name="line-390"></a><a name="InstEnv"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UniqDFM</span> <span class='hs-conid'>Class</span> <span class='hs-conid'>ClsInstEnv</span>      <span class='hs-comment'>-- Maps Class to instances for that class</span>
<a name="line-391"></a>  <span class='hs-comment'>-- See Note [InstEnv determinism]</span>
<a name="line-392"></a>
<a name="line-393"></a><a name="InstEnvs"></a><span class='hs-comment'>-- | 'InstEnvs' represents the combination of the global type class instance</span>
<a name="line-394"></a><a name="InstEnvs"></a><span class='hs-comment'>-- environment, the local type class instance environment, and the set of</span>
<a name="line-395"></a><a name="InstEnvs"></a><span class='hs-comment'>-- transitively reachable orphan modules (according to what modules have been</span>
<a name="line-396"></a><a name="InstEnvs"></a><span class='hs-comment'>-- directly imported) used to test orphan instance visibility.</span>
<a name="line-397"></a><a name="InstEnvs"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>InstEnvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InstEnvs</span> <span class='hs-layout'>{</span>
<a name="line-398"></a>        <span class='hs-varid'>ie_global</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span><span class='hs-layout'>,</span>               <span class='hs-comment'>-- External-package instances</span>
<a name="line-399"></a>        <span class='hs-varid'>ie_local</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span><span class='hs-layout'>,</span>               <span class='hs-comment'>-- Home-package instances</span>
<a name="line-400"></a>        <span class='hs-varid'>ie_visible</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VisibleOrphanModules</span>   <span class='hs-comment'>-- Set of all orphan modules transitively</span>
<a name="line-401"></a>                                             <span class='hs-comment'>-- reachable from the module being compiled</span>
<a name="line-402"></a>                                             <span class='hs-comment'>-- See Note [Instance lookup and orphan instances]</span>
<a name="line-403"></a>    <span class='hs-layout'>}</span>
<a name="line-404"></a>
<a name="line-405"></a><a name="VisibleOrphanModules"></a><span class='hs-comment'>-- | Set of visible orphan modules, according to what modules have been directly</span>
<a name="line-406"></a><a name="VisibleOrphanModules"></a><span class='hs-comment'>-- imported.  This is based off of the dep_orphs field, which records</span>
<a name="line-407"></a><a name="VisibleOrphanModules"></a><span class='hs-comment'>-- transitively reachable orphan modules (modules that define orphan instances).</span>
<a name="line-408"></a><a name="VisibleOrphanModules"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>VisibleOrphanModules</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ModuleSet</span>
<a name="line-409"></a>
<a name="line-410"></a><a name="ClsInstEnv"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>ClsInstEnv</span>
<a name="line-411"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsIE</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- The instances for a particular class, in any order</span>
<a name="line-412"></a>
<a name="line-413"></a><a name="instance%20Outputable%20ClsInstEnv"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ClsInstEnv</span> <span class='hs-keyword'>where</span>
<a name="line-414"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>is</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprInstances</span> <span class='hs-varid'>is</span>
<a name="line-415"></a>
<a name="line-416"></a><span class='hs-comment'>-- INVARIANTS:</span>
<a name="line-417"></a><span class='hs-comment'>--  * The is_tvs are distinct in each ClsInst</span>
<a name="line-418"></a><span class='hs-comment'>--      of a ClsInstEnv (so we can safely unify them)</span>
<a name="line-419"></a>
<a name="line-420"></a><span class='hs-comment'>-- Thus, the @ClassInstEnv@ for @Eq@ might contain the following entry:</span>
<a name="line-421"></a><span class='hs-comment'>--      [a] ===&gt; dfun_Eq_List :: forall a. Eq a =&gt; Eq [a]</span>
<a name="line-422"></a><span class='hs-comment'>-- The "a" in the pattern must be one of the forall'd variables in</span>
<a name="line-423"></a><span class='hs-comment'>-- the dfun type.</span>
<a name="line-424"></a>
<a name="line-425"></a><a name="emptyInstEnv"></a><span class='hs-definition'>emptyInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span>
<a name="line-426"></a><span class='hs-definition'>emptyInstEnv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyUDFM</span>
<a name="line-427"></a>
<a name="line-428"></a><a name="instEnvElts"></a><span class='hs-definition'>instEnvElts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span>
<a name="line-429"></a><span class='hs-definition'>instEnvElts</span> <span class='hs-varid'>ie</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>elt</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ClsIE</span> <span class='hs-varid'>elts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eltsUDFM</span> <span class='hs-varid'>ie</span><span class='hs-layout'>,</span> <span class='hs-varid'>elt</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>elts</span><span class='hs-keyglyph'>]</span>
<a name="line-430"></a>  <span class='hs-comment'>-- See Note [InstEnv determinism]</span>
<a name="line-431"></a>
<a name="line-432"></a><a name="instEnvClasses"></a><span class='hs-definition'>instEnvClasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Class</span><span class='hs-keyglyph'>]</span>
<a name="line-433"></a><span class='hs-definition'>instEnvClasses</span> <span class='hs-varid'>ie</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>is_cls</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ClsIE</span> <span class='hs-layout'>(</span><span class='hs-varid'>e</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eltsUDFM</span> <span class='hs-varid'>ie</span><span class='hs-keyglyph'>]</span>
<a name="line-434"></a>
<a name="line-435"></a><a name="instIsVisible"></a><span class='hs-comment'>-- | Test if an instance is visible, by checking that its origin module</span>
<a name="line-436"></a><span class='hs-comment'>-- is in 'VisibleOrphanModules'.</span>
<a name="line-437"></a><span class='hs-comment'>-- See Note [Instance lookup and orphan instances]</span>
<a name="line-438"></a><span class='hs-definition'>instIsVisible</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VisibleOrphanModules</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-439"></a><span class='hs-definition'>instIsVisible</span> <span class='hs-varid'>vis_mods</span> <span class='hs-varid'>ispec</span>
<a name="line-440"></a>  <span class='hs-comment'>-- NB: Instances from the interactive package always are visible. We can't</span>
<a name="line-441"></a>  <span class='hs-comment'>-- add interactive modules to the set since we keep creating new ones</span>
<a name="line-442"></a>  <span class='hs-comment'>-- as a GHCi session progresses.</span>
<a name="line-443"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>nameModule_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun_name</span> <span class='hs-varid'>ispec</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-444"></a>      <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-445"></a>      <span class='hs-conid'>Just</span> <span class='hs-varid'>mod</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isInteractiveModule</span> <span class='hs-varid'>mod</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-446"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IsOrphan</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>is_orphan</span> <span class='hs-varid'>ispec</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mod</span> <span class='hs-varop'>`elemModuleSet`</span> <span class='hs-varid'>vis_mods</span>
<a name="line-447"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-448"></a>
<a name="line-449"></a><a name="classInstances"></a><span class='hs-definition'>classInstances</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span>
<a name="line-450"></a><span class='hs-definition'>classInstances</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstEnvs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ie_global</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pkg_ie</span><span class='hs-layout'>,</span> <span class='hs-varid'>ie_local</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>home_ie</span><span class='hs-layout'>,</span> <span class='hs-varid'>ie_visible</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vis_mods</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>cls</span>
<a name="line-451"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>get</span> <span class='hs-varid'>home_ie</span> <span class='hs-varop'>++</span> <span class='hs-varid'>get</span> <span class='hs-varid'>pkg_ie</span>
<a name="line-452"></a>  <span class='hs-keyword'>where</span>
<a name="line-453"></a>    <span class='hs-varid'>get</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupUDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cls</span> <span class='hs-keyword'>of</span>
<a name="line-454"></a>                <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>insts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>instIsVisible</span> <span class='hs-varid'>vis_mods</span><span class='hs-layout'>)</span> <span class='hs-varid'>insts</span>
<a name="line-455"></a>                <span class='hs-conid'>Nothing</span>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-456"></a>
<a name="line-457"></a><a name="memberInstEnv"></a><span class='hs-comment'>-- | Checks for an exact match of ClsInst in the instance environment.</span>
<a name="line-458"></a><span class='hs-comment'>-- We use this when we do signature checking in "GHC.Tc.Module"</span>
<a name="line-459"></a><span class='hs-definition'>memberInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-460"></a><span class='hs-definition'>memberInstEnv</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>ins_item</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-461"></a>    <span class='hs-varid'>maybe</span> <span class='hs-conid'>False</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>items</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>identicalDFunType</span> <span class='hs-varid'>ins_item</span><span class='hs-layout'>)</span> <span class='hs-varid'>items</span><span class='hs-layout'>)</span>
<a name="line-462"></a>          <span class='hs-layout'>(</span><span class='hs-varid'>lookupUDFM_Directly</span> <span class='hs-varid'>inst_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUnique</span> <span class='hs-varid'>cls_nm</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-463"></a> <span class='hs-keyword'>where</span>
<a name="line-464"></a>  <span class='hs-varid'>identicalDFunType</span> <span class='hs-varid'>cls1</span> <span class='hs-varid'>cls2</span> <span class='hs-keyglyph'>=</span>
<a name="line-465"></a>    <span class='hs-varid'>eqType</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun</span> <span class='hs-varid'>cls1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_dfun</span> <span class='hs-varid'>cls2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-466"></a>
<a name="line-467"></a><a name="extendInstEnvList"></a><span class='hs-definition'>extendInstEnvList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstEnv</span>
<a name="line-468"></a><span class='hs-definition'>extendInstEnvList</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>ispecs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>extendInstEnv</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>ispecs</span>
<a name="line-469"></a>
<a name="line-470"></a><a name="extendInstEnv"></a><span class='hs-definition'>extendInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstEnv</span>
<a name="line-471"></a><span class='hs-definition'>extendInstEnv</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>ins_item</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-472"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>addToUDFM_C_Directly</span> <span class='hs-varid'>add</span> <span class='hs-varid'>inst_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUnique</span> <span class='hs-varid'>cls_nm</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ins_item</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-473"></a>  <span class='hs-keyword'>where</span>
<a name="line-474"></a>    <span class='hs-varid'>add</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>cur_insts</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsIE</span> <span class='hs-layout'>(</span><span class='hs-varid'>ins_item</span> <span class='hs-conop'>:</span> <span class='hs-varid'>cur_insts</span><span class='hs-layout'>)</span>
<a name="line-475"></a>
<a name="line-476"></a><a name="deleteFromInstEnv"></a><span class='hs-definition'>deleteFromInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstEnv</span>
<a name="line-477"></a><span class='hs-definition'>deleteFromInstEnv</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>ins_item</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-478"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adjustUDFM_Directly</span> <span class='hs-varid'>adjust</span> <span class='hs-varid'>inst_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>getUnique</span> <span class='hs-varid'>cls_nm</span><span class='hs-layout'>)</span>
<a name="line-479"></a>  <span class='hs-keyword'>where</span>
<a name="line-480"></a>    <span class='hs-varid'>adjust</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>items</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsIE</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterOut</span> <span class='hs-layout'>(</span><span class='hs-varid'>identicalClsInstHead</span> <span class='hs-varid'>ins_item</span><span class='hs-layout'>)</span> <span class='hs-varid'>items</span><span class='hs-layout'>)</span>
<a name="line-481"></a>
<a name="line-482"></a><a name="deleteDFunFromInstEnv"></a><span class='hs-definition'>deleteDFunFromInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DFunId</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstEnv</span>
<a name="line-483"></a><span class='hs-comment'>-- Delete a specific instance fron an InstEnv</span>
<a name="line-484"></a><span class='hs-definition'>deleteDFunFromInstEnv</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>dfun</span>
<a name="line-485"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adjustUDFM</span> <span class='hs-varid'>adjust</span> <span class='hs-varid'>inst_env</span> <span class='hs-varid'>cls</span>
<a name="line-486"></a>  <span class='hs-keyword'>where</span>
<a name="line-487"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>dfun</span><span class='hs-layout'>)</span>
<a name="line-488"></a>    <span class='hs-varid'>adjust</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>items</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ClsIE</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterOut</span> <span class='hs-varid'>same_dfun</span> <span class='hs-varid'>items</span><span class='hs-layout'>)</span>
<a name="line-489"></a>    <span class='hs-varid'>same_dfun</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_dfun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dfun</span> <span class='hs-varop'>==</span> <span class='hs-varid'>dfun'</span>
<a name="line-490"></a>
<a name="line-491"></a><a name="identicalClsInstHead"></a><span class='hs-definition'>identicalClsInstHead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-492"></a><span class='hs-comment'>-- ^ True when when the instance heads are the same</span>
<a name="line-493"></a><span class='hs-comment'>-- e.g.  both are   Eq [(a,b)]</span>
<a name="line-494"></a><span class='hs-comment'>-- Used for overriding in GHCi</span>
<a name="line-495"></a><span class='hs-comment'>-- Obviously should be insensitive to alpha-renaming</span>
<a name="line-496"></a><span class='hs-definition'>identicalClsInstHead</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm1</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rough1</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-497"></a>                     <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_cls_nm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls_nm2</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rough2</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-498"></a>  <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>cls_nm1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>cls_nm2</span>
<a name="line-499"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>instanceCantMatch</span> <span class='hs-varid'>rough1</span> <span class='hs-varid'>rough2</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Fast check for no match, uses the "rough match" fields</span>
<a name="line-500"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcMatchTys</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span>
<a name="line-501"></a>  <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcMatchTys</span> <span class='hs-varid'>tys2</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span>
<a name="line-502"></a>
<a name="line-503"></a><span class='hs-comment'>{-
<a name="line-504"></a>************************************************************************
<a name="line-505"></a>*                                                                      *
<a name="line-506"></a>        Looking up an instance
<a name="line-507"></a>*                                                                      *
<a name="line-508"></a>************************************************************************
<a name="line-509"></a>
<a name="line-510"></a>@lookupInstEnv@ looks up in a @InstEnv@, using a one-way match.  Since
<a name="line-511"></a>the env is kept ordered, the first match must be the only one.  The
<a name="line-512"></a>thing we are looking up can have an arbitrary "flexi" part.
<a name="line-513"></a>
<a name="line-514"></a>Note [Instance lookup and orphan instances]
<a name="line-515"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-516"></a>Suppose we are compiling a module M, and we have a zillion packages
<a name="line-517"></a>loaded, and we are looking up an instance for C (T W).  If we find a
<a name="line-518"></a>match in module 'X' from package 'p', should be "in scope"; that is,
<a name="line-519"></a>
<a name="line-520"></a>  is p:X in the transitive closure of modules imported from M?
<a name="line-521"></a>
<a name="line-522"></a>The difficulty is that the "zillion packages" might include ones loaded
<a name="line-523"></a>through earlier invocations of the GHC API, or earlier module loads in GHCi.
<a name="line-524"></a>They might not be in the dependencies of M itself; and if not, the instances
<a name="line-525"></a>in them should not be visible.  #2182, #8427.
<a name="line-526"></a>
<a name="line-527"></a>There are two cases:
<a name="line-528"></a>  * If the instance is *not an orphan*, then module X defines C, T, or W.
<a name="line-529"></a>    And in order for those types to be involved in typechecking M, it
<a name="line-530"></a>    must be that X is in the transitive closure of M's imports.  So we
<a name="line-531"></a>    can use the instance.
<a name="line-532"></a>
<a name="line-533"></a>  * If the instance *is an orphan*, the above reasoning does not apply.
<a name="line-534"></a>    So we keep track of the set of orphan modules transitively below M;
<a name="line-535"></a>    this is the ie_visible field of InstEnvs, of type VisibleOrphanModules.
<a name="line-536"></a>
<a name="line-537"></a>    If module p:X is in this set, then we can use the instance, otherwise
<a name="line-538"></a>    we can't.
<a name="line-539"></a>
<a name="line-540"></a>Note [Rules for instance lookup]
<a name="line-541"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-542"></a>These functions implement the carefully-written rules in the user
<a name="line-543"></a>manual section on "overlapping instances". At risk of duplication,
<a name="line-544"></a>here are the rules.  If the rules change, change this text and the
<a name="line-545"></a>user manual simultaneously.  The link may be this:
<a name="line-546"></a><a href="http://www.haskell.org/ghc/docs/latest/html/users_guide/glasgow_exts.html#instance-overlap">http://www.haskell.org/ghc/docs/latest/html/users_guide/glasgow_exts.html#instance-overlap</a>
<a name="line-547"></a>
<a name="line-548"></a>The willingness to be overlapped or incoherent is a property of the
<a name="line-549"></a>instance declaration itself, controlled as follows:
<a name="line-550"></a>
<a name="line-551"></a> * An instance is "incoherent"
<a name="line-552"></a>   if it has an INCOHERENT pragma, or
<a name="line-553"></a>   if it appears in a module compiled with -XIncoherentInstances.
<a name="line-554"></a>
<a name="line-555"></a> * An instance is "overlappable"
<a name="line-556"></a>   if it has an OVERLAPPABLE or OVERLAPS pragma, or
<a name="line-557"></a>   if it appears in a module compiled with -XOverlappingInstances, or
<a name="line-558"></a>   if the instance is incoherent.
<a name="line-559"></a>
<a name="line-560"></a> * An instance is "overlapping"
<a name="line-561"></a>   if it has an OVERLAPPING or OVERLAPS pragma, or
<a name="line-562"></a>   if it appears in a module compiled with -XOverlappingInstances, or
<a name="line-563"></a>   if the instance is incoherent.
<a name="line-564"></a>     compiled with -XOverlappingInstances.
<a name="line-565"></a>
<a name="line-566"></a>Now suppose that, in some client module, we are searching for an instance
<a name="line-567"></a>of the target constraint (C ty1 .. tyn). The search works like this.
<a name="line-568"></a>
<a name="line-569"></a>*  Find all instances `I` that *match* the target constraint; that is, the
<a name="line-570"></a>   target constraint is a substitution instance of `I`. These instance
<a name="line-571"></a>   declarations are the *candidates*.
<a name="line-572"></a>
<a name="line-573"></a>*  Eliminate any candidate `IX` for which both of the following hold:
<a name="line-574"></a>
<a name="line-575"></a>   -  There is another candidate `IY` that is strictly more specific; that
<a name="line-576"></a>      is, `IY` is a substitution instance of `IX` but not vice versa.
<a name="line-577"></a>
<a name="line-578"></a>   -  Either `IX` is *overlappable*, or `IY` is *overlapping*. (This
<a name="line-579"></a>      "either/or" design, rather than a "both/and" design, allow a
<a name="line-580"></a>      client to deliberately override an instance from a library,
<a name="line-581"></a>      without requiring a change to the library.)
<a name="line-582"></a>
<a name="line-583"></a>-  If exactly one non-incoherent candidate remains, select it. If all
<a name="line-584"></a>   remaining candidates are incoherent, select an arbitrary one.
<a name="line-585"></a>   Otherwise the search fails (i.e. when more than one surviving
<a name="line-586"></a>   candidate is not incoherent).
<a name="line-587"></a>
<a name="line-588"></a>-  If the selected candidate (from the previous step) is incoherent, the
<a name="line-589"></a>   search succeeds, returning that candidate.
<a name="line-590"></a>
<a name="line-591"></a>-  If not, find all instances that *unify* with the target constraint,
<a name="line-592"></a>   but do not *match* it. Such non-candidate instances might match when
<a name="line-593"></a>   the target constraint is further instantiated. If all of them are
<a name="line-594"></a>   incoherent, the search succeeds, returning the selected candidate; if
<a name="line-595"></a>   not, the search fails.
<a name="line-596"></a>
<a name="line-597"></a>Notice that these rules are not influenced by flag settings in the
<a name="line-598"></a>client module, where the instances are *used*. These rules make it
<a name="line-599"></a>possible for a library author to design a library that relies on
<a name="line-600"></a>overlapping instances without the client having to know.
<a name="line-601"></a>
<a name="line-602"></a>Note [Overlapping instances]   (NB: these notes are quite old)
<a name="line-603"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-604"></a>Overlap is permitted, but only in such a way that one can make
<a name="line-605"></a>a unique choice when looking up.  That is, overlap is only permitted if
<a name="line-606"></a>one template matches the other, or vice versa.  So this is ok:
<a name="line-607"></a>
<a name="line-608"></a>  [a]  [Int]
<a name="line-609"></a>
<a name="line-610"></a>but this is not
<a name="line-611"></a>
<a name="line-612"></a>  (Int,a)  (b,Int)
<a name="line-613"></a>
<a name="line-614"></a>If overlap is permitted, the list is kept most specific first, so that
<a name="line-615"></a>the first lookup is the right choice.
<a name="line-616"></a>
<a name="line-617"></a>
<a name="line-618"></a>For now we just use association lists.
<a name="line-619"></a>
<a name="line-620"></a>\subsection{Avoiding a problem with overlapping}
<a name="line-621"></a>
<a name="line-622"></a>Consider this little program:
<a name="line-623"></a>
<a name="line-624"></a>\begin{pseudocode}
<a name="line-625"></a>     class C a        where c :: a
<a name="line-626"></a>     class C a =&gt; D a where d :: a
<a name="line-627"></a>
<a name="line-628"></a>     instance C Int where c = 17
<a name="line-629"></a>     instance D Int where d = 13
<a name="line-630"></a>
<a name="line-631"></a>     instance C a =&gt; C [a] where c = [c]
<a name="line-632"></a>     instance ({- C [a], -} D a) =&gt; D [a] where d = c
<a name="line-633"></a>
<a name="line-634"></a>     instance C [Int] where c = [37]
<a name="line-635"></a>
<a name="line-636"></a>     main = print (d :: [Int])
<a name="line-637"></a>\end{pseudocode}
<a name="line-638"></a>
<a name="line-639"></a>What do you think `main' prints  (assuming we have overlapping instances, and
<a name="line-640"></a>all that turned on)?  Well, the instance for `D' at type `[a]' is defined to
<a name="line-641"></a>be `c' at the same type, and we've got an instance of `C' at `[Int]', so the
<a name="line-642"></a>answer is `[37]', right? (the generic `C [a]' instance shouldn't apply because
<a name="line-643"></a>the `C [Int]' instance is more specific).
<a name="line-644"></a>
<a name="line-645"></a>Ghc-4.04 gives `[37]', while ghc-4.06 gives `[17]', so 4.06 is wrong.  That
<a name="line-646"></a>was easy ;-)  Let's just consult hugs for good measure.  Wait - if I use old
<a name="line-647"></a>hugs (pre-September99), I get `[17]', and stranger yet, if I use hugs98, it
<a name="line-648"></a>doesn't even compile!  What's going on!?
<a name="line-649"></a>
<a name="line-650"></a>What hugs complains about is the `D [a]' instance decl.
<a name="line-651"></a>
<a name="line-652"></a>\begin{pseudocode}
<a name="line-653"></a>     ERROR "mj.hs" (line 10): Cannot build superclass instance
<a name="line-654"></a>     *** Instance            : D [a]
<a name="line-655"></a>     *** Context supplied    : D a
<a name="line-656"></a>     *** Required superclass : C [a]
<a name="line-657"></a>\end{pseudocode}
<a name="line-658"></a>
<a name="line-659"></a>You might wonder what hugs is complaining about.  It's saying that you
<a name="line-660"></a>need to add `C [a]' to the context of the `D [a]' instance (as appears
<a name="line-661"></a>in comments).  But there's that `C [a]' instance decl one line above
<a name="line-662"></a>that says that I can reduce the need for a `C [a]' instance to the
<a name="line-663"></a>need for a `C a' instance, and in this case, I already have the
<a name="line-664"></a>necessary `C a' instance (since we have `D a' explicitly in the
<a name="line-665"></a>context, and `C' is a superclass of `D').
<a name="line-666"></a>
<a name="line-667"></a>Unfortunately, the above reasoning indicates a premature commitment to the
<a name="line-668"></a>generic `C [a]' instance.  I.e., it prematurely rules out the more specific
<a name="line-669"></a>instance `C [Int]'.  This is the mistake that ghc-4.06 makes.  The fix is to
<a name="line-670"></a>add the context that hugs suggests (uncomment the `C [a]'), effectively
<a name="line-671"></a>deferring the decision about which instance to use.
<a name="line-672"></a>
<a name="line-673"></a>Now, interestingly enough, 4.04 has this same bug, but it's covered up
<a name="line-674"></a>in this case by a little known `optimization' that was disabled in
<a name="line-675"></a>4.06.  Ghc-4.04 silently inserts any missing superclass context into
<a name="line-676"></a>an instance declaration.  In this case, it silently inserts the `C
<a name="line-677"></a>[a]', and everything happens to work out.
<a name="line-678"></a>
<a name="line-679"></a>(See `GHC.Types.Id.Make.mkDictFunId' for the code in question.  Search for
<a name="line-680"></a>`Mark Jones', although Mark claims no credit for the `optimization' in
<a name="line-681"></a>question, and would rather it stopped being called the `Mark Jones
<a name="line-682"></a>optimization' ;-)
<a name="line-683"></a>
<a name="line-684"></a>So, what's the fix?  I think hugs has it right.  Here's why.  Let's try
<a name="line-685"></a>something else out with ghc-4.04.  Let's add the following line:
<a name="line-686"></a>
<a name="line-687"></a>    d' :: D a =&gt; [a]
<a name="line-688"></a>    d' = c
<a name="line-689"></a>
<a name="line-690"></a>Everyone raise their hand who thinks that `d :: [Int]' should give a
<a name="line-691"></a>different answer from `d' :: [Int]'.  Well, in ghc-4.04, it does.  The
<a name="line-692"></a>`optimization' only applies to instance decls, not to regular
<a name="line-693"></a>bindings, giving inconsistent behavior.
<a name="line-694"></a>
<a name="line-695"></a>Old hugs had this same bug.  Here's how we fixed it: like GHC, the
<a name="line-696"></a>list of instances for a given class is ordered, so that more specific
<a name="line-697"></a>instances come before more generic ones.  For example, the instance
<a name="line-698"></a>list for C might contain:
<a name="line-699"></a>    ..., C Int, ..., C a, ...
<a name="line-700"></a>When we go to look for a `C Int' instance we'll get that one first.
<a name="line-701"></a>But what if we go looking for a `C b' (`b' is unconstrained)?  We'll
<a name="line-702"></a>pass the `C Int' instance, and keep going.  But if `b' is
<a name="line-703"></a>unconstrained, then we don't know yet if the more specific instance
<a name="line-704"></a>will eventually apply.  GHC keeps going, and matches on the generic `C
<a name="line-705"></a>a'.  The fix is to, at each step, check to see if there's a reverse
<a name="line-706"></a>match, and if so, abort the search.  This prevents hugs from
<a name="line-707"></a>prematurely choosing a generic instance when a more specific one
<a name="line-708"></a>exists.
<a name="line-709"></a>
<a name="line-710"></a>--Jeff
<a name="line-711"></a>
<a name="line-712"></a>BUT NOTE [Nov 2001]: we must actually *unify* not reverse-match in
<a name="line-713"></a>this test.  Suppose the instance envt had
<a name="line-714"></a>    ..., forall a b. C a a b, ..., forall a b c. C a b c, ...
<a name="line-715"></a>(still most specific first)
<a name="line-716"></a>Now suppose we are looking for (C x y Int), where x and y are unconstrained.
<a name="line-717"></a>        C x y Int  doesn't match the template {a,b} C a a b
<a name="line-718"></a>but neither does
<a name="line-719"></a>        C a a b  match the template {x,y} C x y Int
<a name="line-720"></a>But still x and y might subsequently be unified so they *do* match.
<a name="line-721"></a>
<a name="line-722"></a>Simple story: unify, don't match.
<a name="line-723"></a>-}</span>
<a name="line-724"></a>
<a name="line-725"></a><a name="DFunInstType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>DFunInstType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span>
<a name="line-726"></a>        <span class='hs-comment'>-- Just ty   =&gt; Instantiate with this type</span>
<a name="line-727"></a>        <span class='hs-comment'>-- Nothing   =&gt; Instantiate with any type of this tyvar's kind</span>
<a name="line-728"></a>        <span class='hs-comment'>-- See Note [DFunInstType: instantiating types]</span>
<a name="line-729"></a>
<a name="line-730"></a><a name="InstMatch"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>InstMatch</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>DFunInstType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-731"></a>
<a name="line-732"></a><a name="ClsInstLookupResult"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ClsInstLookupResult</span>
<a name="line-733"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstMatch</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Successful matches</span>
<a name="line-734"></a>       <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- These don't match but do unify</span>
<a name="line-735"></a>       <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstMatch</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- Unsafe overlapped instances under Safe Haskell</span>
<a name="line-736"></a>                         <span class='hs-comment'>-- (see Note [Safe Haskell Overlapping Instances] in</span>
<a name="line-737"></a>                         <span class='hs-comment'>-- GHC.Tc.Solver).</span>
<a name="line-738"></a>
<a name="line-739"></a><span class='hs-comment'>{-
<a name="line-740"></a>Note [DFunInstType: instantiating types]
<a name="line-741"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-742"></a>A successful match is a ClsInst, together with the types at which
<a name="line-743"></a>        the dfun_id in the ClsInst should be instantiated
<a name="line-744"></a>The instantiating types are (Either TyVar Type)s because the dfun
<a name="line-745"></a>might have some tyvars that *only* appear in arguments
<a name="line-746"></a>        dfun :: forall a b. C a b, Ord b =&gt; D [a]
<a name="line-747"></a>When we match this against D [ty], we return the instantiating types
<a name="line-748"></a>        [Just ty, Nothing]
<a name="line-749"></a>where the 'Nothing' indicates that 'b' can be freely instantiated.
<a name="line-750"></a>(The caller instantiates it to a flexi type variable, which will
<a name="line-751"></a> presumably later become fixed via functional dependencies.)
<a name="line-752"></a>
<a name="line-753"></a>Note [Infinitary substitution in lookup]
<a name="line-754"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-755"></a>Consider
<a name="line-756"></a>
<a name="line-757"></a>  class C a b
<a name="line-758"></a>  instance C c c
<a name="line-759"></a>  instance C d (Maybe d)
<a name="line-760"></a>  [W] C e (Maybe e)
<a name="line-761"></a>
<a name="line-762"></a>You would think we could just use the second instance, because the first doesn't
<a name="line-763"></a>unify. But that's just ever so slightly wrong. The reason we check for unifiers
<a name="line-764"></a>along with matchers is that we don't want the possibility that a type variable
<a name="line-765"></a>instantiation could cause an instance choice to change. Yet if we have
<a name="line-766"></a>  type family M = Maybe M
<a name="line-767"></a>and choose (e |-&gt; M), then both instances match. This is absurd, but we cannot
<a name="line-768"></a>rule it out. Yet, worrying about this case is awfully inconvenient to users,
<a name="line-769"></a>and so we pretend the problem doesn't exist, by considering a lookup that runs into
<a name="line-770"></a>this occurs-check issue to indicate that an instance surely does not apply (i.e.
<a name="line-771"></a>is like the SurelyApart case). In the brief time that we didn't treat infinitary
<a name="line-772"></a>substitutions specially, two tickets were filed: #19044 and #19052, both trying
<a name="line-773"></a>to do Real Work.
<a name="line-774"></a>
<a name="line-775"></a>Why don't we just exclude any instances that are MaybeApart? Because we might
<a name="line-776"></a>have a [W] C e (F e), where F is a type family. The second instance above does
<a name="line-777"></a>not match, but it should be included as a future possibility. Unification will
<a name="line-778"></a>return MaybeApart MARTypeFamily in this case.
<a name="line-779"></a>
<a name="line-780"></a>What can go wrong with this design choice? We might get incoherence -- but not
<a name="line-781"></a>loss of type safety. In particular, if we have [W] C M M (for the M type family
<a name="line-782"></a>above), then GHC might arbitrarily choose either instance, depending on how
<a name="line-783"></a>M reduces (or doesn't).
<a name="line-784"></a>
<a name="line-785"></a>For type families, we can't just ignore the problem (as we essentially do here),
<a name="line-786"></a>because doing so would give us a hole in the type safety proof (as explored in
<a name="line-787"></a>Section 6 of "Closed Type Families with Overlapping Equations", POPL'14). This
<a name="line-788"></a>possibility of an infinitary substitution manifests as closed type families that
<a name="line-789"></a>look like they should reduce, but don't. Users complain: #9082 and #17311. For
<a name="line-790"></a>open type families, we actually can have unsoundness if we don't take infinitary
<a name="line-791"></a>substitutions into account: #8162. But, luckily, for class instances, we just
<a name="line-792"></a>risk coherence -- not great, but it seems better to give users what they likely
<a name="line-793"></a>want. (Also, note that this problem existed for the entire decade of 201x without
<a name="line-794"></a>anyone noticing, so it's manifestly not ruining anyone's day.)
<a name="line-795"></a>-}</span>
<a name="line-796"></a>
<a name="line-797"></a><a name="lookupUniqueInstEnv"></a><span class='hs-comment'>-- |Look up an instance in the given instance environment. The given class application must match exactly</span>
<a name="line-798"></a><span class='hs-comment'>-- one instance and the match may not contain any flexi type variables.  If the lookup is unsuccessful,</span>
<a name="line-799"></a><span class='hs-comment'>-- yield 'Left errorMessage'.</span>
<a name="line-800"></a><span class='hs-definition'>lookupUniqueInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnvs</span>
<a name="line-801"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-802"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>SDoc</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-803"></a><span class='hs-definition'>lookupUniqueInstEnv</span> <span class='hs-varid'>instEnv</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-804"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupInstEnv</span> <span class='hs-conid'>False</span> <span class='hs-varid'>instEnv</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyword'>of</span>
<a name="line-805"></a>      <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>inst</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-806"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>noFlexiVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>inst</span><span class='hs-layout'>,</span> <span class='hs-varid'>inst_tys'</span><span class='hs-layout'>)</span>
<a name="line-807"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"flexible type variable:"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-808"></a>                                    <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-809"></a>             <span class='hs-keyword'>where</span>
<a name="line-810"></a>               <span class='hs-varid'>inst_tys'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>inst_tys</span><span class='hs-keyglyph'>]</span>
<a name="line-811"></a>               <span class='hs-varid'>noFlexiVar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>inst_tys</span>
<a name="line-812"></a>      <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"instance not found"</span> <span class='hs-varop'>&lt;+&gt;</span>
<a name="line-813"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-814"></a>
<a name="line-815"></a><a name="lookupInstEnv'"></a><span class='hs-definition'>lookupInstEnv'</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstEnv</span>          <span class='hs-comment'>-- InstEnv to look in</span>
<a name="line-816"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VisibleOrphanModules</span>   <span class='hs-comment'>-- But filter against this</span>
<a name="line-817"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- What we are looking for</span>
<a name="line-818"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>InstMatch</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Successful matches</span>
<a name="line-819"></a>                   <span class='hs-keyglyph'>[</span><span class='hs-conid'>ClsInst</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- These don't match but do unify</span>
<a name="line-820"></a>                                   <span class='hs-comment'>-- (no incoherent ones in here)</span>
<a name="line-821"></a><span class='hs-comment'>-- The second component of the result pair happens when we look up</span>
<a name="line-822"></a><span class='hs-comment'>--      Foo [a]</span>
<a name="line-823"></a><span class='hs-comment'>-- in an InstEnv that has entries for</span>
<a name="line-824"></a><span class='hs-comment'>--      Foo [Int]</span>
<a name="line-825"></a><span class='hs-comment'>--      Foo [b]</span>
<a name="line-826"></a><span class='hs-comment'>-- Then which we choose would depend on the way in which 'a'</span>
<a name="line-827"></a><span class='hs-comment'>-- is instantiated.  So we report that Foo [b] is a match (mapping b-&gt;a)</span>
<a name="line-828"></a><span class='hs-comment'>-- but Foo [Int] is a unifier.  This gives the caller a better chance of</span>
<a name="line-829"></a><span class='hs-comment'>-- giving a suitable error message</span>
<a name="line-830"></a>
<a name="line-831"></a><span class='hs-definition'>lookupInstEnv'</span> <span class='hs-varid'>ie</span> <span class='hs-varid'>vis_mods</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-832"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookup</span> <span class='hs-varid'>ie</span>
<a name="line-833"></a>  <span class='hs-keyword'>where</span>
<a name="line-834"></a>    <span class='hs-varid'>rough_tcs</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>roughMatchTcs</span> <span class='hs-varid'>tys</span>
<a name="line-835"></a>
<a name="line-836"></a>    <span class='hs-comment'>--------------</span>
<a name="line-837"></a>    <span class='hs-varid'>lookup</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupUDFM</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cls</span> <span class='hs-keyword'>of</span>
<a name="line-838"></a>                   <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- No instances for this class</span>
<a name="line-839"></a>                   <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>ClsIE</span> <span class='hs-varid'>insts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>find</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>insts</span>
<a name="line-840"></a>
<a name="line-841"></a>    <span class='hs-comment'>--------------</span>
<a name="line-842"></a>    <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ms</span><span class='hs-layout'>,</span> <span class='hs-varid'>us</span><span class='hs-layout'>)</span>
<a name="line-843"></a>    <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span> <span class='hs-layout'>(</span><span class='hs-varid'>item</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ClsInst</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_tcs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mb_tcs</span><span class='hs-layout'>,</span> <span class='hs-varid'>is_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tpl_tvs</span>
<a name="line-844"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>is_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tpl_tys</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-845"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>instIsVisible</span> <span class='hs-varid'>vis_mods</span> <span class='hs-varid'>item</span><span class='hs-layout'>)</span>
<a name="line-846"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span> <span class='hs-varid'>rest</span>  <span class='hs-comment'>-- See Note [Instance lookup and orphan instances]</span>
<a name="line-847"></a>
<a name="line-848"></a>        <span class='hs-comment'>-- Fast check for no match, uses the "rough match" fields</span>
<a name="line-849"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>instanceCantMatch</span> <span class='hs-varid'>rough_tcs</span> <span class='hs-varid'>mb_tcs</span>
<a name="line-850"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span> <span class='hs-varid'>rest</span>
<a name="line-851"></a>
<a name="line-852"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcMatchTys</span> <span class='hs-varid'>tpl_tys</span> <span class='hs-varid'>tys</span>
<a name="line-853"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>find</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>item</span><span class='hs-layout'>,</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>lookupTyVar</span> <span class='hs-varid'>subst</span><span class='hs-layout'>)</span> <span class='hs-varid'>tpl_tvs</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>ms</span><span class='hs-layout'>)</span> <span class='hs-varid'>us</span> <span class='hs-varid'>rest</span>
<a name="line-854"></a>
<a name="line-855"></a>        <span class='hs-comment'>-- Does not match, so next check whether the things unify</span>
<a name="line-856"></a>        <span class='hs-comment'>-- See Note [Overlapping instances]</span>
<a name="line-857"></a>        <span class='hs-comment'>-- Ignore ones that are incoherent: Note [Incoherent instances]</span>
<a name="line-858"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIncoherent</span> <span class='hs-varid'>item</span>
<a name="line-859"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span> <span class='hs-varid'>rest</span>
<a name="line-860"></a>
<a name="line-861"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-862"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>tys_tv_set</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>tpl_tv_set</span><span class='hs-layout'>,</span>
<a name="line-863"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-varop'>$$</span>
<a name="line-864"></a>                 <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tpl_tvs</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tpl_tys</span><span class='hs-layout'>)</span>
<a name="line-865"></a>                <span class='hs-layout'>)</span>
<a name="line-866"></a>                <span class='hs-comment'>-- Unification will break badly if the variables overlap</span>
<a name="line-867"></a>                <span class='hs-comment'>-- They shouldn't because we allocate separate uniques for them</span>
<a name="line-868"></a>                <span class='hs-comment'>-- See Note [Template tyvars are fresh]</span>
<a name="line-869"></a>        <span class='hs-keyword'>case</span> <span class='hs-varid'>tcUnifyTysFG</span> <span class='hs-varid'>instanceBindFun</span> <span class='hs-varid'>tpl_tys</span> <span class='hs-varid'>tys</span> <span class='hs-keyword'>of</span>
<a name="line-870"></a>          <span class='hs-comment'>-- We consider MaybeApart to be a case where the instance might</span>
<a name="line-871"></a>          <span class='hs-comment'>-- apply in the future. This covers an instance like C Int and</span>
<a name="line-872"></a>          <span class='hs-comment'>-- a target like [W] C (F a), where F is a type family.</span>
<a name="line-873"></a>            <span class='hs-conid'>SurelyApart</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span>        <span class='hs-varid'>rest</span>
<a name="line-874"></a>              <span class='hs-comment'>-- Note [Infinitary substitution in lookup]</span>
<a name="line-875"></a>            <span class='hs-conid'>MaybeApart</span> <span class='hs-conid'>MARInfinite</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-varid'>us</span>        <span class='hs-varid'>rest</span>
<a name="line-876"></a>            <span class='hs-keyword'>_</span>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>find</span> <span class='hs-varid'>ms</span> <span class='hs-layout'>(</span><span class='hs-varid'>item</span><span class='hs-conop'>:</span><span class='hs-varid'>us</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-877"></a>      <span class='hs-keyword'>where</span>
<a name="line-878"></a>        <span class='hs-varid'>tpl_tv_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>tpl_tvs</span>
<a name="line-879"></a>        <span class='hs-varid'>tys_tv_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>tys</span>
<a name="line-880"></a>
<a name="line-881"></a><a name="lookupInstEnv"></a><span class='hs-comment'>---------------</span>
<a name="line-882"></a><span class='hs-comment'>-- This is the common way to call this function.</span>
<a name="line-883"></a><span class='hs-definition'>lookupInstEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>              <span class='hs-comment'>-- Check Safe Haskell overlap restrictions</span>
<a name="line-884"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstEnvs</span>          <span class='hs-comment'>-- External and home package inst-env</span>
<a name="line-885"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- What we are looking for</span>
<a name="line-886"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ClsInstLookupResult</span>
<a name="line-887"></a><span class='hs-comment'>-- ^ See Note [Rules for instance lookup]</span>
<a name="line-888"></a><span class='hs-comment'>-- ^ See Note [Safe Haskell Overlapping Instances] in "GHC.Tc.Solver"</span>
<a name="line-889"></a><span class='hs-comment'>-- ^ See Note [Safe Haskell Overlapping Instances Implementation] in "GHC.Tc.Solver"</span>
<a name="line-890"></a><span class='hs-definition'>lookupInstEnv</span> <span class='hs-varid'>check_overlap_safe</span>
<a name="line-891"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>InstEnvs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ie_global</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pkg_ie</span>
<a name="line-892"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>ie_local</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>home_ie</span>
<a name="line-893"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>ie_visible</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vis_mods</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-894"></a>              <span class='hs-varid'>cls</span>
<a name="line-895"></a>              <span class='hs-varid'>tys</span>
<a name="line-896"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "lookupInstEnv" (ppr cls &lt;+&gt; ppr tys $$ ppr home_ie) $</span>
<a name="line-897"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>final_matches</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_unifs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafe_overlapped</span><span class='hs-layout'>)</span>
<a name="line-898"></a>  <span class='hs-keyword'>where</span>
<a name="line-899"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>home_matches</span><span class='hs-layout'>,</span> <span class='hs-varid'>home_unifs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupInstEnv'</span> <span class='hs-varid'>home_ie</span> <span class='hs-varid'>vis_mods</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-900"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>pkg_matches</span><span class='hs-layout'>,</span>  <span class='hs-varid'>pkg_unifs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupInstEnv'</span> <span class='hs-varid'>pkg_ie</span>  <span class='hs-varid'>vis_mods</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-901"></a>    <span class='hs-varid'>all_matches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>home_matches</span> <span class='hs-varop'>++</span> <span class='hs-varid'>pkg_matches</span>
<a name="line-902"></a>    <span class='hs-varid'>all_unifs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>home_unifs</span>   <span class='hs-varop'>++</span> <span class='hs-varid'>pkg_unifs</span>
<a name="line-903"></a>    <span class='hs-varid'>final_matches</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>insert_overlapping</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>all_matches</span>
<a name="line-904"></a>        <span class='hs-comment'>-- Even if the unifs is non-empty (an error situation)</span>
<a name="line-905"></a>        <span class='hs-comment'>-- we still prune the matches, so that the error message isn't</span>
<a name="line-906"></a>        <span class='hs-comment'>-- misleading (complaining of multiple matches when some should be</span>
<a name="line-907"></a>        <span class='hs-comment'>-- overlapped away)</span>
<a name="line-908"></a>
<a name="line-909"></a>    <span class='hs-varid'>unsafe_overlapped</span>
<a name="line-910"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>final_matches</span> <span class='hs-keyword'>of</span>
<a name="line-911"></a>           <span class='hs-keyglyph'>[</span><span class='hs-varid'>match</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>check_safe</span> <span class='hs-varid'>match</span>
<a name="line-912"></a>           <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-913"></a>
<a name="line-914"></a>    <span class='hs-comment'>-- If the selected match is incoherent, discard all unifiers</span>
<a name="line-915"></a>    <span class='hs-varid'>final_unifs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>final_matches</span> <span class='hs-keyword'>of</span>
<a name="line-916"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>m</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIncoherent</span> <span class='hs-layout'>(</span><span class='hs-varid'>fst</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-917"></a>                    <span class='hs-keyword'>_</span>                            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>all_unifs</span>
<a name="line-918"></a>
<a name="line-919"></a>    <span class='hs-comment'>-- NOTE [Safe Haskell isSafeOverlap]</span>
<a name="line-920"></a>    <span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-921"></a>    <span class='hs-comment'>-- We restrict code compiled in 'Safe' mode from overriding code</span>
<a name="line-922"></a>    <span class='hs-comment'>-- compiled in any other mode. The rationale is that code compiled</span>
<a name="line-923"></a>    <span class='hs-comment'>-- in 'Safe' mode is code that is untrusted by the ghc user. So</span>
<a name="line-924"></a>    <span class='hs-comment'>-- we shouldn't let that code change the behaviour of code the</span>
<a name="line-925"></a>    <span class='hs-comment'>-- user didn't compile in 'Safe' mode since that's the code they</span>
<a name="line-926"></a>    <span class='hs-comment'>-- trust. So 'Safe' instances can only overlap instances from the</span>
<a name="line-927"></a>    <span class='hs-comment'>-- same module. A same instance origin policy for safe compiled</span>
<a name="line-928"></a>    <span class='hs-comment'>-- instances.</span>
<a name="line-929"></a>    <span class='hs-varid'>check_safe</span> <span class='hs-layout'>(</span><span class='hs-varid'>inst</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-930"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>check_overlap_safe</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>unsafeTopInstance</span> <span class='hs-varid'>inst</span> <span class='hs-keyword'>of</span>
<a name="line-931"></a>                <span class='hs-comment'>-- make sure it only overlaps instances from the same module</span>
<a name="line-932"></a>                <span class='hs-conid'>True</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>all_matches</span>
<a name="line-933"></a>                <span class='hs-comment'>-- most specific is from a trusted location.</span>
<a name="line-934"></a>                <span class='hs-conid'>False</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>[]</span>
<a name="line-935"></a>        <span class='hs-keyword'>where</span>
<a name="line-936"></a>            <span class='hs-varid'>go</span> <span class='hs-varid'>bad</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bad</span>
<a name="line-937"></a>            <span class='hs-varid'>go</span> <span class='hs-varid'>bad</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>unchecked</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-938"></a>                <span class='hs-keyword'>if</span> <span class='hs-varid'>inSameMod</span> <span class='hs-varid'>x</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isOverlappable</span> <span class='hs-varid'>x</span>
<a name="line-939"></a>                    <span class='hs-keyword'>then</span> <span class='hs-varid'>go</span> <span class='hs-varid'>bad</span> <span class='hs-varid'>unchecked</span>
<a name="line-940"></a>                    <span class='hs-keyword'>else</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>i</span><span class='hs-conop'>:</span><span class='hs-varid'>bad</span><span class='hs-layout'>)</span> <span class='hs-varid'>unchecked</span>
<a name="line-941"></a>
<a name="line-942"></a>            <span class='hs-varid'>inSameMod</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span>
<a name="line-943"></a>                <span class='hs-keyword'>let</span> <span class='hs-varid'>na</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getName</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getName</span> <span class='hs-varid'>inst</span>
<a name="line-944"></a>                    <span class='hs-varid'>la</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isInternalName</span> <span class='hs-varid'>na</span>
<a name="line-945"></a>                    <span class='hs-varid'>nb</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getName</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getName</span> <span class='hs-varid'>b</span>
<a name="line-946"></a>                    <span class='hs-varid'>lb</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isInternalName</span> <span class='hs-varid'>nb</span>
<a name="line-947"></a>                <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>la</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>lb</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>nameModule</span> <span class='hs-varid'>na</span> <span class='hs-varop'>==</span> <span class='hs-varid'>nameModule</span> <span class='hs-varid'>nb</span><span class='hs-layout'>)</span>
<a name="line-948"></a>
<a name="line-949"></a>    <span class='hs-comment'>-- We consider the most specific instance unsafe when it both:</span>
<a name="line-950"></a>    <span class='hs-comment'>--   (1) Comes from a module compiled as `Safe`</span>
<a name="line-951"></a>    <span class='hs-comment'>--   (2) Is an orphan instance, OR, an instance for a MPTC</span>
<a name="line-952"></a>    <span class='hs-varid'>unsafeTopInstance</span> <span class='hs-varid'>inst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isSafeOverlap</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_flag</span> <span class='hs-varid'>inst</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-953"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>isOrphan</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_orphan</span> <span class='hs-varid'>inst</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>classArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_cls</span> <span class='hs-varid'>inst</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-954"></a>
<a name="line-955"></a><a name="insert_overlapping"></a><span class='hs-comment'>---------------</span>
<a name="line-956"></a><span class='hs-definition'>insert_overlapping</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InstMatch</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstMatch</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InstMatch</span><span class='hs-keyglyph'>]</span>
<a name="line-957"></a><span class='hs-comment'>-- ^ Add a new solution, knocking out strictly less specific ones</span>
<a name="line-958"></a><span class='hs-comment'>-- See Note [Rules for instance lookup]</span>
<a name="line-959"></a><span class='hs-definition'>insert_overlapping</span> <span class='hs-varid'>new_item</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>new_item</span><span class='hs-keyglyph'>]</span>
<a name="line-960"></a><span class='hs-definition'>insert_overlapping</span> <span class='hs-varid'>new_item</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>new_inst</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>old_item</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>old_inst</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>old_items</span><span class='hs-layout'>)</span>
<a name="line-961"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>new_beats_old</span>        <span class='hs-comment'>-- New strictly overrides old</span>
<a name="line-962"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>old_beats_new</span>
<a name="line-963"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>new_inst</span> <span class='hs-varop'>`can_override`</span> <span class='hs-varid'>old_inst</span>
<a name="line-964"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insert_overlapping</span> <span class='hs-varid'>new_item</span> <span class='hs-varid'>old_items</span>
<a name="line-965"></a>
<a name="line-966"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>old_beats_new</span>        <span class='hs-comment'>-- Old strictly overrides new</span>
<a name="line-967"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-varid'>new_beats_old</span>
<a name="line-968"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>old_inst</span> <span class='hs-varop'>`can_override`</span> <span class='hs-varid'>new_inst</span>
<a name="line-969"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_item</span> <span class='hs-conop'>:</span> <span class='hs-varid'>old_items</span>
<a name="line-970"></a>
<a name="line-971"></a>  <span class='hs-comment'>-- Discard incoherent instances; see Note [Incoherent instances]</span>
<a name="line-972"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIncoherent</span> <span class='hs-varid'>old_inst</span>      <span class='hs-comment'>-- Old is incoherent; discard it</span>
<a name="line-973"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insert_overlapping</span> <span class='hs-varid'>new_item</span> <span class='hs-varid'>old_items</span>
<a name="line-974"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIncoherent</span> <span class='hs-varid'>new_inst</span>      <span class='hs-comment'>-- New is incoherent; discard it</span>
<a name="line-975"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_item</span> <span class='hs-conop'>:</span> <span class='hs-varid'>old_items</span>
<a name="line-976"></a>
<a name="line-977"></a>  <span class='hs-comment'>-- Equal or incomparable, and neither is incoherent; keep both</span>
<a name="line-978"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-979"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_item</span> <span class='hs-conop'>:</span> <span class='hs-varid'>insert_overlapping</span> <span class='hs-varid'>new_item</span> <span class='hs-varid'>old_items</span>
<a name="line-980"></a>  <span class='hs-keyword'>where</span>
<a name="line-981"></a>
<a name="line-982"></a>    <span class='hs-varid'>new_beats_old</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_inst</span> <span class='hs-varop'>`more_specific_than`</span> <span class='hs-varid'>old_inst</span>
<a name="line-983"></a>    <span class='hs-varid'>old_beats_new</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_inst</span> <span class='hs-varop'>`more_specific_than`</span> <span class='hs-varid'>new_inst</span>
<a name="line-984"></a>
<a name="line-985"></a>    <span class='hs-comment'>-- `instB` can be instantiated to match `instA`</span>
<a name="line-986"></a>    <span class='hs-comment'>-- or the two are equal</span>
<a name="line-987"></a>    <span class='hs-varid'>instA</span> <span class='hs-varop'>`more_specific_than`</span> <span class='hs-varid'>instB</span>
<a name="line-988"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJust</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcMatchTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_tys</span> <span class='hs-varid'>instB</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_tys</span> <span class='hs-varid'>instA</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-989"></a>
<a name="line-990"></a>    <span class='hs-varid'>instA</span> <span class='hs-varop'>`can_override`</span> <span class='hs-varid'>instB</span>
<a name="line-991"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isOverlapping</span> <span class='hs-varid'>instA</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isOverlappable</span> <span class='hs-varid'>instB</span>
<a name="line-992"></a>       <span class='hs-comment'>-- Overlap permitted if either the more specific instance</span>
<a name="line-993"></a>       <span class='hs-comment'>-- is marked as overlapping, or the more general one is</span>
<a name="line-994"></a>       <span class='hs-comment'>-- marked as overlappable.</span>
<a name="line-995"></a>       <span class='hs-comment'>-- Latest change described in: #9242.</span>
<a name="line-996"></a>       <span class='hs-comment'>-- Previous change: #3877, Dec 10.</span>
<a name="line-997"></a>
<a name="line-998"></a><span class='hs-comment'>{-
<a name="line-999"></a>Note [Incoherent instances]
<a name="line-1000"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1001"></a>For some classes, the choice of a particular instance does not matter, any one
<a name="line-1002"></a>is good. E.g. consider
<a name="line-1003"></a>
<a name="line-1004"></a>        class D a b where { opD :: a -&gt; b -&gt; String }
<a name="line-1005"></a>        instance D Int b where ...
<a name="line-1006"></a>        instance D a Int where ...
<a name="line-1007"></a>
<a name="line-1008"></a>        g (x::Int) = opD x x  -- Wanted: D Int Int
<a name="line-1009"></a>
<a name="line-1010"></a>For such classes this should work (without having to add an "instance D Int
<a name="line-1011"></a>Int", and using -XOverlappingInstances, which would then work). This is what
<a name="line-1012"></a>-XIncoherentInstances is for: Telling GHC "I don't care which instance you use;
<a name="line-1013"></a>if you can use one, use it."
<a name="line-1014"></a>
<a name="line-1015"></a>Should this logic only work when *all* candidates have the incoherent flag, or
<a name="line-1016"></a>even when all but one have it? The right choice is the latter, which can be
<a name="line-1017"></a>justified by comparing the behaviour with how -XIncoherentInstances worked when
<a name="line-1018"></a>it was only about the unify-check (note [Overlapping instances]):
<a name="line-1019"></a>
<a name="line-1020"></a>Example:
<a name="line-1021"></a>        class C a b c where foo :: (a,b,c)
<a name="line-1022"></a>        instance C [a] b Int
<a name="line-1023"></a>        instance [incoherent] [Int] b c
<a name="line-1024"></a>        instance [incoherent] C a Int c
<a name="line-1025"></a>Thanks to the incoherent flags,
<a name="line-1026"></a>        [Wanted]  C [a] b Int
<a name="line-1027"></a>works: Only instance one matches, the others just unify, but are marked
<a name="line-1028"></a>incoherent.
<a name="line-1029"></a>
<a name="line-1030"></a>So I can write
<a name="line-1031"></a>        (foo :: ([a],b,Int)) :: ([Int], Int, Int).
<a name="line-1032"></a>but if that works then I really want to be able to write
<a name="line-1033"></a>        foo :: ([Int], Int, Int)
<a name="line-1034"></a>as well. Now all three instances from above match. None is more specific than
<a name="line-1035"></a>another, so none is ruled out by the normal overlapping rules. One of them is
<a name="line-1036"></a>not incoherent, but we still want this to compile. Hence the
<a name="line-1037"></a>"all-but-one-logic".
<a name="line-1038"></a>
<a name="line-1039"></a>The implementation is in insert_overlapping, where we remove matching
<a name="line-1040"></a>incoherent instances as long as there are others.
<a name="line-1041"></a>
<a name="line-1042"></a>
<a name="line-1043"></a>
<a name="line-1044"></a>************************************************************************
<a name="line-1045"></a>*                                                                      *
<a name="line-1046"></a>        Binding decisions
<a name="line-1047"></a>*                                                                      *
<a name="line-1048"></a>************************************************************************
<a name="line-1049"></a>-}</span>
<a name="line-1050"></a>
<a name="line-1051"></a><a name="instanceBindFun"></a><span class='hs-definition'>instanceBindFun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>BindFun</span>
<a name="line-1052"></a><span class='hs-definition'>instanceBindFun</span> <span class='hs-varid'>tv</span> <span class='hs-sel'>_rhs_ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isOverlappableTyVar</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Apart</span>
<a name="line-1053"></a>                           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BindMe</span>
<a name="line-1054"></a>   <span class='hs-comment'>-- Note [Binding when looking up instances]</span>
<a name="line-1055"></a>
<a name="line-1056"></a><span class='hs-comment'>{-
<a name="line-1057"></a>Note [Binding when looking up instances]
<a name="line-1058"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1059"></a>When looking up in the instance environment, or family-instance environment,
<a name="line-1060"></a>we are careful about multiple matches, as described above in
<a name="line-1061"></a>Note [Overlapping instances]
<a name="line-1062"></a>
<a name="line-1063"></a>The target tys can contain skolem constants. For existentials and instance variables,
<a name="line-1064"></a>we can guarantee that those
<a name="line-1065"></a>are never going to be instantiated to anything, so we should not involve
<a name="line-1066"></a>them in the unification test. These are called "super skolems". Example:
<a name="line-1067"></a>        class Foo a where { op :: a -&gt; Int }
<a name="line-1068"></a>        instance Foo a =&gt; Foo [a]       -- NB overlap
<a name="line-1069"></a>        instance Foo [Int]              -- NB overlap
<a name="line-1070"></a>        data T = forall a. Foo a =&gt; MkT a
<a name="line-1071"></a>        f :: T -&gt; Int
<a name="line-1072"></a>        f (MkT x) = op [x,x]
<a name="line-1073"></a>The op [x,x] means we need (Foo [a]). This `a` will never be instantiated, and
<a name="line-1074"></a>so it is a super skolem. (See the use of tcInstSuperSkolTyVarsX in
<a name="line-1075"></a>GHC.Tc.Gen.Pat.tcDataConPat.) Super skolems respond True to
<a name="line-1076"></a>isOverlappableTyVar, and the use of Apart in instanceBindFun, above, means
<a name="line-1077"></a>that these will be treated as fresh constants in the unification algorithm
<a name="line-1078"></a>during instance lookup. Without this treatment, GHC would complain, saying
<a name="line-1079"></a>that the choice of instance depended on the instantiation of 'a'; but of
<a name="line-1080"></a>course it isn't *going* to be instantiated. Note that it is necessary that
<a name="line-1081"></a>the unification algorithm returns SurelyApart for these super-skolems
<a name="line-1082"></a>for GHC to be able to commit to another instance.
<a name="line-1083"></a>
<a name="line-1084"></a>We do this only for super skolems.  For example we reject
<a name="line-1085"></a>        g :: forall a =&gt; [a] -&gt; Int
<a name="line-1086"></a>        g x = op x
<a name="line-1087"></a>on the grounds that the correct instance depends on the instantiation of 'a'
<a name="line-1088"></a>-}</span>
</pre></body>
</html>
