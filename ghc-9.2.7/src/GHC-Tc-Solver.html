<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Tc/Solver.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Tc.Solver</span><span class='hs-layout'>(</span>
<a name="line-4"></a>       <span class='hs-conid'>InferMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyInfer</span><span class='hs-layout'>,</span> <span class='hs-varid'>findInferredDiff</span><span class='hs-layout'>,</span>
<a name="line-5"></a>       <span class='hs-varid'>growThetaTyVars</span><span class='hs-layout'>,</span>
<a name="line-6"></a>       <span class='hs-varid'>simplifyAmbiguityCheck</span><span class='hs-layout'>,</span>
<a name="line-7"></a>       <span class='hs-varid'>simplifyDefault</span><span class='hs-layout'>,</span>
<a name="line-8"></a>       <span class='hs-varid'>simplifyTop</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyTopImplic</span><span class='hs-layout'>,</span>
<a name="line-9"></a>       <span class='hs-varid'>simplifyInteractive</span><span class='hs-layout'>,</span>
<a name="line-10"></a>       <span class='hs-varid'>solveEqualities</span><span class='hs-layout'>,</span>
<a name="line-11"></a>       <span class='hs-varid'>pushLevelAndSolveEqualities</span><span class='hs-layout'>,</span> <span class='hs-varid'>pushLevelAndSolveEqualitiesX</span><span class='hs-layout'>,</span>
<a name="line-12"></a>       <span class='hs-varid'>reportUnsolvedEqualities</span><span class='hs-layout'>,</span>
<a name="line-13"></a>       <span class='hs-varid'>simplifyWantedsTcM</span><span class='hs-layout'>,</span>
<a name="line-14"></a>       <span class='hs-varid'>tcCheckGivens</span><span class='hs-layout'>,</span>
<a name="line-15"></a>       <span class='hs-varid'>tcCheckWanteds</span><span class='hs-layout'>,</span>
<a name="line-16"></a>       <span class='hs-varid'>tcNormalise</span><span class='hs-layout'>,</span>
<a name="line-17"></a>
<a name="line-18"></a>       <span class='hs-varid'>captureTopConstraints</span><span class='hs-layout'>,</span>
<a name="line-19"></a>
<a name="line-20"></a>       <span class='hs-varid'>simplifyTopWanteds</span><span class='hs-layout'>,</span>
<a name="line-21"></a>
<a name="line-22"></a>       <span class='hs-varid'>promoteTyVarSet</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyAndEmitFlatConstraints</span><span class='hs-layout'>,</span>
<a name="line-23"></a>
<a name="line-24"></a>       <span class='hs-comment'>-- For Rules we need these</span>
<a name="line-25"></a>       <span class='hs-varid'>solveWanteds</span><span class='hs-layout'>,</span> <span class='hs-varid'>solveWantedsAndDrop</span><span class='hs-layout'>,</span>
<a name="line-26"></a>       <span class='hs-varid'>approximateWC</span><span class='hs-layout'>,</span> <span class='hs-varid'>runTcSDeriveds</span>
<a name="line-27"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-28"></a>
<a name="line-29"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-30"></a>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-32"></a>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Bag</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Class</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-varid'>classKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>classTyCon</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Instantiate</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.List.SetOps</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span><span class='hs-layout'>(</span> <span class='hs-varid'>idType</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Utils</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Errors</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Evidence</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver.Interact</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver.Canonical</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>makeSuperClasses</span><span class='hs-layout'>,</span> <span class='hs-varid'>solveCallStack</span> <span class='hs-layout'>)</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver.Rewrite</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>rewriteType</span> <span class='hs-layout'>)</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Unify</span>        <span class='hs-layout'>(</span> <span class='hs-varid'>buildTvImplication</span> <span class='hs-layout'>)</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcMType</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcM</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Monad</span>   <span class='hs-keyword'>as</span> <span class='hs-conid'>TcM</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver.Monad</span>  <span class='hs-keyword'>as</span> <span class='hs-conid'>TcS</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Constraint</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Predicate</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Origin</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcType</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Ppr</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types</span> <span class='hs-layout'>(</span> <span class='hs-varid'>liftedRepTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>manyDataConTy</span> <span class='hs-layout'>)</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Unify</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>tcMatchTyKi</span> <span class='hs-layout'>)</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>    <span class='hs-layout'>(</span> <span class='hs-conid'>IntWithInf</span><span class='hs-layout'>,</span> <span class='hs-varid'>intGtLimit</span> <span class='hs-layout'>)</span>
<a name="line-65"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Error</span>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>GHC.LanguageExtensions</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>LangExt</span>
<a name="line-67"></a>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Foldable</span>      <span class='hs-layout'>(</span> <span class='hs-varid'>toList</span> <span class='hs-layout'>)</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>          <span class='hs-layout'>(</span> <span class='hs-varid'>partition</span> <span class='hs-layout'>)</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-layout'>(</span> <span class='hs-conid'>NonEmpty</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-72"></a>
<a name="line-73"></a><span class='hs-comment'>{-
<a name="line-74"></a>*********************************************************************************
<a name="line-75"></a>*                                                                               *
<a name="line-76"></a>*                           External interface                                  *
<a name="line-77"></a>*                                                                               *
<a name="line-78"></a>*********************************************************************************
<a name="line-79"></a>-}</span>
<a name="line-80"></a>
<a name="line-81"></a><a name="captureTopConstraints"></a><span class='hs-definition'>captureTopConstraints</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-82"></a><span class='hs-comment'>-- (captureTopConstraints m) runs m, and returns the type constraints it</span>
<a name="line-83"></a><span class='hs-comment'>-- generates plus the constraints produced by static forms inside.</span>
<a name="line-84"></a><span class='hs-comment'>-- If it fails with an exception, it reports any insolubles</span>
<a name="line-85"></a><span class='hs-comment'>-- (out of scope variables) before doing so</span>
<a name="line-86"></a><span class='hs-comment'>--</span>
<a name="line-87"></a><span class='hs-comment'>-- captureTopConstraints is used exclusively by GHC.Tc.Module at the top</span>
<a name="line-88"></a><span class='hs-comment'>-- level of a module.</span>
<a name="line-89"></a><span class='hs-comment'>--</span>
<a name="line-90"></a><span class='hs-comment'>-- Importantly, if captureTopConstraints propagates an exception, it</span>
<a name="line-91"></a><span class='hs-comment'>-- reports any insoluble constraints first, lest they be lost</span>
<a name="line-92"></a><span class='hs-comment'>-- altogether.  This is important, because solveEqualities (maybe</span>
<a name="line-93"></a><span class='hs-comment'>-- other things too) throws an exception without adding any error</span>
<a name="line-94"></a><span class='hs-comment'>-- messages; it just puts the unsolved constraints back into the</span>
<a name="line-95"></a><span class='hs-comment'>-- monad. See GHC.Tc.Utils.Monad Note [Constraints and errors]</span>
<a name="line-96"></a><span class='hs-comment'>-- #16376 is an example of what goes wrong if you don't do this.</span>
<a name="line-97"></a><span class='hs-comment'>--</span>
<a name="line-98"></a><span class='hs-comment'>-- NB: the caller should bring any environments into scope before</span>
<a name="line-99"></a><span class='hs-comment'>-- calling this, so that the reportUnsolved has access to the most</span>
<a name="line-100"></a><span class='hs-comment'>-- complete GlobalRdrEnv</span>
<a name="line-101"></a><span class='hs-definition'>captureTopConstraints</span> <span class='hs-varid'>thing_inside</span>
<a name="line-102"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>static_wc_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.newTcRef</span> <span class='hs-varid'>emptyWC</span> <span class='hs-layout'>;</span>
<a name="line-103"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>mb_res</span><span class='hs-layout'>,</span> <span class='hs-varid'>lie</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.updGblEnv</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tcg_static_wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>static_wc_var</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-104"></a>                          <span class='hs-conid'>TcM.tryCaptureConstraints</span> <span class='hs-varid'>thing_inside</span>
<a name="line-105"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stWC</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.readTcRef</span> <span class='hs-varid'>static_wc_var</span>
<a name="line-106"></a>
<a name="line-107"></a>       <span class='hs-comment'>-- See GHC.Tc.Utils.Monad Note [Constraints and errors]</span>
<a name="line-108"></a>       <span class='hs-comment'>-- If the thing_inside threw an exception, but generated some insoluble</span>
<a name="line-109"></a>       <span class='hs-comment'>-- constraints, report the latter before propagating the exception</span>
<a name="line-110"></a>       <span class='hs-comment'>-- Otherwise they will be lost altogether</span>
<a name="line-111"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_res</span> <span class='hs-keyword'>of</span>
<a name="line-112"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>res</span><span class='hs-layout'>,</span> <span class='hs-varid'>lie</span> <span class='hs-varop'>`andWC`</span> <span class='hs-varid'>stWC</span><span class='hs-layout'>)</span>
<a name="line-113"></a>           <span class='hs-conid'>Nothing</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyTop</span> <span class='hs-varid'>lie</span><span class='hs-layout'>;</span> <span class='hs-varid'>failM</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-114"></a>                <span class='hs-comment'>-- This call to simplifyTop is the reason</span>
<a name="line-115"></a>                <span class='hs-comment'>-- this function is here instead of GHC.Tc.Utils.Monad</span>
<a name="line-116"></a>                <span class='hs-comment'>-- We call simplifyTop so that it does defaulting</span>
<a name="line-117"></a>                <span class='hs-comment'>-- (esp of runtime-reps) before reporting errors</span>
<a name="line-118"></a>
<a name="line-119"></a><a name="simplifyTopImplic"></a><span class='hs-definition'>simplifyTopImplic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-120"></a><span class='hs-definition'>simplifyTopImplic</span> <span class='hs-varid'>implics</span>
<a name="line-121"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>empty_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyTop</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkImplicWC</span> <span class='hs-varid'>implics</span><span class='hs-layout'>)</span>
<a name="line-122"></a>
<a name="line-123"></a>       <span class='hs-comment'>-- Since all the inputs are implications the returned bindings will be empty</span>
<a name="line-124"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>empty_binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>empty_binds</span> <span class='hs-layout'>)</span>
<a name="line-125"></a>
<a name="line-126"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-127"></a>
<a name="line-128"></a><a name="simplifyTop"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-129"></a><span class='hs-comment'>-- Simplify top-level constraints</span>
<a name="line-130"></a><span class='hs-comment'>-- Usually these will be implications,</span>
<a name="line-131"></a><span class='hs-comment'>-- but when there is nothing to quantify we don't wrap</span>
<a name="line-132"></a><span class='hs-comment'>-- in a degenerate implication, so we do that here instead</span>
<a name="line-133"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-varid'>wanteds</span>
<a name="line-134"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyTop {"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-135"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>final_wc</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafe_ol</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcS</span> <span class='hs-varop'>$</span>
<a name="line-136"></a>            <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>final_wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyTopWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-137"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>unsafe_ol</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getSafeOverlapFailures</span>
<a name="line-138"></a>               <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_wc</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsafe_ol</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-139"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End simplifyTop }"</span> <span class='hs-varid'>empty</span>
<a name="line-140"></a>
<a name="line-141"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>final_wc</span>
<a name="line-142"></a>
<a name="line-143"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved (unsafe overlapping) {"</span> <span class='hs-varid'>empty</span>
<a name="line-144"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyCts</span> <span class='hs-varid'>unsafe_ol</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>
<a name="line-145"></a>           <span class='hs-comment'>-- grab current error messages and clear, warnAllUnsolved will</span>
<a name="line-146"></a>           <span class='hs-comment'>-- update error messages which we'll grab and then restore saved</span>
<a name="line-147"></a>           <span class='hs-comment'>-- messages.</span>
<a name="line-148"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>errs_var</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getErrsVar</span>
<a name="line-149"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>saved_msg</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.readTcRef</span> <span class='hs-varid'>errs_var</span>
<a name="line-150"></a>           <span class='hs-layout'>;</span> <span class='hs-conid'>TcM.writeTcRef</span> <span class='hs-varid'>errs_var</span> <span class='hs-varid'>emptyMessages</span>
<a name="line-151"></a>
<a name="line-152"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>warnAllUnsolved</span> <span class='hs-varop'>$</span> <span class='hs-varid'>emptyWC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsafe_ol</span> <span class='hs-layout'>}</span>
<a name="line-153"></a>
<a name="line-154"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>whyUnsafe</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getWarningMessages</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-conid'>TcM.readTcRef</span> <span class='hs-varid'>errs_var</span>
<a name="line-155"></a>           <span class='hs-layout'>;</span> <span class='hs-conid'>TcM.writeTcRef</span> <span class='hs-varid'>errs_var</span> <span class='hs-varid'>saved_msg</span>
<a name="line-156"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>recordUnsafeInfer</span> <span class='hs-varid'>whyUnsafe</span>
<a name="line-157"></a>           <span class='hs-layout'>}</span>
<a name="line-158"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved (unsafe overlapping) }"</span> <span class='hs-varid'>empty</span>
<a name="line-159"></a>
<a name="line-160"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>binds1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>binds2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-161"></a>
<a name="line-162"></a><a name="pushLevelAndSolveEqualities"></a><span class='hs-definition'>pushLevelAndSolveEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SkolemInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span>
<a name="line-163"></a><span class='hs-comment'>-- Push level, and solve all resulting equalities</span>
<a name="line-164"></a><span class='hs-comment'>-- If there are any unsolved equalities, report them</span>
<a name="line-165"></a><span class='hs-comment'>-- and fail (in the monad)</span>
<a name="line-166"></a><span class='hs-comment'>--</span>
<a name="line-167"></a><span class='hs-comment'>-- Panics if we solve any non-equality constraints.  (In runTCSEqualities</span>
<a name="line-168"></a><span class='hs-comment'>-- we use an error thunk for the evidence bindings.)</span>
<a name="line-169"></a><span class='hs-definition'>pushLevelAndSolveEqualities</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>thing_inside</span>
<a name="line-170"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>tclvl</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushLevelAndSolveEqualitiesX</span>
<a name="line-171"></a>                                      <span class='hs-str'>"pushLevelAndSolveEqualities"</span> <span class='hs-varid'>thing_inside</span>
<a name="line-172"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>reportUnsolvedEqualities</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>wanted</span>
<a name="line-173"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-174"></a>
<a name="line-175"></a><a name="pushLevelAndSolveEqualitiesX"></a><span class='hs-definition'>pushLevelAndSolveEqualitiesX</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span>
<a name="line-176"></a>                             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcLevel</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>,</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-177"></a><span class='hs-comment'>-- Push the level, gather equality constraints, and then solve them.</span>
<a name="line-178"></a><span class='hs-comment'>-- Returns any remaining unsolved equalities.</span>
<a name="line-179"></a><span class='hs-comment'>-- Does not report errors.</span>
<a name="line-180"></a><span class='hs-comment'>--</span>
<a name="line-181"></a><span class='hs-comment'>-- Panics if we solve any non-equality constraints.  (In runTCSEqualities</span>
<a name="line-182"></a><span class='hs-comment'>-- we use an error thunk for the evidence bindings.)</span>
<a name="line-183"></a><span class='hs-definition'>pushLevelAndSolveEqualitiesX</span> <span class='hs-varid'>callsite</span> <span class='hs-varid'>thing_inside</span>
<a name="line-184"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"pushLevelAndSolveEqualitiesX {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Called from"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-varid'>callsite</span><span class='hs-layout'>)</span>
<a name="line-185"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>tclvl</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-186"></a>            <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushTcLevelM</span> <span class='hs-varop'>$</span>
<a name="line-187"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>res</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>captureConstraints</span> <span class='hs-varid'>thing_inside</span>
<a name="line-188"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSEqualities</span> <span class='hs-layout'>(</span><span class='hs-varid'>simplifyTopWanteds</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-189"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanted</span><span class='hs-layout'>,</span><span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-190"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"pushLevelAndSolveEqualities }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Residual:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span>
<a name="line-191"></a>                                                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Level:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tclvl</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-192"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>tclvl</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-193"></a>
<a name="line-194"></a><a name="solveEqualities"></a><span class='hs-comment'>-- | Type-check a thing that emits only equality constraints, solving any</span>
<a name="line-195"></a><span class='hs-comment'>-- constraints we can and re-emitting constraints that we can't.</span>
<a name="line-196"></a><span class='hs-comment'>-- Use this variant only when we'll get another crack at it later</span>
<a name="line-197"></a><span class='hs-comment'>-- See Note [Failure in local type signatures]</span>
<a name="line-198"></a><span class='hs-comment'>--</span>
<a name="line-199"></a><span class='hs-comment'>-- Panics if we solve any non-equality constraints.  (In runTCSEqualities</span>
<a name="line-200"></a><span class='hs-comment'>-- we use an error thunk for the evidence bindings.)</span>
<a name="line-201"></a><span class='hs-definition'>solveEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-varid'>a</span>
<a name="line-202"></a><span class='hs-definition'>solveEqualities</span> <span class='hs-varid'>callsite</span> <span class='hs-varid'>thing_inside</span>
<a name="line-203"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"solveEqualities {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"Called from"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-varid'>callsite</span><span class='hs-layout'>)</span>
<a name="line-204"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>res</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>captureConstraints</span> <span class='hs-varid'>thing_inside</span>
<a name="line-205"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplifyAndEmitFlatConstraints</span> <span class='hs-varid'>wanted</span>
<a name="line-206"></a>            <span class='hs-comment'>-- simplifyAndEmitFlatConstraints fails outright unless</span>
<a name="line-207"></a>            <span class='hs-comment'>--  the only unsolved constraints are soluble-looking</span>
<a name="line-208"></a>            <span class='hs-comment'>--  equalities that can float out</span>
<a name="line-209"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"solveEqualities }"</span> <span class='hs-varid'>empty</span>
<a name="line-210"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-211"></a>
<a name="line-212"></a><a name="simplifyAndEmitFlatConstraints"></a><span class='hs-definition'>simplifyAndEmitFlatConstraints</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-213"></a><span class='hs-comment'>-- See Note [Failure in local type signatures]</span>
<a name="line-214"></a><span class='hs-definition'>simplifyAndEmitFlatConstraints</span> <span class='hs-varid'>wanted</span>
<a name="line-215"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Solve and zonk to esablish the</span>
<a name="line-216"></a>         <span class='hs-comment'>-- preconditions for floatKindEqualities</span>
<a name="line-217"></a>         <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSEqualities</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-218"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.zonkWC</span> <span class='hs-varid'>wanted</span>
<a name="line-219"></a>
<a name="line-220"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"emitFlatConstraints {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-221"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>floatKindEqualities</span> <span class='hs-varid'>wanted</span> <span class='hs-keyword'>of</span>
<a name="line-222"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"emitFlatConstraints } failing"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-223"></a>                         <span class='hs-comment'>-- Emit the bad constraints, wrapped in an implication</span>
<a name="line-224"></a>                         <span class='hs-comment'>-- See Note [Wrapping failing kind equalities]</span>
<a name="line-225"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>tclvl</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.getTcLevel</span>
<a name="line-226"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>buildTvImplication</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-conid'>[]</span> <span class='hs-layout'>(</span><span class='hs-varid'>pushTcLevel</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanted</span>
<a name="line-227"></a>                                    <span class='hs-comment'>--                  ^^^^^^   |  ^^^^^^^^^^^^^^^^^</span>
<a name="line-228"></a>                                    <span class='hs-comment'>-- it's OK to use UnkSkol    |  we must increase the TcLevel,</span>
<a name="line-229"></a>                                    <span class='hs-comment'>-- because we don't bind     |  as explained in</span>
<a name="line-230"></a>                                    <span class='hs-comment'>-- any skolem variables here |  Note [Wrapping failing kind equalities]</span>
<a name="line-231"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplication</span> <span class='hs-varid'>implic</span>
<a name="line-232"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>failM</span> <span class='hs-layout'>}</span>
<a name="line-233"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>holes</span><span class='hs-layout'>)</span>
<a name="line-234"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>promoteTyVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfCts</span> <span class='hs-varid'>simples</span><span class='hs-layout'>)</span>
<a name="line-235"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"emitFlatConstraints }"</span> <span class='hs-varop'>$</span>
<a name="line-236"></a>                      <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"simples:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>simples</span>
<a name="line-237"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"holes:  "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>holes</span> <span class='hs-keyglyph'>]</span>
<a name="line-238"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>emitHoles</span> <span class='hs-varid'>holes</span> <span class='hs-comment'>-- Holes don't need promotion</span>
<a name="line-239"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>emitSimples</span> <span class='hs-varid'>simples</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-240"></a>
<a name="line-241"></a><a name="floatKindEqualities"></a><span class='hs-definition'>floatKindEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Hole</span><span class='hs-layout'>)</span>
<a name="line-242"></a><span class='hs-comment'>-- Float out all the constraints from the WantedConstraints,</span>
<a name="line-243"></a><span class='hs-comment'>-- Return Nothing if any constraints can't be floated (captured</span>
<a name="line-244"></a><span class='hs-comment'>-- by skolems), or if there is an insoluble constraint, or</span>
<a name="line-245"></a><span class='hs-comment'>-- IC_Telescope telescope error</span>
<a name="line-246"></a><span class='hs-comment'>-- Precondition 1: we have tried to solve the 'wanteds', both so that</span>
<a name="line-247"></a><span class='hs-comment'>--    the ic_status field is set, and because solving can make constraints</span>
<a name="line-248"></a><span class='hs-comment'>--    more floatable.</span>
<a name="line-249"></a><span class='hs-comment'>-- Precondition 2: the 'wanteds' are zonked, since floatKindEqualities</span>
<a name="line-250"></a><span class='hs-comment'>--    is not monadic</span>
<a name="line-251"></a><span class='hs-comment'>-- See Note [floatKindEqualities vs approximateWC]</span>
<a name="line-252"></a><span class='hs-definition'>floatKindEqualities</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>wc</span>
<a name="line-253"></a>  <span class='hs-keyword'>where</span>
<a name="line-254"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyCoVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Hole</span><span class='hs-layout'>)</span>
<a name="line-255"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span>
<a name="line-256"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span>
<a name="line-257"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>wc_holes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>holes</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-258"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all</span> <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>simples</span>
<a name="line-259"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>inner_simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>inner_holes</span><span class='hs-layout'>)</span>
<a name="line-260"></a>                <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatMapBagPairM</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>trapping_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span>
<a name="line-261"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>simples</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>inner_simples</span>
<a name="line-262"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>holes</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>inner_holes</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-263"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-264"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-265"></a>      <span class='hs-keyword'>where</span>
<a name="line-266"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>ct</span>
<a name="line-267"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleEqCt</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-268"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>trapping_tvs</span>
<a name="line-269"></a>
<a name="line-270"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyCoVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Hole</span><span class='hs-layout'>)</span>
<a name="line-271"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>ic_given_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>given_eqs</span>
<a name="line-272"></a>                                      <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span><span class='hs-layout'>,</span> <span class='hs-varid'>ic_status</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>status</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-273"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isInsolubleStatus</span> <span class='hs-varid'>status</span>
<a name="line-274"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>   <span class='hs-comment'>-- A short cut /plus/ we must keep track of IC_BadTelescope</span>
<a name="line-275"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-276"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>holes</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-varid'>wanted</span>
<a name="line-277"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>simples</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>given_eqs</span> <span class='hs-varop'>==</span> <span class='hs-conid'>MaybeGivenEqs</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-278"></a>             <span class='hs-conid'>Nothing</span>
<a name="line-279"></a>                 <span class='hs-comment'>-- If there are some constraints to float out, but we can't</span>
<a name="line-280"></a>                 <span class='hs-comment'>-- because we don't float out past local equalities</span>
<a name="line-281"></a>                 <span class='hs-comment'>-- (c.f GHC.Tc.Solver.approximateWC), then fail</span>
<a name="line-282"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>holes</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-283"></a>      <span class='hs-keyword'>where</span>
<a name="line-284"></a>        <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>skols</span>
<a name="line-285"></a>
<a name="line-286"></a>
<a name="line-287"></a><span class='hs-comment'>{- Note [Failure in local type signatures]
<a name="line-288"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-289"></a>When kind checking a type signature, we like to fail fast if we can't
<a name="line-290"></a>solve all the kind equality constraints, for two reasons:
<a name="line-291"></a>
<a name="line-292"></a>  * A kind-bogus type signature may cause a cascade of knock-on
<a name="line-293"></a>    errors if we let it pass
<a name="line-294"></a>
<a name="line-295"></a>  * More seriously, we don't have a convenient term-level place to add
<a name="line-296"></a>    deferred bindings for unsolved kind-equality constraints.  In
<a name="line-297"></a>    earlier GHCs this led to un-filled-in coercion holes, which caused
<a name="line-298"></a>    GHC to crash with "fvProv falls into a hole" See #11563, #11520,
<a name="line-299"></a>    #11516, #11399
<a name="line-300"></a>
<a name="line-301"></a>But what about /local/ type signatures, mentioning in-scope type
<a name="line-302"></a>variables for which there might be 'given' equalities?  For these we
<a name="line-303"></a>might not be able to solve all the equalities locally. Here's an
<a name="line-304"></a>example (T15076b):
<a name="line-305"></a>
<a name="line-306"></a>  class (a ~ b) =&gt; C a b
<a name="line-307"></a>  data SameKind :: k -&gt; k -&gt; Type where { SK :: SameKind a b }
<a name="line-308"></a>
<a name="line-309"></a>  bar :: forall (a :: Type) (b :: Type).
<a name="line-310"></a>         C a b =&gt; Proxy a -&gt; Proxy b -&gt; ()
<a name="line-311"></a>  bar _ _ = const () (undefined :: forall (x :: a) (y :: b). SameKind x y)
<a name="line-312"></a>
<a name="line-313"></a>Consider the type signature on 'undefined'. It's ill-kinded unless
<a name="line-314"></a>a~b.  But the superclass of (C a b) means that indeed (a~b). So all
<a name="line-315"></a>should be well. BUT it's hard to see that when kind-checking the signature
<a name="line-316"></a>for undefined.  We want to emit a residual (a~b) constraint, to solve
<a name="line-317"></a>later.
<a name="line-318"></a>
<a name="line-319"></a>Another possibility is that we might have something like
<a name="line-320"></a>   F alpha ~ [Int]
<a name="line-321"></a>where alpha is bound further out, which might become soluble
<a name="line-322"></a>"later" when we learn more about alpha.  So we want to emit
<a name="line-323"></a>those residual constraints.
<a name="line-324"></a>
<a name="line-325"></a>BUT it's no good simply wrapping all unsolved constraints from
<a name="line-326"></a>a type signature in an implication constraint to solve later. The
<a name="line-327"></a>problem is that we are going to /use/ that signature, including
<a name="line-328"></a>instantiate it.  Say we have
<a name="line-329"></a>     f :: forall a.  (forall b. blah) -&gt; blah2
<a name="line-330"></a>     f x = &lt;body&gt;
<a name="line-331"></a>To typecheck the definition of f, we have to instantiate those
<a name="line-332"></a>foralls.  Moreover, any unsolved kind equalities will be coercion
<a name="line-333"></a>holes in the type.  If we naively wrap them in an implication like
<a name="line-334"></a>     forall a. (co1:k1~k2,  forall b.  co2:k3~k4)
<a name="line-335"></a>hoping to solve it later, we might end up filling in the holes
<a name="line-336"></a>co1 and co2 with coercions involving 'a' and 'b' -- but by now
<a name="line-337"></a>we've instantiated the type.  Chaos!
<a name="line-338"></a>
<a name="line-339"></a>Moreover, the unsolved constraints might be skolem-escape things, and
<a name="line-340"></a>if we proceed with f bound to a nonsensical type, we get a cascade of
<a name="line-341"></a>follow-up errors. For example polykinds/T12593, T15577, and many others.
<a name="line-342"></a>
<a name="line-343"></a>So here's the plan (see tcHsSigType):
<a name="line-344"></a>
<a name="line-345"></a>* pushLevelAndSolveEqualitiesX: try to solve the constraints
<a name="line-346"></a>
<a name="line-347"></a>* kindGeneraliseSome: do kind generalisation
<a name="line-348"></a>
<a name="line-349"></a>* buildTvImplication: build an implication for the residual, unsolved
<a name="line-350"></a>  constraint
<a name="line-351"></a>
<a name="line-352"></a>* simplifyAndEmitFlatConstraints: try to float out every unsolved equality
<a name="line-353"></a>  inside that implication, in the hope that it constrains only global
<a name="line-354"></a>  type variables, not the locally-quantified ones.
<a name="line-355"></a>
<a name="line-356"></a>  * If we fail, or find an insoluble constraint, emit the implication,
<a name="line-357"></a>    so that the errors will be reported, and fail.
<a name="line-358"></a>
<a name="line-359"></a>  * If we succeed in floating all the equalities, promote them and
<a name="line-360"></a>    re-emit them as flat constraint, not wrapped at all (since they
<a name="line-361"></a>    don't mention any of the quantified variables.
<a name="line-362"></a>
<a name="line-363"></a>* Note that this float-and-promote step means that anonymous
<a name="line-364"></a>  wildcards get floated to top level, as we want; see
<a name="line-365"></a>  Note [Checking partial type signatures] in GHC.Tc.Gen.HsType.
<a name="line-366"></a>
<a name="line-367"></a>All this is done:
<a name="line-368"></a>
<a name="line-369"></a>* In GHC.Tc.Gen.HsType.tcHsSigType, as above
<a name="line-370"></a>
<a name="line-371"></a>* solveEqualities. Use this when there no kind-generalisation
<a name="line-372"></a>  step to complicate matters; then we don't need to push levels,
<a name="line-373"></a>  and can solve the equalities immediately without needing to
<a name="line-374"></a>  wrap it in an implication constraint.  (You'll generally see
<a name="line-375"></a>  a kindGeneraliseNone nearby.)
<a name="line-376"></a>
<a name="line-377"></a>* In GHC.Tc.TyCl and GHC.Tc.TyCl.Instance; see calls to
<a name="line-378"></a>  pushLevelAndSolveEqualitiesX, followed by quantification, and
<a name="line-379"></a>  then reportUnsolvedEqualities.
<a name="line-380"></a>
<a name="line-381"></a>  NB: we call reportUnsolvedEqualities before zonkTcTypeToType
<a name="line-382"></a>  because the latter does not expect to see any un-filled-in
<a name="line-383"></a>  coercions, which will happen if we have unsolved equalities.
<a name="line-384"></a>  By calling reportUnsolvedEqualities first, which fails after
<a name="line-385"></a>  reporting errors, we avoid that happening.
<a name="line-386"></a>
<a name="line-387"></a>See also #18062, #11506
<a name="line-388"></a>
<a name="line-389"></a>Note [Wrapping failing kind equalities]
<a name="line-390"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-391"></a>In simplifyAndEmitFlatConstraints, if we fail to get down to simple
<a name="line-392"></a>flat constraints we will
<a name="line-393"></a>* re-emit the constraints so that they are reported
<a name="line-394"></a>* fail in the monad
<a name="line-395"></a>But there is a Terrible Danger that, if -fdefer-type-errors is on, and
<a name="line-396"></a>we just re-emit an insoluble constraint like (* ~ (*-&gt;*)), that we'll
<a name="line-397"></a>report only a warning and proceed with compilation.  But if we ever fail
<a name="line-398"></a>in the monad it should be fatal; we should report an error and stop after
<a name="line-399"></a>the type checker.  If not, chaos results: #19142.
<a name="line-400"></a>
<a name="line-401"></a>Our solution is this:
<a name="line-402"></a>* Even with -fdefer-type-errors, inside an implication with no place for
<a name="line-403"></a>  value bindings (ic_binds = CoEvBindsVar), report failing equalities as
<a name="line-404"></a>  errors.  We have to do this anyway; see GHC.Tc.Errors
<a name="line-405"></a>  Note [Failing equalities with no evidence bindings].
<a name="line-406"></a>
<a name="line-407"></a>* Right here in simplifyAndEmitFlatConstraints, use buildTvImplication
<a name="line-408"></a>  to wrap the failing constraint in a degenerate implication (no
<a name="line-409"></a>  skolems, no theta), with ic_binds = CoEvBindsVar.  This setting of
<a name="line-410"></a>  `ic_binds` means that any failing equalities will lead to an
<a name="line-411"></a>  error not a warning, irrespective of -fdefer-type-errors: see
<a name="line-412"></a>  Note [Failing equalities with no evidence bindings] in GHC.Tc.Errors,
<a name="line-413"></a>  and `maybeSwitchOffDefer` in that module.
<a name="line-414"></a>
<a name="line-415"></a>  We still take care to bump the TcLevel of the implication.  Partly,
<a name="line-416"></a>  that ensures that nested implications have increasing level numbers
<a name="line-417"></a>  which seems nice.  But more specifically, suppose the outer level
<a name="line-418"></a>  has a Given `(C ty)`, which has pending (not-yet-expanded)
<a name="line-419"></a>  superclasses. Consider what happens when we process this implication
<a name="line-420"></a>  constraint (which we have re-emitted) in that context:
<a name="line-421"></a>    - in the inner implication we'll call `getPendingGivenScs`,
<a name="line-422"></a>    - we /do not/ want to get the `(C ty)` from the outer level,
<a name="line-423"></a>    lest we try to add an evidence term for the superclass,
<a name="line-424"></a>    which we can't do because we have specifically set
<a name="line-425"></a>    `ic_binds` = `CoEvBindsVar`.
<a name="line-426"></a>    - as `getPendingGivenSCcs is careful to only get Givens from
<a name="line-427"></a>    the /current/ level, and we bumped the `TcLevel` of the implication,
<a name="line-428"></a>    we're OK.
<a name="line-429"></a>
<a name="line-430"></a>  TL;DR: bump the `TcLevel` when creating the nested implication.
<a name="line-431"></a>  If we don't we get a panic in `GHC.Tc.Utils.Monad.addTcEvBind` (#20043).
<a name="line-432"></a>
<a name="line-433"></a>
<a name="line-434"></a>We re-emit the implication rather than reporting the errors right now,
<a name="line-435"></a>so that the error mesages are improved by other solving and defaulting.
<a name="line-436"></a>e.g. we prefer
<a name="line-437"></a>    Cannot match 'Type-&gt;Type' with 'Type'
<a name="line-438"></a>to  Cannot match 'Type-&gt;Type' with 'TYPE r0'
<a name="line-439"></a>
<a name="line-440"></a>
<a name="line-441"></a>Note [floatKindEqualities vs approximateWC]
<a name="line-442"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-443"></a>floatKindEqualities and approximateWC are strikingly similar to each
<a name="line-444"></a>other, but
<a name="line-445"></a>
<a name="line-446"></a>* floatKindEqualites tries to float /all/ equalities, and fails if
<a name="line-447"></a>  it can't, or if any implication is insoluble.
<a name="line-448"></a>* approximateWC just floats out any constraints
<a name="line-449"></a>  (not just equalities) that can float; it never fails.
<a name="line-450"></a>-}</span>
<a name="line-451"></a>
<a name="line-452"></a>
<a name="line-453"></a><a name="reportUnsolvedEqualities"></a><span class='hs-definition'>reportUnsolvedEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SkolemInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcLevel</span>
<a name="line-454"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-455"></a><span class='hs-comment'>-- Reports all unsolved wanteds provided; fails in the monad if there are any.</span>
<a name="line-456"></a><span class='hs-comment'>--</span>
<a name="line-457"></a><span class='hs-comment'>-- The provided SkolemInfo and [TcTyVar] arguments are used in an implication to</span>
<a name="line-458"></a><span class='hs-comment'>-- provide skolem info for any errors.</span>
<a name="line-459"></a><span class='hs-comment'>--</span>
<a name="line-460"></a><span class='hs-definition'>reportUnsolvedEqualities</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>wanted</span>
<a name="line-461"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanted</span>
<a name="line-462"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-463"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-464"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkNoErrs</span> <span class='hs-varop'>$</span>   <span class='hs-comment'>-- Fail</span>
<a name="line-465"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>buildTvImplication</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>wanted</span>
<a name="line-466"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>reportAllUnsolved</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkImplicWC</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-467"></a>
<a name="line-468"></a>
<a name="line-469"></a><a name="simplifyTopWanteds"></a><span class='hs-comment'>-- | Simplify top-level constraints, but without reporting any unsolved</span>
<a name="line-470"></a><span class='hs-comment'>-- constraints nor unsafe overlapping.</span>
<a name="line-471"></a><span class='hs-definition'>simplifyTopWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-472"></a>    <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-473"></a><span class='hs-definition'>simplifyTopWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-474"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-475"></a>                            <span class='hs-comment'>-- This is where the main work happens</span>
<a name="line-476"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-477"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-layout'>}</span>
<a name="line-478"></a>  <span class='hs-keyword'>where</span>
<a name="line-479"></a>    <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-480"></a>    <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>wc</span>
<a name="line-481"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span>
<a name="line-482"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-483"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wc</span>
<a name="line-484"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>gopt</span> <span class='hs-conid'>Opt_PrintExplicitRuntimeReps</span> <span class='hs-varid'>dflags</span> <span class='hs-comment'>-- See Note [Defaulting insolubles]</span>
<a name="line-485"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-486"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-487"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>free_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.zonkTyCoVarsAndFVList</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfWCList</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-488"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>meta_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyVar</span> <span class='hs-varop'>&lt;&amp;&amp;&gt;</span> <span class='hs-varid'>isMetaTyVar</span><span class='hs-layout'>)</span> <span class='hs-varid'>free_tvs</span>
<a name="line-489"></a>                   <span class='hs-comment'>-- zonkTyCoVarsAndFV: the wc_first_go is not yet zonked</span>
<a name="line-490"></a>                   <span class='hs-comment'>-- filter isMetaTyVar: we might have runtime-skolems in GHCi,</span>
<a name="line-491"></a>                   <span class='hs-comment'>-- and we definitely don't want to try to assign to those!</span>
<a name="line-492"></a>                   <span class='hs-comment'>-- The isTyVar is needed to weed out coercion variables</span>
<a name="line-493"></a>
<a name="line-494"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>defaulted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>defaultTyVarTcS</span> <span class='hs-varid'>meta_tvs</span>   <span class='hs-comment'>-- Has unification side effects</span>
<a name="line-495"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>or</span> <span class='hs-varid'>defaulted</span>
<a name="line-496"></a>             <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-497"></a>                            <span class='hs-comment'>-- See Note [Must simplify after defaulting]</span>
<a name="line-498"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span>
<a name="line-499"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>     <span class='hs-comment'>-- No defaulting took place</span>
<a name="line-500"></a>
<a name="line-501"></a>    <span class='hs-varid'>try_class_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-502"></a>    <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-503"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span> <span class='hs-varop'>||</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wc</span> <span class='hs-comment'>-- See Note [Defaulting insolubles]</span>
<a name="line-504"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-505"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- See Note [When to do type-class defaulting]</span>
<a name="line-506"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>something_happened</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>applyDefaultingRules</span> <span class='hs-varid'>wc</span>
<a name="line-507"></a>                                   <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-508"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>something_happened</span>
<a name="line-509"></a>             <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-510"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span>
<a name="line-511"></a>                  <span class='hs-comment'>-- See Note [Overview of implicit CallStacks] in GHC.Tc.Types.Evidence</span>
<a name="line-512"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>try_callstack_defaulting</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>
<a name="line-513"></a>
<a name="line-514"></a>    <span class='hs-varid'>try_callstack_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-515"></a>    <span class='hs-varid'>try_callstack_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-516"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span>
<a name="line-517"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-518"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-519"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultCallStacks</span> <span class='hs-varid'>wc</span>
<a name="line-520"></a>
<a name="line-521"></a><a name="defaultCallStacks"></a><span class='hs-comment'>-- | Default any remaining @CallStack@ constraints to empty @CallStack@s.</span>
<a name="line-522"></a><span class='hs-definition'>defaultCallStacks</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-523"></a><span class='hs-comment'>-- See Note [Overview of implicit CallStacks] in GHC.Tc.Types.Evidence</span>
<a name="line-524"></a><span class='hs-definition'>defaultCallStacks</span> <span class='hs-varid'>wanteds</span>
<a name="line-525"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>simples</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>handle_simples</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_simple</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-526"></a>       <span class='hs-varid'>mb_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>handle_implic</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-527"></a>       <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanteds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span>
<a name="line-528"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>catBagMaybes</span> <span class='hs-varid'>mb_implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-529"></a>
<a name="line-530"></a>  <span class='hs-keyword'>where</span>
<a name="line-531"></a>
<a name="line-532"></a>  <span class='hs-varid'>handle_simples</span> <span class='hs-varid'>simples</span>
<a name="line-533"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>catBagMaybes</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>defaultCallStack</span> <span class='hs-varid'>simples</span>
<a name="line-534"></a>
<a name="line-535"></a>  <span class='hs-varid'>handle_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-536"></a>  <span class='hs-comment'>-- The Maybe is because solving the CallStack constraint</span>
<a name="line-537"></a>  <span class='hs-comment'>-- may well allow us to discard the implication entirely</span>
<a name="line-538"></a>  <span class='hs-varid'>handle_implic</span> <span class='hs-varid'>implic</span>
<a name="line-539"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSolvedStatus</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_status</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span>
<a name="line-540"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span>
<a name="line-541"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-542"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setEvBindsTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_binds</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-543"></a>                      <span class='hs-comment'>-- defaultCallStack sets a binding, so</span>
<a name="line-544"></a>                      <span class='hs-comment'>-- we must set the correct binding group</span>
<a name="line-545"></a>                      <span class='hs-varid'>defaultCallStacks</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span>
<a name="line-546"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>setImplicationStatus</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-547"></a>
<a name="line-548"></a>  <span class='hs-varid'>defaultCallStack</span> <span class='hs-varid'>ct</span>
<a name="line-549"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-550"></a>    <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isCallStackPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-551"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>solveCallStack</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span> <span class='hs-conid'>EvCsEmpty</span>
<a name="line-552"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>Nothing</span> <span class='hs-layout'>}</span>
<a name="line-553"></a>
<a name="line-554"></a>  <span class='hs-varid'>defaultCallStack</span> <span class='hs-varid'>ct</span>
<a name="line-555"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-556"></a>
<a name="line-557"></a>
<a name="line-558"></a><span class='hs-comment'>{- Note [When to do type-class defaulting]
<a name="line-559"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-560"></a>In GHC 7.6 and 7.8.2, we did type-class defaulting only if insolubleWC
<a name="line-561"></a>was false, on the grounds that defaulting can't help solve insoluble
<a name="line-562"></a>constraints.  But if we *don't* do defaulting we may report a whole
<a name="line-563"></a>lot of errors that would be solved by defaulting; these errors are
<a name="line-564"></a>quite spurious because fixing the single insoluble error means that
<a name="line-565"></a>defaulting happens again, which makes all the other errors go away.
<a name="line-566"></a>This is jolly confusing: #9033.
<a name="line-567"></a>
<a name="line-568"></a>So it seems better to always do type-class defaulting.
<a name="line-569"></a>
<a name="line-570"></a>However, always doing defaulting does mean that we'll do it in
<a name="line-571"></a>situations like this (#5934):
<a name="line-572"></a>   run :: (forall s. GenST s) -&gt; Int
<a name="line-573"></a>   run = fromInteger 0
<a name="line-574"></a>We don't unify the return type of fromInteger with the given function
<a name="line-575"></a>type, because the latter involves foralls.  So we're left with
<a name="line-576"></a>    (Num alpha, alpha ~ (forall s. GenST s) -&gt; Int)
<a name="line-577"></a>Now we do defaulting, get alpha := Integer, and report that we can't
<a name="line-578"></a>match Integer with (forall s. GenST s) -&gt; Int.  That's not totally
<a name="line-579"></a>stupid, but perhaps a little strange.
<a name="line-580"></a>
<a name="line-581"></a>Another potential alternative would be to suppress *all* non-insoluble
<a name="line-582"></a>errors if there are *any* insoluble errors, anywhere, but that seems
<a name="line-583"></a>too drastic.
<a name="line-584"></a>
<a name="line-585"></a>Note [Must simplify after defaulting]
<a name="line-586"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-587"></a>We may have a deeply buried constraint
<a name="line-588"></a>    (t:*) ~ (a:Open)
<a name="line-589"></a>which we couldn't solve because of the kind incompatibility, and 'a' is free.
<a name="line-590"></a>Then when we default 'a' we can solve the constraint.  And we want to do
<a name="line-591"></a>that before starting in on type classes.  We MUST do it before reporting
<a name="line-592"></a>errors, because it isn't an error!  #7967 was due to this.
<a name="line-593"></a>
<a name="line-594"></a>Note [Top-level Defaulting Plan]
<a name="line-595"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-596"></a>We have considered two design choices for where/when to apply defaulting.
<a name="line-597"></a>   (i) Do it in SimplCheck mode only /whenever/ you try to solve some
<a name="line-598"></a>       simple constraints, maybe deep inside the context of implications.
<a name="line-599"></a>       This used to be the case in GHC 7.4.1.
<a name="line-600"></a>   (ii) Do it in a tight loop at simplifyTop, once all other constraints have
<a name="line-601"></a>        finished. This is the current story.
<a name="line-602"></a>
<a name="line-603"></a>Option (i) had many disadvantages:
<a name="line-604"></a>   a) Firstly, it was deep inside the actual solver.
<a name="line-605"></a>   b) Secondly, it was dependent on the context (Infer a type signature,
<a name="line-606"></a>      or Check a type signature, or Interactive) since we did not want
<a name="line-607"></a>      to always start defaulting when inferring (though there is an exception to
<a name="line-608"></a>      this, see Note [Default while Inferring]).
<a name="line-609"></a>   c) It plainly did not work. Consider typecheck/should_compile/DfltProb2.hs:
<a name="line-610"></a>          f :: Int -&gt; Bool
<a name="line-611"></a>          f x = const True (\y -&gt; let w :: a -&gt; a
<a name="line-612"></a>                                      w a = const a (y+1)
<a name="line-613"></a>                                  in w y)
<a name="line-614"></a>      We will get an implication constraint (for beta the type of y):
<a name="line-615"></a>               [untch=beta] forall a. 0 =&gt; Num beta
<a name="line-616"></a>      which we really cannot default /while solving/ the implication, since beta is
<a name="line-617"></a>      untouchable.
<a name="line-618"></a>
<a name="line-619"></a>Instead our new defaulting story is to pull defaulting out of the solver loop and
<a name="line-620"></a>go with option (ii), implemented at SimplifyTop. Namely:
<a name="line-621"></a>     - First, have a go at solving the residual constraint of the whole
<a name="line-622"></a>       program
<a name="line-623"></a>     - Try to approximate it with a simple constraint
<a name="line-624"></a>     - Figure out derived defaulting equations for that simple constraint
<a name="line-625"></a>     - Go round the loop again if you did manage to get some equations
<a name="line-626"></a>
<a name="line-627"></a>Now, that has to do with class defaulting. However there exists type variable /kind/
<a name="line-628"></a>defaulting. Again this is done at the top-level and the plan is:
<a name="line-629"></a>     - At the top-level, once you had a go at solving the constraint, do
<a name="line-630"></a>       figure out /all/ the touchable unification variables of the wanted constraints.
<a name="line-631"></a>     - Apply defaulting to their kinds
<a name="line-632"></a>
<a name="line-633"></a>More details in Note [DefaultTyVar].
<a name="line-634"></a>
<a name="line-635"></a>Note [Safe Haskell Overlapping Instances]
<a name="line-636"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-637"></a>In Safe Haskell, we apply an extra restriction to overlapping instances. The
<a name="line-638"></a>motive is to prevent untrusted code provided by a third-party, changing the
<a name="line-639"></a>behavior of trusted code through type-classes. This is due to the global and
<a name="line-640"></a>implicit nature of type-classes that can hide the source of the dictionary.
<a name="line-641"></a>
<a name="line-642"></a>Another way to state this is: if a module M compiles without importing another
<a name="line-643"></a>module N, changing M to import N shouldn't change the behavior of M.
<a name="line-644"></a>
<a name="line-645"></a>Overlapping instances with type-classes can violate this principle. However,
<a name="line-646"></a>overlapping instances aren't always unsafe. They are just unsafe when the most
<a name="line-647"></a>selected dictionary comes from untrusted code (code compiled with -XSafe) and
<a name="line-648"></a>overlaps instances provided by other modules.
<a name="line-649"></a>
<a name="line-650"></a>In particular, in Safe Haskell at a call site with overlapping instances, we
<a name="line-651"></a>apply the following rule to determine if it is a 'unsafe' overlap:
<a name="line-652"></a>
<a name="line-653"></a> 1) Most specific instance, I1, defined in an `-XSafe` compiled module.
<a name="line-654"></a> 2) I1 is an orphan instance or a MPTC.
<a name="line-655"></a> 3) At least one overlapped instance, Ix, is both:
<a name="line-656"></a>    A) from a different module than I1
<a name="line-657"></a>    B) Ix is not marked `OVERLAPPABLE`
<a name="line-658"></a>
<a name="line-659"></a>This is a slightly involved heuristic, but captures the situation of an
<a name="line-660"></a>imported module N changing the behavior of existing code. For example, if
<a name="line-661"></a>condition (2) isn't violated, then the module author M must depend either on a
<a name="line-662"></a>type-class or type defined in N.
<a name="line-663"></a>
<a name="line-664"></a>Secondly, when should these heuristics be enforced? We enforced them when the
<a name="line-665"></a>type-class method call site is in a module marked `-XSafe` or `-XTrustworthy`.
<a name="line-666"></a>This allows `-XUnsafe` modules to operate without restriction, and for Safe
<a name="line-667"></a>Haskell inferrence to infer modules with unsafe overlaps as unsafe.
<a name="line-668"></a>
<a name="line-669"></a>One alternative design would be to also consider if an instance was imported as
<a name="line-670"></a>a `safe` import or not and only apply the restriction to instances imported
<a name="line-671"></a>safely. However, since instances are global and can be imported through more
<a name="line-672"></a>than one path, this alternative doesn't work.
<a name="line-673"></a>
<a name="line-674"></a>Note [Safe Haskell Overlapping Instances Implementation]
<a name="line-675"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-676"></a>How is this implemented? It's complicated! So we'll step through it all:
<a name="line-677"></a>
<a name="line-678"></a> 1) `InstEnv.lookupInstEnv` -- Performs instance resolution, so this is where
<a name="line-679"></a>    we check if a particular type-class method call is safe or unsafe. We do this
<a name="line-680"></a>    through the return type, `ClsInstLookupResult`, where the last parameter is a
<a name="line-681"></a>    list of instances that are unsafe to overlap. When the method call is safe,
<a name="line-682"></a>    the list is null.
<a name="line-683"></a>
<a name="line-684"></a> 2) `GHC.Tc.Solver.Interact.matchClassInst` -- This module drives the instance resolution
<a name="line-685"></a>    / dictionary generation. The return type is `ClsInstResult`, which either
<a name="line-686"></a>    says no instance matched, or one found, and if it was a safe or unsafe
<a name="line-687"></a>    overlap.
<a name="line-688"></a>
<a name="line-689"></a> 3) `GHC.Tc.Solver.Interact.doTopReactDict` -- Takes a dictionary / class constraint and
<a name="line-690"></a>     tries to resolve it by calling (in part) `matchClassInst`. The resolving
<a name="line-691"></a>     mechanism has a work list (of constraints) that it process one at a time. If
<a name="line-692"></a>     the constraint can't be resolved, it's added to an inert set. When compiling
<a name="line-693"></a>     an `-XSafe` or `-XTrustworthy` module, we follow this approach as we know
<a name="line-694"></a>     compilation should fail. These are handled as normal constraint resolution
<a name="line-695"></a>     failures from here-on (see step 6).
<a name="line-696"></a>
<a name="line-697"></a>     Otherwise, we may be inferring safety (or using `-Wunsafe`), and
<a name="line-698"></a>     compilation should succeed, but print warnings and/or mark the compiled module
<a name="line-699"></a>     as `-XUnsafe`. In this case, we call `insertSafeOverlapFailureTcS` which adds
<a name="line-700"></a>     the unsafe (but resolved!) constraint to the `inert_safehask` field of
<a name="line-701"></a>     `InertCans`.
<a name="line-702"></a>
<a name="line-703"></a> 4) `GHC.Tc.Solver.simplifyTop`:
<a name="line-704"></a>       * Call simplifyTopWanteds, the top-level function for driving the simplifier for
<a name="line-705"></a>         constraint resolution.
<a name="line-706"></a>
<a name="line-707"></a>       * Once finished, call `getSafeOverlapFailures` to retrieve the
<a name="line-708"></a>         list of overlapping instances that were successfully resolved,
<a name="line-709"></a>         but unsafe. Remember, this is only applicable for generating warnings
<a name="line-710"></a>         (`-Wunsafe`) or inferring a module unsafe. `-XSafe` and `-XTrustworthy`
<a name="line-711"></a>         cause compilation failure by not resolving the unsafe constraint at all.
<a name="line-712"></a>
<a name="line-713"></a>       * For unresolved constraints (all types), call `GHC.Tc.Errors.reportUnsolved`,
<a name="line-714"></a>         while for resolved but unsafe overlapping dictionary constraints, call
<a name="line-715"></a>         `GHC.Tc.Errors.warnAllUnsolved`. Both functions convert constraints into a
<a name="line-716"></a>         warning message for the user.
<a name="line-717"></a>
<a name="line-718"></a>       * In the case of `warnAllUnsolved` for resolved, but unsafe
<a name="line-719"></a>         dictionary constraints, we collect the generated warning
<a name="line-720"></a>         message (pop it) and call `GHC.Tc.Utils.Monad.recordUnsafeInfer` to
<a name="line-721"></a>         mark the module we are compiling as unsafe, passing the
<a name="line-722"></a>         warning message along as the reason.
<a name="line-723"></a>
<a name="line-724"></a> 5) `GHC.Tc.Errors.*Unsolved` -- Generates error messages for constraints by
<a name="line-725"></a>    actually calling `InstEnv.lookupInstEnv` again! Yes, confusing, but all we
<a name="line-726"></a>    know is the constraint that is unresolved or unsafe. For dictionary, all we
<a name="line-727"></a>    know is that we need a dictionary of type C, but not what instances are
<a name="line-728"></a>    available and how they overlap. So we once again call `lookupInstEnv` to
<a name="line-729"></a>    figure that out so we can generate a helpful error message.
<a name="line-730"></a>
<a name="line-731"></a> 6) `GHC.Tc.Utils.Monad.recordUnsafeInfer` -- Save the unsafe result and reason in an
<a name="line-732"></a>      IORef called `tcg_safeInfer`.
<a name="line-733"></a>
<a name="line-734"></a> 7) `GHC.Driver.Main.tcRnModule'` -- Reads `tcg_safeInfer` after type-checking, calling
<a name="line-735"></a>    `GHC.Driver.Main.markUnsafeInfer` (passing the reason along) when safe-inferrence
<a name="line-736"></a>    failed.
<a name="line-737"></a>
<a name="line-738"></a>Note [No defaulting in the ambiguity check]
<a name="line-739"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-740"></a>When simplifying constraints for the ambiguity check, we use
<a name="line-741"></a>solveWantedsAndDrop, not simplifyTopWanteds, so that we do no defaulting.
<a name="line-742"></a>#11947 was an example:
<a name="line-743"></a>   f :: Num a =&gt; Int -&gt; Int
<a name="line-744"></a>This is ambiguous of course, but we don't want to default the
<a name="line-745"></a>(Num alpha) constraint to (Num Int)!  Doing so gives a defaulting
<a name="line-746"></a>warning, but no error.
<a name="line-747"></a>
<a name="line-748"></a>Note [Defaulting insolubles]
<a name="line-749"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-750"></a>If a set of wanteds is insoluble, we have no hope of accepting the
<a name="line-751"></a>program. Yet we do not stop constraint solving, etc., because we may
<a name="line-752"></a>simplify the wanteds to produce better error messages. So, once
<a name="line-753"></a>we have an insoluble constraint, everything we do is just about producing
<a name="line-754"></a>helpful error messages.
<a name="line-755"></a>
<a name="line-756"></a>Should we default in this case or not? Let's look at an example (tcfail004):
<a name="line-757"></a>
<a name="line-758"></a>  (f,g) = (1,2,3)
<a name="line-759"></a>
<a name="line-760"></a>With defaulting, we get a conflict between (a0,b0) and (Integer,Integer,Integer).
<a name="line-761"></a>Without defaulting, we get a conflict between (a0,b0) and (a1,b1,c1). I (Richard)
<a name="line-762"></a>find the latter more helpful. Several other test cases (e.g. tcfail005) suggest
<a name="line-763"></a>similarly. So: we should not do class defaulting with insolubles.
<a name="line-764"></a>
<a name="line-765"></a>On the other hand, RuntimeRep-defaulting is different. Witness tcfail078:
<a name="line-766"></a>
<a name="line-767"></a>  f :: Integer i =&gt; i
<a name="line-768"></a>  f =               0
<a name="line-769"></a>
<a name="line-770"></a>Without RuntimeRep-defaulting, we GHC suggests that Integer should have kind
<a name="line-771"></a>TYPE r0 -&gt; Constraint and then complains that r0 is actually untouchable
<a name="line-772"></a>(presumably, because it can't be sure if `Integer i` entails an equality).
<a name="line-773"></a>If we default, we are told of a clash between (* -&gt; Constraint) and Constraint.
<a name="line-774"></a>The latter seems far better, suggesting we *should* do RuntimeRep-defaulting
<a name="line-775"></a>even on insolubles.
<a name="line-776"></a>
<a name="line-777"></a>But, evidently, not always. Witness UnliftedNewtypesInfinite:
<a name="line-778"></a>
<a name="line-779"></a>  newtype Foo = FooC (# Int#, Foo #)
<a name="line-780"></a>
<a name="line-781"></a>This should fail with an occurs-check error on the kind of Foo (with -XUnliftedNewtypes).
<a name="line-782"></a>If we default RuntimeRep-vars, we get
<a name="line-783"></a>
<a name="line-784"></a>  Expecting a lifted type, but ‘(# Int#, Foo #)’ is unlifted
<a name="line-785"></a>
<a name="line-786"></a>which is just plain wrong.
<a name="line-787"></a>
<a name="line-788"></a>Conclusion: we should do RuntimeRep-defaulting on insolubles only when the user does not
<a name="line-789"></a>want to hear about RuntimeRep stuff -- that is, when -fprint-explicit-runtime-reps
<a name="line-790"></a>is not set.
<a name="line-791"></a>-}</span>
<a name="line-792"></a>
<a name="line-793"></a><a name="simplifyAmbiguityCheck"></a><span class='hs-comment'>------------------</span>
<a name="line-794"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-795"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>wanteds</span>
<a name="line-796"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyAmbiguityCheck {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"type = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-797"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>final_wc</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-varid'>wanteds</span>
<a name="line-798"></a>             <span class='hs-comment'>-- NB: no defaulting!  See Note [No defaulting in the ambiguity check]</span>
<a name="line-799"></a>
<a name="line-800"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End simplifyAmbiguityCheck }"</span> <span class='hs-varid'>empty</span>
<a name="line-801"></a>
<a name="line-802"></a>       <span class='hs-comment'>-- Normally report all errors; but with -XAllowAmbiguousTypes</span>
<a name="line-803"></a>       <span class='hs-comment'>-- report only insoluble ones, since they represent genuinely</span>
<a name="line-804"></a>       <span class='hs-comment'>-- inaccessible code</span>
<a name="line-805"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>allow_ambiguous</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.AllowAmbiguousTypes</span>
<a name="line-806"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved(ambig) {"</span> <span class='hs-varid'>empty</span>
<a name="line-807"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>allow_ambiguous</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>final_wc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-808"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>discardResult</span> <span class='hs-layout'>(</span><span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>final_wc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-809"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved(ambig) }"</span> <span class='hs-varid'>empty</span>
<a name="line-810"></a>
<a name="line-811"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-812"></a>
<a name="line-813"></a><a name="simplifyInteractive"></a><span class='hs-comment'>------------------</span>
<a name="line-814"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-815"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-varid'>wanteds</span>
<a name="line-816"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span>
<a name="line-817"></a>    <span class='hs-varid'>simplifyTop</span> <span class='hs-varid'>wanteds</span>
<a name="line-818"></a>
<a name="line-819"></a><a name="simplifyDefault"></a><span class='hs-comment'>------------------</span>
<a name="line-820"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span>    <span class='hs-comment'>-- Wanted; has no type variables in it</span>
<a name="line-821"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>Bool</span>     <span class='hs-comment'>-- Return if the constraint is soluble</span>
<a name="line-822"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-varid'>theta</span>
<a name="line-823"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyDefault"</span> <span class='hs-varid'>empty</span>
<a name="line-824"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanteds</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWanteds</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-varid'>theta</span>
<a name="line-825"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSDeriveds</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-826"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>unsolved</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-827"></a>
<a name="line-828"></a><a name="tcCheckGivens"></a><span class='hs-comment'>------------------</span>
<a name="line-829"></a><span class='hs-definition'>tcCheckGivens</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>EvVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>InertSet</span><span class='hs-layout'>)</span>
<a name="line-830"></a><span class='hs-comment'>-- ^ Return (Just new_inerts) if the Givens are satisfiable, Nothing if definitely</span>
<a name="line-831"></a><span class='hs-comment'>-- contradictory</span>
<a name="line-832"></a><span class='hs-definition'>tcCheckGivens</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>given_ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-833"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>sat</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_inerts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSInerts</span> <span class='hs-varid'>inerts</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-834"></a>    <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"checkGivens {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>given_ids</span><span class='hs-layout'>)</span>
<a name="line-835"></a>    <span class='hs-varid'>lcl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getLclEnv</span>
<a name="line-836"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>given_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivenLoc</span> <span class='hs-varid'>topTcLevel</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-varid'>lcl_env</span>
<a name="line-837"></a>    <span class='hs-keyword'>let</span> <span class='hs-varid'>given_cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivens</span> <span class='hs-varid'>given_loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>given_ids</span><span class='hs-layout'>)</span>
<a name="line-838"></a>    <span class='hs-comment'>-- See Note [Superclasses and satisfiability]</span>
<a name="line-839"></a>    <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-varid'>given_cts</span>
<a name="line-840"></a>    <span class='hs-varid'>insols</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInertInsols</span>
<a name="line-841"></a>    <span class='hs-varid'>insols</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try_harder</span> <span class='hs-varid'>insols</span>
<a name="line-842"></a>    <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"checkGivens }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>insols</span><span class='hs-layout'>)</span>
<a name="line-843"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>insols</span><span class='hs-layout'>)</span>
<a name="line-844"></a>  <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>sat</span> <span class='hs-keyword'>then</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>new_inerts</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>Nothing</span>
<a name="line-845"></a>  <span class='hs-keyword'>where</span>
<a name="line-846"></a>    <span class='hs-varid'>try_harder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-847"></a>    <span class='hs-comment'>-- Maybe we have to search up the superclass chain to find</span>
<a name="line-848"></a>    <span class='hs-comment'>-- an unsatisfiable constraint.  Example: pmcheck/T3927b.</span>
<a name="line-849"></a>    <span class='hs-comment'>-- At the moment we try just once</span>
<a name="line-850"></a>    <span class='hs-varid'>try_harder</span> <span class='hs-varid'>insols</span>
<a name="line-851"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>insols</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- We've found that it's definitely unsatisfiable</span>
<a name="line-852"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>insols</span>             <span class='hs-comment'>-- Hurrah -- stop now.</span>
<a name="line-853"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-854"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>pending_given</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getPendingGivenScs</span>
<a name="line-855"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>new_given</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeSuperClasses</span> <span class='hs-varid'>pending_given</span>
<a name="line-856"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-varid'>new_given</span>
<a name="line-857"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>getInertInsols</span> <span class='hs-layout'>}</span>
<a name="line-858"></a>
<a name="line-859"></a><a name="tcCheckWanteds"></a><span class='hs-definition'>tcCheckWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>Bool</span>
<a name="line-860"></a><span class='hs-comment'>-- ^ Return True if the Wanteds are soluble, False if not</span>
<a name="line-861"></a><span class='hs-definition'>tcCheckWanteds</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-862"></a>  <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWanteds</span> <span class='hs-conid'>PatCheckOrigin</span> <span class='hs-varid'>wanteds</span>
<a name="line-863"></a>  <span class='hs-layout'>(</span><span class='hs-varid'>sat</span><span class='hs-layout'>,</span> <span class='hs-sel'>_new_inerts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSInerts</span> <span class='hs-varid'>inerts</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>do</span>
<a name="line-864"></a>    <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"checkWanteds {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-865"></a>    <span class='hs-comment'>-- See Note [Superclasses and satisfiability]</span>
<a name="line-866"></a>    <span class='hs-varid'>wcs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>cts</span><span class='hs-layout'>)</span>
<a name="line-867"></a>    <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"checkWanteds }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wcs</span><span class='hs-layout'>)</span>
<a name="line-868"></a>    <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSolvedWC</span> <span class='hs-varid'>wcs</span><span class='hs-layout'>)</span>
<a name="line-869"></a>  <span class='hs-varid'>return</span> <span class='hs-varid'>sat</span>
<a name="line-870"></a>
<a name="line-871"></a><a name="tcNormalise"></a><span class='hs-comment'>-- | Normalise a type as much as possible using the given constraints.</span>
<a name="line-872"></a><span class='hs-comment'>-- See @Note [tcNormalise]@.</span>
<a name="line-873"></a><span class='hs-definition'>tcNormalise</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InertSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>Type</span>
<a name="line-874"></a><span class='hs-definition'>tcNormalise</span> <span class='hs-varid'>inerts</span> <span class='hs-varid'>ty</span>
<a name="line-875"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>norm_loc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getCtLocM</span> <span class='hs-conid'>PatCheckOrigin</span> <span class='hs-conid'>Nothing</span>
<a name="line-876"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>res</span><span class='hs-layout'>,</span> <span class='hs-sel'>_new_inerts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSInerts</span> <span class='hs-varid'>inerts</span> <span class='hs-varop'>$</span>
<a name="line-877"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"tcNormalise {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span>
<a name="line-878"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteType</span> <span class='hs-varid'>norm_loc</span> <span class='hs-varid'>ty</span>
<a name="line-879"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"tcNormalise }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span>
<a name="line-880"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>ty'</span> <span class='hs-layout'>}</span>
<a name="line-881"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-882"></a>
<a name="line-883"></a><span class='hs-comment'>{- Note [Superclasses and satisfiability]
<a name="line-884"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-885"></a>Expand superclasses before starting, because (Int ~ Bool), has
<a name="line-886"></a>(Int ~~ Bool) as a superclass, which in turn has (Int ~N# Bool)
<a name="line-887"></a>as a superclass, and it's the latter that is insoluble.  See
<a name="line-888"></a>Note [The equality types story] in GHC.Builtin.Types.Prim.
<a name="line-889"></a>
<a name="line-890"></a>If we fail to prove unsatisfiability we (arbitrarily) try just once to
<a name="line-891"></a>find superclasses, using try_harder.  Reason: we might have a type
<a name="line-892"></a>signature
<a name="line-893"></a>   f :: F op (Implements push) =&gt; ..
<a name="line-894"></a>where F is a type function.  This happened in #3972.
<a name="line-895"></a>
<a name="line-896"></a>We could do more than once but we'd have to have /some/ limit: in the
<a name="line-897"></a>the recursive case, we would go on forever in the common case where
<a name="line-898"></a>the constraints /are/ satisfiable (#10592 comment:12!).
<a name="line-899"></a>
<a name="line-900"></a>For stratightforard situations without type functions the try_harder
<a name="line-901"></a>step does nothing.
<a name="line-902"></a>
<a name="line-903"></a>Note [tcNormalise]
<a name="line-904"></a>~~~~~~~~~~~~~~~~~~
<a name="line-905"></a>tcNormalise is a rather atypical entrypoint to the constraint solver. Whereas
<a name="line-906"></a>most invocations of the constraint solver are intended to simplify a set of
<a name="line-907"></a>constraints or to decide if a particular set of constraints is satisfiable,
<a name="line-908"></a>the purpose of tcNormalise is to take a type, plus some locally solved
<a name="line-909"></a>constraints in the form of an InertSet, and normalise the type as much as
<a name="line-910"></a>possible with respect to those constraints.
<a name="line-911"></a>
<a name="line-912"></a>It does *not* reduce type or data family applications or look through newtypes.
<a name="line-913"></a>
<a name="line-914"></a>Why is this useful? As one example, when coverage-checking an EmptyCase
<a name="line-915"></a>expression, it's possible that the type of the scrutinee will only reduce
<a name="line-916"></a>if some local equalities are solved for. See "Wrinkle: Local equalities"
<a name="line-917"></a>in Note [Type normalisation] in "GHC.HsToCore.Pmc".
<a name="line-918"></a>
<a name="line-919"></a>To accomplish its stated goal, tcNormalise first initialises the solver monad
<a name="line-920"></a>with the given InertCans, then uses rewriteType to simplify the desired type
<a name="line-921"></a>with respect to the Givens in the InertCans.
<a name="line-922"></a>
<a name="line-923"></a>***********************************************************************************
<a name="line-924"></a>*                                                                                 *
<a name="line-925"></a>*                            Inference
<a name="line-926"></a>*                                                                                 *
<a name="line-927"></a>***********************************************************************************
<a name="line-928"></a>
<a name="line-929"></a>Note [Inferring the type of a let-bound variable]
<a name="line-930"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-931"></a>Consider
<a name="line-932"></a>   f x = rhs
<a name="line-933"></a>
<a name="line-934"></a>To infer f's type we do the following:
<a name="line-935"></a> * Gather the constraints for the RHS with ambient level *one more than*
<a name="line-936"></a>   the current one.  This is done by the call
<a name="line-937"></a>        pushLevelAndCaptureConstraints (tcMonoBinds...)
<a name="line-938"></a>   in GHC.Tc.Gen.Bind.tcPolyInfer
<a name="line-939"></a>
<a name="line-940"></a> * Call simplifyInfer to simplify the constraints and decide what to
<a name="line-941"></a>   quantify over. We pass in the level used for the RHS constraints,
<a name="line-942"></a>   here called rhs_tclvl.
<a name="line-943"></a>
<a name="line-944"></a>This ensures that the implication constraint we generate, if any,
<a name="line-945"></a>has a strictly-increased level compared to the ambient level outside
<a name="line-946"></a>the let binding.
<a name="line-947"></a>
<a name="line-948"></a>-}</span>
<a name="line-949"></a>
<a name="line-950"></a><a name="InferMode"></a><span class='hs-comment'>-- | How should we choose which constraints to quantify over?</span>
<a name="line-951"></a><a name="InferMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>InferMode</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ApplyMR</span>          <span class='hs-comment'>-- ^ Apply the monomorphism restriction,</span>
<a name="line-952"></a>                                  <span class='hs-comment'>-- never quantifying over any constraints</span>
<a name="line-953"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EagerDefaulting</span>  <span class='hs-comment'>-- ^ See Note [TcRnExprMode] in "GHC.Tc.Module",</span>
<a name="line-954"></a>                                  <span class='hs-comment'>-- the :type +d case; this mode refuses</span>
<a name="line-955"></a>                                  <span class='hs-comment'>-- to quantify over any defaultable constraint</span>
<a name="line-956"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NoRestrictions</span>   <span class='hs-comment'>-- ^ Quantify over any constraint that</span>
<a name="line-957"></a>                                  <span class='hs-comment'>-- satisfies 'GHC.Tc.Utils.TcType.pickQuantifiablePreds'</span>
<a name="line-958"></a>
<a name="line-959"></a><a name="instance%20Outputable%20InferMode"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>InferMode</span> <span class='hs-keyword'>where</span>
<a name="line-960"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>ApplyMR</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ApplyMR"</span>
<a name="line-961"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>EagerDefaulting</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"EagerDefaulting"</span>
<a name="line-962"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>NoRestrictions</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"NoRestrictions"</span>
<a name="line-963"></a>
<a name="line-964"></a><a name="simplifyInfer"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span>               <span class='hs-comment'>-- Used when generating the constraints</span>
<a name="line-965"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InferMode</span>
<a name="line-966"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcIdSigInst</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- Any signatures (possibly partial)</span>
<a name="line-967"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Variables to be generalised,</span>
<a name="line-968"></a>                                       <span class='hs-comment'>-- and their tau-types</span>
<a name="line-969"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-970"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Quantify over these type variables</span>
<a name="line-971"></a>                      <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ... and these constraints (fully zonked)</span>
<a name="line-972"></a>                      <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- ... binding these evidence variables</span>
<a name="line-973"></a>                      <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- True &lt;=&gt; the residual constraints are insoluble</span>
<a name="line-974"></a>
<a name="line-975"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>infer_mode</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>wanteds</span>
<a name="line-976"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-977"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- When quantifying, we want to preserve any order of variables as they</span>
<a name="line-978"></a>          <span class='hs-comment'>-- appear in partial signatures. cf. decideQuantifiedTyVars</span>
<a name="line-979"></a>          <span class='hs-keyword'>let</span> <span class='hs-varid'>psig_tv_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>partial_sigs</span>
<a name="line-980"></a>                                          <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sig_inst_skols</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>]</span>
<a name="line-981"></a>              <span class='hs-varid'>psig_theta</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>partial_sigs</span>
<a name="line-982"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sig_inst_theta</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>]</span>
<a name="line-983"></a>
<a name="line-984"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dep_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>candidateQTyVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>psig_tv_tys</span> <span class='hs-varop'>++</span> <span class='hs-varid'>psig_theta</span> <span class='hs-varop'>++</span> <span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span>
<a name="line-985"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtkvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>dep_vars</span>
<a name="line-986"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer: empty WC"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name_taus</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtkvs</span><span class='hs-layout'>)</span>
<a name="line-987"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtkvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyTcEvBinds</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-988"></a>
<a name="line-989"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-990"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer {"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-991"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"sigs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>sigs</span>
<a name="line-992"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"binds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name_taus</span>
<a name="line-993"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"rhs_tclvl ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_tclvl</span>
<a name="line-994"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"infer_mode ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>infer_mode</span>
<a name="line-995"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"(unzonked) wanted ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-996"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-997"></a>
<a name="line-998"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>psig_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMap</span> <span class='hs-varid'>sig_inst_theta</span> <span class='hs-varid'>partial_sigs</span>
<a name="line-999"></a>
<a name="line-1000"></a>       <span class='hs-comment'>-- First do full-blown solving</span>
<a name="line-1001"></a>       <span class='hs-comment'>-- NB: we must gather up all the bindings from doing</span>
<a name="line-1002"></a>       <span class='hs-comment'>-- this solving; hence (runTcSWithEvBinds ev_binds_var).</span>
<a name="line-1003"></a>       <span class='hs-comment'>-- And note that since there are nested implications,</span>
<a name="line-1004"></a>       <span class='hs-comment'>-- calling solveWanteds will side-effect their evidence</span>
<a name="line-1005"></a>       <span class='hs-comment'>-- bindings, so we can't just revert to the input</span>
<a name="line-1006"></a>       <span class='hs-comment'>-- constraint.</span>
<a name="line-1007"></a>
<a name="line-1008"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.newTcEvBinds</span>
<a name="line-1009"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>psig_evs</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWanteds</span> <span class='hs-conid'>AnnOrigin</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1010"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-1011"></a>            <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setTcLevel</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varop'>$</span>
<a name="line-1012"></a>               <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varop'>$</span>
<a name="line-1013"></a>               <span class='hs-varid'>solveWanteds</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>psig_evs</span> <span class='hs-varop'>`andWC`</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-1014"></a>               <span class='hs-comment'>-- psig_evs : see Note [Add signature contexts as wanteds]</span>
<a name="line-1015"></a>
<a name="line-1016"></a>       <span class='hs-comment'>-- Find quant_pred_candidates, the predicates that</span>
<a name="line-1017"></a>       <span class='hs-comment'>-- we'll consider quantifying over</span>
<a name="line-1018"></a>       <span class='hs-comment'>-- NB1: wanted_transformed does not include anything provable from</span>
<a name="line-1019"></a>       <span class='hs-comment'>--      the psig_theta; it's just the extra bit</span>
<a name="line-1020"></a>       <span class='hs-comment'>-- NB2: We do not do any defaulting when inferring a type, this can lead</span>
<a name="line-1021"></a>       <span class='hs-comment'>--      to less polymorphic types, see Note [Default while Inferring]</span>
<a name="line-1022"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.zonkWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-1023"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>definite_error</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-1024"></a>                              <span class='hs-comment'>-- See Note [Quantification with errors]</span>
<a name="line-1025"></a>                              <span class='hs-comment'>-- NB: must include derived errors in this test,</span>
<a name="line-1026"></a>                              <span class='hs-comment'>--     hence "incl_derivs"</span>
<a name="line-1027"></a>             <span class='hs-varid'>wanted_transformed</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-1028"></a>             <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-1029"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>definite_error</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1030"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctsPreds</span> <span class='hs-layout'>(</span><span class='hs-varid'>approximateWC</span> <span class='hs-conid'>False</span> <span class='hs-varid'>wanted_transformed</span><span class='hs-layout'>)</span>
<a name="line-1031"></a>
<a name="line-1032"></a>       <span class='hs-comment'>-- Decide what type variables and constraints to quantify</span>
<a name="line-1033"></a>       <span class='hs-comment'>-- NB: quant_pred_candidates is already fully zonked</span>
<a name="line-1034"></a>       <span class='hs-comment'>-- NB: bound_theta are constraints we want to quantify over,</span>
<a name="line-1035"></a>       <span class='hs-comment'>--     including the psig_theta, which we always quantify over</span>
<a name="line-1036"></a>       <span class='hs-comment'>-- NB: bound_theta are fully zonked</span>
<a name="line-1037"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>bound_theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_vars</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decideQuantification</span> <span class='hs-varid'>infer_mode</span> <span class='hs-varid'>rhs_tclvl</span>
<a name="line-1038"></a>                                                     <span class='hs-varid'>name_taus</span> <span class='hs-varid'>partial_sigs</span>
<a name="line-1039"></a>                                                     <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-1040"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bound_theta_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM.newEvVar</span> <span class='hs-varid'>bound_theta</span>
<a name="line-1041"></a>
<a name="line-1042"></a>       <span class='hs-comment'>-- Now emit the residual constraint</span>
<a name="line-1043"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitResidualConstraints</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-1044"></a>                                 <span class='hs-varid'>name_taus</span> <span class='hs-varid'>co_vars</span> <span class='hs-varid'>qtvs</span> <span class='hs-varid'>bound_theta_vars</span>
<a name="line-1045"></a>                                 <span class='hs-varid'>wanted_transformed</span>
<a name="line-1046"></a>
<a name="line-1047"></a>         <span class='hs-comment'>-- All done!</span>
<a name="line-1048"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/produced residual implication for quantification"</span> <span class='hs-varop'>$</span>
<a name="line-1049"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"quant_pred_candidates ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-1050"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"psig_theta ="</span>     <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1051"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"bound_theta ="</span>    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCoreBinders</span> <span class='hs-varid'>bound_theta_vars</span>
<a name="line-1052"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"qtvs ="</span>           <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span>
<a name="line-1053"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"definite_error ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>definite_error</span> <span class='hs-keyglyph'>]</span>
<a name="line-1054"></a>
<a name="line-1055"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>bound_theta_vars</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>,</span> <span class='hs-varid'>definite_error</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1056"></a>         <span class='hs-comment'>-- NB: bound_theta_vars must be fully zonked</span>
<a name="line-1057"></a>  <span class='hs-keyword'>where</span>
<a name="line-1058"></a>    <span class='hs-varid'>partial_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isPartialSig</span> <span class='hs-varid'>sigs</span>
<a name="line-1059"></a>
<a name="line-1060"></a><a name="emitResidualConstraints"></a><span class='hs-comment'>--------------------</span>
<a name="line-1061"></a><span class='hs-definition'>emitResidualConstraints</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvBindsVar</span>
<a name="line-1062"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1063"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span>
<a name="line-1064"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-1065"></a><span class='hs-comment'>-- Emit the remaining constraints from the RHS.</span>
<a name="line-1066"></a><span class='hs-definition'>emitResidualConstraints</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-1067"></a>                        <span class='hs-varid'>name_taus</span> <span class='hs-varid'>co_vars</span> <span class='hs-varid'>qtvs</span> <span class='hs-varid'>full_theta_vars</span> <span class='hs-varid'>wanteds</span>
<a name="line-1068"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-1069"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-1070"></a>
<a name="line-1071"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1072"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanted_simple</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.zonkSimples</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_simple</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-1073"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>outer_simple</span><span class='hs-layout'>,</span> <span class='hs-varid'>inner_simple</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>is_mono</span> <span class='hs-varid'>wanted_simple</span>
<a name="line-1074"></a>             <span class='hs-varid'>is_mono</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isWantedCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>ctEvId</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>co_vars</span>
<a name="line-1075"></a>             <span class='hs-comment'>-- Reason for the partition:</span>
<a name="line-1076"></a>             <span class='hs-comment'>-- see Note [Emitting the residual implication in simplifyInfer]</span>
<a name="line-1077"></a>
<a name="line-1078"></a><span class='hs-comment'>-- Already done by defaultTyVarsAndSimplify</span>
<a name="line-1079"></a><span class='hs-comment'>--      ; _ &lt;- TcM.promoteTyVarSet (tyCoVarsOfCts outer_simple)</span>
<a name="line-1080"></a>
<a name="line-1081"></a>        <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>inner_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inner_simple</span> <span class='hs-layout'>}</span>
<a name="line-1082"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>inner_wanted</span>
<a name="line-1083"></a>                     <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>emptyBag</span>
<a name="line-1084"></a>                     <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>implic1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newImplication</span>
<a name="line-1085"></a>                             <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unitBag</span> <span class='hs-varop'>$</span>
<a name="line-1086"></a>                                      <span class='hs-varid'>implic1</span>  <span class='hs-layout'>{</span> <span class='hs-varid'>ic_tclvl</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_tclvl</span>
<a name="line-1087"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>qtvs</span>
<a name="line-1088"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>full_theta_vars</span>
<a name="line-1089"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inner_wanted</span>
<a name="line-1090"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-1091"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MaybeGivenEqs</span>
<a name="line-1092"></a>                                               <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skol_info</span> <span class='hs-layout'>}</span>
<a name="line-1093"></a>
<a name="line-1094"></a>        <span class='hs-layout'>;</span> <span class='hs-varid'>emitConstraints</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyWC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>outer_simple</span>
<a name="line-1095"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1096"></a>  <span class='hs-keyword'>where</span>
<a name="line-1097"></a>    <span class='hs-varid'>full_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>full_theta_vars</span>
<a name="line-1098"></a>    <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InferSkol</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSigmaTy</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>full_theta</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1099"></a>                          <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>name_taus</span> <span class='hs-keyglyph'>]</span>
<a name="line-1100"></a>    <span class='hs-comment'>-- We don't add the quantified variables here, because they are</span>
<a name="line-1101"></a>    <span class='hs-comment'>-- also bound in ic_skols and we want them to be tidied</span>
<a name="line-1102"></a>    <span class='hs-comment'>-- uniformly.</span>
<a name="line-1103"></a>
<a name="line-1104"></a><a name="ctsPreds"></a><span class='hs-comment'>--------------------</span>
<a name="line-1105"></a><span class='hs-definition'>ctsPreds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>
<a name="line-1106"></a><span class='hs-definition'>ctsPreds</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>cts</span>
<a name="line-1107"></a>                             <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>]</span>
<a name="line-1108"></a>
<a name="line-1109"></a><a name="findInferredDiff"></a><span class='hs-definition'>findInferredDiff</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>TcThetaType</span>
<a name="line-1110"></a><span class='hs-comment'>-- Given a partial type signature f :: (C a, D a, _) =&gt; blah</span>
<a name="line-1111"></a><span class='hs-comment'>-- and the inferred constraints (X a, D a, Y a, C a)</span>
<a name="line-1112"></a><span class='hs-comment'>-- compute the difference, which is what will fill in the "_" underscore,</span>
<a name="line-1113"></a><span class='hs-comment'>-- In this case the diff is (X a, Y a).</span>
<a name="line-1114"></a><span class='hs-definition'>findInferredDiff</span> <span class='hs-varid'>annotated_theta</span> <span class='hs-varid'>inferred_theta</span>
<a name="line-1115"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>annotated_theta</span>   <span class='hs-comment'>-- Short cut the common case when the user didn't</span>
<a name="line-1116"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>inferred_theta</span>  <span class='hs-comment'>-- write any constraints in the partial signature</span>
<a name="line-1117"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1118"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pushTcLevelM_</span> <span class='hs-varop'>$</span>
<a name="line-1119"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lcl_env</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.getLclEnv</span>
<a name="line-1120"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>given_ids</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM.newEvVar</span> <span class='hs-varid'>annotated_theta</span>
<a name="line-1121"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanteds</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWanteds</span> <span class='hs-conid'>AnnOrigin</span> <span class='hs-varid'>inferred_theta</span>
<a name="line-1122"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>given_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivenLoc</span> <span class='hs-varid'>topTcLevel</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-varid'>lcl_env</span>
<a name="line-1123"></a>             <span class='hs-varid'>given_cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivens</span> <span class='hs-varid'>given_loc</span> <span class='hs-varid'>given_ids</span>
<a name="line-1124"></a>
<a name="line-1125"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSDeriveds</span> <span class='hs-varop'>$</span>
<a name="line-1126"></a>                     <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-varid'>given_cts</span>
<a name="line-1127"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>solveSimpleWanteds</span> <span class='hs-layout'>(</span><span class='hs-varid'>listToBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1128"></a>         <span class='hs-comment'>-- NB: There are no meta tyvars fromn this level annotated_theta</span>
<a name="line-1129"></a>         <span class='hs-comment'>-- because we have either promoted them or unified them</span>
<a name="line-1130"></a>         <span class='hs-comment'>-- See `Note [Quantification and partial signatures]` Wrinkle 2</span>
<a name="line-1131"></a>
<a name="line-1132"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>box_pred</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ctPred</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1133"></a>                 <span class='hs-varid'>bagToList</span>               <span class='hs-varop'>$</span>
<a name="line-1134"></a>                 <span class='hs-varid'>wc_simple</span> <span class='hs-varid'>residual</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1135"></a>  <span class='hs-keyword'>where</span>
<a name="line-1136"></a>     <span class='hs-varid'>box_pred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span>
<a name="line-1137"></a>     <span class='hs-varid'>box_pred</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-1138"></a>                        <span class='hs-conid'>EqPred</span> <span class='hs-varid'>rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1139"></a>                          <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>boxEqPred</span> <span class='hs-varid'>rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1140"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-1141"></a>                          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1142"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"findInferredDiff"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-1143"></a>                        <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pred</span>
<a name="line-1144"></a>
<a name="line-1145"></a><span class='hs-comment'>{- Note [Emitting the residual implication in simplifyInfer]
<a name="line-1146"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1147"></a>Consider
<a name="line-1148"></a>   f = e
<a name="line-1149"></a>where f's type is inferred to be something like (a, Proxy k (Int |&gt; co))
<a name="line-1150"></a>and we have an as-yet-unsolved, or perhaps insoluble, constraint
<a name="line-1151"></a>   [W] co :: Type ~ k
<a name="line-1152"></a>We can't form types like (forall co. blah), so we can't generalise over
<a name="line-1153"></a>the coercion variable, and hence we can't generalise over things free in
<a name="line-1154"></a>its kind, in the case 'k'.  But we can still generalise over 'a'.  So
<a name="line-1155"></a>we'll generalise to
<a name="line-1156"></a>   f :: forall a. (a, Proxy k (Int |&gt; co))
<a name="line-1157"></a>Now we do NOT want to form the residual implication constraint
<a name="line-1158"></a>   forall a. [W] co :: Type ~ k
<a name="line-1159"></a>because then co's eventual binding (which will be a value binding if we
<a name="line-1160"></a>use -fdefer-type-errors) won't scope over the entire binding for 'f' (whose
<a name="line-1161"></a>type mentions 'co').  Instead, just as we don't generalise over 'co', we
<a name="line-1162"></a>should not bury its constraint inside the implication.  Instead, we must
<a name="line-1163"></a>put it outside.
<a name="line-1164"></a>
<a name="line-1165"></a>That is the reason for the partitionBag in emitResidualConstraints,
<a name="line-1166"></a>which takes the CoVars free in the inferred type, and pulls their
<a name="line-1167"></a>constraints out.  (NB: this set of CoVars should be closed-over-kinds.)
<a name="line-1168"></a>
<a name="line-1169"></a>All rather subtle; see #14584.
<a name="line-1170"></a>
<a name="line-1171"></a>Note [Add signature contexts as wanteds]
<a name="line-1172"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1173"></a>Consider this (#11016):
<a name="line-1174"></a>  f2 :: (?x :: Int) =&gt; _
<a name="line-1175"></a>  f2 = ?x
<a name="line-1176"></a>
<a name="line-1177"></a>or this
<a name="line-1178"></a>  class C a b | a -&gt; b
<a name="line-1179"></a>  g :: C p q =&gt; p -&gt; q
<a name="line-1180"></a>  f3 :: C Int b =&gt; _
<a name="line-1181"></a>  f3 = g (3::Int)
<a name="line-1182"></a>
<a name="line-1183"></a>We'll use plan InferGen because there are holes in the type.  But:
<a name="line-1184"></a> * For f2 we want to have the (?x :: Int) constraint floating around
<a name="line-1185"></a>   so that the functional dependencies kick in.  Otherwise the
<a name="line-1186"></a>   occurrence of ?x on the RHS produces constraint (?x :: alpha), and
<a name="line-1187"></a>   we won't unify alpha:=Int.
<a name="line-1188"></a>
<a name="line-1189"></a> * For f3 want the (C Int b) constraint from the partial signature
<a name="line-1190"></a>   to meet the (C Int beta) constraint we get from the call to g; again,
<a name="line-1191"></a>   fundeps
<a name="line-1192"></a>
<a name="line-1193"></a>Solution: in simplifyInfer, we add the constraints from the signature
<a name="line-1194"></a>as extra Wanteds.
<a name="line-1195"></a>
<a name="line-1196"></a>Why Wanteds?  Wouldn't it be neater to treat them as Givens?  Alas
<a name="line-1197"></a>that would mess up (GivenInv) in Note [TcLevel invariants].  Consider
<a name="line-1198"></a>    f :: (Eq a, _) =&gt; blah1
<a name="line-1199"></a>    f = ....g...
<a name="line-1200"></a>    g :: (Eq b, _) =&gt; blah2
<a name="line-1201"></a>    g = ...f...
<a name="line-1202"></a>
<a name="line-1203"></a>Then we have two psig_theta constraints (Eq a[tv], Eq b[tv]), both with
<a name="line-1204"></a>TyVarTvs inside.  Ultimately a[tv] := b[tv], but only when we've solved
<a name="line-1205"></a>all those constraints.  And both have level 1, so we can't put them as
<a name="line-1206"></a>Givens when solving at level 1.
<a name="line-1207"></a>
<a name="line-1208"></a>Best to treat them as Wanteds.
<a name="line-1209"></a>
<a name="line-1210"></a>But see also #20076, which would be solved if they were Givens.
<a name="line-1211"></a>
<a name="line-1212"></a>
<a name="line-1213"></a>************************************************************************
<a name="line-1214"></a>*                                                                      *
<a name="line-1215"></a>                Quantification
<a name="line-1216"></a>*                                                                      *
<a name="line-1217"></a>************************************************************************
<a name="line-1218"></a>
<a name="line-1219"></a>Note [Deciding quantification]
<a name="line-1220"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1221"></a>If the monomorphism restriction does not apply, then we quantify as follows:
<a name="line-1222"></a>
<a name="line-1223"></a>* Step 1. Take the global tyvars, and "grow" them using the equality
<a name="line-1224"></a>  constraints
<a name="line-1225"></a>     E.g.  if x:alpha is in the environment, and alpha ~ [beta] (which can
<a name="line-1226"></a>          happen because alpha is untouchable here) then do not quantify over
<a name="line-1227"></a>          beta, because alpha fixes beta, and beta is effectively free in
<a name="line-1228"></a>          the environment too
<a name="line-1229"></a>
<a name="line-1230"></a>  We also account for the monomorphism restriction; if it applies,
<a name="line-1231"></a>  add the free vars of all the constraints.
<a name="line-1232"></a>
<a name="line-1233"></a>  Result is mono_tvs; we will not quantify over these.
<a name="line-1234"></a>
<a name="line-1235"></a>* Step 2. Default any non-mono tyvars (i.e ones that are definitely
<a name="line-1236"></a>  not going to become further constrained), and re-simplify the
<a name="line-1237"></a>  candidate constraints.
<a name="line-1238"></a>
<a name="line-1239"></a>  Motivation for re-simplification (#7857): imagine we have a
<a name="line-1240"></a>  constraint (C (a-&gt;b)), where 'a :: TYPE l1' and 'b :: TYPE l2' are
<a name="line-1241"></a>  not free in the envt, and instance forall (a::*) (b::*). (C a) =&gt; C
<a name="line-1242"></a>  (a -&gt; b) The instance doesn't match while l1,l2 are polymorphic, but
<a name="line-1243"></a>  it will match when we default them to LiftedRep.
<a name="line-1244"></a>
<a name="line-1245"></a>  This is all very tiresome.
<a name="line-1246"></a>
<a name="line-1247"></a>* Step 3: decide which variables to quantify over, as follows:
<a name="line-1248"></a>
<a name="line-1249"></a>  - Take the free vars of the tau-type (zonked_tau_tvs) and "grow"
<a name="line-1250"></a>    them using all the constraints.  These are tau_tvs_plus
<a name="line-1251"></a>
<a name="line-1252"></a>  - Use quantifyTyVars to quantify over (tau_tvs_plus - mono_tvs), being
<a name="line-1253"></a>    careful to close over kinds, and to skolemise the quantified tyvars.
<a name="line-1254"></a>    (This actually unifies each quantifies meta-tyvar with a fresh skolem.)
<a name="line-1255"></a>
<a name="line-1256"></a>  Result is qtvs.
<a name="line-1257"></a>
<a name="line-1258"></a>* Step 4: Filter the constraints using pickQuantifiablePreds and the
<a name="line-1259"></a>  qtvs. We have to zonk the constraints first, so they "see" the
<a name="line-1260"></a>  freshly created skolems.
<a name="line-1261"></a>
<a name="line-1262"></a>-}</span>
<a name="line-1263"></a>
<a name="line-1264"></a><a name="decideQuantification"></a><span class='hs-definition'>decideQuantification</span>
<a name="line-1265"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InferMode</span>
<a name="line-1266"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcLevel</span>
<a name="line-1267"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Variables to be generalised</span>
<a name="line-1268"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcIdSigInst</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- Partial type signatures (if any)</span>
<a name="line-1269"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- Candidate theta; already zonked</span>
<a name="line-1270"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Quantify over these (skolems)</span>
<a name="line-1271"></a>         <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- and this context (fully zonked)</span>
<a name="line-1272"></a>         <span class='hs-layout'>,</span> <span class='hs-conid'>VarSet</span><span class='hs-layout'>)</span>
<a name="line-1273"></a><span class='hs-comment'>-- See Note [Deciding quantification]</span>
<a name="line-1274"></a><span class='hs-definition'>decideQuantification</span> <span class='hs-varid'>infer_mode</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>psigs</span> <span class='hs-varid'>candidates</span>
<a name="line-1275"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Step 1: find the mono_tvs</span>
<a name="line-1276"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>mono_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>candidates</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_vars</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decideMonoTyVars</span> <span class='hs-varid'>infer_mode</span>
<a name="line-1277"></a>                                              <span class='hs-varid'>name_taus</span> <span class='hs-varid'>psigs</span> <span class='hs-varid'>candidates</span>
<a name="line-1278"></a>
<a name="line-1279"></a>       <span class='hs-comment'>-- Step 2: default any non-mono tyvars, and re-simplify</span>
<a name="line-1280"></a>       <span class='hs-comment'>-- This step may do some unification, but result candidates is zonked</span>
<a name="line-1281"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>candidates</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>defaultTyVarsAndSimplify</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>mono_tvs</span> <span class='hs-varid'>candidates</span>
<a name="line-1282"></a>
<a name="line-1283"></a>       <span class='hs-comment'>-- Step 3: decide which kind/type variables to quantify over</span>
<a name="line-1284"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decideQuantifiedTyVars</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>psigs</span> <span class='hs-varid'>candidates</span>
<a name="line-1285"></a>
<a name="line-1286"></a>       <span class='hs-comment'>-- Step 4: choose which of the remaining candidate</span>
<a name="line-1287"></a>       <span class='hs-comment'>--         predicates to actually quantify over</span>
<a name="line-1288"></a>       <span class='hs-comment'>-- NB: decideQuantifiedTyVars turned some meta tyvars</span>
<a name="line-1289"></a>       <span class='hs-comment'>-- into quantified skolems, so we have to zonk again</span>
<a name="line-1290"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>candidates</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.zonkTcTypes</span> <span class='hs-varid'>candidates</span>
<a name="line-1291"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>psig_theta</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.zonkTcTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>concatMap</span> <span class='hs-varid'>sig_inst_theta</span> <span class='hs-varid'>psigs</span><span class='hs-layout'>)</span>
<a name="line-1292"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>min_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varid'>id</span> <span class='hs-varop'>$</span>  <span class='hs-comment'>-- See Note [Minimize by Superclasses]</span>
<a name="line-1293"></a>                         <span class='hs-varid'>pickQuantifiablePreds</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>candidates</span>
<a name="line-1294"></a>
<a name="line-1295"></a>             <span class='hs-varid'>min_psig_theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varid'>id</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1296"></a>
<a name="line-1297"></a>       <span class='hs-comment'>-- Add psig_theta back in here, even though it's already</span>
<a name="line-1298"></a>       <span class='hs-comment'>-- part of candidates, because we always want to quantify over</span>
<a name="line-1299"></a>       <span class='hs-comment'>-- psig_theta, and pickQuantifiableCandidates might have</span>
<a name="line-1300"></a>       <span class='hs-comment'>-- dropped some e.g. CallStack constraints.  c.f #14658</span>
<a name="line-1301"></a>       <span class='hs-comment'>--                   equalities (a ~ Bool)</span>
<a name="line-1302"></a>       <span class='hs-comment'>-- It's helpful to use the same "find difference" algorithm here as</span>
<a name="line-1303"></a>       <span class='hs-comment'>-- we use in GHC.Tc.Gen.Bind.chooseInferredQuantifiers (#20921)</span>
<a name="line-1304"></a>       <span class='hs-comment'>-- See Note [Constraints in partial type signatures]</span>
<a name="line-1305"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>theta</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1306"></a>                  <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>min_theta</span>  <span class='hs-comment'>-- Fast path for the non-partial-sig case</span>
<a name="line-1307"></a>                  <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>diff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>findInferredDiff</span> <span class='hs-varid'>min_psig_theta</span> <span class='hs-varid'>min_theta</span>
<a name="line-1308"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>min_psig_theta</span> <span class='hs-varop'>++</span> <span class='hs-varid'>diff</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1309"></a>
<a name="line-1310"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"decideQuantification"</span>
<a name="line-1311"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"infer_mode:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>infer_mode</span>
<a name="line-1312"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"candidates:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>candidates</span>
<a name="line-1313"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"psig_theta:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1314"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mono_tvs:"</span>   <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mono_tvs</span>
<a name="line-1315"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"co_vars:"</span>    <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co_vars</span>
<a name="line-1316"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"qtvs:"</span>       <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span>
<a name="line-1317"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"theta:"</span>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1318"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_vars</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1319"></a>
<a name="line-1320"></a><span class='hs-comment'>{- Note [Constraints in partial type signatures]
<a name="line-1321"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1322"></a>Suppose we have a partial type signature
<a name="line-1323"></a>    f :: (Eq a, C a, _) =&gt; blah
<a name="line-1324"></a>
<a name="line-1325"></a>We will ultimately quantify f over (Eq a, C a, &lt;diff&gt;), where
<a name="line-1326"></a>
<a name="line-1327"></a>   * &lt;diff&gt; is the result of
<a name="line-1328"></a>         findInferredDiff (Eq a, C a) &lt;quant-theta&gt;
<a name="line-1329"></a>     in GHC.Tc.Gen.Bind.chooseInferredQuantifiers
<a name="line-1330"></a>
<a name="line-1331"></a>   * &lt;quant-theta&gt; is the theta returned right here,
<a name="line-1332"></a>     by decideQuantification
<a name="line-1333"></a>
<a name="line-1334"></a>At least for single functions we would like to quantify f over
<a name="line-1335"></a>precisely the same theta as &lt;quant-theta&gt;, so that we get to take
<a name="line-1336"></a>the short-cut path in GHC.Tc.Gen.Bind.mkExport, and avoid calling
<a name="line-1337"></a>tcSubTypeSigma for impedence matching. Why avoid?  Because it falls
<a name="line-1338"></a>over for ambiguous types (#20921).
<a name="line-1339"></a>
<a name="line-1340"></a>We can get precisely the same theta by using the same algorithm,
<a name="line-1341"></a>findInferredDiff.
<a name="line-1342"></a>
<a name="line-1343"></a>All of this goes wrong if we have (a) mutual recursion, (b) mutiple
<a name="line-1344"></a>partial type signatures, (c) with different constraints, and (d)
<a name="line-1345"></a>ambiguous types.  Something like
<a name="line-1346"></a>    f :: forall a. Eq a =&gt; F a -&gt; _
<a name="line-1347"></a>    f x = (undefined :: a) == g x undefined
<a name="line-1348"></a>    g :: forall b. Show b =&gt; F b -&gt; _ -&gt; b
<a name="line-1349"></a>    g x y = let _ = (f y, show x) in x
<a name="line-1350"></a>But that's a battle for another day.
<a name="line-1351"></a>-}</span>
<a name="line-1352"></a>
<a name="line-1353"></a><a name="decideMonoTyVars"></a><span class='hs-definition'>decideMonoTyVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InferMode</span>
<a name="line-1354"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span><span class='hs-conid'>TcType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1355"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcIdSigInst</span><span class='hs-keyglyph'>]</span>
<a name="line-1356"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>
<a name="line-1357"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcTyCoVarSet</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoVarSet</span><span class='hs-layout'>)</span>
<a name="line-1358"></a><span class='hs-comment'>-- Decide which tyvars and covars cannot be generalised:</span>
<a name="line-1359"></a><span class='hs-comment'>--   (a) Free in the environment</span>
<a name="line-1360"></a><span class='hs-comment'>--   (b) Mentioned in a constraint we can't generalise</span>
<a name="line-1361"></a><span class='hs-comment'>--   (c) Connected by an equality to (a) or (b)</span>
<a name="line-1362"></a><span class='hs-comment'>-- Also return CoVars that appear free in the final quantified types</span>
<a name="line-1363"></a><span class='hs-comment'>--   we can't quantify over these, and we must make sure they are in scope</span>
<a name="line-1364"></a><span class='hs-definition'>decideMonoTyVars</span> <span class='hs-varid'>infer_mode</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>psigs</span> <span class='hs-varid'>candidates</span>
<a name="line-1365"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_quant</span><span class='hs-layout'>,</span> <span class='hs-varid'>maybe_quant</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pick</span> <span class='hs-varid'>infer_mode</span> <span class='hs-varid'>candidates</span>
<a name="line-1366"></a>
<a name="line-1367"></a>       <span class='hs-comment'>-- If possible, we quantify over partial-sig qtvs, so they are</span>
<a name="line-1368"></a>       <span class='hs-comment'>-- not mono. Need to zonk them because they are meta-tyvar TyVarTvs</span>
<a name="line-1369"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>psig_qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>zonkTcTyVarToTyVar</span> <span class='hs-varop'>$</span> <span class='hs-varid'>binderVars</span> <span class='hs-varop'>$</span>
<a name="line-1370"></a>                      <span class='hs-varid'>concatMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>.</span> <span class='hs-varid'>sig_inst_skols</span><span class='hs-layout'>)</span> <span class='hs-varid'>psigs</span>
<a name="line-1371"></a>
<a name="line-1372"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>psig_theta</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM.zonkTcType</span> <span class='hs-varop'>$</span>
<a name="line-1373"></a>                       <span class='hs-varid'>concatMap</span> <span class='hs-varid'>sig_inst_theta</span> <span class='hs-varid'>psigs</span>
<a name="line-1374"></a>
<a name="line-1375"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>taus</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcM.zonkTcType</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-varid'>name_taus</span>
<a name="line-1376"></a>
<a name="line-1377"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tc_lvl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.getTcLevel</span>
<a name="line-1378"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>psig_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTys</span> <span class='hs-varid'>psig_qtvs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1379"></a>
<a name="line-1380"></a>             <span class='hs-varid'>co_vars</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>psig_tys</span> <span class='hs-varop'>++</span> <span class='hs-varid'>taus</span><span class='hs-layout'>)</span>
<a name="line-1381"></a>             <span class='hs-varid'>co_var_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>closeOverKinds</span> <span class='hs-varid'>co_vars</span>
<a name="line-1382"></a>               <span class='hs-comment'>-- The co_var_tvs are tvs mentioned in the types of covars or</span>
<a name="line-1383"></a>               <span class='hs-comment'>-- coercion holes. We can't quantify over these covars, so we</span>
<a name="line-1384"></a>               <span class='hs-comment'>-- must include the variable in their types in the mono_tvs.</span>
<a name="line-1385"></a>               <span class='hs-comment'>-- E.g.  If we can't quantify over co :: k~Type, then we can't</span>
<a name="line-1386"></a>               <span class='hs-comment'>--       quantify over k either!  Hence closeOverKinds</span>
<a name="line-1387"></a>
<a name="line-1388"></a>             <span class='hs-varid'>mono_tvs0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isQuantifiableTv</span> <span class='hs-varid'>tc_lvl</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1389"></a>                         <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>candidates</span>
<a name="line-1390"></a>               <span class='hs-comment'>-- We need to grab all the non-quantifiable tyvars in the</span>
<a name="line-1391"></a>               <span class='hs-comment'>-- candidates so that we can grow this set to find other</span>
<a name="line-1392"></a>               <span class='hs-comment'>-- non-quantifiable tyvars. This can happen with something</span>
<a name="line-1393"></a>               <span class='hs-comment'>-- like</span>
<a name="line-1394"></a>               <span class='hs-comment'>--    f x y = ...</span>
<a name="line-1395"></a>               <span class='hs-comment'>--      where z = x 3</span>
<a name="line-1396"></a>               <span class='hs-comment'>-- The body of z tries to unify the type of x (call it alpha[1])</span>
<a name="line-1397"></a>               <span class='hs-comment'>-- with (beta[2] -&gt; gamma[2]). This unification fails because</span>
<a name="line-1398"></a>               <span class='hs-comment'>-- alpha is untouchable. But we need to know not to quantify over</span>
<a name="line-1399"></a>               <span class='hs-comment'>-- beta or gamma, because they are in the equality constraint with</span>
<a name="line-1400"></a>               <span class='hs-comment'>-- alpha. Actual test case: typecheck/should_compile/tc213</span>
<a name="line-1401"></a>
<a name="line-1402"></a>             <span class='hs-varid'>mono_tvs1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mono_tvs0</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>co_var_tvs</span>
<a name="line-1403"></a>
<a name="line-1404"></a>             <span class='hs-varid'>eq_constraints</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isEqPrimPred</span> <span class='hs-varid'>candidates</span>
<a name="line-1405"></a>             <span class='hs-varid'>mono_tvs2</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-varid'>eq_constraints</span> <span class='hs-varid'>mono_tvs1</span>
<a name="line-1406"></a>
<a name="line-1407"></a>             <span class='hs-varid'>constrained_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>isQuantifiableTv</span> <span class='hs-varid'>tc_lvl</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1408"></a>                               <span class='hs-layout'>(</span><span class='hs-varid'>growThetaTyVars</span> <span class='hs-varid'>eq_constraints</span>
<a name="line-1409"></a>                                               <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>no_quant</span><span class='hs-layout'>)</span>
<a name="line-1410"></a>                                <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>mono_tvs2</span><span class='hs-layout'>)</span>
<a name="line-1411"></a>                               <span class='hs-varop'>`delVarSetList`</span> <span class='hs-varid'>psig_qtvs</span>
<a name="line-1412"></a>             <span class='hs-comment'>-- constrained_tvs: the tyvars that we are not going to</span>
<a name="line-1413"></a>             <span class='hs-comment'>-- quantify solely because of the monomorphism restriction</span>
<a name="line-1414"></a>             <span class='hs-comment'>--</span>
<a name="line-1415"></a>             <span class='hs-comment'>-- (`minusVarSet` mono_tvs2`): a type variable is only</span>
<a name="line-1416"></a>             <span class='hs-comment'>--   "constrained" (so that the MR bites) if it is not</span>
<a name="line-1417"></a>             <span class='hs-comment'>--   free in the environment (#13785)</span>
<a name="line-1418"></a>             <span class='hs-comment'>--</span>
<a name="line-1419"></a>             <span class='hs-comment'>-- (`delVarSetList` psig_qtvs): if the user has explicitly</span>
<a name="line-1420"></a>             <span class='hs-comment'>--   asked for quantification, then that request "wins"</span>
<a name="line-1421"></a>             <span class='hs-comment'>--   over the MR.  Note: do /not/ delete psig_qtvs from</span>
<a name="line-1422"></a>             <span class='hs-comment'>--   mono_tvs1, because mono_tvs1 cannot under any circumstances</span>
<a name="line-1423"></a>             <span class='hs-comment'>--   be quantified (#14479); see</span>
<a name="line-1424"></a>             <span class='hs-comment'>--   Note [Quantification and partial signatures], Wrinkle 3, 4</span>
<a name="line-1425"></a>
<a name="line-1426"></a>             <span class='hs-varid'>mono_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mono_tvs2</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>constrained_tvs</span>
<a name="line-1427"></a>
<a name="line-1428"></a>           <span class='hs-comment'>-- Warn about the monomorphism restriction</span>
<a name="line-1429"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>warn_mono</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>woptM</span> <span class='hs-conid'>Opt_WarnMonomorphism</span>
<a name="line-1430"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-keyword'>case</span> <span class='hs-varid'>infer_mode</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>ApplyMR</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>warn_mono</span><span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1431"></a>         <span class='hs-varid'>warnTc</span> <span class='hs-layout'>(</span><span class='hs-conid'>Reason</span> <span class='hs-conid'>Opt_WarnMonomorphism</span><span class='hs-layout'>)</span>
<a name="line-1432"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>constrained_tvs</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>taus</span><span class='hs-layout'>)</span>
<a name="line-1433"></a>                <span class='hs-varid'>mr_msg</span>
<a name="line-1434"></a>
<a name="line-1435"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"decideMonoTyVars"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-1436"></a>           <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"infer_mode ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>infer_mode</span>
<a name="line-1437"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mono_tvs0 ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mono_tvs0</span>
<a name="line-1438"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"no_quant ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>no_quant</span>
<a name="line-1439"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"maybe_quant ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>maybe_quant</span>
<a name="line-1440"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"eq_constraints ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eq_constraints</span>
<a name="line-1441"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"mono_tvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mono_tvs</span>
<a name="line-1442"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"co_vars ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co_vars</span> <span class='hs-keyglyph'>]</span>
<a name="line-1443"></a>
<a name="line-1444"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mono_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>maybe_quant</span><span class='hs-layout'>,</span> <span class='hs-varid'>co_vars</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1445"></a>  <span class='hs-keyword'>where</span>
<a name="line-1446"></a>    <span class='hs-varid'>pick</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>InferMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1447"></a>    <span class='hs-comment'>-- Split the candidates into ones we definitely</span>
<a name="line-1448"></a>    <span class='hs-comment'>-- won't quantify, and ones that we might</span>
<a name="line-1449"></a>    <span class='hs-varid'>pick</span> <span class='hs-conid'>NoRestrictions</span>  <span class='hs-varid'>cand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>cand</span><span class='hs-layout'>)</span>
<a name="line-1450"></a>    <span class='hs-varid'>pick</span> <span class='hs-conid'>ApplyMR</span>         <span class='hs-varid'>cand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>cand</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1451"></a>    <span class='hs-varid'>pick</span> <span class='hs-conid'>EagerDefaulting</span> <span class='hs-varid'>cand</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>os</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.OverloadedStrings</span>
<a name="line-1452"></a>                                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>partition</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_int_ct</span> <span class='hs-varid'>os</span><span class='hs-layout'>)</span> <span class='hs-varid'>cand</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1453"></a>
<a name="line-1454"></a>    <span class='hs-comment'>-- For EagerDefaulting, do not quantify over</span>
<a name="line-1455"></a>    <span class='hs-comment'>-- over any interactive class constraint</span>
<a name="line-1456"></a>    <span class='hs-varid'>is_int_ct</span> <span class='hs-varid'>ovl_strings</span> <span class='hs-varid'>pred</span>
<a name="line-1457"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-varid'>pred</span>
<a name="line-1458"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>ovl_strings</span> <span class='hs-varid'>cls</span>
<a name="line-1459"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1460"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1461"></a>
<a name="line-1462"></a>    <span class='hs-varid'>pp_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprWithCommas</span> <span class='hs-layout'>(</span><span class='hs-varid'>quotes</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>name_taus</span>
<a name="line-1463"></a>    <span class='hs-varid'>mr_msg</span> <span class='hs-keyglyph'>=</span>
<a name="line-1464"></a>         <span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"The Monomorphism Restriction applies to the binding"</span>
<a name="line-1465"></a>                     <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>plural</span> <span class='hs-varid'>name_taus</span>
<a name="line-1466"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"for"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pp_bndrs</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1467"></a>            <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Consider giving"</span>
<a name="line-1468"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>isSingleton</span> <span class='hs-varid'>name_taus</span> <span class='hs-keyword'>then</span> <span class='hs-str'>"it"</span> <span class='hs-keyword'>else</span> <span class='hs-str'>"them"</span><span class='hs-layout'>)</span>
<a name="line-1469"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"a type signature"</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1470"></a>
<a name="line-1471"></a><a name="defaultTyVarsAndSimplify"></a><span class='hs-comment'>-------------------</span>
<a name="line-1472"></a><span class='hs-definition'>defaultTyVarsAndSimplify</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span>
<a name="line-1473"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCoVarSet</span>
<a name="line-1474"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- Assumed zonked</span>
<a name="line-1475"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- Guaranteed zonked</span>
<a name="line-1476"></a><span class='hs-comment'>-- Default any tyvar free in the constraints,</span>
<a name="line-1477"></a><span class='hs-comment'>-- and re-simplify in case the defaulting allows further simplification</span>
<a name="line-1478"></a><span class='hs-definition'>defaultTyVarsAndSimplify</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>mono_tvs</span> <span class='hs-varid'>candidates</span>
<a name="line-1479"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>  <span class='hs-comment'>-- Promote any tyvars that we cannot generalise</span>
<a name="line-1480"></a>          <span class='hs-comment'>-- See Note [Promote monomorphic tyvars]</span>
<a name="line-1481"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"decideMonoTyVars: promotion:"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>mono_tvs</span><span class='hs-layout'>)</span>
<a name="line-1482"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>any_promoted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>promoteTyVarSet</span> <span class='hs-varid'>mono_tvs</span>
<a name="line-1483"></a>
<a name="line-1484"></a>       <span class='hs-comment'>-- Default any kind/levity vars</span>
<a name="line-1485"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>DV</span> <span class='hs-layout'>{</span><span class='hs-varid'>dv_kvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cand_kvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>dv_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cand_tvs</span><span class='hs-layout'>}</span>
<a name="line-1486"></a>                <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>candidateQTyVarsOfTypes</span> <span class='hs-varid'>candidates</span>
<a name="line-1487"></a>                <span class='hs-comment'>-- any covars should already be handled by</span>
<a name="line-1488"></a>                <span class='hs-comment'>-- the logic in decideMonoTyVars, which looks at</span>
<a name="line-1489"></a>                <span class='hs-comment'>-- the constraints generated</span>
<a name="line-1490"></a>
<a name="line-1491"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>poly_kinds</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>LangExt.PolyKinds</span>
<a name="line-1492"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>default_kvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_one</span> <span class='hs-varid'>poly_kinds</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-1493"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>dVarSetElems</span> <span class='hs-varid'>cand_kvs</span><span class='hs-layout'>)</span>
<a name="line-1494"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>default_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_one</span> <span class='hs-varid'>poly_kinds</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-1495"></a>                             <span class='hs-layout'>(</span><span class='hs-varid'>dVarSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>cand_tvs</span> <span class='hs-varop'>`minusDVarSet`</span> <span class='hs-varid'>cand_kvs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1496"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>some_default</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>or</span> <span class='hs-varid'>default_kvs</span> <span class='hs-varop'>||</span> <span class='hs-varid'>or</span> <span class='hs-varid'>default_tvs</span>
<a name="line-1497"></a>
<a name="line-1498"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-conid'>()</span> <span class='hs-keyword'>of</span>
<a name="line-1499"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>some_default</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>simplify_cand</span> <span class='hs-varid'>candidates</span>
<a name="line-1500"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>any_promoted</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM.zonkTcType</span> <span class='hs-varid'>candidates</span>
<a name="line-1501"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>candidates</span>
<a name="line-1502"></a>       <span class='hs-layout'>}</span>
<a name="line-1503"></a>  <span class='hs-keyword'>where</span>
<a name="line-1504"></a>    <span class='hs-varid'>default_one</span> <span class='hs-varid'>poly_kinds</span> <span class='hs-varid'>is_kind_var</span> <span class='hs-varid'>tv</span>
<a name="line-1505"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1506"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-1507"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>mono_tvs</span>
<a name="line-1508"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-1509"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1510"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultTyVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>poly_kinds</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>is_kind_var</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv</span>
<a name="line-1511"></a>
<a name="line-1512"></a>    <span class='hs-varid'>simplify_cand</span> <span class='hs-varid'>candidates</span>
<a name="line-1513"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>clone_wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWanteds</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-varid'>candidates</span>
<a name="line-1514"></a>           <span class='hs-layout'>;</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setTcLevel</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varop'>$</span>
<a name="line-1515"></a>                                           <span class='hs-varid'>simplifyWantedsTcM</span> <span class='hs-varid'>clone_wanteds</span>
<a name="line-1516"></a>              <span class='hs-comment'>-- Discard evidence; simples is fully zonked</span>
<a name="line-1517"></a>
<a name="line-1518"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_candidates</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctsPreds</span> <span class='hs-varid'>simples</span>
<a name="line-1519"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"Simplified after defaulting"</span> <span class='hs-varop'>$</span>
<a name="line-1520"></a>                      <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Before:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>candidates</span>
<a name="line-1521"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"After:"</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_candidates</span> <span class='hs-keyglyph'>]</span>
<a name="line-1522"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>new_candidates</span> <span class='hs-layout'>}</span>
<a name="line-1523"></a>
<a name="line-1524"></a><a name="decideQuantifiedTyVars"></a><span class='hs-comment'>------------------</span>
<a name="line-1525"></a><span class='hs-definition'>decideQuantifiedTyVars</span>
<a name="line-1526"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span><span class='hs-conid'>TcType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Annotated theta and (name,tau) pairs</span>
<a name="line-1527"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcIdSigInst</span><span class='hs-keyglyph'>]</span>     <span class='hs-comment'>-- Partial signatures</span>
<a name="line-1528"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- Candidates, zonked</span>
<a name="line-1529"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span>
<a name="line-1530"></a><span class='hs-comment'>-- Fix what tyvars we are going to quantify over, and quantify them</span>
<a name="line-1531"></a><span class='hs-definition'>decideQuantifiedTyVars</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>psigs</span> <span class='hs-varid'>candidates</span>
<a name="line-1532"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>     <span class='hs-comment'>-- Why psig_tys? We try to quantify over everything free in here</span>
<a name="line-1533"></a>             <span class='hs-comment'>-- See Note [Quantification and partial signatures]</span>
<a name="line-1534"></a>             <span class='hs-comment'>--     Wrinkles 2 and 3</span>
<a name="line-1535"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>psig_tv_tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM.zonkTcTyVar</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>psigs</span>
<a name="line-1536"></a>                                                  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sig_inst_skols</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>]</span>
<a name="line-1537"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>psig_theta</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM.zonkTcType</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>psigs</span>
<a name="line-1538"></a>                                                  <span class='hs-layout'>,</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>sig_inst_theta</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>]</span>
<a name="line-1539"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tau_tys</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcM.zonkTcType</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-varid'>name_taus</span>
<a name="line-1540"></a>
<a name="line-1541"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-comment'>-- Try to quantify over variables free in these types</span>
<a name="line-1542"></a>             <span class='hs-varid'>psig_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>psig_tv_tys</span> <span class='hs-varop'>++</span> <span class='hs-varid'>psig_theta</span>
<a name="line-1543"></a>             <span class='hs-varid'>seed_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>psig_tys</span> <span class='hs-varop'>++</span> <span class='hs-varid'>tau_tys</span>
<a name="line-1544"></a>
<a name="line-1545"></a>             <span class='hs-comment'>-- Now "grow" those seeds to find ones reachable via 'candidates'</span>
<a name="line-1546"></a>             <span class='hs-varid'>grown_tcvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-varid'>candidates</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>seed_tys</span><span class='hs-layout'>)</span>
<a name="line-1547"></a>
<a name="line-1548"></a>       <span class='hs-comment'>-- Now we have to classify them into kind variables and type variables</span>
<a name="line-1549"></a>       <span class='hs-comment'>-- (sigh) just for the benefit of -XNoPolyKinds; see quantifyTyVars</span>
<a name="line-1550"></a>       <span class='hs-comment'>--</span>
<a name="line-1551"></a>       <span class='hs-comment'>-- Keep the psig_tys first, so that candidateQTyVarsOfTypes produces</span>
<a name="line-1552"></a>       <span class='hs-comment'>-- them in that order, so that the final qtvs quantifies in the same</span>
<a name="line-1553"></a>       <span class='hs-comment'>-- order as the partial signatures do (#13524)</span>
<a name="line-1554"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dv</span><span class='hs-keyglyph'>@</span><span class='hs-conid'>DV</span> <span class='hs-layout'>{</span><span class='hs-varid'>dv_kvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cand_kvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>dv_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cand_tvs</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>candidateQTyVarsOfTypes</span> <span class='hs-varop'>$</span>
<a name="line-1555"></a>                                                         <span class='hs-varid'>psig_tys</span> <span class='hs-varop'>++</span> <span class='hs-varid'>candidates</span> <span class='hs-varop'>++</span> <span class='hs-varid'>tau_tys</span>
<a name="line-1556"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pick</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>`dVarSetIntersectVarSet`</span> <span class='hs-varid'>grown_tcvs</span><span class='hs-layout'>)</span>
<a name="line-1557"></a>             <span class='hs-varid'>dvs_plus</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dv_kvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pick</span> <span class='hs-varid'>cand_kvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>dv_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pick</span> <span class='hs-varid'>cand_tvs</span> <span class='hs-layout'>}</span>
<a name="line-1558"></a>
<a name="line-1559"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"decideQuantifiedTyVars"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-1560"></a>           <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"tau_tys ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tau_tys</span>
<a name="line-1561"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"candidates ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>candidates</span>
<a name="line-1562"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"cand_kvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cand_kvs</span>
<a name="line-1563"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"cand_tvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cand_tvs</span>
<a name="line-1564"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"tau_tys ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tau_tys</span>
<a name="line-1565"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"seed_tys ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>seed_tys</span>
<a name="line-1566"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"seed_tcvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>seed_tys</span><span class='hs-layout'>)</span>
<a name="line-1567"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"grown_tcvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>grown_tcvs</span>
<a name="line-1568"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"dvs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>dvs_plus</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1569"></a>
<a name="line-1570"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>dvs_plus</span> <span class='hs-layout'>}</span>
<a name="line-1571"></a>
<a name="line-1572"></a><a name="growThetaTyVars"></a><span class='hs-comment'>------------------</span>
<a name="line-1573"></a><span class='hs-definition'>growThetaTyVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCoVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCoVarSet</span>
<a name="line-1574"></a><span class='hs-comment'>-- See Note [Growing the tau-tvs using constraints]</span>
<a name="line-1575"></a><span class='hs-definition'>growThetaTyVars</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tcvs</span>
<a name="line-1576"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcvs</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>transCloVarSet</span> <span class='hs-varid'>mk_next</span> <span class='hs-varid'>seed_tcvs</span>
<a name="line-1578"></a>  <span class='hs-keyword'>where</span>
<a name="line-1579"></a>    <span class='hs-varid'>seed_tcvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>ips</span>
<a name="line-1580"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>ips</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_ips</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partition</span> <span class='hs-varid'>isIPLikePred</span> <span class='hs-varid'>theta</span>
<a name="line-1581"></a>                         <span class='hs-comment'>-- See Note [Inheriting implicit parameters] in GHC.Tc.Utils.TcType</span>
<a name="line-1582"></a>
<a name="line-1583"></a>    <span class='hs-varid'>mk_next</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-comment'>-- Maps current set to newly-grown ones</span>
<a name="line-1584"></a>    <span class='hs-varid'>mk_next</span> <span class='hs-varid'>so_far</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>grow_one</span> <span class='hs-varid'>so_far</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>non_ips</span>
<a name="line-1585"></a>    <span class='hs-varid'>grow_one</span> <span class='hs-varid'>so_far</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tcvs</span>
<a name="line-1586"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pred_tcvs</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>so_far</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>pred_tcvs</span>
<a name="line-1587"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcvs</span>
<a name="line-1588"></a>       <span class='hs-keyword'>where</span>
<a name="line-1589"></a>         <span class='hs-varid'>pred_tcvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfType</span> <span class='hs-varid'>pred</span>
<a name="line-1590"></a>
<a name="line-1591"></a>
<a name="line-1592"></a><span class='hs-comment'>{- Note [Promote monomorphic tyvars]
<a name="line-1593"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1594"></a>Promote any type variables that are free in the environment.  Eg
<a name="line-1595"></a>   f :: forall qtvs. bound_theta =&gt; zonked_tau
<a name="line-1596"></a>The free vars of f's type become free in the envt, and hence will show
<a name="line-1597"></a>up whenever 'f' is called.  They may currently at rhs_tclvl, but they
<a name="line-1598"></a>had better be unifiable at the outer_tclvl!  Example: envt mentions
<a name="line-1599"></a>alpha[1]
<a name="line-1600"></a>           tau_ty = beta[2] -&gt; beta[2]
<a name="line-1601"></a>           constraints = alpha ~ [beta]
<a name="line-1602"></a>we don't quantify over beta (since it is fixed by envt)
<a name="line-1603"></a>so we must promote it!  The inferred type is just
<a name="line-1604"></a>  f :: beta -&gt; beta
<a name="line-1605"></a>
<a name="line-1606"></a>NB: promoteTyVarSet ignores coercion variables
<a name="line-1607"></a>
<a name="line-1608"></a>Note [Quantification and partial signatures]
<a name="line-1609"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1610"></a>When choosing type variables to quantify, the basic plan is to
<a name="line-1611"></a>quantify over all type variables that are
<a name="line-1612"></a> * free in the tau_tvs, and
<a name="line-1613"></a> * not forced to be monomorphic (mono_tvs),
<a name="line-1614"></a>   for example by being free in the environment.
<a name="line-1615"></a>
<a name="line-1616"></a>However, in the case of a partial type signature, be doing inference
<a name="line-1617"></a>*in the presence of a type signature*. For example:
<a name="line-1618"></a>   f :: _ -&gt; a
<a name="line-1619"></a>   f x = ...
<a name="line-1620"></a>or
<a name="line-1621"></a>   g :: (Eq _a) =&gt; _b -&gt; _b
<a name="line-1622"></a>In both cases we use plan InferGen, and hence call simplifyInfer.  But
<a name="line-1623"></a>those 'a' variables are skolems (actually TyVarTvs), and we should be
<a name="line-1624"></a>sure to quantify over them.  This leads to several wrinkles:
<a name="line-1625"></a>
<a name="line-1626"></a>* Wrinkle 1.  In the case of a type error
<a name="line-1627"></a>     f :: _ -&gt; Maybe a
<a name="line-1628"></a>     f x = True &amp;&amp; x
<a name="line-1629"></a>  The inferred type of 'f' is f :: Bool -&gt; Bool, but there's a
<a name="line-1630"></a>  left-over error of form (HoleCan (Maybe a ~ Bool)).  The error-reporting
<a name="line-1631"></a>  machine expects to find a binding site for the skolem 'a', so we
<a name="line-1632"></a>  add it to the quantified tyvars.
<a name="line-1633"></a>
<a name="line-1634"></a>* Wrinkle 2.  Consider the partial type signature
<a name="line-1635"></a>     f :: (Eq _) =&gt; Int -&gt; Int
<a name="line-1636"></a>     f x = x
<a name="line-1637"></a>  In normal cases that makes sense; e.g.
<a name="line-1638"></a>     g :: Eq _a =&gt; _a -&gt; _a
<a name="line-1639"></a>     g x = x
<a name="line-1640"></a>  where the signature makes the type less general than it could
<a name="line-1641"></a>  be. But for 'f' we must therefore quantify over the user-annotated
<a name="line-1642"></a>  constraints, to get
<a name="line-1643"></a>     f :: forall a. Eq a =&gt; Int -&gt; Int
<a name="line-1644"></a>  (thereby correctly triggering an ambiguity error later).  If we don't
<a name="line-1645"></a>  we'll end up with a strange open type
<a name="line-1646"></a>     f :: Eq alpha =&gt; Int -&gt; Int
<a name="line-1647"></a>  which isn't ambiguous but is still very wrong.
<a name="line-1648"></a>
<a name="line-1649"></a>  Bottom line: Try to quantify over any variable free in psig_theta,
<a name="line-1650"></a>  just like the tau-part of the type.
<a name="line-1651"></a>
<a name="line-1652"></a>* Wrinkle 3 (#13482). Also consider
<a name="line-1653"></a>    f :: forall a. _ =&gt; Int -&gt; Int
<a name="line-1654"></a>    f x = if (undefined :: a) == undefined then x else 0
<a name="line-1655"></a>  Here we get an (Eq a) constraint, but it's not mentioned in the
<a name="line-1656"></a>  psig_theta nor the type of 'f'.  But we still want to quantify
<a name="line-1657"></a>  over 'a' even if the monomorphism restriction is on.
<a name="line-1658"></a>
<a name="line-1659"></a>* Wrinkle 4 (#14479)
<a name="line-1660"></a>    foo :: Num a =&gt; a -&gt; a
<a name="line-1661"></a>    foo xxx = g xxx
<a name="line-1662"></a>      where
<a name="line-1663"></a>        g :: forall b. Num b =&gt; _ -&gt; b
<a name="line-1664"></a>        g y = xxx + y
<a name="line-1665"></a>
<a name="line-1666"></a>  In the signature for 'g', we cannot quantify over 'b' because it turns out to
<a name="line-1667"></a>  get unified with 'a', which is free in g's environment.  So we carefully
<a name="line-1668"></a>  refrain from bogusly quantifying, in GHC.Tc.Solver.decideMonoTyVars.  We
<a name="line-1669"></a>  report the error later, in GHC.Tc.Gen.Bind.chooseInferredQuantifiers.
<a name="line-1670"></a>
<a name="line-1671"></a>Note [Growing the tau-tvs using constraints]
<a name="line-1672"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1673"></a>(growThetaTyVars insts tvs) is the result of extending the set
<a name="line-1674"></a>    of tyvars, tvs, using all conceivable links from pred
<a name="line-1675"></a>
<a name="line-1676"></a>E.g. tvs = {a}, preds = {H [a] b, K (b,Int) c, Eq e}
<a name="line-1677"></a>Then growThetaTyVars preds tvs = {a,b,c}
<a name="line-1678"></a>
<a name="line-1679"></a>Notice that
<a name="line-1680"></a>   growThetaTyVars is conservative       if v might be fixed by vs
<a name="line-1681"></a>                                         =&gt; v `elem` grow(vs,C)
<a name="line-1682"></a>
<a name="line-1683"></a>Note [Quantification with errors]
<a name="line-1684"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1685"></a>If we find that the RHS of the definition has some absolutely-insoluble
<a name="line-1686"></a>constraints (including especially "variable not in scope"), we
<a name="line-1687"></a>
<a name="line-1688"></a>* Abandon all attempts to find a context to quantify over,
<a name="line-1689"></a>  and instead make the function fully-polymorphic in whatever
<a name="line-1690"></a>  type we have found
<a name="line-1691"></a>
<a name="line-1692"></a>* Return a flag from simplifyInfer, indicating that we found an
<a name="line-1693"></a>  insoluble constraint.  This flag is used to suppress the ambiguity
<a name="line-1694"></a>  check for the inferred type, which may well be bogus, and which
<a name="line-1695"></a>  tends to obscure the real error.  This fix feels a bit clunky,
<a name="line-1696"></a>  but I failed to come up with anything better.
<a name="line-1697"></a>
<a name="line-1698"></a>Reasons:
<a name="line-1699"></a>    - Avoid downstream errors
<a name="line-1700"></a>    - Do not perform an ambiguity test on a bogus type, which might well
<a name="line-1701"></a>      fail spuriously, thereby obfuscating the original insoluble error.
<a name="line-1702"></a>      #14000 is an example
<a name="line-1703"></a>
<a name="line-1704"></a>I tried an alternative approach: simply failM, after emitting the
<a name="line-1705"></a>residual implication constraint; the exception will be caught in
<a name="line-1706"></a>GHC.Tc.Gen.Bind.tcPolyBinds, which gives all the binders in the group the type
<a name="line-1707"></a>(forall a. a).  But that didn't work with -fdefer-type-errors, because
<a name="line-1708"></a>the recovery from failM emits no code at all, so there is no function
<a name="line-1709"></a>to run!   But -fdefer-type-errors aspires to produce a runnable program.
<a name="line-1710"></a>
<a name="line-1711"></a>NB that we must include *derived* errors in the check for insolubles.
<a name="line-1712"></a>Example:
<a name="line-1713"></a>    (a::*) ~ Int#
<a name="line-1714"></a>We get an insoluble derived error *~#, and we don't want to discard
<a name="line-1715"></a>it before doing the isInsolubleWC test!  (#8262)
<a name="line-1716"></a>
<a name="line-1717"></a>Note [Default while Inferring]
<a name="line-1718"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1719"></a>Our current plan is that defaulting only happens at simplifyTop and
<a name="line-1720"></a>not simplifyInfer.  This may lead to some insoluble deferred constraints.
<a name="line-1721"></a>Example:
<a name="line-1722"></a>
<a name="line-1723"></a>instance D g =&gt; C g Int b
<a name="line-1724"></a>
<a name="line-1725"></a>constraint inferred = (forall b. 0 =&gt; C gamma alpha b) /\ Num alpha
<a name="line-1726"></a>type inferred       = gamma -&gt; gamma
<a name="line-1727"></a>
<a name="line-1728"></a>Now, if we try to default (alpha := Int) we will be able to refine the implication to
<a name="line-1729"></a>  (forall b. 0 =&gt; C gamma Int b)
<a name="line-1730"></a>which can then be simplified further to
<a name="line-1731"></a>  (forall b. 0 =&gt; D gamma)
<a name="line-1732"></a>Finally, we /can/ approximate this implication with (D gamma) and infer the quantified
<a name="line-1733"></a>type:  forall g. D g =&gt; g -&gt; g
<a name="line-1734"></a>
<a name="line-1735"></a>Instead what will currently happen is that we will get a quantified type
<a name="line-1736"></a>(forall g. g -&gt; g) and an implication:
<a name="line-1737"></a>       forall g. 0 =&gt; (forall b. 0 =&gt; C g alpha b) /\ Num alpha
<a name="line-1738"></a>
<a name="line-1739"></a>Which, even if the simplifyTop defaults (alpha := Int) we will still be left with an
<a name="line-1740"></a>unsolvable implication:
<a name="line-1741"></a>       forall g. 0 =&gt; (forall b. 0 =&gt; D g)
<a name="line-1742"></a>
<a name="line-1743"></a>The concrete example would be:
<a name="line-1744"></a>       h :: C g a s =&gt; g -&gt; a -&gt; ST s a
<a name="line-1745"></a>       f (x::gamma) = (\_ -&gt; x) (runST (h x (undefined::alpha)) + 1)
<a name="line-1746"></a>
<a name="line-1747"></a>But it is quite tedious to do defaulting and resolve the implication constraints, and
<a name="line-1748"></a>we have not observed code breaking because of the lack of defaulting in inference, so
<a name="line-1749"></a>we don't do it for now.
<a name="line-1750"></a>
<a name="line-1751"></a>
<a name="line-1752"></a>
<a name="line-1753"></a>Note [Minimize by Superclasses]
<a name="line-1754"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1755"></a>When we quantify over a constraint, in simplifyInfer we need to
<a name="line-1756"></a>quantify over a constraint that is minimal in some sense: For
<a name="line-1757"></a>instance, if the final wanted constraint is (Eq alpha, Ord alpha),
<a name="line-1758"></a>we'd like to quantify over Ord alpha, because we can just get Eq alpha
<a name="line-1759"></a>from superclass selection from Ord alpha. This minimization is what
<a name="line-1760"></a>mkMinimalBySCs does. Then, simplifyInfer uses the minimal constraint
<a name="line-1761"></a>to check the original wanted.
<a name="line-1762"></a>
<a name="line-1763"></a>
<a name="line-1764"></a>Note [Avoid unnecessary constraint simplification]
<a name="line-1765"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1766"></a>    -------- NB NB NB (Jun 12) -------------
<a name="line-1767"></a>    This note not longer applies; see the notes with #4361.
<a name="line-1768"></a>    But I'm leaving it in here so we remember the issue.)
<a name="line-1769"></a>    ----------------------------------------
<a name="line-1770"></a>When inferring the type of a let-binding, with simplifyInfer,
<a name="line-1771"></a>try to avoid unnecessarily simplifying class constraints.
<a name="line-1772"></a>Doing so aids sharing, but it also helps with delicate
<a name="line-1773"></a>situations like
<a name="line-1774"></a>
<a name="line-1775"></a>   instance C t =&gt; C [t] where ..
<a name="line-1776"></a>
<a name="line-1777"></a>   f :: C [t] =&gt; ....
<a name="line-1778"></a>   f x = let g y = ...(constraint C [t])...
<a name="line-1779"></a>         in ...
<a name="line-1780"></a>When inferring a type for 'g', we don't want to apply the
<a name="line-1781"></a>instance decl, because then we can't satisfy (C t).  So we
<a name="line-1782"></a>just notice that g isn't quantified over 't' and partition
<a name="line-1783"></a>the constraints before simplifying.
<a name="line-1784"></a>
<a name="line-1785"></a>This only half-works, but then let-generalisation only half-works.
<a name="line-1786"></a>
<a name="line-1787"></a>*********************************************************************************
<a name="line-1788"></a>*                                                                                 *
<a name="line-1789"></a>*                                 Main Simplifier                                 *
<a name="line-1790"></a>*                                                                                 *
<a name="line-1791"></a>***********************************************************************************
<a name="line-1792"></a>
<a name="line-1793"></a>-}</span>
<a name="line-1794"></a>
<a name="line-1795"></a><a name="simplifyWantedsTcM"></a><span class='hs-definition'>simplifyWantedsTcM</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CtEvidence</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-1796"></a><span class='hs-comment'>-- Solve the specified Wanted constraints</span>
<a name="line-1797"></a><span class='hs-comment'>-- Discard the evidence binds</span>
<a name="line-1798"></a><span class='hs-comment'>-- Discards all Derived stuff in result</span>
<a name="line-1799"></a><span class='hs-comment'>-- Postcondition: fully zonked</span>
<a name="line-1800"></a><span class='hs-definition'>simplifyWantedsTcM</span> <span class='hs-varid'>wanted</span>
<a name="line-1801"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyWantedsTcM {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-1802"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>result</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1803"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM.zonkWC</span> <span class='hs-varid'>result</span>
<a name="line-1804"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyWantedsTcM }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>result</span><span class='hs-layout'>)</span>
<a name="line-1805"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>result</span> <span class='hs-layout'>}</span>
<a name="line-1806"></a>
<a name="line-1807"></a><a name="solveWantedsAndDrop"></a><span class='hs-definition'>solveWantedsAndDrop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-1808"></a><span class='hs-comment'>-- Since solveWanteds returns the residual WantedConstraints,</span>
<a name="line-1809"></a><span class='hs-comment'>-- it should always be called within a runTcS or something similar,</span>
<a name="line-1810"></a><span class='hs-comment'>-- Result is not zonked</span>
<a name="line-1811"></a><span class='hs-definition'>solveWantedsAndDrop</span> <span class='hs-varid'>wanted</span>
<a name="line-1812"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanted</span>
<a name="line-1813"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1814"></a>
<a name="line-1815"></a><a name="solveWanteds"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-1816"></a><span class='hs-comment'>-- so that the inert set doesn't mindlessly propagate.</span>
<a name="line-1817"></a><span class='hs-comment'>-- NB: wc_simples may be wanted /or/ derived now</span>
<a name="line-1818"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-varid'>wc</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_holes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>holes</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1819"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cur_lvl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcLevel</span>
<a name="line-1820"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds {"</span> <span class='hs-varop'>$</span>
<a name="line-1821"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Level ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cur_lvl</span>
<a name="line-1822"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>]</span>
<a name="line-1823"></a>
<a name="line-1824"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1825"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solved_wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplify_loop</span> <span class='hs-num'>0</span> <span class='hs-layout'>(</span><span class='hs-varid'>solverIterations</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-conid'>True</span> <span class='hs-varid'>wc</span>
<a name="line-1826"></a>
<a name="line-1827"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>holes'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simplifyHoles</span> <span class='hs-varid'>holes</span>
<a name="line-1828"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solved_wc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_holes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>holes'</span> <span class='hs-layout'>}</span>
<a name="line-1829"></a>
<a name="line-1830"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsVar</span>
<a name="line-1831"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcEvBindsMap</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-1832"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds }"</span> <span class='hs-varop'>$</span>
<a name="line-1833"></a>                 <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"final wc ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_wc</span>
<a name="line-1834"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current evbinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>bb</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1835"></a>
<a name="line-1836"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>final_wc</span> <span class='hs-layout'>}</span>
<a name="line-1837"></a>
<a name="line-1838"></a><a name="simplify_loop"></a><span class='hs-definition'>simplify_loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IntWithInf</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1839"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-1840"></a><span class='hs-comment'>-- Do a round of solving, and call maybe_simplify_again to iterate</span>
<a name="line-1841"></a><span class='hs-comment'>-- The 'definitely_redo_implications' flags is False if the only reason we</span>
<a name="line-1842"></a><span class='hs-comment'>-- are iterating is that we have added some new Derived superclasses (from Wanteds)</span>
<a name="line-1843"></a><span class='hs-comment'>-- hoping for fundeps to help us; see Note [Superclass iteration]</span>
<a name="line-1844"></a><span class='hs-comment'>--</span>
<a name="line-1845"></a><span class='hs-comment'>-- Does not affect wc_holes at all; reason: wc_holes never affects anything</span>
<a name="line-1846"></a><span class='hs-comment'>-- else, so we do them once, at the end in solveWanteds</span>
<a name="line-1847"></a><span class='hs-definition'>simplify_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>limit</span> <span class='hs-varid'>definitely_redo_implications</span>
<a name="line-1848"></a>              <span class='hs-varid'>wc</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1849"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>csTraceTcS</span> <span class='hs-varop'>$</span>
<a name="line-1850"></a>         <span class='hs-varid'>text</span> <span class='hs-str'>"simplify_loop iteration="</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>n</span>
<a name="line-1851"></a>         <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>parens</span> <span class='hs-varop'>$</span> <span class='hs-varid'>hsep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"definitely_redo ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>definitely_redo_implications</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>comma</span>
<a name="line-1852"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>int</span> <span class='hs-layout'>(</span><span class='hs-varid'>lengthBag</span> <span class='hs-varid'>simples</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"simples to solve"</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1853"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"simplify_loop: wc ="</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-1854"></a>
<a name="line-1855"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>unifs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnifications</span> <span class='hs-varop'>$</span>  <span class='hs-comment'>-- See Note [Superclass iteration]</span>
<a name="line-1856"></a>                          <span class='hs-varid'>solveSimpleWanteds</span> <span class='hs-varid'>simples</span>
<a name="line-1857"></a>                <span class='hs-comment'>-- Any insoluble constraints are in 'simples' and so get rewritten</span>
<a name="line-1858"></a>                <span class='hs-comment'>-- See Note [Rewrite insolubles] in GHC.Tc.Solver.Monad</span>
<a name="line-1859"></a>
<a name="line-1860"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wc2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-varid'>definitely_redo_implications</span>  <span class='hs-comment'>-- See Note [Superclass iteration]</span>
<a name="line-1861"></a>                   <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>unifs1</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span>                    <span class='hs-comment'>-- for this conditional</span>
<a name="line-1862"></a>                   <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wc1</span><span class='hs-layout'>)</span>
<a name="line-1863"></a>                <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_simple</span> <span class='hs-varid'>wc1</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Short cut</span>
<a name="line-1864"></a>                <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>implics2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveNestedImplications</span> <span class='hs-varop'>$</span>
<a name="line-1865"></a>                                      <span class='hs-varid'>implics</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wc1</span><span class='hs-layout'>)</span>
<a name="line-1866"></a>                        <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc_simple</span> <span class='hs-varid'>wc1</span>
<a name="line-1867"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics2</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1868"></a>
<a name="line-1869"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unif_happened</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>resetUnificationFlag</span>
<a name="line-1870"></a>         <span class='hs-comment'>-- Note [The Unification Level Flag] in GHC.Tc.Solver.Monad</span>
<a name="line-1871"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>maybe_simplify_again</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>limit</span> <span class='hs-varid'>unif_happened</span> <span class='hs-varid'>wc2</span> <span class='hs-layout'>}</span>
<a name="line-1872"></a>
<a name="line-1873"></a><a name="maybe_simplify_again"></a><span class='hs-definition'>maybe_simplify_again</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IntWithInf</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1874"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-1875"></a><span class='hs-definition'>maybe_simplify_again</span> <span class='hs-varid'>n</span> <span class='hs-varid'>limit</span> <span class='hs-varid'>unif_happened</span> <span class='hs-varid'>wc</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1876"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>`intGtLimit`</span> <span class='hs-varid'>limit</span>
<a name="line-1877"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Add an error (not a warning) if we blow the limit,</span>
<a name="line-1878"></a>         <span class='hs-comment'>-- Typically if we blow the limit we are going to report some other error</span>
<a name="line-1879"></a>         <span class='hs-comment'>-- (an unsolved constraint), and we don't want that error to suppress</span>
<a name="line-1880"></a>         <span class='hs-comment'>-- the iteration limit warning!</span>
<a name="line-1881"></a>         <span class='hs-varid'>addErrTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>hang</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"solveWanteds: too many iterations"</span>
<a name="line-1882"></a>                   <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"limit ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>limit</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1883"></a>                <span class='hs-num'>2</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Unsolved:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span>
<a name="line-1884"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Set limit with -fconstraint-solver-iterations=n; n=0 for no limit"</span>
<a name="line-1885"></a>                  <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1886"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>
<a name="line-1887"></a>
<a name="line-1888"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>unif_happened</span>
<a name="line-1889"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simplify_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>limit</span> <span class='hs-conid'>True</span> <span class='hs-varid'>wc</span>
<a name="line-1890"></a>
<a name="line-1891"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>superClassesMightHelp</span> <span class='hs-varid'>wc</span>
<a name="line-1892"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- We still have unsolved goals, and apparently no way to solve them,</span>
<a name="line-1893"></a>    <span class='hs-comment'>-- so try expanding superclasses at this level, both Given and Wanted</span>
<a name="line-1894"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>pending_given</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getPendingGivenScs</span>
<a name="line-1895"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>pending_wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>simples1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getPendingWantedScs</span> <span class='hs-varid'>simples</span>
<a name="line-1896"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>null</span> <span class='hs-varid'>pending_given</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>pending_wanted</span>
<a name="line-1897"></a>           <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>  <span class='hs-comment'>-- After all, superclasses did not help</span>
<a name="line-1898"></a>           <span class='hs-keyword'>else</span>
<a name="line-1899"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>new_given</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeSuperClasses</span> <span class='hs-varid'>pending_given</span>
<a name="line-1900"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>makeSuperClasses</span> <span class='hs-varid'>pending_wanted</span>
<a name="line-1901"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-varid'>new_given</span> <span class='hs-comment'>-- Add the new Givens to the inert set</span>
<a name="line-1902"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>simplify_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>limit</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>pending_given</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1903"></a>         <span class='hs-varid'>wc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>listToBag</span> <span class='hs-varid'>new_wanted</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1904"></a>         <span class='hs-comment'>-- (not (null pending_given)): see Note [Superclass iteration]</span>
<a name="line-1905"></a>
<a name="line-1906"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1907"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-1908"></a>
<a name="line-1909"></a><span class='hs-comment'>{- Note [Superclass iteration]
<a name="line-1910"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1911"></a>Consider this implication constraint
<a name="line-1912"></a>    forall a.
<a name="line-1913"></a>       [W] d: C Int beta
<a name="line-1914"></a>       forall b. blah
<a name="line-1915"></a>where
<a name="line-1916"></a>  class D a b | a -&gt; b
<a name="line-1917"></a>  class D a b =&gt; C a b
<a name="line-1918"></a>We will expand d's superclasses, giving [D] D Int beta, in the hope of geting
<a name="line-1919"></a>fundeps to unify beta.  Doing so is usually fruitless (no useful fundeps),
<a name="line-1920"></a>and if so it seems a pity to waste time iterating the implications (forall b. blah)
<a name="line-1921"></a>(If we add new Given superclasses it's a different matter: it's really worth looking
<a name="line-1922"></a>at the implications.)
<a name="line-1923"></a>
<a name="line-1924"></a>Hence the definitely_redo_implications flag to simplify_loop.  It's usually
<a name="line-1925"></a>True, but False in the case where the only reason to iterate is new Derived
<a name="line-1926"></a>superclasses.  In that case we check whether the new Deriveds actually led to
<a name="line-1927"></a>any new unifications, and iterate the implications only if so.
<a name="line-1928"></a>-}</span>
<a name="line-1929"></a>
<a name="line-1930"></a><a name="solveNestedImplications"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-1931"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-1932"></a><span class='hs-comment'>-- Precondition: the TcS inerts may contain unsolved simples which have</span>
<a name="line-1933"></a><span class='hs-comment'>-- to be converted to givens before we go inside a nested implication.</span>
<a name="line-1934"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-1935"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics</span>
<a name="line-1936"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-1937"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1938"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications starting {"</span> <span class='hs-varid'>empty</span>
<a name="line-1939"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>solveImplication</span> <span class='hs-varid'>implics</span>
<a name="line-1940"></a>
<a name="line-1941"></a>       <span class='hs-comment'>-- ... and we are back in the original TcS inerts</span>
<a name="line-1942"></a>       <span class='hs-comment'>-- Notice that the original includes the _insoluble_simples so it was safe to ignore</span>
<a name="line-1943"></a>       <span class='hs-comment'>-- them in the beginning of this function.</span>
<a name="line-1944"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications end }"</span> <span class='hs-varop'>$</span>
<a name="line-1945"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-1946"></a>
<a name="line-1947"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>catBagMaybes</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1948"></a>
<a name="line-1949"></a><a name="solveImplication"></a><span class='hs-definition'>solveImplication</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span>    <span class='hs-comment'>-- Wanted</span>
<a name="line-1950"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Simplified implication (empty or singleton)</span>
<a name="line-1951"></a><span class='hs-comment'>-- Precondition: The TcS monad contains an empty worklist and given-only inerts</span>
<a name="line-1952"></a><span class='hs-comment'>-- which after trying to solve this implication we must restore to their original value</span>
<a name="line-1953"></a><span class='hs-definition'>solveImplication</span> <span class='hs-varid'>imp</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_tclvl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tclvl</span>
<a name="line-1954"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-1955"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>given_ids</span>
<a name="line-1956"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span>
<a name="line-1957"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span>
<a name="line-1958"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_status</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>status</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1959"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isSolvedStatus</span> <span class='hs-varid'>status</span>
<a name="line-1960"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Do nothing</span>
<a name="line-1961"></a>
<a name="line-1962"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Even for IC_Insoluble it is worth doing more work</span>
<a name="line-1963"></a>               <span class='hs-comment'>-- The insoluble stuff might be in one sub-implication</span>
<a name="line-1964"></a>               <span class='hs-comment'>-- and other unsolved goals in another; and we want to</span>
<a name="line-1965"></a>               <span class='hs-comment'>-- solve the latter as much as possible</span>
<a name="line-1966"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-1967"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>imp</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Inerts"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span>
<a name="line-1968"></a>
<a name="line-1969"></a>       <span class='hs-comment'>-- commented out; see `where` clause below</span>
<a name="line-1970"></a>       <span class='hs-comment'>-- ; when debugIsOn check_tc_level</span>
<a name="line-1971"></a>
<a name="line-1972"></a>         <span class='hs-comment'>-- Solve the nested constraints</span>
<a name="line-1973"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>has_given_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>given_insols</span><span class='hs-layout'>,</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span>
<a name="line-1974"></a>            <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>tclvl</span> <span class='hs-varop'>$</span>
<a name="line-1975"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>loc</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivenLoc</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>info</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_env</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-1976"></a>                        <span class='hs-varid'>givens</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivens</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>given_ids</span>
<a name="line-1977"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-varid'>givens</span>
<a name="line-1978"></a>
<a name="line-1979"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>residual_wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-1980"></a>                        <span class='hs-comment'>-- solveWanteds, *not* solveWantedsAndDrop, because</span>
<a name="line-1981"></a>                        <span class='hs-comment'>-- we want to retain derived equalities so we can float</span>
<a name="line-1982"></a>                        <span class='hs-comment'>-- them out in floatEqualities.</span>
<a name="line-1983"></a>
<a name="line-1984"></a>                  <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>has_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>given_insols</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getHasGivenEqs</span> <span class='hs-varid'>tclvl</span>
<a name="line-1985"></a>                        <span class='hs-comment'>-- Call getHasGivenEqs /after/ solveWanteds, because</span>
<a name="line-1986"></a>                        <span class='hs-comment'>-- solveWanteds can augment the givens, via expandSuperClasses,</span>
<a name="line-1987"></a>                        <span class='hs-comment'>-- to reveal given superclass equalities</span>
<a name="line-1988"></a>
<a name="line-1989"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>has_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>given_insols</span><span class='hs-layout'>,</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1990"></a>
<a name="line-1991"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication 2"</span>
<a name="line-1992"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>given_insols</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span>
<a name="line-1993"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>final_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>residual_wanted</span> <span class='hs-varop'>`addInsols`</span> <span class='hs-varid'>given_insols</span>
<a name="line-1994"></a>             <span class='hs-comment'>-- Don't lose track of the insoluble givens,</span>
<a name="line-1995"></a>             <span class='hs-comment'>-- which signal unreachable code; put them in ic_wanted</span>
<a name="line-1996"></a>
<a name="line-1997"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setImplicationStatus</span> <span class='hs-layout'>(</span><span class='hs-varid'>imp</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_given_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>has_given_eqs</span>
<a name="line-1998"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>final_wanted</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1999"></a>
<a name="line-2000"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evbinds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcEvBindsMap</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-2001"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tcvs</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcEvTyCoVars</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-2002"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication end }"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-2003"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"has_given_eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>has_given_eqs</span>
<a name="line-2004"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_implic ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_implic</span>
<a name="line-2005"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implication evbinds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>evbinds</span><span class='hs-layout'>)</span>
<a name="line-2006"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implication tvcs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tcvs</span> <span class='hs-keyglyph'>]</span>
<a name="line-2007"></a>
<a name="line-2008"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>res_implic</span> <span class='hs-layout'>}</span>
<a name="line-2009"></a>
<a name="line-2010"></a>    <span class='hs-comment'>-- TcLevels must be strictly increasing (see (ImplicInv) in</span>
<a name="line-2011"></a>    <span class='hs-comment'>-- Note [TcLevel invariants] in GHC.Tc.Utils.TcType),</span>
<a name="line-2012"></a>    <span class='hs-comment'>-- and in fact I think they should always increase one level at a time.</span>
<a name="line-2013"></a>
<a name="line-2014"></a>    <span class='hs-comment'>-- Though sensible, this check causes lots of testsuite failures. It is</span>
<a name="line-2015"></a>    <span class='hs-comment'>-- remaining commented out for now.</span>
<a name="line-2016"></a>    <span class='hs-comment'>{-
<a name="line-2017"></a>    check_tc_level = do { cur_lvl &lt;- TcS.getTcLevel
<a name="line-2018"></a>                        ; MASSERT2( tclvl == pushTcLevel cur_lvl , text "Cur lvl =" &lt;+&gt; ppr cur_lvl $$ text "Imp lvl =" &lt;+&gt; ppr tclvl ) }
<a name="line-2019"></a>    -}</span>
<a name="line-2020"></a>
<a name="line-2021"></a><a name="setImplicationStatus"></a><span class='hs-comment'>----------------------</span>
<a name="line-2022"></a><span class='hs-definition'>setImplicationStatus</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-2023"></a><span class='hs-comment'>-- Finalise the implication returned from solveImplication:</span>
<a name="line-2024"></a><span class='hs-comment'>--    * Set the ic_status field</span>
<a name="line-2025"></a><span class='hs-comment'>--    * Trim the ic_wanted field to remove Derived constraints</span>
<a name="line-2026"></a><span class='hs-comment'>-- Precondition: the ic_status field is not already IC_Solved</span>
<a name="line-2027"></a><span class='hs-comment'>-- Return Nothing if we can discard the implication altogether</span>
<a name="line-2028"></a><span class='hs-definition'>setImplicationStatus</span> <span class='hs-varid'>implic</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_status</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>status</span>
<a name="line-2029"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span>
<a name="line-2030"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc</span>
<a name="line-2031"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2032"></a> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSolvedStatus</span> <span class='hs-varid'>status</span> <span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>info</span> <span class='hs-layout'>)</span>
<a name="line-2033"></a>   <span class='hs-comment'>-- Precondition: we only set the status if it is not already solved</span>
<a name="line-2034"></a>   <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSolvedWC</span> <span class='hs-varid'>pruned_wc</span><span class='hs-layout'>)</span>
<a name="line-2035"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"setImplicationStatus(not-all-solved) {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span>
<a name="line-2036"></a>
<a name="line-2037"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>neededEvVars</span> <span class='hs-varid'>implic</span>
<a name="line-2038"></a>
<a name="line-2039"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_status</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>pruned_wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IC_Insoluble</span>
<a name="line-2040"></a>                       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IC_Unsolved</span>
<a name="line-2041"></a>            <span class='hs-varid'>new_implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_status</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_status</span>
<a name="line-2042"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pruned_wc</span> <span class='hs-layout'>}</span>
<a name="line-2043"></a>
<a name="line-2044"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"setImplicationStatus(not-all-solved) }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>new_implic</span><span class='hs-layout'>)</span>
<a name="line-2045"></a>
<a name="line-2046"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>new_implic</span> <span class='hs-layout'>}</span>
<a name="line-2047"></a>
<a name="line-2048"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- Everything is solved</span>
<a name="line-2049"></a>              <span class='hs-comment'>-- Set status to IC_Solved,</span>
<a name="line-2050"></a>              <span class='hs-comment'>-- and compute the dead givens and outer needs</span>
<a name="line-2051"></a>              <span class='hs-comment'>-- See Note [Tracking redundant constraints]</span>
<a name="line-2052"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"setImplicationStatus(all-solved) {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>implic</span><span class='hs-layout'>)</span>
<a name="line-2053"></a>
<a name="line-2054"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>implic</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_need_inner</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>need_inner</span>
<a name="line-2055"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_need_outer</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>need_outer</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>neededEvVars</span> <span class='hs-varid'>implic</span>
<a name="line-2056"></a>
<a name="line-2057"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>bad_telescope</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>checkBadTelescope</span> <span class='hs-varid'>implic</span>
<a name="line-2058"></a>
<a name="line-2059"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>used_givens</span><span class='hs-layout'>,</span> <span class='hs-varid'>unused_givens</span><span class='hs-layout'>)</span>
<a name="line-2060"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>warnRedundantGivens</span> <span class='hs-varid'>info</span>
<a name="line-2061"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partition</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>need_inner</span><span class='hs-layout'>)</span> <span class='hs-varid'>givens</span>
<a name="line-2062"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>givens</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- None to report</span>
<a name="line-2063"></a>
<a name="line-2064"></a>            <span class='hs-varid'>minimal_used_givens</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varid'>evVarPred</span> <span class='hs-varid'>used_givens</span>
<a name="line-2065"></a>            <span class='hs-varid'>is_minimal</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>minimal_used_givens</span><span class='hs-layout'>)</span>
<a name="line-2066"></a>
<a name="line-2067"></a>            <span class='hs-varid'>warn_givens</span>
<a name="line-2068"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>unused_givens</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unused_givens</span>
<a name="line-2069"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>warnRedundantGivens</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterOut</span> <span class='hs-varid'>is_minimal</span> <span class='hs-varid'>used_givens</span>
<a name="line-2070"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-2071"></a>
<a name="line-2072"></a>            <span class='hs-varid'>discard_entire_implication</span>  <span class='hs-comment'>-- Can we discard the entire implication?</span>
<a name="line-2073"></a>              <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>null</span> <span class='hs-varid'>warn_givens</span>           <span class='hs-comment'>-- No warning from this implication</span>
<a name="line-2074"></a>              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-varid'>bad_telescope</span>
<a name="line-2075"></a>              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>pruned_wc</span>        <span class='hs-comment'>-- No live children</span>
<a name="line-2076"></a>              <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>need_outer</span>   <span class='hs-comment'>-- No needed vars to pass up to parent</span>
<a name="line-2077"></a>
<a name="line-2078"></a>            <span class='hs-varid'>final_status</span>
<a name="line-2079"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bad_telescope</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IC_BadTelescope</span>
<a name="line-2080"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>IC_Solved</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ics_dead</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>warn_givens</span> <span class='hs-layout'>}</span>
<a name="line-2081"></a>            <span class='hs-varid'>final_implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_status</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>final_status</span>
<a name="line-2082"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pruned_wc</span> <span class='hs-layout'>}</span>
<a name="line-2083"></a>
<a name="line-2084"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"setImplicationStatus(all-solved) }"</span> <span class='hs-varop'>$</span>
<a name="line-2085"></a>        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"discard:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>discard_entire_implication</span>
<a name="line-2086"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"new_implic:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_implic</span> <span class='hs-keyglyph'>]</span>
<a name="line-2087"></a>
<a name="line-2088"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>discard_entire_implication</span>
<a name="line-2089"></a>                 <span class='hs-keyword'>then</span> <span class='hs-conid'>Nothing</span>
<a name="line-2090"></a>                 <span class='hs-keyword'>else</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>final_implic</span> <span class='hs-layout'>}</span>
<a name="line-2091"></a> <span class='hs-keyword'>where</span>
<a name="line-2092"></a>   <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_holes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>holes</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wc</span>
<a name="line-2093"></a>
<a name="line-2094"></a>   <span class='hs-varid'>pruned_simples</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropDerivedSimples</span> <span class='hs-varid'>simples</span>
<a name="line-2095"></a>   <span class='hs-varid'>pruned_implics</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterBag</span> <span class='hs-varid'>keep_me</span> <span class='hs-varid'>implics</span>
<a name="line-2096"></a>   <span class='hs-varid'>pruned_wc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pruned_simples</span>
<a name="line-2097"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pruned_implics</span>
<a name="line-2098"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>wc_holes</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>holes</span> <span class='hs-layout'>}</span>   <span class='hs-comment'>-- do not prune holes; these should be reported</span>
<a name="line-2099"></a>
<a name="line-2100"></a>   <span class='hs-varid'>keep_me</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2101"></a>   <span class='hs-varid'>keep_me</span> <span class='hs-varid'>ic</span>
<a name="line-2102"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IC_Solved</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ics_dead</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dead_givens</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ic_status</span> <span class='hs-varid'>ic</span>
<a name="line-2103"></a>                          <span class='hs-comment'>-- Fully solved</span>
<a name="line-2104"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-varid'>dead_givens</span>   <span class='hs-comment'>-- No redundant givens to report</span>
<a name="line-2105"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>ic</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2106"></a>           <span class='hs-comment'>-- And no children that might have things to report</span>
<a name="line-2107"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>       <span class='hs-comment'>-- Tnen we don't need to keep it</span>
<a name="line-2108"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2109"></a>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>        <span class='hs-comment'>-- Otherwise, keep it</span>
<a name="line-2110"></a>
<a name="line-2111"></a><a name="checkBadTelescope"></a><span class='hs-definition'>checkBadTelescope</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-2112"></a><span class='hs-comment'>-- True &lt;=&gt; the skolems form a bad telescope</span>
<a name="line-2113"></a><span class='hs-comment'>-- See Note [Checking telescopes] in GHC.Tc.Types.Constraint</span>
<a name="line-2114"></a><span class='hs-definition'>checkBadTelescope</span> <span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_info</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span>
<a name="line-2115"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2116"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>checkTelescopeSkol</span> <span class='hs-varid'>info</span>
<a name="line-2117"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span><span class='hs-layout'>{</span> <span class='hs-varid'>skols</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcS.zonkTyCoVarKind</span> <span class='hs-varid'>skols</span>
<a name="line-2118"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>skols</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span>
<a name="line-2119"></a>
<a name="line-2120"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2121"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2122"></a>
<a name="line-2123"></a>  <span class='hs-keyword'>where</span>
<a name="line-2124"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span>   <span class='hs-comment'>-- skolems that appear *later* than the current ones</span>
<a name="line-2125"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- ordered skolems, in reverse order</span>
<a name="line-2126"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>       <span class='hs-comment'>-- True &lt;=&gt; there is an out-of-order skolem</span>
<a name="line-2127"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2128"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>later_skols</span> <span class='hs-layout'>(</span><span class='hs-varid'>one_skol</span> <span class='hs-conop'>:</span> <span class='hs-varid'>earlier_skols</span><span class='hs-layout'>)</span>
<a name="line-2129"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tyCoVarsOfType</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>one_skol</span><span class='hs-layout'>)</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>later_skols</span>
<a name="line-2130"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2131"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2132"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>later_skols</span> <span class='hs-varop'>`extendVarSet`</span> <span class='hs-varid'>one_skol</span><span class='hs-layout'>)</span> <span class='hs-varid'>earlier_skols</span>
<a name="line-2133"></a>
<a name="line-2134"></a><a name="warnRedundantGivens"></a><span class='hs-definition'>warnRedundantGivens</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SkolemInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2135"></a><span class='hs-definition'>warnRedundantGivens</span> <span class='hs-layout'>(</span><span class='hs-conid'>SigSkol</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-2136"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-2137"></a>       <span class='hs-conid'>FunSigCtxt</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>warn_redundant</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>warn_redundant</span>
<a name="line-2138"></a>       <span class='hs-conid'>ExprSigCtxt</span>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-2139"></a>       <span class='hs-keyword'>_</span>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-2140"></a>
<a name="line-2141"></a>  <span class='hs-comment'>-- To think about: do we want to report redundant givens for</span>
<a name="line-2142"></a>  <span class='hs-comment'>-- pattern synonyms, PatSynSigSkol? c.f #9953, comment:21.</span>
<a name="line-2143"></a><span class='hs-definition'>warnRedundantGivens</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstSkol</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2144"></a><span class='hs-definition'>warnRedundantGivens</span> <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2145"></a>
<a name="line-2146"></a><a name="neededEvVars"></a><span class='hs-definition'>neededEvVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Implication</span>
<a name="line-2147"></a><span class='hs-comment'>-- Find all the evidence variables that are "needed",</span>
<a name="line-2148"></a><span class='hs-comment'>-- and delete dead evidence bindings</span>
<a name="line-2149"></a><span class='hs-comment'>--   See Note [Tracking redundant constraints]</span>
<a name="line-2150"></a><span class='hs-comment'>--   See Note [Delete dead Given evidence bindings]</span>
<a name="line-2151"></a><span class='hs-comment'>--</span>
<a name="line-2152"></a><span class='hs-comment'>--   - Start from initial_seeds (from nested implications)</span>
<a name="line-2153"></a><span class='hs-comment'>--</span>
<a name="line-2154"></a><span class='hs-comment'>--   - Add free vars of RHS of all Wanted evidence bindings</span>
<a name="line-2155"></a><span class='hs-comment'>--     and coercion variables accumulated in tcvs (all Wanted)</span>
<a name="line-2156"></a><span class='hs-comment'>--</span>
<a name="line-2157"></a><span class='hs-comment'>--   - Generate 'needed', the needed set of EvVars, by doing transitive</span>
<a name="line-2158"></a><span class='hs-comment'>--     closure through Given bindings</span>
<a name="line-2159"></a><span class='hs-comment'>--     e.g.   Needed {a,b}</span>
<a name="line-2160"></a><span class='hs-comment'>--            Given  a = sc_sel a2</span>
<a name="line-2161"></a><span class='hs-comment'>--            Then a2 is needed too</span>
<a name="line-2162"></a><span class='hs-comment'>--</span>
<a name="line-2163"></a><span class='hs-comment'>--   - Prune out all Given bindings that are not needed</span>
<a name="line-2164"></a><span class='hs-comment'>--</span>
<a name="line-2165"></a><span class='hs-comment'>--   - From the 'needed' set, delete ev_bndrs, the binders of the</span>
<a name="line-2166"></a><span class='hs-comment'>--     evidence bindings, to give the final needed variables</span>
<a name="line-2167"></a><span class='hs-comment'>--</span>
<a name="line-2168"></a><span class='hs-definition'>neededEvVars</span> <span class='hs-varid'>implic</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span>
<a name="line-2169"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-2170"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span>
<a name="line-2171"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>ic_need_inner</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_needs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2172"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ev_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcEvBindsMap</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-2173"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tcvs</span>     <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcEvTyCoVars</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-2174"></a>
<a name="line-2175"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>seeds1</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>add_implic_seeds</span> <span class='hs-varid'>old_needs</span> <span class='hs-varid'>implics</span>
<a name="line-2176"></a>            <span class='hs-varid'>seeds2</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nonDetStrictFoldEvBindMap</span> <span class='hs-varid'>add_wanted</span> <span class='hs-varid'>seeds1</span> <span class='hs-varid'>ev_binds</span>
<a name="line-2177"></a>                            <span class='hs-comment'>-- It's OK to use a non-deterministic fold here</span>
<a name="line-2178"></a>                            <span class='hs-comment'>-- because add_wanted is commutative</span>
<a name="line-2179"></a>            <span class='hs-varid'>seeds3</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>seeds2</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tcvs</span>
<a name="line-2180"></a>            <span class='hs-varid'>need_inner</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findNeededEvVars</span> <span class='hs-varid'>ev_binds</span> <span class='hs-varid'>seeds3</span>
<a name="line-2181"></a>            <span class='hs-varid'>live_ev_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterEvBindMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>needed_ev_bind</span> <span class='hs-varid'>need_inner</span><span class='hs-layout'>)</span> <span class='hs-varid'>ev_binds</span>
<a name="line-2182"></a>            <span class='hs-varid'>need_outer</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varSetMinusEvBindMap</span> <span class='hs-varid'>need_inner</span> <span class='hs-varid'>live_ev_binds</span>
<a name="line-2183"></a>                            <span class='hs-varop'>`delVarSetList`</span> <span class='hs-varid'>givens</span>
<a name="line-2184"></a>
<a name="line-2185"></a>      <span class='hs-layout'>;</span> <span class='hs-conid'>TcS.setTcEvBindsMap</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>live_ev_binds</span>
<a name="line-2186"></a>           <span class='hs-comment'>-- See Note [Delete dead Given evidence bindings]</span>
<a name="line-2187"></a>
<a name="line-2188"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"neededEvVars"</span> <span class='hs-varop'>$</span>
<a name="line-2189"></a>        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"old_needs:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>old_needs</span>
<a name="line-2190"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"seeds3:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>seeds3</span>
<a name="line-2191"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"tcvs:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tcvs</span>
<a name="line-2192"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ev_binds:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev_binds</span>
<a name="line-2193"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"live_ev_binds:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>live_ev_binds</span> <span class='hs-keyglyph'>]</span>
<a name="line-2194"></a>
<a name="line-2195"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_need_inner</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>need_inner</span>
<a name="line-2196"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_need_outer</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>need_outer</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2197"></a> <span class='hs-keyword'>where</span>
<a name="line-2198"></a>   <span class='hs-varid'>add_implic_seeds</span> <span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_need_outer</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>needs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span>
<a name="line-2199"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>needs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>acc</span>
<a name="line-2200"></a>
<a name="line-2201"></a>   <span class='hs-varid'>needed_ev_bind</span> <span class='hs-varid'>needed</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>eb_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_var</span>
<a name="line-2202"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>eb_is_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_given</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2203"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_var</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>needed</span>
<a name="line-2204"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>   <span class='hs-comment'>-- Keep all wanted bindings</span>
<a name="line-2205"></a>
<a name="line-2206"></a>   <span class='hs-varid'>add_wanted</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EvBind</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-2207"></a>   <span class='hs-varid'>add_wanted</span> <span class='hs-layout'>(</span><span class='hs-conid'>EvBind</span> <span class='hs-layout'>{</span> <span class='hs-varid'>eb_is_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_given</span><span class='hs-layout'>,</span> <span class='hs-varid'>eb_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>needs</span>
<a name="line-2208"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>needs</span>  <span class='hs-comment'>-- Add the rhs vars of the Wanted bindings only</span>
<a name="line-2209"></a>     <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evVarsOfTerm</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>needs</span>
<a name="line-2210"></a>
<a name="line-2211"></a><a name="simplifyHoles"></a><span class='hs-comment'>-------------------------------------------------</span>
<a name="line-2212"></a><span class='hs-definition'>simplifyHoles</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Hole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>Hole</span><span class='hs-layout'>)</span>
<a name="line-2213"></a><span class='hs-definition'>simplifyHoles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>simpl_hole</span>
<a name="line-2214"></a>  <span class='hs-keyword'>where</span>
<a name="line-2215"></a>    <span class='hs-varid'>simpl_hole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Hole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Hole</span>
<a name="line-2216"></a>
<a name="line-2217"></a>     <span class='hs-comment'>-- See Note [Do not simplify ConstraintHoles]</span>
<a name="line-2218"></a>    <span class='hs-varid'>simpl_hole</span> <span class='hs-varid'>h</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Hole</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hole_sort</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ConstraintHole</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>h</span>
<a name="line-2219"></a>
<a name="line-2220"></a>     <span class='hs-comment'>-- other wildcards should be simplified for printing</span>
<a name="line-2221"></a>     <span class='hs-comment'>-- we must do so here, and not in the error-message generation</span>
<a name="line-2222"></a>     <span class='hs-comment'>-- code, because we have all the givens already set up</span>
<a name="line-2223"></a>    <span class='hs-varid'>simpl_hole</span> <span class='hs-varid'>h</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Hole</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>hole_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2224"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteType</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>ty</span>
<a name="line-2225"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>h</span> <span class='hs-layout'>{</span> <span class='hs-varid'>hole_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2226"></a>
<a name="line-2227"></a><span class='hs-comment'>{- Note [Delete dead Given evidence bindings]
<a name="line-2228"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2229"></a>As a result of superclass expansion, we speculatively
<a name="line-2230"></a>generate evidence bindings for Givens. E.g.
<a name="line-2231"></a>   f :: (a ~ b) =&gt; a -&gt; b -&gt; Bool
<a name="line-2232"></a>   f x y = ...
<a name="line-2233"></a>We'll have
<a name="line-2234"></a>   [G] d1 :: (a~b)
<a name="line-2235"></a>and we'll speculatively generate the evidence binding
<a name="line-2236"></a>   [G] d2 :: (a ~# b) = sc_sel d
<a name="line-2237"></a>
<a name="line-2238"></a>Now d2 is available for solving.  But it may not be needed!  Usually
<a name="line-2239"></a>such dead superclass selections will eventually be dropped as dead
<a name="line-2240"></a>code, but:
<a name="line-2241"></a>
<a name="line-2242"></a> * It won't always be dropped (#13032).  In the case of an
<a name="line-2243"></a>   unlifted-equality superclass like d2 above, we generate
<a name="line-2244"></a>       case heq_sc d1 of d2 -&gt; ...
<a name="line-2245"></a>   and we can't (in general) drop that case expression in case
<a name="line-2246"></a>   d1 is bottom.  So it's technically unsound to have added it
<a name="line-2247"></a>   in the first place.
<a name="line-2248"></a>
<a name="line-2249"></a> * Simply generating all those extra superclasses can generate lots of
<a name="line-2250"></a>   code that has to be zonked, only to be discarded later.  Better not
<a name="line-2251"></a>   to generate it in the first place.
<a name="line-2252"></a>
<a name="line-2253"></a>   Moreover, if we simplify this implication more than once
<a name="line-2254"></a>   (e.g. because we can't solve it completely on the first iteration
<a name="line-2255"></a>   of simpl_looop), we'll generate all the same bindings AGAIN!
<a name="line-2256"></a>
<a name="line-2257"></a>Easy solution: take advantage of the work we are doing to track dead
<a name="line-2258"></a>(unused) Givens, and use it to prune the Given bindings too.  This is
<a name="line-2259"></a>all done by neededEvVars.
<a name="line-2260"></a>
<a name="line-2261"></a>This led to a remarkable 25% overall compiler allocation decrease in
<a name="line-2262"></a>test T12227.
<a name="line-2263"></a>
<a name="line-2264"></a>But we don't get to discard all redundant equality superclasses, alas;
<a name="line-2265"></a>see #15205.
<a name="line-2266"></a>
<a name="line-2267"></a>Note [Do not simplify ConstraintHoles]
<a name="line-2268"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2269"></a>Before printing the inferred value for a type hole (a _ wildcard in
<a name="line-2270"></a>a partial type signature), we simplify it w.r.t. any Givens. This
<a name="line-2271"></a>makes for an easier-to-understand diagnostic for the user.
<a name="line-2272"></a>
<a name="line-2273"></a>However, we do not wish to do this for extra-constraint holes. Here is
<a name="line-2274"></a>the example for why (partial-sigs/should_compile/T12844):
<a name="line-2275"></a>
<a name="line-2276"></a>  bar :: _ =&gt; FooData rngs
<a name="line-2277"></a>  bar = foo
<a name="line-2278"></a>
<a name="line-2279"></a>  data FooData rngs
<a name="line-2280"></a>
<a name="line-2281"></a>  class Foo xs where foo :: (Head xs ~ '(r,r')) =&gt; FooData xs
<a name="line-2282"></a>
<a name="line-2283"></a>  type family Head (xs :: [k]) where Head (x ': xs) = x
<a name="line-2284"></a>
<a name="line-2285"></a>GHC correctly infers that the extra-constraints wildcard on `bar`
<a name="line-2286"></a>should be (Head rngs ~ '(r, r'), Foo rngs). It then adds this
<a name="line-2287"></a>constraint as a Given on the implication constraint for `bar`. (This
<a name="line-2288"></a>implication is emitted by emitResidualConstraints.) The Hole for the _
<a name="line-2289"></a>is stored within the implication's WantedConstraints.  When
<a name="line-2290"></a>simplifyHoles is called, that constraint is already assumed as a
<a name="line-2291"></a>Given. Simplifying with respect to it turns it into ('(r, r') ~ '(r,
<a name="line-2292"></a>r'), Foo rngs), which is disastrous.
<a name="line-2293"></a>
<a name="line-2294"></a>Furthermore, there is no need to simplify here: extra-constraints wildcards
<a name="line-2295"></a>are filled in with the output of the solver, in chooseInferredQuantifiers
<a name="line-2296"></a>(choose_psig_context), so they are already simplified. (Contrast to normal
<a name="line-2297"></a>type holes, which are just bound to a meta-variable.) Avoiding the poor output
<a name="line-2298"></a>is simple: just don't simplify extra-constraints wildcards.
<a name="line-2299"></a>
<a name="line-2300"></a>This is the only reason we need to track ConstraintHole separately
<a name="line-2301"></a>from TypeHole in HoleSort.
<a name="line-2302"></a>
<a name="line-2303"></a>See also Note [Extra-constraint holes in partial type signatures]
<a name="line-2304"></a>in GHC.Tc.Gen.HsType.
<a name="line-2305"></a>
<a name="line-2306"></a>Note [Tracking redundant constraints]
<a name="line-2307"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2308"></a>With Opt_WarnRedundantConstraints, GHC can report which
<a name="line-2309"></a>constraints of a type signature (or instance declaration) are
<a name="line-2310"></a>redundant, and can be omitted.  Here is an overview of how it
<a name="line-2311"></a>works.
<a name="line-2312"></a>
<a name="line-2313"></a>This is all tested in typecheck/should_compile/T20602 (among
<a name="line-2314"></a>others).
<a name="line-2315"></a>
<a name="line-2316"></a>----- What is a redundant constraint?
<a name="line-2317"></a>
<a name="line-2318"></a>* The things that can be redundant are precisely the Given
<a name="line-2319"></a>  constraints of an implication.
<a name="line-2320"></a>
<a name="line-2321"></a>* A constraint can be redundant in two different ways:
<a name="line-2322"></a>  a) It is not needed by the Wanted constraints covered by the
<a name="line-2323"></a>     implication E.g.
<a name="line-2324"></a>       f :: Eq a =&gt; a -&gt; Bool
<a name="line-2325"></a>       f x = True  -- Equality not used
<a name="line-2326"></a>  b) It is implied by other givens.  E.g.
<a name="line-2327"></a>       f :: (Eq a, Ord a)     =&gt; blah   -- Eq a unnecessary
<a name="line-2328"></a>       g :: (Eq a, a~b, Eq b) =&gt; blah   -- Either Eq a or Eq b unnecessary
<a name="line-2329"></a>
<a name="line-2330"></a>*  To find (a) we need to know which evidence bindings are 'wanted';
<a name="line-2331"></a>   hence the eb_is_given field on an EvBind.
<a name="line-2332"></a>
<a name="line-2333"></a>*  To find (b), we use mkMinimalBySCs on the Givens to see if any
<a name="line-2334"></a>   are unnecessary.
<a name="line-2335"></a>
<a name="line-2336"></a>----- How tracking works
<a name="line-2337"></a>
<a name="line-2338"></a>* When two Givens are the same, we drop the evidence for the one
<a name="line-2339"></a>  that requires more superclass selectors. This is done
<a name="line-2340"></a>  according to Note [Replacement vs keeping] in GHC.Tc.Solver.Interact.
<a name="line-2341"></a>
<a name="line-2342"></a>* The ic_need fields of an Implic records in-scope (given) evidence
<a name="line-2343"></a>  variables bound by the context, that were needed to solve this
<a name="line-2344"></a>  implication (so far).  See the declaration of Implication.
<a name="line-2345"></a>
<a name="line-2346"></a>* When the constraint solver finishes solving all the wanteds in
<a name="line-2347"></a>  an implication, it sets its status to IC_Solved
<a name="line-2348"></a>
<a name="line-2349"></a>  - The ics_dead field, of IC_Solved, records the subset of this
<a name="line-2350"></a>    implication's ic_given that are redundant (not needed).
<a name="line-2351"></a>
<a name="line-2352"></a>* We compute which evidence variables are needed by an implication
<a name="line-2353"></a>  in setImplicationStatus.  A variable is needed if
<a name="line-2354"></a>    a) it is free in the RHS of a Wanted EvBind,
<a name="line-2355"></a>    b) it is free in the RHS of an EvBind whose LHS is needed, or
<a name="line-2356"></a>    c) it is in the ics_need of a nested implication.
<a name="line-2357"></a>
<a name="line-2358"></a>* After computing which variables are needed, we then look at the
<a name="line-2359"></a>  remaining variables for internal redundancies. This is case (b)
<a name="line-2360"></a>  from above. This is also done in setImplicationStatus.
<a name="line-2361"></a>  Note that we only look for case (b) if case (a) shows up empty,
<a name="line-2362"></a>  as exemplified below.
<a name="line-2363"></a>
<a name="line-2364"></a>* We need to be careful not to discard an implication
<a name="line-2365"></a>  prematurely, even one that is fully solved, because we might
<a name="line-2366"></a>  thereby forget which variables it needs, and hence wrongly
<a name="line-2367"></a>  report a constraint as redundant.  But we can discard it once
<a name="line-2368"></a>  its free vars have been incorporated into its parent; or if it
<a name="line-2369"></a>  simply has no free vars. This careful discarding is also
<a name="line-2370"></a>  handled in setImplicationStatus.
<a name="line-2371"></a>
<a name="line-2372"></a>* Examples:
<a name="line-2373"></a>
<a name="line-2374"></a>    f, g, h :: (Eq a, Ord a) =&gt; a -&gt; Bool
<a name="line-2375"></a>    f x = x == x
<a name="line-2376"></a>    g x = x &gt; x
<a name="line-2377"></a>    h x = x == x &amp;&amp; x &gt; x
<a name="line-2378"></a>
<a name="line-2379"></a>    All three will discover that they have two [G] Eq a constraints:
<a name="line-2380"></a>    one as given and one extracted from the Ord a constraint. They will
<a name="line-2381"></a>    both discard the latter, as noted above and in
<a name="line-2382"></a>    Note [Replacement vs keeping] in GHC.Tc.Solver.Interact.
<a name="line-2383"></a>
<a name="line-2384"></a>    The body of f uses the [G] Eq a, but not the [G] Ord a. It will
<a name="line-2385"></a>    report a redundant Ord a using the logic for case (a).
<a name="line-2386"></a>
<a name="line-2387"></a>    The body of g uses the [G] Ord a, but not the [G] Eq a. It will
<a name="line-2388"></a>    report a redundant Eq a using the logic for case (a).
<a name="line-2389"></a>
<a name="line-2390"></a>    The body of h uses both [G] Ord a and [G] Eq a. Case (a) will
<a name="line-2391"></a>    thus come up with nothing redundant. But then, the case (b)
<a name="line-2392"></a>    check will discover that Eq a is redundant and report this.
<a name="line-2393"></a>
<a name="line-2394"></a>    If we did case (b) even when case (a) reports something, then
<a name="line-2395"></a>    we would report both constraints as redundant for f, which is
<a name="line-2396"></a>    terrible.
<a name="line-2397"></a>
<a name="line-2398"></a>----- Reporting redundant constraints
<a name="line-2399"></a>
<a name="line-2400"></a>* GHC.Tc.Errors does the actual warning, in warnRedundantConstraints.
<a name="line-2401"></a>
<a name="line-2402"></a>* We don't report redundant givens for *every* implication; only
<a name="line-2403"></a>  for those which reply True to GHC.Tc.Solver.warnRedundantGivens:
<a name="line-2404"></a>
<a name="line-2405"></a>   - For example, in a class declaration, the default method *can*
<a name="line-2406"></a>     use the class constraint, but it certainly doesn't *have* to,
<a name="line-2407"></a>     and we don't want to report an error there.
<a name="line-2408"></a>
<a name="line-2409"></a>   - More subtly, in a function definition
<a name="line-2410"></a>       f :: (Ord a, Ord a, Ix a) =&gt; a -&gt; a
<a name="line-2411"></a>       f x = rhs
<a name="line-2412"></a>     we do an ambiguity check on the type (which would find that one
<a name="line-2413"></a>     of the Ord a constraints was redundant), and then we check that
<a name="line-2414"></a>     the definition has that type (which might find that both are
<a name="line-2415"></a>     redundant).  We don't want to report the same error twice, so we
<a name="line-2416"></a>     disable it for the ambiguity check.  Hence using two different
<a name="line-2417"></a>     FunSigCtxts, one with the warn-redundant field set True, and the
<a name="line-2418"></a>     other set False in
<a name="line-2419"></a>        - GHC.Tc.Gen.Bind.tcSpecPrag
<a name="line-2420"></a>        - GHC.Tc.Gen.Bind.tcTySig
<a name="line-2421"></a>
<a name="line-2422"></a>  This decision is taken in setImplicationStatus, rather than GHC.Tc.Errors
<a name="line-2423"></a>  so that we can discard implication constraints that we don't need.
<a name="line-2424"></a>  So ics_dead consists only of the *reportable* redundant givens.
<a name="line-2425"></a>
<a name="line-2426"></a>----- Shortcomings
<a name="line-2427"></a>
<a name="line-2428"></a>Consider
<a name="line-2429"></a>
<a name="line-2430"></a>  j :: (Eq a, a ~ b) =&gt; a -&gt; Bool
<a name="line-2431"></a>  j x = x == x
<a name="line-2432"></a>
<a name="line-2433"></a>  k :: (Eq a, b ~ a) =&gt; a -&gt; Bool
<a name="line-2434"></a>  k x = x == x
<a name="line-2435"></a>
<a name="line-2436"></a>Currently (Nov 2021), j issues no warning, while k says that b ~ a
<a name="line-2437"></a>is redundant. This is because j uses the a ~ b constraint to rewrite
<a name="line-2438"></a>everything to be in terms of b, while k does none of that. This is
<a name="line-2439"></a>ridiculous, but I (Richard E) don't see a good fix.
<a name="line-2440"></a>
<a name="line-2441"></a>-}</span>
<a name="line-2442"></a>
<a name="line-2443"></a><a name="defaultTyVarTcS"></a><span class='hs-comment'>-- | Like 'defaultTyVar', but in the TcS monad.</span>
<a name="line-2444"></a><span class='hs-definition'>defaultTyVarTcS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-2445"></a><span class='hs-definition'>defaultTyVarTcS</span> <span class='hs-varid'>the_tv</span>
<a name="line-2446"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRuntimeRepVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-2447"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyVarTyVar</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span>
<a name="line-2448"></a>    <span class='hs-comment'>-- TyVarTvs should only be unified with a tyvar</span>
<a name="line-2449"></a>    <span class='hs-comment'>-- never with a type; c.f. GHC.Tc.Utils.TcMType.defaultTyVar</span>
<a name="line-2450"></a>    <span class='hs-comment'>-- and Note [Inferring kinds for type declarations] in GHC.Tc.TyCl</span>
<a name="line-2451"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"defaultTyVarTcS RuntimeRep"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span>
<a name="line-2452"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unifyTyVar</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>liftedRepTy</span>
<a name="line-2453"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-2454"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isMultiplicityVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-2455"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTyVarTyVar</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- TyVarTvs should only be unified with a tyvar</span>
<a name="line-2456"></a>                             <span class='hs-comment'>-- never with a type; c.f. TcMType.defaultTyVar</span>
<a name="line-2457"></a>                             <span class='hs-comment'>-- See Note [Kind generalisation and SigTvs]</span>
<a name="line-2458"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"defaultTyVarTcS Multiplicity"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span>
<a name="line-2459"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unifyTyVar</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>manyDataConTy</span>
<a name="line-2460"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-2461"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2462"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>  <span class='hs-comment'>-- the common case</span>
<a name="line-2463"></a>
<a name="line-2464"></a><a name="approximateWC"></a><span class='hs-definition'>approximateWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-2465"></a><span class='hs-comment'>-- Postcondition: Wanted or Derived Cts</span>
<a name="line-2466"></a><span class='hs-comment'>-- See Note [ApproximateWC]</span>
<a name="line-2467"></a><span class='hs-comment'>-- See Note [floatKindEqualities vs approximateWC]</span>
<a name="line-2468"></a><span class='hs-definition'>approximateWC</span> <span class='hs-varid'>float_past_equalities</span> <span class='hs-varid'>wc</span>
<a name="line-2469"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>wc</span>
<a name="line-2470"></a>  <span class='hs-keyword'>where</span>
<a name="line-2471"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyCoVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-2472"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-2473"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>is_floatable</span> <span class='hs-varid'>trapping_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>simples</span> <span class='hs-varop'>`unionBags`</span>
<a name="line-2474"></a>        <span class='hs-varid'>concatMapBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>trapping_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span>
<a name="line-2475"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyCoVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-2476"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varid'>imp</span>
<a name="line-2477"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>float_past_equalities</span> <span class='hs-varop'>||</span> <span class='hs-varid'>ic_given_eqs</span> <span class='hs-varid'>imp</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>MaybeGivenEqs</span>
<a name="line-2478"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-2479"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Take care with equalities</span>
<a name="line-2480"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyCts</span>    <span class='hs-comment'>-- See (1) under Note [ApproximateWC]</span>
<a name="line-2481"></a>      <span class='hs-keyword'>where</span>
<a name="line-2482"></a>        <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>ic_skols</span> <span class='hs-varid'>imp</span>
<a name="line-2483"></a>
<a name="line-2484"></a>    <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>ct</span>
<a name="line-2485"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGivenCt</span> <span class='hs-varid'>ct</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2486"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleEqCt</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2487"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>skol_tvs</span>
<a name="line-2488"></a>
<a name="line-2489"></a><span class='hs-comment'>{- Note [ApproximateWC]
<a name="line-2490"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2491"></a>approximateWC takes a constraint, typically arising from the RHS of a
<a name="line-2492"></a>let-binding whose type we are *inferring*, and extracts from it some
<a name="line-2493"></a>*simple* constraints that we might plausibly abstract over.  Of course
<a name="line-2494"></a>the top-level simple constraints are plausible, but we also float constraints
<a name="line-2495"></a>out from inside, if they are not captured by skolems.
<a name="line-2496"></a>
<a name="line-2497"></a>The same function is used when doing type-class defaulting (see the call
<a name="line-2498"></a>to applyDefaultingRules) to extract constraints that might be defaulted.
<a name="line-2499"></a>
<a name="line-2500"></a>There is one caveat:
<a name="line-2501"></a>
<a name="line-2502"></a>1.  When inferring most-general types (in simplifyInfer), we do *not*
<a name="line-2503"></a>    float anything out if the implication binds equality constraints,
<a name="line-2504"></a>    because that defeats the OutsideIn story.  Consider
<a name="line-2505"></a>       data T a where
<a name="line-2506"></a>         TInt :: T Int
<a name="line-2507"></a>         MkT :: T a
<a name="line-2508"></a>
<a name="line-2509"></a>       f TInt = 3::Int
<a name="line-2510"></a>
<a name="line-2511"></a>    We get the implication (a ~ Int =&gt; res ~ Int), where so far we've decided
<a name="line-2512"></a>      f :: T a -&gt; res
<a name="line-2513"></a>    We don't want to float (res~Int) out because then we'll infer
<a name="line-2514"></a>      f :: T a -&gt; Int
<a name="line-2515"></a>    which is only on of the possible types. (GHC 7.6 accidentally *did*
<a name="line-2516"></a>    float out of such implications, which meant it would happily infer
<a name="line-2517"></a>    non-principal types.)
<a name="line-2518"></a>
<a name="line-2519"></a>   HOWEVER (#12797) in findDefaultableGroups we are not worried about
<a name="line-2520"></a>   the most-general type; and we /do/ want to float out of equalities.
<a name="line-2521"></a>   Hence the boolean flag to approximateWC.
<a name="line-2522"></a>
<a name="line-2523"></a>------ Historical note -----------
<a name="line-2524"></a>There used to be a second caveat, driven by #8155
<a name="line-2525"></a>
<a name="line-2526"></a>   2. We do not float out an inner constraint that shares a type variable
<a name="line-2527"></a>      (transitively) with one that is trapped by a skolem.  Eg
<a name="line-2528"></a>          forall a.  F a ~ beta, Integral beta
<a name="line-2529"></a>      We don't want to float out (Integral beta).  Doing so would be bad
<a name="line-2530"></a>      when defaulting, because then we'll default beta:=Integer, and that
<a name="line-2531"></a>      makes the error message much worse; we'd get
<a name="line-2532"></a>          Can't solve  F a ~ Integer
<a name="line-2533"></a>      rather than
<a name="line-2534"></a>          Can't solve  Integral (F a)
<a name="line-2535"></a>
<a name="line-2536"></a>      Moreover, floating out these "contaminated" constraints doesn't help
<a name="line-2537"></a>      when generalising either. If we generalise over (Integral b), we still
<a name="line-2538"></a>      can't solve the retained implication (forall a. F a ~ b).  Indeed,
<a name="line-2539"></a>      arguably that too would be a harder error to understand.
<a name="line-2540"></a>
<a name="line-2541"></a>But this transitive closure stuff gives rise to a complex rule for
<a name="line-2542"></a>when defaulting actually happens, and one that was never documented.
<a name="line-2543"></a>Moreover (#12923), the more complex rule is sometimes NOT what
<a name="line-2544"></a>you want.  So I simply removed the extra code to implement the
<a name="line-2545"></a>contamination stuff.  There was zero effect on the testsuite (not even #8155).
<a name="line-2546"></a>------ End of historical note -----------
<a name="line-2547"></a>
<a name="line-2548"></a>
<a name="line-2549"></a>Note [DefaultTyVar]
<a name="line-2550"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-2551"></a>defaultTyVar is used on any un-instantiated meta type variables to
<a name="line-2552"></a>default any RuntimeRep variables to LiftedRep.  This is important
<a name="line-2553"></a>to ensure that instance declarations match.  For example consider
<a name="line-2554"></a>
<a name="line-2555"></a>     instance Show (a-&gt;b)
<a name="line-2556"></a>     foo x = show (\_ -&gt; True)
<a name="line-2557"></a>
<a name="line-2558"></a>Then we'll get a constraint (Show (p -&gt;q)) where p has kind (TYPE r),
<a name="line-2559"></a>and that won't match the tcTypeKind (*) in the instance decl.  See tests
<a name="line-2560"></a>tc217 and tc175.
<a name="line-2561"></a>
<a name="line-2562"></a>We look only at touchable type variables. No further constraints
<a name="line-2563"></a>are going to affect these type variables, so it's time to do it by
<a name="line-2564"></a>hand.  However we aren't ready to default them fully to () or
<a name="line-2565"></a>whatever, because the type-class defaulting rules have yet to run.
<a name="line-2566"></a>
<a name="line-2567"></a>An alternate implementation would be to emit a derived constraint setting
<a name="line-2568"></a>the RuntimeRep variable to LiftedRep, but this seems unnecessarily indirect.
<a name="line-2569"></a>
<a name="line-2570"></a>Note [Promote _and_ default when inferring]
<a name="line-2571"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2572"></a>When we are inferring a type, we simplify the constraint, and then use
<a name="line-2573"></a>approximateWC to produce a list of candidate constraints.  Then we MUST
<a name="line-2574"></a>
<a name="line-2575"></a>  a) Promote any meta-tyvars that have been floated out by
<a name="line-2576"></a>     approximateWC, to restore invariant (WantedInv) described in
<a name="line-2577"></a>     Note [TcLevel invariants] in GHC.Tc.Utils.TcType.
<a name="line-2578"></a>
<a name="line-2579"></a>  b) Default the kind of any meta-tyvars that are not mentioned in
<a name="line-2580"></a>     in the environment.
<a name="line-2581"></a>
<a name="line-2582"></a>To see (b), suppose the constraint is (C ((a :: OpenKind) -&gt; Int)), and we
<a name="line-2583"></a>have an instance (C ((x:*) -&gt; Int)).  The instance doesn't match -- but it
<a name="line-2584"></a>should!  If we don't solve the constraint, we'll stupidly quantify over
<a name="line-2585"></a>(C (a-&gt;Int)) and, worse, in doing so skolemiseQuantifiedTyVar will quantify over
<a name="line-2586"></a>(b:*) instead of (a:OpenKind), which can lead to disaster; see #7332.
<a name="line-2587"></a>#7641 is a simpler example.
<a name="line-2588"></a>
<a name="line-2589"></a>Note [Promoting unification variables]
<a name="line-2590"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2591"></a>When we float an equality out of an implication we must "promote" free
<a name="line-2592"></a>unification variables of the equality, in order to maintain Invariant
<a name="line-2593"></a>(WantedInv) from Note [TcLevel invariants] in GHC.Tc.Types.TcType.
<a name="line-2594"></a>
<a name="line-2595"></a>This is absolutely necessary. Consider the following example. We start
<a name="line-2596"></a>with two implications and a class with a functional dependency.
<a name="line-2597"></a>
<a name="line-2598"></a>    class C x y | x -&gt; y
<a name="line-2599"></a>    instance C [a] [a]
<a name="line-2600"></a>
<a name="line-2601"></a>    (I1)      [untch=beta]forall b. 0 =&gt; F Int ~ [beta]
<a name="line-2602"></a>    (I2)      [untch=beta]forall c. 0 =&gt; F Int ~ [[alpha]] /\ C beta [c]
<a name="line-2603"></a>
<a name="line-2604"></a>We float (F Int ~ [beta]) out of I1, and we float (F Int ~ [[alpha]]) out of I2.
<a name="line-2605"></a>They may react to yield that (beta := [alpha]) which can then be pushed inwards
<a name="line-2606"></a>the leftover of I2 to get (C [alpha] [a]) which, using the FunDep, will mean that
<a name="line-2607"></a>(alpha := a). In the end we will have the skolem 'b' escaping in the untouchable
<a name="line-2608"></a>beta! Concrete example is in indexed_types/should_fail/ExtraTcsUntch.hs:
<a name="line-2609"></a>
<a name="line-2610"></a>    class C x y | x -&gt; y where
<a name="line-2611"></a>     op :: x -&gt; y -&gt; ()
<a name="line-2612"></a>
<a name="line-2613"></a>    instance C [a] [a]
<a name="line-2614"></a>
<a name="line-2615"></a>    type family F a :: *
<a name="line-2616"></a>
<a name="line-2617"></a>    h :: F Int -&gt; ()
<a name="line-2618"></a>    h = undefined
<a name="line-2619"></a>
<a name="line-2620"></a>    data TEx where
<a name="line-2621"></a>      TEx :: a -&gt; TEx
<a name="line-2622"></a>
<a name="line-2623"></a>    f (x::beta) =
<a name="line-2624"></a>        let g1 :: forall b. b -&gt; ()
<a name="line-2625"></a>            g1 _ = h [x]
<a name="line-2626"></a>            g2 z = case z of TEx y -&gt; (h [[undefined]], op x [y])
<a name="line-2627"></a>        in (g1 '3', g2 undefined)
<a name="line-2628"></a>
<a name="line-2629"></a>
<a name="line-2630"></a>*********************************************************************************
<a name="line-2631"></a>*                                                                               *
<a name="line-2632"></a>*                          Defaulting and disambiguation                        *
<a name="line-2633"></a>*                                                                               *
<a name="line-2634"></a>*********************************************************************************
<a name="line-2635"></a>-}</span>
<a name="line-2636"></a>
<a name="line-2637"></a><a name="applyDefaultingRules"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-2638"></a><span class='hs-comment'>-- True &lt;=&gt; I did some defaulting, by unifying a meta-tyvar</span>
<a name="line-2639"></a><span class='hs-comment'>-- Input WantedConstraints are not necessarily zonked</span>
<a name="line-2640"></a>
<a name="line-2641"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-varid'>wanteds</span>
<a name="line-2642"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-2643"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2644"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2645"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDefaultInfo</span>
<a name="line-2646"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanteds</span>               <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.zonkWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-2647"></a>
<a name="line-2648"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDefaultableGroups</span> <span class='hs-varid'>info</span> <span class='hs-varid'>wanteds</span>
<a name="line-2649"></a>
<a name="line-2650"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules {"</span> <span class='hs-varop'>$</span>
<a name="line-2651"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanteds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-2652"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"groups  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>groups</span>
<a name="line-2653"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"info    ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>]</span>
<a name="line-2654"></a>
<a name="line-2655"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>something_happeneds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>groups</span>
<a name="line-2656"></a>
<a name="line-2657"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>something_happeneds</span><span class='hs-layout'>)</span>
<a name="line-2658"></a>
<a name="line-2659"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>or</span> <span class='hs-varid'>something_happeneds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2660"></a>
<a name="line-2661"></a><a name="findDefaultableGroups"></a><span class='hs-definition'>findDefaultableGroups</span>
<a name="line-2662"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-2663"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>     <span class='hs-comment'>-- (Overloaded strings, extended default rules)</span>
<a name="line-2664"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>   <span class='hs-comment'>-- Unsolved (wanted or derived)</span>
<a name="line-2665"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVar</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-2666"></a><span class='hs-definition'>findDefaultableGroups</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span><span class='hs-layout'>,</span> <span class='hs-varid'>extended_defaults</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanteds</span>
<a name="line-2667"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>default_tys</span>
<a name="line-2668"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-2669"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2670"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>map</span> <span class='hs-varid'>fstOf3</span> <span class='hs-varid'>group</span><span class='hs-layout'>)</span>
<a name="line-2671"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>group'</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-conop'>:|</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unary_groups</span>
<a name="line-2672"></a>    <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>group</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toList</span> <span class='hs-varid'>group'</span>
<a name="line-2673"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>defaultable_tyvar</span> <span class='hs-varid'>tv</span>
<a name="line-2674"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>defaultable_classes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>sndOf3</span> <span class='hs-varid'>group</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-2675"></a>  <span class='hs-keyword'>where</span>
<a name="line-2676"></a>    <span class='hs-varid'>simples</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateWC</span> <span class='hs-conid'>True</span> <span class='hs-varid'>wanteds</span>
<a name="line-2677"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unaries</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_unaries</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionWith</span> <span class='hs-varid'>find_unary</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>simples</span><span class='hs-layout'>)</span>
<a name="line-2678"></a>    <span class='hs-varid'>unary_groups</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equivClasses</span> <span class='hs-varid'>cmp_tv</span> <span class='hs-varid'>unaries</span>
<a name="line-2679"></a>
<a name="line-2680"></a>    <span class='hs-varid'>unary_groups</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>NonEmpty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- (C tv) constraints</span>
<a name="line-2681"></a>    <span class='hs-varid'>unaries</span>      <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- (C tv) constraints</span>
<a name="line-2682"></a>    <span class='hs-varid'>non_unaries</span>  <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>                            <span class='hs-comment'>-- and *other* constraints</span>
<a name="line-2683"></a>
<a name="line-2684"></a>        <span class='hs-comment'>-- Finds unary type-class constraints</span>
<a name="line-2685"></a>        <span class='hs-comment'>-- But take account of polykinded classes like Typeable,</span>
<a name="line-2686"></a>        <span class='hs-comment'>-- which may look like (Typeable * (a:*))   (#8931)</span>
<a name="line-2687"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TyVar</span><span class='hs-layout'>)</span> <span class='hs-conid'>Ct</span>
<a name="line-2688"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span>
<a name="line-2689"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>cc</span><span class='hs-layout'>)</span>
<a name="line-2690"></a>        <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>filterOutInvisibleTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-2691"></a>              <span class='hs-comment'>-- Ignore invisible arguments for this purpose</span>
<a name="line-2692"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-2693"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv</span>  <span class='hs-comment'>-- We might have runtime-skolems in GHCi, and</span>
<a name="line-2694"></a>                          <span class='hs-comment'>-- we definitely don't want to try to assign to those!</span>
<a name="line-2695"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-2696"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>cc</span>  <span class='hs-comment'>-- Non unary or non dictionary</span>
<a name="line-2697"></a>
<a name="line-2698"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyCoVarSet</span>  <span class='hs-comment'>-- TyVars mentioned by non-unaries</span>
<a name="line-2699"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapUnionVarSet</span> <span class='hs-varid'>tyCoVarsOfCt</span> <span class='hs-varid'>non_unaries</span>
<a name="line-2700"></a>
<a name="line-2701"></a>    <span class='hs-varid'>cmp_tv</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>tv2</span>
<a name="line-2702"></a>
<a name="line-2703"></a>    <span class='hs-varid'>defaultable_tyvar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2704"></a>    <span class='hs-varid'>defaultable_tyvar</span> <span class='hs-varid'>tv</span>
<a name="line-2705"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>b1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyConableTyVar</span> <span class='hs-varid'>tv</span>  <span class='hs-comment'>-- Note [Avoiding spurious errors]</span>
<a name="line-2706"></a>              <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-2707"></a>          <span class='hs-keyword'>in</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>b2</span> <span class='hs-varop'>||</span> <span class='hs-varid'>extended_defaults</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Note [Multi-parameter defaults]</span>
<a name="line-2708"></a>
<a name="line-2709"></a>    <span class='hs-varid'>defaultable_classes</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Class</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2710"></a>    <span class='hs-varid'>defaultable_classes</span> <span class='hs-varid'>clss</span>
<a name="line-2711"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>extended_defaults</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>ovl_strings</span><span class='hs-layout'>)</span> <span class='hs-varid'>clss</span>
<a name="line-2712"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>clss</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-varid'>isNumClass</span> <span class='hs-varid'>ovl_strings</span><span class='hs-layout'>)</span> <span class='hs-varid'>clss</span><span class='hs-layout'>)</span>
<a name="line-2713"></a>
<a name="line-2714"></a>    <span class='hs-comment'>-- is_std_class adds IsString to the standard numeric classes,</span>
<a name="line-2715"></a>    <span class='hs-comment'>-- when -foverloaded-strings is enabled</span>
<a name="line-2716"></a>    <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStandardClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span>
<a name="line-2717"></a>                       <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2718"></a>
<a name="line-2719"></a><a name="disambigGroup"></a><span class='hs-comment'>------------------------------</span>
<a name="line-2720"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- The default types</span>
<a name="line-2721"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcTyVar</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- All classes of the form (C a)</span>
<a name="line-2722"></a>                                   <span class='hs-comment'>--  sharing same type variable</span>
<a name="line-2723"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- True &lt;=&gt; something happened, reflected in ty_binds</span>
<a name="line-2724"></a>
<a name="line-2725"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span>
<a name="line-2726"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2727"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_ty</span><span class='hs-conop'>:</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>group</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>the_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-2728"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2729"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fake_ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.newTcEvBinds</span>
<a name="line-2730"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tclvl</span>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcLevel</span>
<a name="line-2731"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>success</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>fake_ev_binds_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>pushTcLevel</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>try_group</span>
<a name="line-2732"></a>
<a name="line-2733"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>success</span> <span class='hs-keyword'>then</span>
<a name="line-2734"></a>             <span class='hs-comment'>-- Success: record the type variable binding, and return</span>
<a name="line-2735"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unifyTyVar</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>default_ty</span>
<a name="line-2736"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>wrapWarnTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>warnDefaulting</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>default_ty</span>
<a name="line-2737"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup succeeded }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-2738"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-2739"></a>         <span class='hs-keyword'>else</span>
<a name="line-2740"></a>             <span class='hs-comment'>-- Failure: try with the next type</span>
<a name="line-2741"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup failed, will try other default types }"</span>
<a name="line-2742"></a>                           <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-2743"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span> <span class='hs-varid'>group</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-2744"></a>  <span class='hs-keyword'>where</span>
<a name="line-2745"></a>    <span class='hs-varid'>try_group</span>
<a name="line-2746"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>subst</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mb_subst</span>
<a name="line-2747"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lcl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getLclEnv</span>
<a name="line-2748"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>tc_lvl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS.getTcLevel</span>
<a name="line-2749"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkGivenLoc</span> <span class='hs-varid'>tc_lvl</span> <span class='hs-conid'>UnkSkol</span> <span class='hs-varid'>lcl_env</span>
<a name="line-2750"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_evs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>newWantedEvVarNC</span> <span class='hs-varid'>loc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ctPred</span><span class='hs-layout'>)</span>
<a name="line-2751"></a>                                <span class='hs-varid'>wanteds</span>
<a name="line-2752"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>fmap</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varop'>$</span>
<a name="line-2753"></a>             <span class='hs-varid'>solveSimpleWanteds</span> <span class='hs-varop'>$</span> <span class='hs-varid'>listToBag</span> <span class='hs-varop'>$</span>
<a name="line-2754"></a>             <span class='hs-varid'>map</span> <span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>wanted_evs</span> <span class='hs-layout'>}</span>
<a name="line-2755"></a>
<a name="line-2756"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2757"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-2758"></a>
<a name="line-2759"></a>    <span class='hs-varid'>the_ty</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>the_tv</span>
<a name="line-2760"></a>    <span class='hs-varid'>mb_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcMatchTyKi</span> <span class='hs-varid'>the_ty</span> <span class='hs-varid'>default_ty</span>
<a name="line-2761"></a>      <span class='hs-comment'>-- Make sure the kinds match too; hence this call to tcMatchTyKi</span>
<a name="line-2762"></a>      <span class='hs-comment'>-- E.g. suppose the only constraint was (Typeable k (a::k))</span>
<a name="line-2763"></a>      <span class='hs-comment'>-- With the addition of polykinded defaulting we also want to reject</span>
<a name="line-2764"></a>      <span class='hs-comment'>-- ill-kinded defaulting attempts like (Eq []) or (Foldable Int) here.</span>
<a name="line-2765"></a>
<a name="line-2766"></a><a name="isInteractiveClass"></a><span class='hs-comment'>-- In interactive mode, or with -XExtendedDefaultRules,</span>
<a name="line-2767"></a><span class='hs-comment'>-- we default Show a to Show () to avoid graututious errors on "show []"</span>
<a name="line-2768"></a><span class='hs-definition'>isInteractiveClass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- -XOverloadedStrings?</span>
<a name="line-2769"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2770"></a><span class='hs-definition'>isInteractiveClass</span> <span class='hs-varid'>ovl_strings</span> <span class='hs-varid'>cls</span>
<a name="line-2771"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNumClass</span> <span class='hs-varid'>ovl_strings</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>classKey</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>interactiveClassKeys</span><span class='hs-layout'>)</span>
<a name="line-2772"></a>
<a name="line-2773"></a>    <span class='hs-comment'>-- isNumClass adds IsString to the standard numeric classes,</span>
<a name="line-2774"></a>    <span class='hs-comment'>-- when -foverloaded-strings is enabled</span>
<a name="line-2775"></a><a name="isNumClass"></a><span class='hs-definition'>isNumClass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- -XOverloadedStrings?</span>
<a name="line-2776"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-2777"></a><span class='hs-definition'>isNumClass</span> <span class='hs-varid'>ovl_strings</span> <span class='hs-varid'>cls</span>
<a name="line-2778"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNumericClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2779"></a>
<a name="line-2780"></a>
<a name="line-2781"></a><span class='hs-comment'>{-
<a name="line-2782"></a>Note [Avoiding spurious errors]
<a name="line-2783"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2784"></a>When doing the unification for defaulting, we check for skolem
<a name="line-2785"></a>type variables, and simply don't default them.  For example:
<a name="line-2786"></a>   f = (*)      -- Monomorphic
<a name="line-2787"></a>   g :: Num a =&gt; a -&gt; a
<a name="line-2788"></a>   g x = f x x
<a name="line-2789"></a>Here, we get a complaint when checking the type signature for g,
<a name="line-2790"></a>that g isn't polymorphic enough; but then we get another one when
<a name="line-2791"></a>dealing with the (Num a) context arising from f's definition;
<a name="line-2792"></a>we try to unify a with Int (to default it), but find that it's
<a name="line-2793"></a>already been unified with the rigid variable from g's type sig.
<a name="line-2794"></a>
<a name="line-2795"></a>Note [Multi-parameter defaults]
<a name="line-2796"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2797"></a>With -XExtendedDefaultRules, we default only based on single-variable
<a name="line-2798"></a>constraints, but do not exclude from defaulting any type variables which also
<a name="line-2799"></a>appear in multi-variable constraints. This means that the following will
<a name="line-2800"></a>default properly:
<a name="line-2801"></a>
<a name="line-2802"></a>   default (Integer, Double)
<a name="line-2803"></a>
<a name="line-2804"></a>   class A b (c :: Symbol) where
<a name="line-2805"></a>      a :: b -&gt; Proxy c
<a name="line-2806"></a>
<a name="line-2807"></a>   instance A Integer c where a _ = Proxy
<a name="line-2808"></a>
<a name="line-2809"></a>   main = print (a 5 :: Proxy "5")
<a name="line-2810"></a>
<a name="line-2811"></a>Note that if we change the above instance ("instance A Integer") to
<a name="line-2812"></a>"instance A Double", we get an error:
<a name="line-2813"></a>
<a name="line-2814"></a>   No instance for (A Integer "5")
<a name="line-2815"></a>
<a name="line-2816"></a>This is because the first defaulted type (Integer) has successfully satisfied
<a name="line-2817"></a>its single-parameter constraints (in this case Num).
<a name="line-2818"></a>-}</span>
</pre></body>
</html>
