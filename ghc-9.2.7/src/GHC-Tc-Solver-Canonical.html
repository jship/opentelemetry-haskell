<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Tc/Solver/Canonical.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE DeriveFunctor #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE MultiWayIf #-}</span>
<a name="line-4"></a>
<a name="line-5"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Tc.Solver.Canonical</span><span class='hs-layout'>(</span>
<a name="line-6"></a>     <span class='hs-varid'>canonicalize</span><span class='hs-layout'>,</span>
<a name="line-7"></a>     <span class='hs-varid'>unifyDerived</span><span class='hs-layout'>,</span>
<a name="line-8"></a>     <span class='hs-varid'>makeSuperClasses</span><span class='hs-layout'>,</span>
<a name="line-9"></a>     <span class='hs-conid'>StopOrContinue</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>stopWith</span><span class='hs-layout'>,</span> <span class='hs-varid'>continueWith</span><span class='hs-layout'>,</span> <span class='hs-varid'>andWhenContinue</span><span class='hs-layout'>,</span>
<a name="line-10"></a>     <span class='hs-varid'>solveCallStack</span>    <span class='hs-comment'>-- For GHC.Tc.Solver</span>
<a name="line-11"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-12"></a>
<a name="line-13"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-14"></a>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-16"></a>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Constraint</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Predicate</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Origin</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.Unify</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Utils.TcType</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver.Rewrite</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Solver.Monad</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Evidence</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.EvTerm</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Class</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span>   <span class='hs-comment'>-- cleverly decomposes types, good for completeness checking</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion.Axiom</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span><span class='hs-layout'>(</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span> <span class='hs-layout'>(</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Instance.Family</span> <span class='hs-layout'>(</span> <span class='hs-varid'>tcTopNormaliseNewTypeTF_maybe</span> <span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span><span class='hs-layout'>(</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span><span class='hs-layout'>(</span> <span class='hs-varid'>delVarSetList</span><span class='hs-layout'>,</span> <span class='hs-varid'>anyVarSet</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types</span> <span class='hs-layout'>(</span> <span class='hs-varid'>anyTypeOfKind</span> <span class='hs-layout'>)</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Set</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name.Reader</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Hs.Type</span><span class='hs-layout'>(</span> <span class='hs-conid'>HsIPName</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-46"></a>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Pair</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Bag</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Monad</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Maybe</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isJust</span><span class='hs-layout'>,</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>)</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>zip4</span> <span class='hs-layout'>)</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-55"></a>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Bifunctor</span> <span class='hs-layout'>(</span> <span class='hs-varid'>bimap</span> <span class='hs-layout'>)</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Foldable</span> <span class='hs-layout'>(</span> <span class='hs-varid'>traverse_</span> <span class='hs-layout'>)</span>
<a name="line-58"></a>
<a name="line-59"></a><span class='hs-comment'>{-
<a name="line-60"></a>************************************************************************
<a name="line-61"></a>*                                                                      *
<a name="line-62"></a>*                      The Canonicaliser                               *
<a name="line-63"></a>*                                                                      *
<a name="line-64"></a>************************************************************************
<a name="line-65"></a>
<a name="line-66"></a>Note [Canonicalization]
<a name="line-67"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-68"></a>
<a name="line-69"></a>Canonicalization converts a simple constraint to a canonical form. It is
<a name="line-70"></a>unary (i.e. treats individual constraints one at a time).
<a name="line-71"></a>
<a name="line-72"></a>Constraints originating from user-written code come into being as
<a name="line-73"></a>CNonCanonicals. We know nothing about these constraints. So, first:
<a name="line-74"></a>
<a name="line-75"></a>     Classify CNonCanoncal constraints, depending on whether they
<a name="line-76"></a>     are equalities, class predicates, or other.
<a name="line-77"></a>
<a name="line-78"></a>Then proceed depending on the shape of the constraint. Generally speaking,
<a name="line-79"></a>each constraint gets rewritten and then decomposed into one of several forms
<a name="line-80"></a>(see type Ct in GHC.Tc.Types).
<a name="line-81"></a>
<a name="line-82"></a>When an already-canonicalized constraint gets kicked out of the inert set,
<a name="line-83"></a>it must be recanonicalized. But we know a bit about its shape from the
<a name="line-84"></a>last time through, so we can skip the classification step.
<a name="line-85"></a>
<a name="line-86"></a>-}</span>
<a name="line-87"></a>
<a name="line-88"></a><span class='hs-comment'>-- Top-level canonicalization</span>
<a name="line-89"></a><span class='hs-comment'>-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="line-90"></a>
<a name="line-91"></a><a name="canonicalize"></a><span class='hs-definition'>canonicalize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-92"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CNonCanonical</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-93"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "canNC" #-}</span>
<a name="line-94"></a>    <span class='hs-varid'>canNC</span> <span class='hs-varid'>ev</span>
<a name="line-95"></a>
<a name="line-96"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CQuantCan</span> <span class='hs-layout'>(</span><span class='hs-conid'>QCI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>qci_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>qci_pend_sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pend_sc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-97"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canForAll</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>pend_sc</span>
<a name="line-98"></a>
<a name="line-99"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CIrredCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-100"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canNC</span> <span class='hs-varid'>ev</span>
<a name="line-101"></a>    <span class='hs-comment'>-- Instead of rewriting the evidence before classifying, it's possible we</span>
<a name="line-102"></a>    <span class='hs-comment'>-- can make progress without the rewrite. Try this first.</span>
<a name="line-103"></a>    <span class='hs-comment'>-- For insolubles (all of which are equalities), do /not/ rewrite the arguments</span>
<a name="line-104"></a>    <span class='hs-comment'>-- In #14350 doing so led entire-unnecessary and ridiculously large</span>
<a name="line-105"></a>    <span class='hs-comment'>-- type function expansion.  Instead, canEqNC just applies</span>
<a name="line-106"></a>    <span class='hs-comment'>-- the substitution to the predicate, and may do decomposition;</span>
<a name="line-107"></a>    <span class='hs-comment'>--    e.g. a ~ [a], where [G] a ~ [Int], can decompose</span>
<a name="line-108"></a>
<a name="line-109"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span>
<a name="line-110"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_pend_sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pend_sc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-111"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "canClass" #-}</span>
<a name="line-112"></a>    <span class='hs-varid'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span> <span class='hs-varid'>pend_sc</span>
<a name="line-113"></a>
<a name="line-114"></a><span class='hs-definition'>canonicalize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-115"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_lhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs</span>
<a name="line-116"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-117"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-118"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>{-# SCC "canEqLeafTyVarEq" #-}</span>
<a name="line-119"></a>    <span class='hs-varid'>canEqNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqLHSType</span> <span class='hs-varid'>lhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-120"></a>
<a name="line-121"></a><a name="canNC"></a><span class='hs-definition'>canNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-122"></a><span class='hs-definition'>canNC</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span>
<a name="line-123"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-124"></a>      <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:cls"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-125"></a>                                  <span class='hs-varid'>canClassNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-126"></a>      <span class='hs-conid'>EqPred</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:eq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-127"></a>                                  <span class='hs-varid'>canEqNC</span>    <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-128"></a>      <span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-129"></a>                                  <span class='hs-varid'>canIrred</span> <span class='hs-varid'>ev</span>
<a name="line-130"></a>      <span class='hs-conid'>ForAllPred</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>th</span> <span class='hs-varid'>p</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:forall"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-131"></a>                                  <span class='hs-varid'>canForAllNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>th</span> <span class='hs-varid'>p</span>
<a name="line-132"></a>  <span class='hs-keyword'>where</span>
<a name="line-133"></a>    <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span>
<a name="line-134"></a>
<a name="line-135"></a><span class='hs-comment'>{-
<a name="line-136"></a>************************************************************************
<a name="line-137"></a>*                                                                      *
<a name="line-138"></a>*                      Class Canonicalization
<a name="line-139"></a>*                                                                      *
<a name="line-140"></a>************************************************************************
<a name="line-141"></a>-}</span>
<a name="line-142"></a>
<a name="line-143"></a><a name="canClassNC"></a><span class='hs-definition'>canClassNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-144"></a><span class='hs-comment'>-- "NC" means "non-canonical"; that is, we have got here</span>
<a name="line-145"></a><span class='hs-comment'>-- from a NonCanonical constraint, not from a CDictCan</span>
<a name="line-146"></a><span class='hs-comment'>-- Precondition: EvVar is class evidence</span>
<a name="line-147"></a><span class='hs-definition'>canClassNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-148"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span>  <span class='hs-comment'>-- See Note [Eagerly expand given superclasses]</span>
<a name="line-149"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkStrictSuperClasses</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-150"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWork</span> <span class='hs-varid'>sc_cts</span>
<a name="line-151"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-152"></a>
<a name="line-153"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span>
<a name="line-154"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ip_name</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isCallStackPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-155"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>OccurrenceOf</span> <span class='hs-varid'>func</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ctLocOrigin</span> <span class='hs-varid'>loc</span>
<a name="line-156"></a>  <span class='hs-comment'>-- If we're given a CallStack constraint that arose from a function</span>
<a name="line-157"></a>  <span class='hs-comment'>-- call, we need to push the current call-site onto the stack instead</span>
<a name="line-158"></a>  <span class='hs-comment'>-- of solving it directly from a given.</span>
<a name="line-159"></a>  <span class='hs-comment'>-- See Note [Overview of implicit CallStacks] in GHC.Tc.Types.Evidence</span>
<a name="line-160"></a>  <span class='hs-comment'>-- and Note [Solving CallStack constraints] in GHC.Tc.Solver.Monad</span>
<a name="line-161"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- First we emit a new constraint that will capture the</span>
<a name="line-162"></a>         <span class='hs-comment'>-- given CallStack.</span>
<a name="line-163"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setCtLocOrigin</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-conid'>IPOccOrigin</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsIPName</span> <span class='hs-varid'>ip_name</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-164"></a>                            <span class='hs-comment'>-- We change the origin to IPOccOrigin so</span>
<a name="line-165"></a>                            <span class='hs-comment'>-- this rule does not fire again.</span>
<a name="line-166"></a>                            <span class='hs-comment'>-- See Note [Overview of implicit CallStacks]</span>
<a name="line-167"></a>
<a name="line-168"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWantedEvVarNC</span> <span class='hs-varid'>new_loc</span> <span class='hs-varid'>pred</span>
<a name="line-169"></a>
<a name="line-170"></a>         <span class='hs-comment'>-- Then we solve the wanted by pushing the call-site</span>
<a name="line-171"></a>         <span class='hs-comment'>-- onto the newly emitted CallStack</span>
<a name="line-172"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ev_cs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvCsPushCall</span> <span class='hs-varid'>func</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctLocSpan</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvExpr</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span>
<a name="line-173"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solveCallStack</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ev_cs</span>
<a name="line-174"></a>
<a name="line-175"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canClass</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-176"></a>
<a name="line-177"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-178"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>(</span><span class='hs-varid'>has_scs</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span>
<a name="line-179"></a>
<a name="line-180"></a>  <span class='hs-keyword'>where</span>
<a name="line-181"></a>    <span class='hs-varid'>has_scs</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>classSCTheta</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-182"></a>    <span class='hs-varid'>loc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span>
<a name="line-183"></a>    <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span>
<a name="line-184"></a>
<a name="line-185"></a><a name="solveCallStack"></a><span class='hs-definition'>solveCallStack</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EvCallStack</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-186"></a><span class='hs-comment'>-- Also called from GHC.Tc.Solver when defaulting call stacks</span>
<a name="line-187"></a><span class='hs-definition'>solveCallStack</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ev_cs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-188"></a>  <span class='hs-comment'>-- We're given ev_cs :: CallStack, but the evidence term should be a</span>
<a name="line-189"></a>  <span class='hs-comment'>-- dictionary, so we have to coerce ev_cs to a dictionary for</span>
<a name="line-190"></a>  <span class='hs-comment'>-- `IP ip CallStack`. See Note [Overview of implicit CallStacks]</span>
<a name="line-191"></a>  <span class='hs-varid'>cs_tm</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>evCallStack</span> <span class='hs-varid'>ev_cs</span>
<a name="line-192"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>ev_tm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEvCast</span> <span class='hs-varid'>cs_tm</span> <span class='hs-layout'>(</span><span class='hs-varid'>wrapIP</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-193"></a>  <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ev_tm</span>
<a name="line-194"></a>
<a name="line-195"></a><a name="canClass"></a><span class='hs-definition'>canClass</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-196"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-197"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>            <span class='hs-comment'>-- True &lt;=&gt; un-explored superclasses</span>
<a name="line-198"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-199"></a><span class='hs-comment'>-- Precondition: EvVar is class evidence</span>
<a name="line-200"></a>
<a name="line-201"></a><span class='hs-definition'>canClass</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>pend_sc</span>
<a name="line-202"></a>  <span class='hs-keyglyph'>=</span>   <span class='hs-comment'>-- all classes do *nominal* matching</span>
<a name="line-203"></a>    <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>)</span>
<a name="line-204"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteArgsNom</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>cls_tc</span> <span class='hs-varid'>tys</span>
<a name="line-205"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>cls_tc</span> <span class='hs-varid'>cos</span>
<a name="line-206"></a>             <span class='hs-varid'>xi</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>xis</span>
<a name="line-207"></a>             <span class='hs-varid'>mk_ct</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span>
<a name="line-208"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-209"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span>
<a name="line-210"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>cc_pend_sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pend_sc</span> <span class='hs-layout'>}</span>
<a name="line-211"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span>
<a name="line-212"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canClass"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span>
<a name="line-213"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mb</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-214"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>mk_ct</span> <span class='hs-varid'>mb</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-215"></a>  <span class='hs-keyword'>where</span>
<a name="line-216"></a>    <span class='hs-varid'>cls_tc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classTyCon</span> <span class='hs-varid'>cls</span>
<a name="line-217"></a>
<a name="line-218"></a><span class='hs-comment'>{- Note [The superclass story]
<a name="line-219"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-220"></a>We need to add superclass constraints for two reasons:
<a name="line-221"></a>
<a name="line-222"></a>* For givens [G], they give us a route to proof.  E.g.
<a name="line-223"></a>    f :: Ord a =&gt; a -&gt; Bool
<a name="line-224"></a>    f x = x == x
<a name="line-225"></a>  We get a Wanted (Eq a), which can only be solved from the superclass
<a name="line-226"></a>  of the Given (Ord a).
<a name="line-227"></a>
<a name="line-228"></a>* For wanteds [W], and deriveds [WD], [D], they may give useful
<a name="line-229"></a>  functional dependencies.  E.g.
<a name="line-230"></a>     class C a b | a -&gt; b where ...
<a name="line-231"></a>     class C a b =&gt; D a b where ...
<a name="line-232"></a>  Now a [W] constraint (D Int beta) has (C Int beta) as a superclass
<a name="line-233"></a>  and that might tell us about beta, via C's fundeps.  We can get this
<a name="line-234"></a>  by generating a [D] (C Int beta) constraint.  It's derived because
<a name="line-235"></a>  we don't actually have to cough up any evidence for it; it's only there
<a name="line-236"></a>  to generate fundep equalities.
<a name="line-237"></a>
<a name="line-238"></a>See Note [Why adding superclasses can help].
<a name="line-239"></a>
<a name="line-240"></a>For these reasons we want to generate superclass constraints for both
<a name="line-241"></a>Givens and Wanteds. But:
<a name="line-242"></a>
<a name="line-243"></a>* (Minor) they are often not needed, so generating them aggressively
<a name="line-244"></a>  is a waste of time.
<a name="line-245"></a>
<a name="line-246"></a>* (Major) if we want recursive superclasses, there would be an infinite
<a name="line-247"></a>  number of them.  Here is a real-life example (#10318);
<a name="line-248"></a>
<a name="line-249"></a>     class (Frac (Frac a) ~ Frac a,
<a name="line-250"></a>            Fractional (Frac a),
<a name="line-251"></a>            IntegralDomain (Frac a))
<a name="line-252"></a>         =&gt; IntegralDomain a where
<a name="line-253"></a>      type Frac a :: *
<a name="line-254"></a>
<a name="line-255"></a>  Notice that IntegralDomain has an associated type Frac, and one
<a name="line-256"></a>  of IntegralDomain's superclasses is another IntegralDomain constraint.
<a name="line-257"></a>
<a name="line-258"></a>So here's the plan:
<a name="line-259"></a>
<a name="line-260"></a>1. Eagerly generate superclasses for given (but not wanted)
<a name="line-261"></a>   constraints; see Note [Eagerly expand given superclasses].
<a name="line-262"></a>   This is done using mkStrictSuperClasses in canClassNC, when
<a name="line-263"></a>   we take a non-canonical Given constraint and cannonicalise it.
<a name="line-264"></a>
<a name="line-265"></a>   However stop if you encounter the same class twice.  That is,
<a name="line-266"></a>   mkStrictSuperClasses expands eagerly, but has a conservative
<a name="line-267"></a>   termination condition: see Note [Expanding superclasses] in GHC.Tc.Utils.TcType.
<a name="line-268"></a>
<a name="line-269"></a>2. Solve the wanteds as usual, but do no further expansion of
<a name="line-270"></a>   superclasses for canonical CDictCans in solveSimpleGivens or
<a name="line-271"></a>   solveSimpleWanteds; Note [Danger of adding superclasses during solving]
<a name="line-272"></a>
<a name="line-273"></a>   However, /do/ continue to eagerly expand superclasses for new /given/
<a name="line-274"></a>   /non-canonical/ constraints (canClassNC does this).  As #12175
<a name="line-275"></a>   showed, a type-family application can expand to a class constraint,
<a name="line-276"></a>   and we want to see its superclasses for just the same reason as
<a name="line-277"></a>   Note [Eagerly expand given superclasses].
<a name="line-278"></a>
<a name="line-279"></a>3. If we have any remaining unsolved wanteds
<a name="line-280"></a>        (see Note [When superclasses help] in GHC.Tc.Types.Constraint)
<a name="line-281"></a>   try harder: take both the Givens and Wanteds, and expand
<a name="line-282"></a>   superclasses again.  See the calls to expandSuperClasses in
<a name="line-283"></a>   GHC.Tc.Solver.simpl_loop and solveWanteds.
<a name="line-284"></a>
<a name="line-285"></a>   This may succeed in generating (a finite number of) extra Givens,
<a name="line-286"></a>   and extra Deriveds. Both may help the proof.
<a name="line-287"></a>
<a name="line-288"></a>3a An important wrinkle: only expand Givens from the current level.
<a name="line-289"></a>   Two reasons:
<a name="line-290"></a>      - We only want to expand it once, and that is best done at
<a name="line-291"></a>        the level it is bound, rather than repeatedly at the leaves
<a name="line-292"></a>        of the implication tree
<a name="line-293"></a>      - We may be inside a type where we can't create term-level
<a name="line-294"></a>        evidence anyway, so we can't superclass-expand, say,
<a name="line-295"></a>        (a ~ b) to get (a ~# b).  This happened in #15290.
<a name="line-296"></a>
<a name="line-297"></a>4. Go round to (2) again.  This loop (2,3,4) is implemented
<a name="line-298"></a>   in GHC.Tc.Solver.simpl_loop.
<a name="line-299"></a>
<a name="line-300"></a>The cc_pend_sc flag in a CDictCan records whether the superclasses of
<a name="line-301"></a>this constraint have been expanded.  Specifically, in Step 3 we only
<a name="line-302"></a>expand superclasses for constraints with cc_pend_sc set to true (i.e.
<a name="line-303"></a>isPendingScDict holds).
<a name="line-304"></a>
<a name="line-305"></a>Why do we do this?  Two reasons:
<a name="line-306"></a>
<a name="line-307"></a>* To avoid repeated work, by repeatedly expanding the superclasses of
<a name="line-308"></a>  same constraint,
<a name="line-309"></a>
<a name="line-310"></a>* To terminate the above loop, at least in the -XNoRecursiveSuperClasses
<a name="line-311"></a>  case.  If there are recursive superclasses we could, in principle,
<a name="line-312"></a>  expand forever, always encountering new constraints.
<a name="line-313"></a>
<a name="line-314"></a>When we take a CNonCanonical or CIrredCan, but end up classifying it
<a name="line-315"></a>as a CDictCan, we set the cc_pend_sc flag to False.
<a name="line-316"></a>
<a name="line-317"></a>Note [Superclass loops]
<a name="line-318"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-319"></a>Suppose we have
<a name="line-320"></a>  class C a =&gt; D a
<a name="line-321"></a>  class D a =&gt; C a
<a name="line-322"></a>
<a name="line-323"></a>Then, when we expand superclasses, we'll get back to the self-same
<a name="line-324"></a>predicate, so we have reached a fixpoint in expansion and there is no
<a name="line-325"></a>point in fruitlessly expanding further.  This case just falls out from
<a name="line-326"></a>our strategy.  Consider
<a name="line-327"></a>  f :: C a =&gt; a -&gt; Bool
<a name="line-328"></a>  f x = x==x
<a name="line-329"></a>Then canClassNC gets the [G] d1: C a constraint, and eager emits superclasses
<a name="line-330"></a>G] d2: D a, [G] d3: C a (psc).  (The "psc" means it has its sc_pend flag set.)
<a name="line-331"></a>When processing d3 we find a match with d1 in the inert set, and we always
<a name="line-332"></a>keep the inert item (d1) if possible: see Note [Replacement vs keeping] in
<a name="line-333"></a>GHC.Tc.Solver.Interact.  So d3 dies a quick, happy death.
<a name="line-334"></a>
<a name="line-335"></a>Note [Eagerly expand given superclasses]
<a name="line-336"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-337"></a>In step (1) of Note [The superclass story], why do we eagerly expand
<a name="line-338"></a>Given superclasses by one layer?  (By "one layer" we mean expand transitively
<a name="line-339"></a>until you meet the same class again -- the conservative criterion embodied
<a name="line-340"></a>in expandSuperClasses.  So a "layer" might be a whole stack of superclasses.)
<a name="line-341"></a>We do this eagerly for Givens mainly because of some very obscure
<a name="line-342"></a>cases like this:
<a name="line-343"></a>
<a name="line-344"></a>   instance Bad a =&gt; Eq (T a)
<a name="line-345"></a>
<a name="line-346"></a>   f :: (Ord (T a)) =&gt; blah
<a name="line-347"></a>   f x = ....needs Eq (T a), Ord (T a)....
<a name="line-348"></a>
<a name="line-349"></a>Here if we can't satisfy (Eq (T a)) from the givens we'll use the
<a name="line-350"></a>instance declaration; but then we are stuck with (Bad a).  Sigh.
<a name="line-351"></a>This is really a case of non-confluent proofs, but to stop our users
<a name="line-352"></a>complaining we expand one layer in advance.
<a name="line-353"></a>
<a name="line-354"></a>Note [Instance and Given overlap] in GHC.Tc.Solver.Interact.
<a name="line-355"></a>
<a name="line-356"></a>We also want to do this if we have
<a name="line-357"></a>
<a name="line-358"></a>   f :: F (T a) =&gt; blah
<a name="line-359"></a>
<a name="line-360"></a>where
<a name="line-361"></a>   type instance F (T a) = Ord (T a)
<a name="line-362"></a>
<a name="line-363"></a>So we may need to do a little work on the givens to expose the
<a name="line-364"></a>class that has the superclasses.  That's why the superclass
<a name="line-365"></a>expansion for Givens happens in canClassNC.
<a name="line-366"></a>
<a name="line-367"></a>This same scenario happens with quantified constraints, whose superclasses
<a name="line-368"></a>are also eagerly expanded. Test case: typecheck/should_compile/T16502b
<a name="line-369"></a>These are handled in canForAllNC, analogously to canClassNC.
<a name="line-370"></a>
<a name="line-371"></a>Note [Why adding superclasses can help]
<a name="line-372"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-373"></a>Examples of how adding superclasses can help:
<a name="line-374"></a>
<a name="line-375"></a>    --- Example 1
<a name="line-376"></a>        class C a b | a -&gt; b
<a name="line-377"></a>    Suppose we want to solve
<a name="line-378"></a>         [G] C a b
<a name="line-379"></a>         [W] C a beta
<a name="line-380"></a>    Then adding [D] beta~b will let us solve it.
<a name="line-381"></a>
<a name="line-382"></a>    -- Example 2 (similar but using a type-equality superclass)
<a name="line-383"></a>        class (F a ~ b) =&gt; C a b
<a name="line-384"></a>    And try to sllve:
<a name="line-385"></a>         [G] C a b
<a name="line-386"></a>         [W] C a beta
<a name="line-387"></a>    Follow the superclass rules to add
<a name="line-388"></a>         [G] F a ~ b
<a name="line-389"></a>         [D] F a ~ beta
<a name="line-390"></a>    Now we get [D] beta ~ b, and can solve that.
<a name="line-391"></a>
<a name="line-392"></a>    -- Example (tcfail138)
<a name="line-393"></a>      class L a b | a -&gt; b
<a name="line-394"></a>      class (G a, L a b) =&gt; C a b
<a name="line-395"></a>
<a name="line-396"></a>      instance C a b' =&gt; G (Maybe a)
<a name="line-397"></a>      instance C a b  =&gt; C (Maybe a) a
<a name="line-398"></a>      instance L (Maybe a) a
<a name="line-399"></a>
<a name="line-400"></a>    When solving the superclasses of the (C (Maybe a) a) instance, we get
<a name="line-401"></a>      [G] C a b, and hance by superclasses, [G] G a, [G] L a b
<a name="line-402"></a>      [W] G (Maybe a)
<a name="line-403"></a>    Use the instance decl to get
<a name="line-404"></a>      [W] C a beta
<a name="line-405"></a>    Generate its derived superclass
<a name="line-406"></a>      [D] L a beta.  Now using fundeps, combine with [G] L a b to get
<a name="line-407"></a>      [D] beta ~ b
<a name="line-408"></a>    which is what we want.
<a name="line-409"></a>
<a name="line-410"></a>Note [Danger of adding superclasses during solving]
<a name="line-411"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-412"></a>Here's a serious, but now out-dated example, from #4497:
<a name="line-413"></a>
<a name="line-414"></a>   class Num (RealOf t) =&gt; Normed t
<a name="line-415"></a>   type family RealOf x
<a name="line-416"></a>
<a name="line-417"></a>Assume the generated wanted constraint is:
<a name="line-418"></a>   [W] RealOf e ~ e
<a name="line-419"></a>   [W] Normed e
<a name="line-420"></a>
<a name="line-421"></a>If we were to be adding the superclasses during simplification we'd get:
<a name="line-422"></a>   [W] RealOf e ~ e
<a name="line-423"></a>   [W] Normed e
<a name="line-424"></a>   [D] RealOf e ~ fuv
<a name="line-425"></a>   [D] Num fuv
<a name="line-426"></a>==&gt;
<a name="line-427"></a>   e := fuv, Num fuv, Normed fuv, RealOf fuv ~ fuv
<a name="line-428"></a>
<a name="line-429"></a>While looks exactly like our original constraint. If we add the
<a name="line-430"></a>superclass of (Normed fuv) again we'd loop.  By adding superclasses
<a name="line-431"></a>definitely only once, during canonicalisation, this situation can't
<a name="line-432"></a>happen.
<a name="line-433"></a>
<a name="line-434"></a>Mind you, now that Wanteds cannot rewrite Derived, I think this particular
<a name="line-435"></a>situation can't happen.
<a name="line-436"></a>
<a name="line-437"></a>Note [Nested quantified constraint superclasses]
<a name="line-438"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-439"></a>Consider (typecheck/should_compile/T17202)
<a name="line-440"></a>
<a name="line-441"></a>  class C1 a
<a name="line-442"></a>  class (forall c. C1 c) =&gt; C2 a
<a name="line-443"></a>  class (forall b. (b ~ F a) =&gt; C2 a) =&gt; C3 a
<a name="line-444"></a>
<a name="line-445"></a>Elsewhere in the code, we get a [G] g1 :: C3 a. We expand its superclass
<a name="line-446"></a>to get [G] g2 :: (forall b. (b ~ F a) =&gt; C2 a). This constraint has a
<a name="line-447"></a>superclass, as well. But we now must be careful: we cannot just add
<a name="line-448"></a>(forall c. C1 c) as a Given, because we need to remember g2's context.
<a name="line-449"></a>That new constraint is Given only when forall b. (b ~ F a) is true.
<a name="line-450"></a>
<a name="line-451"></a>It's tempting to make the new Given be (forall b. (b ~ F a) =&gt; forall c. C1 c),
<a name="line-452"></a>but that's problematic, because it's nested, and ForAllPred is not capable
<a name="line-453"></a>of representing a nested quantified constraint. (We could change ForAllPred
<a name="line-454"></a>to allow this, but the solution in this Note is much more local and simpler.)
<a name="line-455"></a>
<a name="line-456"></a>So, we swizzle it around to get (forall b c. (b ~ F a) =&gt; C1 c).
<a name="line-457"></a>
<a name="line-458"></a>More generally, if we are expanding the superclasses of
<a name="line-459"></a>  g0 :: forall tvs. theta =&gt; cls tys
<a name="line-460"></a>and find a superclass constraint
<a name="line-461"></a>  forall sc_tvs. sc_theta =&gt; sc_inner_pred
<a name="line-462"></a>we must have a selector
<a name="line-463"></a>  sel_id :: forall cls_tvs. cls cls_tvs -&gt; forall sc_tvs. sc_theta =&gt; sc_inner_pred
<a name="line-464"></a>and thus build
<a name="line-465"></a>  g_sc :: forall tvs sc_tvs. theta =&gt; sc_theta =&gt; sc_inner_pred
<a name="line-466"></a>  g_sc = /\ tvs. /\ sc_tvs. \ theta_ids. \ sc_theta_ids.
<a name="line-467"></a>         sel_id tys (g0 tvs theta_ids) sc_tvs sc_theta_ids
<a name="line-468"></a>
<a name="line-469"></a>Actually, we cheat a bit by eta-reducing: note that sc_theta_ids are both the
<a name="line-470"></a>last bound variables and the last arguments. This avoids the need to produce
<a name="line-471"></a>the sc_theta_ids at all. So our final construction is
<a name="line-472"></a>
<a name="line-473"></a>  g_sc = /\ tvs. /\ sc_tvs. \ theta_ids.
<a name="line-474"></a>         sel_id tys (g0 tvs theta_ids) sc_tvs
<a name="line-475"></a>
<a name="line-476"></a>  -}</span>
<a name="line-477"></a>
<a name="line-478"></a><a name="makeSuperClasses"></a><span class='hs-definition'>makeSuperClasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-479"></a><span class='hs-comment'>-- Returns strict superclasses, transitively, see Note [The superclasses story]</span>
<a name="line-480"></a><span class='hs-comment'>-- See Note [The superclass story]</span>
<a name="line-481"></a><span class='hs-comment'>-- The loop-breaking here follows Note [Expanding superclasses] in GHC.Tc.Utils.TcType</span>
<a name="line-482"></a><span class='hs-comment'>-- Specifically, for an incoming (C t) constraint, we return all of (C t)'s</span>
<a name="line-483"></a><span class='hs-comment'>--    superclasses, up to /and including/ the first repetition of C</span>
<a name="line-484"></a><span class='hs-comment'>--</span>
<a name="line-485"></a><span class='hs-comment'>-- Example:  class D a =&gt; C a</span>
<a name="line-486"></a><span class='hs-comment'>--           class C [a] =&gt; D a</span>
<a name="line-487"></a><span class='hs-comment'>-- makeSuperClasses (C x) will return (D x, C [x])</span>
<a name="line-488"></a><span class='hs-comment'>--</span>
<a name="line-489"></a><span class='hs-comment'>-- NB: the incoming constraints have had their cc_pend_sc flag already</span>
<a name="line-490"></a><span class='hs-comment'>--     flipped to False, by isPendingScDict, so we are /obliged/ to at</span>
<a name="line-491"></a><span class='hs-comment'>--     least produce the immediate superclasses</span>
<a name="line-492"></a><span class='hs-definition'>makeSuperClasses</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMapM</span> <span class='hs-varid'>go</span> <span class='hs-varid'>cts</span>
<a name="line-493"></a>  <span class='hs-keyword'>where</span>
<a name="line-494"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-495"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkStrictSuperClasses</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-496"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>CQuantCan</span> <span class='hs-layout'>(</span><span class='hs-conid'>QCI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>qci_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>qci_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-497"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isClassPred</span> <span class='hs-varid'>pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- The cts should all have</span>
<a name="line-498"></a>                                               <span class='hs-comment'>-- class pred heads</span>
<a name="line-499"></a>        <span class='hs-varid'>mkStrictSuperClasses</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-500"></a>      <span class='hs-keyword'>where</span>
<a name="line-501"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitDFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-502"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"makeSuperClasses"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-503"></a>
<a name="line-504"></a><a name="mkStrictSuperClasses"></a><span class='hs-definition'>mkStrictSuperClasses</span>
<a name="line-505"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-506"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span>  <span class='hs-comment'>-- These two args are non-empty only when taking</span>
<a name="line-507"></a>                             <span class='hs-comment'>-- superclasses of a /quantified/ constraint</span>
<a name="line-508"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-509"></a><span class='hs-comment'>-- Return constraints for the strict superclasses of</span>
<a name="line-510"></a><span class='hs-comment'>--   ev :: forall as. theta =&gt; cls tys</span>
<a name="line-511"></a><span class='hs-definition'>mkStrictSuperClasses</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-512"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_strict_superclasses</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitNameSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>className</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-513"></a>                           <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-514"></a>
<a name="line-515"></a><a name="mk_strict_superclasses"></a><span class='hs-definition'>mk_strict_superclasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-516"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span>
<a name="line-517"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-518"></a><span class='hs-comment'>-- Always return the immediate superclasses of (cls tys);</span>
<a name="line-519"></a><span class='hs-comment'>-- and expand their superclasses, provided none of them are in rec_clss</span>
<a name="line-520"></a><span class='hs-comment'>-- nor are repeated</span>
<a name="line-521"></a><span class='hs-definition'>mk_strict_superclasses</span> <span class='hs-varid'>rec_clss</span> <span class='hs-layout'>(</span><span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evar</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-522"></a>                       <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-523"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>concatMapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>do_one_given</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_given_loc</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-524"></a>    <span class='hs-varid'>classSCSelIds</span> <span class='hs-varid'>cls</span>
<a name="line-525"></a>  <span class='hs-keyword'>where</span>
<a name="line-526"></a>    <span class='hs-varid'>dict_ids</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTemplateLocals</span> <span class='hs-varid'>theta</span>
<a name="line-527"></a>    <span class='hs-varid'>size</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeTypes</span> <span class='hs-varid'>tys</span>
<a name="line-528"></a>
<a name="line-529"></a>    <span class='hs-varid'>do_one_given</span> <span class='hs-varid'>given_loc</span> <span class='hs-varid'>sel_id</span>
<a name="line-530"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-varid'>sc_pred</span>
<a name="line-531"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-532"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See Note [Equality superclasses in quantified constraints]</span>
<a name="line-533"></a>        <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>
<a name="line-534"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-535"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>given_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEvVar</span> <span class='hs-varid'>given_loc</span> <span class='hs-varop'>$</span>
<a name="line-536"></a>                         <span class='hs-varid'>mk_given_desc</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>sc_pred</span>
<a name="line-537"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>mk_superclasses</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varid'>given_ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>sc_pred</span> <span class='hs-layout'>}</span>
<a name="line-538"></a>      <span class='hs-keyword'>where</span>
<a name="line-539"></a>        <span class='hs-varid'>sc_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>classMethodInstTy</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>tys</span>
<a name="line-540"></a>
<a name="line-541"></a>      <span class='hs-comment'>-- See Note [Nested quantified constraint superclasses]</span>
<a name="line-542"></a>    <span class='hs-varid'>mk_given_desc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>PredType</span><span class='hs-layout'>,</span> <span class='hs-conid'>EvTerm</span><span class='hs-layout'>)</span>
<a name="line-543"></a>    <span class='hs-varid'>mk_given_desc</span> <span class='hs-varid'>sel_id</span> <span class='hs-varid'>sc_pred</span>
<a name="line-544"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>swizzled_pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>swizzled_evterm</span><span class='hs-layout'>)</span>
<a name="line-545"></a>      <span class='hs-keyword'>where</span>
<a name="line-546"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>sc_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_rho</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitForAllTyCoVars</span> <span class='hs-varid'>sc_pred</span>
<a name="line-547"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>sc_theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>sc_inner_pred</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitFunTys</span> <span class='hs-varid'>sc_rho</span>
<a name="line-548"></a>
<a name="line-549"></a>        <span class='hs-varid'>all_tvs</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`chkAppend`</span> <span class='hs-varid'>sc_tvs</span>
<a name="line-550"></a>        <span class='hs-varid'>all_theta</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>theta</span> <span class='hs-varop'>`chkAppend`</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-varid'>sc_theta</span><span class='hs-layout'>)</span>
<a name="line-551"></a>        <span class='hs-varid'>swizzled_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInfSigmaTy</span> <span class='hs-varid'>all_tvs</span> <span class='hs-varid'>all_theta</span> <span class='hs-varid'>sc_inner_pred</span>
<a name="line-552"></a>
<a name="line-553"></a>        <span class='hs-comment'>-- evar :: forall tvs. theta =&gt; cls tys</span>
<a name="line-554"></a>        <span class='hs-comment'>-- sel_id :: forall cls_tvs. cls cls_tvs</span>
<a name="line-555"></a>        <span class='hs-comment'>--                        -&gt; forall sc_tvs. sc_theta =&gt; sc_inner_pred</span>
<a name="line-556"></a>        <span class='hs-comment'>-- swizzled_evterm :: forall tvs sc_tvs. theta =&gt; sc_theta =&gt; sc_inner_pred</span>
<a name="line-557"></a>        <span class='hs-varid'>swizzled_evterm</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>EvExpr</span> <span class='hs-varop'>$</span>
<a name="line-558"></a>          <span class='hs-varid'>mkLams</span> <span class='hs-varid'>all_tvs</span> <span class='hs-varop'>$</span>
<a name="line-559"></a>          <span class='hs-varid'>mkLams</span> <span class='hs-varid'>dict_ids</span> <span class='hs-varop'>$</span>
<a name="line-560"></a>          <span class='hs-conid'>Var</span> <span class='hs-varid'>sel_id</span>
<a name="line-561"></a>            <span class='hs-varop'>`mkTyApps`</span> <span class='hs-varid'>tys</span>
<a name="line-562"></a>            <span class='hs-varop'>`App`</span> <span class='hs-layout'>(</span><span class='hs-varid'>evId</span> <span class='hs-varid'>evar</span> <span class='hs-varop'>`mkVarApps`</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span> <span class='hs-varop'>++</span> <span class='hs-varid'>dict_ids</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-563"></a>            <span class='hs-varop'>`mkVarApps`</span> <span class='hs-varid'>sc_tvs</span>
<a name="line-564"></a>
<a name="line-565"></a>    <span class='hs-varid'>mk_given_loc</span> <span class='hs-varid'>loc</span>
<a name="line-566"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isCTupleClass</span> <span class='hs-varid'>cls</span>
<a name="line-567"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span>   <span class='hs-comment'>-- For tuple predicates, just take them apart, without</span>
<a name="line-568"></a>               <span class='hs-comment'>-- adding their (large) size into the chain.  When we</span>
<a name="line-569"></a>               <span class='hs-comment'>-- get down to a base predicate, we'll include its size.</span>
<a name="line-570"></a>               <span class='hs-comment'>-- #10335</span>
<a name="line-571"></a>
<a name="line-572"></a>         <span class='hs-comment'>-- See Note [Solving superclass constraints] in GHC.Tc.TyCl.Instance</span>
<a name="line-573"></a>         <span class='hs-comment'>-- for explantation of InstSCOrigin and Note [Replacement vs keeping] in</span>
<a name="line-574"></a>         <span class='hs-comment'>-- GHC.Tc.Solver.Interact for why we need OtherSCOrigin and depths</span>
<a name="line-575"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-576"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctl_origin</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_orig</span> <span class='hs-layout'>}</span>
<a name="line-577"></a>       <span class='hs-keyword'>where</span>
<a name="line-578"></a>         <span class='hs-varid'>new_orig</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctLocOrigin</span> <span class='hs-varid'>loc</span> <span class='hs-keyword'>of</span>
<a name="line-579"></a>            <span class='hs-comment'>-- these cases are when we have something that's already a superclass constraint</span>
<a name="line-580"></a>           <span class='hs-conid'>InstSCOrigin</span>  <span class='hs-varid'>sc_depth</span> <span class='hs-varid'>n</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstSCOrigin</span>  <span class='hs-layout'>(</span><span class='hs-varid'>sc_depth</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-varop'>`max`</span> <span class='hs-varid'>size</span><span class='hs-layout'>)</span>
<a name="line-581"></a>           <span class='hs-conid'>OtherSCOrigin</span> <span class='hs-varid'>sc_depth</span> <span class='hs-varid'>si</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OtherSCOrigin</span> <span class='hs-layout'>(</span><span class='hs-varid'>sc_depth</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>si</span>
<a name="line-582"></a>
<a name="line-583"></a>            <span class='hs-comment'>-- these cases do not already have a superclass constraint: depth starts at 1</span>
<a name="line-584"></a>           <span class='hs-conid'>GivenOrigin</span> <span class='hs-conid'>InstSkol</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InstSCOrigin</span>  <span class='hs-num'>1</span> <span class='hs-varid'>size</span>
<a name="line-585"></a>           <span class='hs-conid'>GivenOrigin</span> <span class='hs-varid'>other_skol</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>OtherSCOrigin</span> <span class='hs-num'>1</span> <span class='hs-varid'>other_skol</span>
<a name="line-586"></a>
<a name="line-587"></a>           <span class='hs-varid'>other_orig</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"Given constraint without given origin"</span> <span class='hs-varop'>$</span>
<a name="line-588"></a>                                        <span class='hs-varid'>ppr</span> <span class='hs-varid'>evar</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>other_orig</span>
<a name="line-589"></a>
<a name="line-590"></a><span class='hs-definition'>mk_strict_superclasses</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-591"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>all</span> <span class='hs-varid'>noFreeVarsOfType</span> <span class='hs-varid'>tys</span>
<a name="line-592"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span> <span class='hs-comment'>-- Wanteds with no variables yield no deriveds.</span>
<a name="line-593"></a>              <span class='hs-comment'>-- See Note [Improvement from Ground Wanteds]</span>
<a name="line-594"></a>
<a name="line-595"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- Wanted/Derived case, just add Derived superclasses</span>
<a name="line-596"></a>              <span class='hs-comment'>-- that can lead to improvement.</span>
<a name="line-597"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span> <span class='hs-layout'>)</span>
<a name="line-598"></a>    <span class='hs-varid'>concatMapM</span> <span class='hs-varid'>do_one_derived</span> <span class='hs-layout'>(</span><span class='hs-varid'>immSuperClasses</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-599"></a>  <span class='hs-keyword'>where</span>
<a name="line-600"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span>
<a name="line-601"></a>
<a name="line-602"></a>    <span class='hs-varid'>do_one_derived</span> <span class='hs-varid'>sc_pred</span>
<a name="line-603"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newDerivedNC</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>sc_pred</span>
<a name="line-604"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>mk_superclasses</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varid'>sc_ev</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>sc_pred</span> <span class='hs-layout'>}</span>
<a name="line-605"></a>
<a name="line-606"></a><span class='hs-comment'>{- Note [Improvement from Ground Wanteds]
<a name="line-607"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-608"></a>Suppose class C b a =&gt; D a b
<a name="line-609"></a>and consider
<a name="line-610"></a>  [W] D Int Bool
<a name="line-611"></a>Is there any point in emitting [D] C Bool Int?  No!  The only point of
<a name="line-612"></a>emitting superclass constraints for W/D constraints is to get
<a name="line-613"></a>improvement, extra unifications that result from functional
<a name="line-614"></a>dependencies.  See Note [Why adding superclasses can help] above.
<a name="line-615"></a>
<a name="line-616"></a>But no variables means no improvement; case closed.
<a name="line-617"></a>-}</span>
<a name="line-618"></a>
<a name="line-619"></a><a name="mk_superclasses"></a><span class='hs-definition'>mk_superclasses</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-620"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-621"></a><span class='hs-comment'>-- Return this constraint, plus its superclasses, if any</span>
<a name="line-622"></a><span class='hs-definition'>mk_superclasses</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>pred</span>
<a name="line-623"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span>
<a name="line-624"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mk_superclasses_of</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-625"></a>
<a name="line-626"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-comment'>-- Superclass is not a class predicate</span>
<a name="line-627"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span><span class='hs-keyglyph'>]</span>
<a name="line-628"></a>
<a name="line-629"></a><a name="mk_superclasses_of"></a><span class='hs-definition'>mk_superclasses_of</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NameSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-630"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Class</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-631"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>
<a name="line-632"></a><span class='hs-comment'>-- Always return this class constraint,</span>
<a name="line-633"></a><span class='hs-comment'>-- and expand its superclasses</span>
<a name="line-634"></a><span class='hs-definition'>mk_superclasses_of</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-635"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>loop_found</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"mk_superclasses_of: loop"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-636"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>this_ct</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- cc_pend_sc of this_ct = True</span>
<a name="line-637"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"mk_superclasses_of"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span>
<a name="line-638"></a>                                                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>isCTupleClass</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span>
<a name="line-639"></a>                                                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rec_clss</span>
<a name="line-640"></a>                                                          <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-641"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>sc_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mk_strict_superclasses</span> <span class='hs-varid'>rec_clss'</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-642"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>this_ct</span> <span class='hs-conop'>:</span> <span class='hs-varid'>sc_cts</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-643"></a>                                   <span class='hs-comment'>-- cc_pend_sc of this_ct = False</span>
<a name="line-644"></a>  <span class='hs-keyword'>where</span>
<a name="line-645"></a>    <span class='hs-varid'>cls_nm</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>className</span> <span class='hs-varid'>cls</span>
<a name="line-646"></a>    <span class='hs-varid'>loop_found</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isCTupleClass</span> <span class='hs-varid'>cls</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>cls_nm</span> <span class='hs-varop'>`elemNameSet`</span> <span class='hs-varid'>rec_clss</span>
<a name="line-647"></a>                 <span class='hs-comment'>-- Tuples never contribute to recursion, and can be nested</span>
<a name="line-648"></a>    <span class='hs-varid'>rec_clss'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rec_clss</span> <span class='hs-varop'>`extendNameSet`</span> <span class='hs-varid'>cls_nm</span>
<a name="line-649"></a>
<a name="line-650"></a>    <span class='hs-varid'>this_ct</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span>
<a name="line-651"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CDictCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_class</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tys</span>
<a name="line-652"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>cc_pend_sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop_found</span> <span class='hs-layout'>}</span>
<a name="line-653"></a>                 <span class='hs-comment'>-- NB: If there is a loop, we cut off, so we have not</span>
<a name="line-654"></a>                 <span class='hs-comment'>--     added the superclasses, hence cc_pend_sc = True</span>
<a name="line-655"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-656"></a>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CQuantCan</span> <span class='hs-layout'>(</span><span class='hs-conid'>QCI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>qci_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>qci_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-657"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>qci_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-658"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>qci_pend_sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop_found</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-659"></a>
<a name="line-660"></a>
<a name="line-661"></a><span class='hs-comment'>{- Note [Equality superclasses in quantified constraints]
<a name="line-662"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-663"></a>Consider (#15359, #15593, #15625)
<a name="line-664"></a>  f :: (forall a. theta =&gt; a ~ b) =&gt; stuff
<a name="line-665"></a>
<a name="line-666"></a>It's a bit odd to have a local, quantified constraint for `(a~b)`,
<a name="line-667"></a>but some people want such a thing (see the tickets). And for
<a name="line-668"></a>Coercible it is definitely useful
<a name="line-669"></a>  f :: forall m. (forall p q. Coercible p q =&gt; Coercible (m p) (m q)))
<a name="line-670"></a>                 =&gt; stuff
<a name="line-671"></a>
<a name="line-672"></a>Moreover it's not hard to arrange; we just need to look up /equality/
<a name="line-673"></a>constraints in the quantified-constraint environment, which we do in
<a name="line-674"></a>GHC.Tc.Solver.Interact.doTopReactOther.
<a name="line-675"></a>
<a name="line-676"></a>There is a wrinkle though, in the case where 'theta' is empty, so
<a name="line-677"></a>we have
<a name="line-678"></a>  f :: (forall a. a~b) =&gt; stuff
<a name="line-679"></a>
<a name="line-680"></a>Now, potentially, the superclass machinery kicks in, in
<a name="line-681"></a>makeSuperClasses, giving us a a second quantified constraint
<a name="line-682"></a>       (forall a. a ~# b)
<a name="line-683"></a>BUT this is an unboxed value!  And nothing has prepared us for
<a name="line-684"></a>dictionary "functions" that are unboxed.  Actually it does just
<a name="line-685"></a>about work, but the simplifier ends up with stuff like
<a name="line-686"></a>   case (/\a. eq_sel d) of df -&gt; ...(df @Int)...
<a name="line-687"></a>and fails to simplify that any further.  And it doesn't satisfy
<a name="line-688"></a>isPredTy any more.
<a name="line-689"></a>
<a name="line-690"></a>So for now we simply decline to take superclasses in the quantified
<a name="line-691"></a>case.  Instead we have a special case in GHC.Tc.Solver.Interact.doTopReactOther,
<a name="line-692"></a>which looks for primitive equalities specially in the quantified
<a name="line-693"></a>constraints.
<a name="line-694"></a>
<a name="line-695"></a>See also Note [Evidence for quantified constraints] in GHC.Core.Predicate.
<a name="line-696"></a>
<a name="line-697"></a>
<a name="line-698"></a>************************************************************************
<a name="line-699"></a>*                                                                      *
<a name="line-700"></a>*                      Irreducibles canonicalization
<a name="line-701"></a>*                                                                      *
<a name="line-702"></a>************************************************************************
<a name="line-703"></a>-}</span>
<a name="line-704"></a>
<a name="line-705"></a><a name="canIrred"></a><span class='hs-definition'>canIrred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-706"></a><span class='hs-comment'>-- Precondition: ty not a tuple and no other evidence form</span>
<a name="line-707"></a><span class='hs-definition'>canIrred</span> <span class='hs-varid'>ev</span>
<a name="line-708"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span>
<a name="line-709"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_pred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"IrredPred = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-710"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>pred</span> <span class='hs-comment'>-- co :: xi ~ pred</span>
<a name="line-711"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rewriteEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`andWhenContinue`</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-712"></a>
<a name="line-713"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Re-classify, in case rewriting has improved its shape</span>
<a name="line-714"></a>         <span class='hs-comment'>-- Code is like the canNC, except</span>
<a name="line-715"></a>         <span class='hs-comment'>-- that the IrredPred branch stops work</span>
<a name="line-716"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-717"></a>           <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canClassNC</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-718"></a>           <span class='hs-conid'>EqPred</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canEqNC</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-719"></a>           <span class='hs-conid'>ForAllPred</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>th</span> <span class='hs-varid'>p</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- this is highly suspect; Quick Look</span>
<a name="line-720"></a>                                    <span class='hs-comment'>-- should never leave a meta-var filled</span>
<a name="line-721"></a>                                    <span class='hs-comment'>-- in with a polytype. This is #18987.</span>
<a name="line-722"></a>                                    <span class='hs-keyword'>do</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEvNC:forall"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>pred</span><span class='hs-layout'>)</span>
<a name="line-723"></a>                                       <span class='hs-varid'>canForAllNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>th</span> <span class='hs-varid'>p</span>
<a name="line-724"></a>           <span class='hs-conid'>IrredPred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-varop'>$</span>
<a name="line-725"></a>                                    <span class='hs-varid'>mkIrredCt</span> <span class='hs-conid'>IrredShapeReason</span> <span class='hs-varid'>new_ev</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-726"></a>
<a name="line-727"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-728"></a>*                                                                      *
<a name="line-729"></a>*                      Quantified predicates
<a name="line-730"></a>*                                                                      *
<a name="line-731"></a>********************************************************************* -}</span>
<a name="line-732"></a>
<a name="line-733"></a><span class='hs-comment'>{- Note [Quantified constraints]
<a name="line-734"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-735"></a>The -XQuantifiedConstraints extension allows type-class contexts like this:
<a name="line-736"></a>
<a name="line-737"></a>  data Rose f x = Rose x (f (Rose f x))
<a name="line-738"></a>
<a name="line-739"></a>  instance (Eq a, forall b. Eq b =&gt; Eq (f b))
<a name="line-740"></a>        =&gt; Eq (Rose f a)  where
<a name="line-741"></a>    (Rose x1 rs1) == (Rose x2 rs2) = x1==x2 &amp;&amp; rs1 == rs2
<a name="line-742"></a>
<a name="line-743"></a>Note the (forall b. Eq b =&gt; Eq (f b)) in the instance contexts.
<a name="line-744"></a>This quantified constraint is needed to solve the
<a name="line-745"></a> [W] (Eq (f (Rose f x)))
<a name="line-746"></a>constraint which arises form the (==) definition.
<a name="line-747"></a>
<a name="line-748"></a>The wiki page is
<a name="line-749"></a>  https://gitlab.haskell.org/ghc/ghc/wikis/quantified-constraints
<a name="line-750"></a>which in turn contains a link to the GHC Proposal where the change
<a name="line-751"></a>is specified, and a Haskell Symposium paper about it.
<a name="line-752"></a>
<a name="line-753"></a>We implement two main extensions to the design in the paper:
<a name="line-754"></a>
<a name="line-755"></a> 1. We allow a variable in the instance head, e.g.
<a name="line-756"></a>      f :: forall m a. (forall b. m b) =&gt; D (m a)
<a name="line-757"></a>    Notice the 'm' in the head of the quantified constraint, not
<a name="line-758"></a>    a class.
<a name="line-759"></a>
<a name="line-760"></a> 2. We support superclasses to quantified constraints.
<a name="line-761"></a>    For example (contrived):
<a name="line-762"></a>      f :: (Ord b, forall b. Ord b =&gt; Ord (m b)) =&gt; m a -&gt; m a -&gt; Bool
<a name="line-763"></a>      f x y = x==y
<a name="line-764"></a>    Here we need (Eq (m a)); but the quantified constraint deals only
<a name="line-765"></a>    with Ord.  But we can make it work by using its superclass.
<a name="line-766"></a>
<a name="line-767"></a>Here are the moving parts
<a name="line-768"></a>  * Language extension {-# LANGUAGE QuantifiedConstraints #-}
<a name="line-769"></a>    and add it to ghc-boot-th:GHC.LanguageExtensions.Type.Extension
<a name="line-770"></a>
<a name="line-771"></a>  * A new form of evidence, EvDFun, that is used to discharge
<a name="line-772"></a>    such wanted constraints
<a name="line-773"></a>
<a name="line-774"></a>  * checkValidType gets some changes to accept forall-constraints
<a name="line-775"></a>    only in the right places.
<a name="line-776"></a>
<a name="line-777"></a>  * Predicate.Pred gets a new constructor ForAllPred, and
<a name="line-778"></a>    and classifyPredType analyses a PredType to decompose
<a name="line-779"></a>    the new forall-constraints
<a name="line-780"></a>
<a name="line-781"></a>  * GHC.Tc.Solver.Monad.InertCans gets an extra field, inert_insts,
<a name="line-782"></a>    which holds all the Given forall-constraints.  In effect,
<a name="line-783"></a>    such Given constraints are like local instance decls.
<a name="line-784"></a>
<a name="line-785"></a>  * When trying to solve a class constraint, via
<a name="line-786"></a>    GHC.Tc.Solver.Interact.matchInstEnv, use the InstEnv from inert_insts
<a name="line-787"></a>    so that we include the local Given forall-constraints
<a name="line-788"></a>    in the lookup.  (See GHC.Tc.Solver.Monad.getInstEnvs.)
<a name="line-789"></a>
<a name="line-790"></a>  * GHC.Tc.Solver.Canonical.canForAll deals with solving a
<a name="line-791"></a>    forall-constraint.  See
<a name="line-792"></a>       Note [Solving a Wanted forall-constraint]
<a name="line-793"></a>
<a name="line-794"></a>  * We augment the kick-out code to kick out an inert
<a name="line-795"></a>    forall constraint if it can be rewritten by a new
<a name="line-796"></a>    type equality; see GHC.Tc.Solver.Monad.kick_out_rewritable
<a name="line-797"></a>
<a name="line-798"></a>Note that a quantified constraint is never /inferred/
<a name="line-799"></a>(by GHC.Tc.Solver.simplifyInfer).  A function can only have a
<a name="line-800"></a>quantified constraint in its type if it is given an explicit
<a name="line-801"></a>type signature.
<a name="line-802"></a>
<a name="line-803"></a>-}</span>
<a name="line-804"></a>
<a name="line-805"></a><a name="canForAllNC"></a><span class='hs-definition'>canForAllNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcPredType</span>
<a name="line-806"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-807"></a><span class='hs-definition'>canForAllNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>pred</span>
<a name="line-808"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span>  <span class='hs-comment'>-- See Note [Eagerly expand given superclasses]</span>
<a name="line-809"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cls_pred_tys_maybe</span>
<a name="line-810"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>sc_cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mkStrictSuperClasses</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-811"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWork</span> <span class='hs-varid'>sc_cts</span>
<a name="line-812"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canForAll</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-813"></a>
<a name="line-814"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-815"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canForAll</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJust</span> <span class='hs-varid'>cls_pred_tys_maybe</span><span class='hs-layout'>)</span>
<a name="line-816"></a>
<a name="line-817"></a>  <span class='hs-keyword'>where</span>
<a name="line-818"></a>    <span class='hs-varid'>cls_pred_tys_maybe</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-varid'>pred</span>
<a name="line-819"></a>
<a name="line-820"></a><a name="canForAll"></a><span class='hs-definition'>canForAll</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-821"></a><span class='hs-comment'>-- We have a constraint (forall as. blah =&gt; C tys)</span>
<a name="line-822"></a><span class='hs-definition'>canForAll</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>pend_sc</span>
<a name="line-823"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- First rewrite it to apply the current substitution</span>
<a name="line-824"></a>         <span class='hs-keyword'>let</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span>
<a name="line-825"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span><span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>pred</span> <span class='hs-comment'>-- co :: xi ~ pred</span>
<a name="line-826"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rewriteEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>xi</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`andWhenContinue`</span> <span class='hs-keyglyph'>\</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-827"></a>
<a name="line-828"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- Now decompose into its pieces and solve it</span>
<a name="line-829"></a>         <span class='hs-comment'>-- (It takes a lot less code to rewrite before decomposing.)</span>
<a name="line-830"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-831"></a>           <span class='hs-conid'>ForAllPred</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>pred</span>
<a name="line-832"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>solveForAll</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>pend_sc</span>
<a name="line-833"></a>           <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"canForAll"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span>
<a name="line-834"></a>    <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-835"></a>
<a name="line-836"></a><a name="solveForAll"></a><span class='hs-definition'>solveForAll</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-837"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-838"></a><span class='hs-definition'>solveForAll</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>pend_sc</span>
<a name="line-839"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_dest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dest</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-840"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See Note [Solving a Wanted forall-constraint]</span>
<a name="line-841"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>QuantCtxtSkol</span>
<a name="line-842"></a>             <span class='hs-varid'>empty_subst</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-varop'>$</span>
<a name="line-843"></a>                           <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>pred</span><span class='hs-conop'>:</span><span class='hs-varid'>theta</span><span class='hs-layout'>)</span> <span class='hs-varop'>`delVarSetList`</span> <span class='hs-varid'>tvs</span>
<a name="line-844"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst</span><span class='hs-layout'>,</span> <span class='hs-varid'>skol_tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVarsX</span> <span class='hs-varid'>empty_subst</span> <span class='hs-varid'>tvs</span>
<a name="line-845"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>given_ev_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>newEvVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTheta</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>theta</span><span class='hs-layout'>)</span>
<a name="line-846"></a>
<a name="line-847"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>lvl</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>w_id</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-848"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushLevelNoWorkList</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>skol_info</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-849"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wanted_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWantedEvVarNC</span> <span class='hs-varid'>loc</span> <span class='hs-varop'>$</span>
<a name="line-850"></a>                                  <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>pred</span>
<a name="line-851"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>ctEvEvId</span> <span class='hs-varid'>wanted_ev</span>
<a name="line-852"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>wanted_ev</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-853"></a>
<a name="line-854"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>emitImplicationTcS</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>skol_tvs</span>
<a name="line-855"></a>                                       <span class='hs-varid'>given_ev_vars</span> <span class='hs-varid'>wanteds</span>
<a name="line-856"></a>
<a name="line-857"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedEvTerm</span> <span class='hs-varid'>dest</span> <span class='hs-varop'>$</span>
<a name="line-858"></a>        <span class='hs-conid'>EvFun</span> <span class='hs-layout'>{</span> <span class='hs-varid'>et_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skol_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>et_given</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>given_ev_vars</span>
<a name="line-859"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>et_binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds</span><span class='hs-layout'>,</span> <span class='hs-varid'>et_body</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>w_id</span> <span class='hs-layout'>}</span>
<a name="line-860"></a>
<a name="line-861"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Wanted forall-constraint"</span> <span class='hs-layout'>}</span>
<a name="line-862"></a>
<a name="line-863"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span>   <span class='hs-comment'>-- See Note [Solving a Given forall-constraint]</span>
<a name="line-864"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>addInertForAll</span> <span class='hs-varid'>qci</span>
<a name="line-865"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Given forall-constraint"</span> <span class='hs-layout'>}</span>
<a name="line-866"></a>
<a name="line-867"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-868"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"discarding derived forall-constraint"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-869"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Derived forall-constraint"</span> <span class='hs-layout'>}</span>
<a name="line-870"></a>  <span class='hs-keyword'>where</span>
<a name="line-871"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span>
<a name="line-872"></a>    <span class='hs-varid'>qci</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>QCI</span> <span class='hs-layout'>{</span> <span class='hs-varid'>qci_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>qci_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-873"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>qci_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>qci_pend_sc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pend_sc</span> <span class='hs-layout'>}</span>
<a name="line-874"></a>
<a name="line-875"></a><span class='hs-comment'>{- Note [Solving a Wanted forall-constraint]
<a name="line-876"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-877"></a>Solving a wanted forall (quantified) constraint
<a name="line-878"></a>  [W] df :: forall ab. (Eq a, Ord b) =&gt; C x a b
<a name="line-879"></a>is delightfully easy.   Just build an implication constraint
<a name="line-880"></a>    forall ab. (g1::Eq a, g2::Ord b) =&gt; [W] d :: C x a
<a name="line-881"></a>and discharge df thus:
<a name="line-882"></a>    df = /\ab. \g1 g2. let &lt;binds&gt; in d
<a name="line-883"></a>where &lt;binds&gt; is filled in by solving the implication constraint.
<a name="line-884"></a>All the machinery is to hand; there is little to do.
<a name="line-885"></a>
<a name="line-886"></a>Note [Solving a Given forall-constraint]
<a name="line-887"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-888"></a>For a Given constraint
<a name="line-889"></a>  [G] df :: forall ab. (Eq a, Ord b) =&gt; C x a b
<a name="line-890"></a>we just add it to TcS's local InstEnv of known instances,
<a name="line-891"></a>via addInertForall.  Then, if we look up (C x Int Bool), say,
<a name="line-892"></a>we'll find a match in the InstEnv.
<a name="line-893"></a>
<a name="line-894"></a>
<a name="line-895"></a>************************************************************************
<a name="line-896"></a>*                                                                      *
<a name="line-897"></a>*        Equalities
<a name="line-898"></a>*                                                                      *
<a name="line-899"></a>************************************************************************
<a name="line-900"></a>
<a name="line-901"></a>Note [Canonicalising equalities]
<a name="line-902"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-903"></a>In order to canonicalise an equality, we look at the structure of the
<a name="line-904"></a>two types at hand, looking for similarities. A difficulty is that the
<a name="line-905"></a>types may look dissimilar before rewriting but similar after rewriting.
<a name="line-906"></a>However, we don't just want to jump in and rewrite right away, because
<a name="line-907"></a>this might be wasted effort. So, after looking for similarities and failing,
<a name="line-908"></a>we rewrite and then try again. Of course, we don't want to loop, so we
<a name="line-909"></a>track whether or not we've already rewritten.
<a name="line-910"></a>
<a name="line-911"></a>It is conceivable to do a better job at tracking whether or not a type
<a name="line-912"></a>is rewritten, but this is left as future work. (Mar '15)
<a name="line-913"></a>
<a name="line-914"></a>Note [Decomposing FunTy]
<a name="line-915"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-916"></a>can_eq_nc' may attempt to decompose a FunTy that is un-zonked.  This
<a name="line-917"></a>means that we may very well have a FunTy containing a type of some
<a name="line-918"></a>unknown kind. For instance, we may have,
<a name="line-919"></a>
<a name="line-920"></a>    FunTy (a :: k) Int
<a name="line-921"></a>
<a name="line-922"></a>Where k is a unification variable. So the calls to getRuntimeRep_maybe may
<a name="line-923"></a>fail (returning Nothing).  In that case we'll fall through, zonk, and try again.
<a name="line-924"></a>Zonking should fill the variable k, meaning that decomposition will succeed the
<a name="line-925"></a>second time around.
<a name="line-926"></a>
<a name="line-927"></a>Also note that we require the AnonArgFlag to match.  This will stop
<a name="line-928"></a>us decomposing
<a name="line-929"></a>   (Int -&gt; Bool)  ~  (Show a =&gt; blah)
<a name="line-930"></a>It's as if we treat (-&gt;) and (=&gt;) as different type constructors.
<a name="line-931"></a>-}</span>
<a name="line-932"></a>
<a name="line-933"></a><a name="canEqNC"></a><span class='hs-definition'>canEqNC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-934"></a><span class='hs-definition'>canEqNC</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-935"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>result</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonk_eq_types</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-936"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>result</span> <span class='hs-keyword'>of</span>
<a name="line-937"></a>           <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-conid'>False</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2'</span> <span class='hs-varid'>ty2</span>
<a name="line-938"></a>           <span class='hs-conid'>Right</span> <span class='hs-varid'>ty</span>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canEqReflexive</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span>
<a name="line-939"></a>
<a name="line-940"></a><a name="can_eq_nc"></a><span class='hs-definition'>can_eq_nc</span>
<a name="line-941"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>            <span class='hs-comment'>-- True =&gt; both types are rewritten</span>
<a name="line-942"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-943"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-944"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- LHS, after and before type-synonym expansion, resp</span>
<a name="line-945"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- RHS, after and before type-synonym expansion, resp</span>
<a name="line-946"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-947"></a><span class='hs-definition'>can_eq_nc</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-948"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_nc"</span> <span class='hs-varop'>$</span>
<a name="line-949"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rewritten</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-keyglyph'>]</span>
<a name="line-950"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>rdr_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getGlobalRdrEnvTcS</span>
<a name="line-951"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fam_insts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getFamInstEnvs</span>
<a name="line-952"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>can_eq_nc'</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>fam_insts</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span>
<a name="line-953"></a>
<a name="line-954"></a><a name="can_eq_nc'"></a><span class='hs-definition'>can_eq_nc'</span>
<a name="line-955"></a>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>           <span class='hs-comment'>-- True =&gt; both input types are rewritten</span>
<a name="line-956"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>GlobalRdrEnv</span>   <span class='hs-comment'>-- needed to see which newtypes are in scope</span>
<a name="line-957"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span>    <span class='hs-comment'>-- needed to unwrap data instances</span>
<a name="line-958"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-959"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-960"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- LHS, after and before type-synonym expansion, resp</span>
<a name="line-961"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- RHS, after and before type-synonym expansion, resp</span>
<a name="line-962"></a>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-963"></a>
<a name="line-964"></a><span class='hs-comment'>-- See Note [Comparing nullary type synonyms] in GHC.Core.Type.</span>
<a name="line-965"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-sel'>_flat</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-sel'>_ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span> <span class='hs-sel'>_ps_ty2</span>
<a name="line-966"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span>
<a name="line-967"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqReflexive</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span>
<a name="line-968"></a>
<a name="line-969"></a><span class='hs-comment'>-- Expand synonyms first; see Note [Type synonyms and canonicalization]</span>
<a name="line-970"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-971"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_nc'</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span>  <span class='hs-varid'>ps_ty2</span>
<a name="line-972"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_nc'</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span>  <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2'</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-973"></a>
<a name="line-974"></a><span class='hs-comment'>-- need to check for reflexivity in the ReprEq case.</span>
<a name="line-975"></a><span class='hs-comment'>-- See Note [Eager reflexivity check]</span>
<a name="line-976"></a><span class='hs-comment'>-- Check only when rewritten because the zonk_eq_types check in canEqNC takes</span>
<a name="line-977"></a><span class='hs-comment'>-- care of the non-rewritten case.</span>
<a name="line-978"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-conid'>True</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varid'>ty1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty2</span> <span class='hs-keyword'>_</span>
<a name="line-979"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span>
<a name="line-980"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqReflexive</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varid'>ty1</span>
<a name="line-981"></a>
<a name="line-982"></a><span class='hs-comment'>-- When working with ReprEq, unwrap newtypes.</span>
<a name="line-983"></a><span class='hs-comment'>-- See Note [Unwrap newtypes first]</span>
<a name="line-984"></a><span class='hs-comment'>-- This must be above the TyVarTy case, in order to guarantee (TyEq:N)</span>
<a name="line-985"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-sel'>_rewritten</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-986"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eq_rel</span>
<a name="line-987"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>stuff1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcTopNormaliseNewTypeTF_maybe</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>ty1</span>
<a name="line-988"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_newtype_nc</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>stuff1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-989"></a>
<a name="line-990"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eq_rel</span>
<a name="line-991"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>stuff2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcTopNormaliseNewTypeTF_maybe</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>ty2</span>
<a name="line-992"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_newtype_nc</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>IsSwapped</span>  <span class='hs-varid'>ty2</span> <span class='hs-varid'>stuff2</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-993"></a>
<a name="line-994"></a><span class='hs-comment'>-- Then, get rid of casts</span>
<a name="line-995"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>rewritten</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-996"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqLHS_maybe</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See (3) in Note [Equalities with incompatible kinds]</span>
<a name="line-997"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCast</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-998"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-varid'>rewritten</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-999"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqLHS_maybe</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- See (3) in Note [Equalities with incompatible kinds]</span>
<a name="line-1000"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCast</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>co2</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-1001"></a>
<a name="line-1002"></a><span class='hs-comment'>----------------------</span>
<a name="line-1003"></a><span class='hs-comment'>-- Otherwise try to decompose</span>
<a name="line-1004"></a><span class='hs-comment'>----------------------</span>
<a name="line-1005"></a>
<a name="line-1006"></a><span class='hs-comment'>-- Literals</span>
<a name="line-1007"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-sel'>_rewritten</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-varid'>l1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-varid'>l2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-1008"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>l1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>l2</span>
<a name="line-1009"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>evCoercion</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span>
<a name="line-1010"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Equal LitTy"</span> <span class='hs-layout'>}</span>
<a name="line-1011"></a>
<a name="line-1012"></a><span class='hs-comment'>-- Decompose FunTy: (s -&gt; t) and (c =&gt; t)</span>
<a name="line-1013"></a><span class='hs-comment'>-- NB: don't decompose (Int -&gt; blah) ~ (Show a =&gt; blah)</span>
<a name="line-1014"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-sel'>_rewritten</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1015"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ft_mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>am1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_af</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>af1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1a</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1b</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-sel'>_ps_ty1</span>
<a name="line-1016"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ft_mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>am2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_af</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>af2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty2a</span><span class='hs-layout'>,</span> <span class='hs-varid'>ft_res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty2b</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-sel'>_ps_ty2</span>
<a name="line-1017"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>af1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>af2</span>   <span class='hs-comment'>-- Don't decompose (Int -&gt; blah) ~ (Show a =&gt; blah)</span>
<a name="line-1018"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1a_rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRuntimeRep_maybe</span> <span class='hs-varid'>ty1a</span>  <span class='hs-comment'>-- getRutimeRep_maybe:</span>
<a name="line-1019"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1b_rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRuntimeRep_maybe</span> <span class='hs-varid'>ty1b</span>  <span class='hs-comment'>-- see Note [Decomposing FunTy]</span>
<a name="line-1020"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2a_rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRuntimeRep_maybe</span> <span class='hs-varid'>ty2a</span>
<a name="line-1021"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2b_rep</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getRuntimeRep_maybe</span> <span class='hs-varid'>ty2b</span>
<a name="line-1022"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canDecomposableTyConAppOK</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>funTyCon</span>
<a name="line-1023"></a>                              <span class='hs-keyglyph'>[</span><span class='hs-varid'>am1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1a_rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1b_rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1a</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1b</span><span class='hs-keyglyph'>]</span>
<a name="line-1024"></a>                              <span class='hs-keyglyph'>[</span><span class='hs-varid'>am2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2a_rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2b_rep</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2a</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2b</span><span class='hs-keyglyph'>]</span>
<a name="line-1025"></a>
<a name="line-1026"></a><span class='hs-comment'>-- Decompose type constructor applications</span>
<a name="line-1027"></a><span class='hs-comment'>-- NB: we have expanded type synonyms already</span>
<a name="line-1028"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-sel'>_rewritten</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty2</span> <span class='hs-keyword'>_</span>
<a name="line-1029"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSplitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1030"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSplitTyConApp_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-1031"></a>   <span class='hs-comment'>-- we want to catch e.g. Maybe Int ~ (Int -&gt; Int) here for better</span>
<a name="line-1032"></a>   <span class='hs-comment'>-- error messages rather than decomposing into AppTys;</span>
<a name="line-1033"></a>   <span class='hs-comment'>-- hence no direct match on TyConApp</span>
<a name="line-1034"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc1</span><span class='hs-layout'>)</span>
<a name="line-1035"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc2</span><span class='hs-layout'>)</span>
<a name="line-1036"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canTyConApp</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span>
<a name="line-1037"></a>
<a name="line-1038"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-sel'>_rewritten</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1039"></a>           <span class='hs-varid'>s1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>vis1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-1040"></a>           <span class='hs-varid'>s2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>vis2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyword'>_</span>
<a name="line-1041"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>vis1</span> <span class='hs-varop'>`sameVis`</span> <span class='hs-varid'>vis2</span> <span class='hs-comment'>-- Note [ForAllTy and typechecker equality]</span>
<a name="line-1042"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_nc_forall</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-1043"></a>
<a name="line-1044"></a><span class='hs-comment'>-- See Note [Canonicalising type applications] about why we require rewritten types</span>
<a name="line-1045"></a><span class='hs-comment'>-- Use tcSplitAppTy, not matching on AppTy, to catch oversaturated type families</span>
<a name="line-1046"></a><span class='hs-comment'>-- NB: Only decompose AppTy for nominal equality. See Note [Decomposing equality]</span>
<a name="line-1047"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-conid'>True</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>ty1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty2</span> <span class='hs-keyword'>_</span>
<a name="line-1048"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>t1</span><span class='hs-layout'>,</span> <span class='hs-varid'>s1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSplitAppTy_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1049"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>t2</span><span class='hs-layout'>,</span> <span class='hs-varid'>s2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcSplitAppTy_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-1050"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>can_eq_app</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t2</span> <span class='hs-varid'>s2</span>
<a name="line-1051"></a>
<a name="line-1052"></a><span class='hs-comment'>-------------------</span>
<a name="line-1053"></a><span class='hs-comment'>-- Can't decompose.</span>
<a name="line-1054"></a><span class='hs-comment'>-------------------</span>
<a name="line-1055"></a>
<a name="line-1056"></a><span class='hs-comment'>-- No similarity in type structure detected. Rewrite and try again.</span>
<a name="line-1057"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-conid'>False</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1058"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-1059"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1060"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-1061"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>can_eq_nc'</span> <span class='hs-conid'>True</span> <span class='hs-varid'>rdr_env</span> <span class='hs-varid'>envs</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>xi2</span> <span class='hs-layout'>}</span>
<a name="line-1062"></a>
<a name="line-1063"></a><span class='hs-comment'>----------------------------</span>
<a name="line-1064"></a><span class='hs-comment'>-- Look for a canonical LHS. See Note [Canonical LHS].</span>
<a name="line-1065"></a><span class='hs-comment'>-- Only rewritten types end up below here.</span>
<a name="line-1066"></a><span class='hs-comment'>----------------------------</span>
<a name="line-1067"></a>
<a name="line-1068"></a><span class='hs-comment'>-- NB: pattern match on True: we want only rewritten types sent to canEqLHS</span>
<a name="line-1069"></a><span class='hs-comment'>-- This means we've rewritten any variables and reduced any type family redexes</span>
<a name="line-1070"></a><span class='hs-comment'>-- See also Note [No top-level newtypes on RHS of representational equalities]</span>
<a name="line-1071"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-conid'>True</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1072"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>can_eq_lhs1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>canEqLHS_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1073"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHS</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>can_eq_lhs1</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1074"></a>
<a name="line-1075"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>can_eq_lhs2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>canEqLHS_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-1076"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHS</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>can_eq_lhs2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty1</span>
<a name="line-1077"></a>
<a name="line-1078"></a>     <span class='hs-comment'>-- If the type is TyConApp tc1 args1, then args1 really can't be less</span>
<a name="line-1079"></a>     <span class='hs-comment'>-- than tyConArity tc1. It could be *more* than tyConArity, but then we</span>
<a name="line-1080"></a>     <span class='hs-comment'>-- should have handled the case as an AppTy. That case only fires if</span>
<a name="line-1081"></a>     <span class='hs-comment'>-- _both_ sides of the equality are AppTy-like... but if one side is</span>
<a name="line-1082"></a>     <span class='hs-comment'>-- AppTy-like and the other isn't (and it also isn't a variable or</span>
<a name="line-1083"></a>     <span class='hs-comment'>-- saturated type family application, both of which are handled by</span>
<a name="line-1084"></a>     <span class='hs-comment'>-- can_eq_nc'), we're in a failure mode and can just fall through.</span>
<a name="line-1085"></a>
<a name="line-1086"></a><span class='hs-comment'>----------------------------</span>
<a name="line-1087"></a><span class='hs-comment'>-- Fall-through. Give up.</span>
<a name="line-1088"></a><span class='hs-comment'>----------------------------</span>
<a name="line-1089"></a>
<a name="line-1090"></a><span class='hs-comment'>-- We've rewritten and the types don't match. Give up.</span>
<a name="line-1091"></a><span class='hs-definition'>can_eq_nc'</span> <span class='hs-conid'>True</span> <span class='hs-sel'>_rdr_env</span> <span class='hs-sel'>_envs</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1092"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_nc' catch-all case"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty2</span><span class='hs-layout'>)</span>
<a name="line-1093"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>of</span> <span class='hs-comment'>-- See Note [Unsolved equalities]</span>
<a name="line-1094"></a>            <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-conid'>ReprEqReason</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1095"></a>            <span class='hs-conid'>NomEq</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-conid'>ShapeMismatchReason</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1096"></a>          <span class='hs-comment'>-- No need to call canEqFailure/canEqHardFailure because they</span>
<a name="line-1097"></a>          <span class='hs-comment'>-- rewrite, and the types involved here are already rewritten</span>
<a name="line-1098"></a>
<a name="line-1099"></a><span class='hs-comment'>{- Note [Unsolved equalities]
<a name="line-1100"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1101"></a>If we have an unsolved equality like
<a name="line-1102"></a>  (a b ~R# Int)
<a name="line-1103"></a>that is not necessarily insoluble!  Maybe 'a' will turn out to be a newtype.
<a name="line-1104"></a>So we want to make it a potentially-soluble Irred not an insoluble one.
<a name="line-1105"></a>Missing this point is what caused #15431
<a name="line-1106"></a>
<a name="line-1107"></a>Note [ForAllTy and typechecker equality]
<a name="line-1108"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1109"></a>Should GHC type-check the following program (adapted from #15740)?
<a name="line-1110"></a>
<a name="line-1111"></a>  {-# LANGUAGE PolyKinds, ... #-}
<a name="line-1112"></a>  data D a
<a name="line-1113"></a>  type family F :: forall k. k -&gt; Type
<a name="line-1114"></a>  type instance F = D
<a name="line-1115"></a>
<a name="line-1116"></a>Due to the way F is declared, any instance of F must have a right-hand side
<a name="line-1117"></a>whose kind is equal to `forall k. k -&gt; Type`. The kind of D is
<a name="line-1118"></a>`forall {k}. k -&gt; Type`, which is very close, but technically uses distinct
<a name="line-1119"></a>Core:
<a name="line-1120"></a>
<a name="line-1121"></a>  -----------------------------------------------------------
<a name="line-1122"></a>  | Source Haskell    | Core                                |
<a name="line-1123"></a>  -----------------------------------------------------------
<a name="line-1124"></a>  | forall  k.  &lt;...&gt; | ForAllTy (Bndr k Specified) (&lt;...&gt;) |
<a name="line-1125"></a>  | forall {k}. &lt;...&gt; | ForAllTy (Bndr k Inferred)  (&lt;...&gt;) |
<a name="line-1126"></a>  -----------------------------------------------------------
<a name="line-1127"></a>
<a name="line-1128"></a>We could deem these kinds to be unequal, but that would imply rejecting
<a name="line-1129"></a>programs like the one above. Whether a kind variable binder ends up being
<a name="line-1130"></a>specified or inferred can be somewhat subtle, however, especially for kinds
<a name="line-1131"></a>that aren't explicitly written out in the source code (like in D above).
<a name="line-1132"></a>For now, we decide to not make the specified/inferred status of an invisible
<a name="line-1133"></a>type variable binder affect GHC's notion of typechecker equality
<a name="line-1134"></a>(see Note [Typechecker equality vs definitional equality] in
<a name="line-1135"></a>GHC.Tc.Utils.TcType). That is, we have the following:
<a name="line-1136"></a>
<a name="line-1137"></a>  --------------------------------------------------
<a name="line-1138"></a>  | Type 1            | Type 2            | Equal? |
<a name="line-1139"></a>  --------------------|-----------------------------
<a name="line-1140"></a>  | forall k. &lt;...&gt;   | forall k. &lt;...&gt;   | Yes    |
<a name="line-1141"></a>  |                   | forall {k}. &lt;...&gt; | Yes    |
<a name="line-1142"></a>  |                   | forall k -&gt; &lt;...&gt; | No     |
<a name="line-1143"></a>  --------------------------------------------------
<a name="line-1144"></a>  | forall {k}. &lt;...&gt; | forall k. &lt;...&gt;   | Yes    |
<a name="line-1145"></a>  |                   | forall {k}. &lt;...&gt; | Yes    |
<a name="line-1146"></a>  |                   | forall k -&gt; &lt;...&gt; | No     |
<a name="line-1147"></a>  --------------------------------------------------
<a name="line-1148"></a>  | forall k -&gt; &lt;...&gt; | forall k. &lt;...&gt;   | No     |
<a name="line-1149"></a>  |                   | forall {k}. &lt;...&gt; | No     |
<a name="line-1150"></a>  |                   | forall k -&gt; &lt;...&gt; | Yes    |
<a name="line-1151"></a>  --------------------------------------------------
<a name="line-1152"></a>
<a name="line-1153"></a>We implement this nuance by using the GHC.Types.Var.sameVis function in
<a name="line-1154"></a>GHC.Tc.Solver.Canonical.canEqNC and GHC.Tc.Utils.TcType.tcEqType, which
<a name="line-1155"></a>respect typechecker equality. sameVis puts both forms of invisible type
<a name="line-1156"></a>variable binders into the same equivalence class.
<a name="line-1157"></a>
<a name="line-1158"></a>Note that we do /not/ use sameVis in GHC.Core.Type.eqType, which implements
<a name="line-1159"></a>/definitional/ equality, a slighty more coarse-grained notion of equality
<a name="line-1160"></a>(see Note [Non-trivial definitional equality] in GHC.Core.TyCo.Rep) that does
<a name="line-1161"></a>not consider the ArgFlag of ForAllTys at all. That is, eqType would equate all
<a name="line-1162"></a>of forall k. &lt;...&gt;, forall {k}. &lt;...&gt;, and forall k -&gt; &lt;...&gt;.
<a name="line-1163"></a>-}</span>
<a name="line-1164"></a>
<a name="line-1165"></a><a name="can_eq_nc_forall"></a><span class='hs-comment'>---------------------------------</span>
<a name="line-1166"></a><span class='hs-definition'>can_eq_nc_forall</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-1167"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- LHS and RHS</span>
<a name="line-1168"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1169"></a><span class='hs-comment'>-- (forall as. phi1) ~ (forall bs. phi2)</span>
<a name="line-1170"></a><span class='hs-comment'>-- Check for length match of as, bs</span>
<a name="line-1171"></a><span class='hs-comment'>-- Then build an implication constraint: forall as. phi1 ~ phi2[as/bs]</span>
<a name="line-1172"></a><span class='hs-comment'>-- But remember also to unify the kinds of as and bs</span>
<a name="line-1173"></a><span class='hs-comment'>--  (this is the 'go' loop), and actually substitute phi2[as |&gt; cos / bs]</span>
<a name="line-1174"></a><span class='hs-comment'>-- Remember also that we might have forall z (a:z). blah</span>
<a name="line-1175"></a><span class='hs-comment'>--  so we must proceed one binder at a time (#13879)</span>
<a name="line-1176"></a>
<a name="line-1177"></a><span class='hs-definition'>can_eq_nc_forall</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-1178"></a> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctev_dest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_dest</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-1179"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>free_tvs</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span><span class='hs-varid'>s2</span><span class='hs-keyglyph'>]</span>
<a name="line-1180"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>bndrs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>phi1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTyVarBinders</span> <span class='hs-varid'>s1</span>
<a name="line-1181"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>bndrs2</span><span class='hs-layout'>,</span> <span class='hs-varid'>phi2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitForAllTyVarBinders</span> <span class='hs-varid'>s2</span>
<a name="line-1182"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>equalLength</span> <span class='hs-varid'>bndrs1</span> <span class='hs-varid'>bndrs2</span><span class='hs-layout'>)</span>
<a name="line-1183"></a>        <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Forall failure"</span> <span class='hs-varop'>$</span>
<a name="line-1184"></a>                     <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndrs1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bndrs2</span>
<a name="line-1185"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>binderArgFlag</span> <span class='hs-varid'>bndrs1</span><span class='hs-layout'>)</span>
<a name="line-1186"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>binderArgFlag</span> <span class='hs-varid'>bndrs2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1187"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>canEqHardFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span> <span class='hs-layout'>}</span>
<a name="line-1188"></a>        <span class='hs-keyword'>else</span>
<a name="line-1189"></a>   <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Creating implication for polytype equality"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span>
<a name="line-1190"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>empty_subst1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkInScopeSet</span> <span class='hs-varid'>free_tvs</span>
<a name="line-1191"></a>      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>subst1</span><span class='hs-layout'>,</span> <span class='hs-varid'>skol_tvs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcInstSkolTyVarsX</span> <span class='hs-varid'>empty_subst1</span> <span class='hs-varop'>$</span>
<a name="line-1192"></a>                              <span class='hs-varid'>binderVars</span> <span class='hs-varid'>bndrs1</span>
<a name="line-1193"></a>
<a name="line-1194"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnifyForAllSkol</span> <span class='hs-varid'>phi1</span>
<a name="line-1195"></a>            <span class='hs-varid'>phi1'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>substTy</span> <span class='hs-varid'>subst1</span> <span class='hs-varid'>phi1</span>
<a name="line-1196"></a>
<a name="line-1197"></a>            <span class='hs-comment'>-- Unify the kinds, extend the substitution</span>
<a name="line-1198"></a>            <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TCvSubst</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVarBinder</span><span class='hs-keyglyph'>]</span>
<a name="line-1199"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-1200"></a>            <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>skol_tv</span><span class='hs-conop'>:</span><span class='hs-varid'>skol_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr2</span><span class='hs-conop'>:</span><span class='hs-varid'>bndrs2</span><span class='hs-layout'>)</span>
<a name="line-1201"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>binderVar</span> <span class='hs-varid'>bndr2</span>
<a name="line-1202"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>kind_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unify</span> <span class='hs-varid'>loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>skol_tv</span><span class='hs-layout'>)</span>
<a name="line-1203"></a>                                                  <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-varid'>subst</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1204"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>subst'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendTvSubstAndInScope</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>tv2</span>
<a name="line-1205"></a>                                       <span class='hs-layout'>(</span><span class='hs-varid'>mkCastTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>skol_tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-1206"></a>                         <span class='hs-comment'>-- skol_tv is already in the in-scope set, but the</span>
<a name="line-1207"></a>                         <span class='hs-comment'>-- free vars of kind_co are not; hence "...AndInScope"</span>
<a name="line-1208"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>subst'</span> <span class='hs-varid'>bndrs2</span>
<a name="line-1209"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkTcForAllCo</span> <span class='hs-varid'>skol_tv</span> <span class='hs-varid'>kind_co</span> <span class='hs-varid'>co</span>
<a name="line-1210"></a>                            <span class='hs-layout'>,</span> <span class='hs-varid'>wanteds1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>wanteds2</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1211"></a>
<a name="line-1212"></a>            <span class='hs-comment'>-- Done: unify phi1 ~ phi2</span>
<a name="line-1213"></a>            <span class='hs-varid'>go</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>bndrs2</span>
<a name="line-1214"></a>              <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>null</span> <span class='hs-varid'>bndrs2</span> <span class='hs-layout'>)</span>
<a name="line-1215"></a>                <span class='hs-varid'>unify</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-varid'>phi1'</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTyUnchecked</span> <span class='hs-varid'>subst</span> <span class='hs-varid'>phi2</span><span class='hs-layout'>)</span>
<a name="line-1216"></a>
<a name="line-1217"></a>            <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"cna_eq_nc_forall"</span>  <span class='hs-comment'>-- case (s:ss) []</span>
<a name="line-1218"></a>
<a name="line-1219"></a>            <span class='hs-varid'>empty_subst2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEmptyTCvSubst</span> <span class='hs-layout'>(</span><span class='hs-varid'>getTCvInScope</span> <span class='hs-varid'>subst1</span><span class='hs-layout'>)</span>
<a name="line-1220"></a>
<a name="line-1221"></a>      <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>lvl</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>all_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>pushLevelNoWorkList</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>skol_info</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1222"></a>                                    <span class='hs-varid'>go</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>empty_subst2</span> <span class='hs-varid'>bndrs2</span>
<a name="line-1223"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>emitTvImplicationTcS</span> <span class='hs-varid'>lvl</span> <span class='hs-varid'>skol_info</span> <span class='hs-varid'>skol_tvs</span> <span class='hs-varid'>wanteds</span>
<a name="line-1224"></a>
<a name="line-1225"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedEq</span> <span class='hs-varid'>orig_dest</span> <span class='hs-varid'>all_co</span>
<a name="line-1226"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Deferred polytype equality"</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1227"></a>
<a name="line-1228"></a> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1229"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Omitting decomposition of given polytype equality"</span> <span class='hs-varop'>$</span>
<a name="line-1230"></a>        <span class='hs-varid'>pprEq</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>    <span class='hs-comment'>-- See Note [Do not decompose given polytype equalities]</span>
<a name="line-1231"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Discard given polytype equality"</span> <span class='hs-layout'>}</span>
<a name="line-1232"></a>
<a name="line-1233"></a> <span class='hs-keyword'>where</span>
<a name="line-1234"></a>    <span class='hs-varid'>unify</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcCoercion</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cts</span><span class='hs-layout'>)</span>
<a name="line-1235"></a>    <span class='hs-comment'>-- This version returns the wanted constraint rather</span>
<a name="line-1236"></a>    <span class='hs-comment'>-- than putting it in the work list</span>
<a name="line-1237"></a>    <span class='hs-varid'>unify</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1238"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span>
<a name="line-1239"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-1240"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1241"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanted</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWantedEq</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1242"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1243"></a>
<a name="line-1244"></a><a name="zonk_eq_types"></a><span class='hs-comment'>---------------------------------</span>
<a name="line-1245"></a><span class='hs-comment'>-- | Compare types for equality, while zonking as necessary. Gives up</span>
<a name="line-1246"></a><span class='hs-comment'>-- as soon as it finds that two types are not equal.</span>
<a name="line-1247"></a><span class='hs-comment'>-- This is quite handy when some unification has made two</span>
<a name="line-1248"></a><span class='hs-comment'>-- types in an inert Wanted to be equal. We can discover the equality without</span>
<a name="line-1249"></a><span class='hs-comment'>-- rewriting, which is sometimes very expensive (in the case of type functions).</span>
<a name="line-1250"></a><span class='hs-comment'>-- In particular, this function makes a ~20% improvement in test case</span>
<a name="line-1251"></a><span class='hs-comment'>-- perf/compiler/T5030.</span>
<a name="line-1252"></a><span class='hs-comment'>--</span>
<a name="line-1253"></a><span class='hs-comment'>-- Returns either the (partially zonked) types in the case of</span>
<a name="line-1254"></a><span class='hs-comment'>-- inequality, or the one type in the case of equality. canEqReflexive is</span>
<a name="line-1255"></a><span class='hs-comment'>-- a good next step in the 'Right' case. Returning 'Left' is always safe.</span>
<a name="line-1256"></a><span class='hs-comment'>--</span>
<a name="line-1257"></a><span class='hs-comment'>-- NB: This does *not* look through type synonyms. In fact, it treats type</span>
<a name="line-1258"></a><span class='hs-comment'>-- synonyms as rigid constructors. In the future, it might be convenient</span>
<a name="line-1259"></a><span class='hs-comment'>-- to look at only those arguments of type synonyms that actually appear</span>
<a name="line-1260"></a><span class='hs-comment'>-- in the synonym RHS. But we're not there yet.</span>
<a name="line-1261"></a><span class='hs-definition'>zonk_eq_types</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span>
<a name="line-1262"></a><span class='hs-definition'>zonk_eq_types</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span>
<a name="line-1263"></a>  <span class='hs-keyword'>where</span>
<a name="line-1264"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvar_tyvar</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-1265"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvar</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ty2</span>
<a name="line-1266"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvar</span> <span class='hs-conid'>IsSwapped</span>  <span class='hs-varid'>tv2</span> <span class='hs-varid'>ty1</span>
<a name="line-1267"></a>
<a name="line-1268"></a>    <span class='hs-comment'>-- We handle FunTys explicitly here despite the fact that they could also be</span>
<a name="line-1269"></a>    <span class='hs-comment'>-- treated as an application. Why? Well, for one it's cheaper to just look</span>
<a name="line-1270"></a>    <span class='hs-comment'>-- at two types (the argument and result types) than four (the argument,</span>
<a name="line-1271"></a>    <span class='hs-comment'>-- result, and their RuntimeReps). Also, we haven't completely zonked yet,</span>
<a name="line-1272"></a>    <span class='hs-comment'>-- so we may run into an unzonked type variable while trying to compute the</span>
<a name="line-1273"></a>    <span class='hs-comment'>-- RuntimeReps of the argument and result types. This can be observed in</span>
<a name="line-1274"></a>    <span class='hs-comment'>-- testcase tc269.</span>
<a name="line-1275"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1276"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w1</span> <span class='hs-varid'>arg1</span><span class='hs-layout'>,</span> <span class='hs-varid'>res1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>split1</span>
<a name="line-1277"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>w2</span> <span class='hs-varid'>arg2</span><span class='hs-layout'>,</span> <span class='hs-varid'>res2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>split2</span>
<a name="line-1278"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>eqType</span> <span class='hs-varid'>w1</span> <span class='hs-varid'>w2</span>
<a name="line-1279"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>res_a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>arg1</span> <span class='hs-varid'>arg2</span>
<a name="line-1280"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>res_b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>res1</span> <span class='hs-varid'>res2</span>
<a name="line-1281"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>combine_rev</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkVisFunTy</span> <span class='hs-varid'>w1</span><span class='hs-layout'>)</span> <span class='hs-varid'>res_b</span> <span class='hs-varid'>res_a</span>
<a name="line-1282"></a>           <span class='hs-layout'>}</span>
<a name="line-1283"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>split1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>isJust</span> <span class='hs-varid'>split2</span>
<a name="line-1284"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1285"></a>      <span class='hs-keyword'>where</span>
<a name="line-1286"></a>        <span class='hs-varid'>split1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitFunTy_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1287"></a>        <span class='hs-varid'>split2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcSplitFunTy_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-1288"></a>
<a name="line-1289"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1290"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcRepSplitTyConApp_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1291"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcRepSplitTyConApp_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-1292"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>tys2</span>
<a name="line-1293"></a>          <span class='hs-comment'>-- Crucial to check for equal-length args, because</span>
<a name="line-1294"></a>          <span class='hs-comment'>-- we cannot assume that the two args to 'go' have</span>
<a name="line-1295"></a>          <span class='hs-comment'>-- the same kind.  E.g go (Proxy *      (Maybe Int))</span>
<a name="line-1296"></a>          <span class='hs-comment'>--                        (Proxy (*-&gt;*) Maybe)</span>
<a name="line-1297"></a>          <span class='hs-comment'>-- We'll call (go (Maybe Int) Maybe)</span>
<a name="line-1298"></a>          <span class='hs-comment'>-- See #13083</span>
<a name="line-1299"></a>        <span class='hs-keyword'>then</span> <span class='hs-varid'>tycon</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1300"></a>        <span class='hs-keyword'>else</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1301"></a>
<a name="line-1302"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1303"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty1a</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcRepSplitAppTy_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1304"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2a</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcRepSplitAppTy_maybe</span> <span class='hs-varid'>ty2</span>
<a name="line-1305"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>res_a</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1a</span> <span class='hs-varid'>ty2a</span>
<a name="line-1306"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>res_b</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1b</span> <span class='hs-varid'>ty2b</span>
<a name="line-1307"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-varid'>combine_rev</span> <span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>res_b</span> <span class='hs-varid'>res_a</span> <span class='hs-layout'>}</span>
<a name="line-1308"></a>
<a name="line-1309"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-varid'>lit1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-varid'>lit2</span><span class='hs-layout'>)</span>
<a name="line-1310"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lit1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>lit2</span>
<a name="line-1311"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span>
<a name="line-1312"></a>
<a name="line-1313"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1314"></a>      <span class='hs-comment'>-- We don't handle more complex forms here</span>
<a name="line-1315"></a>
<a name="line-1316"></a>    <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-1317"></a>
<a name="line-1318"></a>    <span class='hs-varid'>tyvar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SwapFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>
<a name="line-1319"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span>
<a name="line-1320"></a>      <span class='hs-comment'>-- Try to do as little as possible, as anything we do here is redundant</span>
<a name="line-1321"></a>      <span class='hs-comment'>-- with rewriting. In particular, no need to zonk kinds. That's why</span>
<a name="line-1322"></a>      <span class='hs-comment'>-- we don't use the already-defined zonking functions</span>
<a name="line-1323"></a>    <span class='hs-varid'>tyvar</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>
<a name="line-1324"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcTyVarDetails</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-1325"></a>          <span class='hs-conid'>MetaTv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mtv_ref</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ref</span> <span class='hs-layout'>}</span>
<a name="line-1326"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTcRef</span> <span class='hs-varid'>ref</span>
<a name="line-1327"></a>                  <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cts</span> <span class='hs-keyword'>of</span>
<a name="line-1328"></a>                      <span class='hs-conid'>Flexi</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>give_up</span>
<a name="line-1329"></a>                      <span class='hs-conid'>Indirect</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>trace_indirect</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty'</span>
<a name="line-1330"></a>                                         <span class='hs-layout'>;</span> <span class='hs-varid'>unSwap</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty'</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1331"></a>          <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>give_up</span>
<a name="line-1332"></a>      <span class='hs-keyword'>where</span>
<a name="line-1333"></a>        <span class='hs-varid'>give_up</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>$</span> <span class='hs-varid'>unSwap</span> <span class='hs-varid'>swapped</span> <span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-1334"></a>
<a name="line-1335"></a>    <span class='hs-varid'>tyvar_tyvar</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-1336"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1337"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty1'</span><span class='hs-layout'>,</span> <span class='hs-varid'>progress1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quick_zonk</span> <span class='hs-varid'>tv1</span>
<a name="line-1338"></a>                        <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2'</span><span class='hs-layout'>,</span> <span class='hs-varid'>progress2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quick_zonk</span> <span class='hs-varid'>tv2</span>
<a name="line-1339"></a>                        <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>progress1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>progress2</span>
<a name="line-1340"></a>                          <span class='hs-keyword'>then</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2'</span>
<a name="line-1341"></a>                          <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1342"></a>
<a name="line-1343"></a>    <span class='hs-varid'>trace_indirect</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty</span>
<a name="line-1344"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Following filled tyvar (zonk_eq_types)"</span>
<a name="line-1345"></a>                  <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1346"></a>
<a name="line-1347"></a>    <span class='hs-varid'>quick_zonk</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcTyVarDetails</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-1348"></a>      <span class='hs-conid'>MetaTv</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mtv_ref</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ref</span> <span class='hs-layout'>}</span>
<a name="line-1349"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>readTcRef</span> <span class='hs-varid'>ref</span>
<a name="line-1350"></a>              <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cts</span> <span class='hs-keyword'>of</span>
<a name="line-1351"></a>                  <span class='hs-conid'>Flexi</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-1352"></a>                  <span class='hs-conid'>Indirect</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>trace_indirect</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>ty'</span>
<a name="line-1353"></a>                                     <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1354"></a>      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-1355"></a>
<a name="line-1356"></a>      <span class='hs-comment'>-- This happens for type families, too. But recall that failure</span>
<a name="line-1357"></a>      <span class='hs-comment'>-- here just means to try harder, so it's OK if the type function</span>
<a name="line-1358"></a>      <span class='hs-comment'>-- isn't injective.</span>
<a name="line-1359"></a>    <span class='hs-varid'>tycon</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-1360"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span>
<a name="line-1361"></a>    <span class='hs-varid'>tycon</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1362"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>results</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWithM</span> <span class='hs-varid'>go</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1363"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varop'>$</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>combine_results</span> <span class='hs-varid'>results</span> <span class='hs-keyword'>of</span>
<a name="line-1364"></a>               <span class='hs-conid'>Left</span> <span class='hs-varid'>tys</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1365"></a>               <span class='hs-conid'>Right</span> <span class='hs-varid'>tys</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1366"></a>
<a name="line-1367"></a>    <span class='hs-varid'>combine_results</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span> <span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-1368"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-1369"></a>    <span class='hs-varid'>combine_results</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bimap</span> <span class='hs-layout'>(</span><span class='hs-varid'>fmap</span> <span class='hs-varid'>reverse</span><span class='hs-layout'>)</span> <span class='hs-varid'>reverse</span> <span class='hs-varop'>.</span>
<a name="line-1370"></a>                      <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-varid'>combine_rev</span> <span class='hs-layout'>(</span><span class='hs-conop'>:</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-1371"></a>
<a name="line-1372"></a>      <span class='hs-comment'>-- combine (in reverse) a new result onto an already-combined result</span>
<a name="line-1373"></a>    <span class='hs-varid'>combine_rev</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-1374"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span>
<a name="line-1375"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>a</span>
<a name="line-1376"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span>
<a name="line-1377"></a>    <span class='hs-varid'>combine_rev</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>list</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>elt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>elt</span>     <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>list</span><span class='hs-layout'>)</span>
<a name="line-1378"></a>    <span class='hs-varid'>combine_rev</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>list</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>list</span><span class='hs-layout'>)</span>
<a name="line-1379"></a>    <span class='hs-varid'>combine_rev</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-varid'>elt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>elt</span>     <span class='hs-varop'>&lt;*&gt;</span> <span class='hs-varid'>pure</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1380"></a>    <span class='hs-varid'>combine_rev</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-1381"></a>
<a name="line-1382"></a><span class='hs-comment'>{- See Note [Unwrap newtypes first]
<a name="line-1383"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1384"></a>Consider
<a name="line-1385"></a>  newtype N m a = MkN (m a)
<a name="line-1386"></a>Then N will get a conservative, Nominal role for its second parameter 'a',
<a name="line-1387"></a>because it appears as an argument to the unknown 'm'. Now consider
<a name="line-1388"></a>  [W] N Maybe a  ~R#  N Maybe b
<a name="line-1389"></a>
<a name="line-1390"></a>If we decompose, we'll get
<a name="line-1391"></a>  [W] a ~N# b
<a name="line-1392"></a>
<a name="line-1393"></a>But if instead we unwrap we'll get
<a name="line-1394"></a>  [W] Maybe a ~R# Maybe b
<a name="line-1395"></a>which in turn gives us
<a name="line-1396"></a>  [W] a ~R# b
<a name="line-1397"></a>which is easier to satisfy.
<a name="line-1398"></a>
<a name="line-1399"></a>Bottom line: unwrap newtypes before decomposing them!
<a name="line-1400"></a>c.f. #9123 comment:52,53 for a compelling example.
<a name="line-1401"></a>
<a name="line-1402"></a>Note [Newtypes can blow the stack]
<a name="line-1403"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1404"></a>Suppose we have
<a name="line-1405"></a>
<a name="line-1406"></a>  newtype X = MkX (Int -&gt; X)
<a name="line-1407"></a>  newtype Y = MkY (Int -&gt; Y)
<a name="line-1408"></a>
<a name="line-1409"></a>and now wish to prove
<a name="line-1410"></a>
<a name="line-1411"></a>  [W] X ~R Y
<a name="line-1412"></a>
<a name="line-1413"></a>This Wanted will loop, expanding out the newtypes ever deeper looking
<a name="line-1414"></a>for a solid match or a solid discrepancy. Indeed, there is something
<a name="line-1415"></a>appropriate to this looping, because X and Y *do* have the same representation,
<a name="line-1416"></a>in the limit -- they're both (Fix ((-&gt;) Int)). However, no finitely-sized
<a name="line-1417"></a>coercion will ever witness it. This loop won't actually cause GHC to hang,
<a name="line-1418"></a>though, because we check our depth when unwrapping newtypes.
<a name="line-1419"></a>
<a name="line-1420"></a>Note [Eager reflexivity check]
<a name="line-1421"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1422"></a>Suppose we have
<a name="line-1423"></a>
<a name="line-1424"></a>  newtype X = MkX (Int -&gt; X)
<a name="line-1425"></a>
<a name="line-1426"></a>and
<a name="line-1427"></a>
<a name="line-1428"></a>  [W] X ~R X
<a name="line-1429"></a>
<a name="line-1430"></a>Naively, we would start unwrapping X and end up in a loop. Instead,
<a name="line-1431"></a>we do this eager reflexivity check. This is necessary only for representational
<a name="line-1432"></a>equality because the rewriter technology deals with the similar case
<a name="line-1433"></a>(recursive type families) for nominal equality.
<a name="line-1434"></a>
<a name="line-1435"></a>Note that this check does not catch all cases, but it will catch the cases
<a name="line-1436"></a>we're most worried about, types like X above that are actually inhabited.
<a name="line-1437"></a>
<a name="line-1438"></a>Here's another place where this reflexivity check is key:
<a name="line-1439"></a>Consider trying to prove (f a) ~R (f a). The AppTys in there can't
<a name="line-1440"></a>be decomposed, because representational equality isn't congruent with respect
<a name="line-1441"></a>to AppTy. So, when canonicalising the equality above, we get stuck and
<a name="line-1442"></a>would normally produce a CIrredCan. However, we really do want to
<a name="line-1443"></a>be able to solve (f a) ~R (f a). So, in the representational case only,
<a name="line-1444"></a>we do a reflexivity check.
<a name="line-1445"></a>
<a name="line-1446"></a>(This would be sound in the nominal case, but unnecessary, and I [Richard
<a name="line-1447"></a>E.] am worried that it would slow down the common case.)
<a name="line-1448"></a>-}</span>
<a name="line-1449"></a>
<a name="line-1450"></a><a name="can_eq_newtype_nc"></a><span class='hs-comment'>------------------------</span>
<a name="line-1451"></a><span class='hs-comment'>-- | We're able to unwrap a newtype. Update the bits accordingly.</span>
<a name="line-1452"></a><span class='hs-definition'>can_eq_newtype_nc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>           <span class='hs-comment'>-- ^ :: ty1 ~ ty2</span>
<a name="line-1453"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-1454"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>                                    <span class='hs-comment'>-- ^ ty1</span>
<a name="line-1455"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>GlobalRdrElt</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcType</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ :: ty1 ~ ty1'</span>
<a name="line-1456"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>               <span class='hs-comment'>-- ^ ty2</span>
<a name="line-1457"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>               <span class='hs-comment'>-- ^ ty2, with type synonyms</span>
<a name="line-1458"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1459"></a><span class='hs-definition'>can_eq_newtype_nc</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>ty1</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>gres</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1'</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1460"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"can_eq_newtype_nc"</span> <span class='hs-varop'>$</span>
<a name="line-1461"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>swapped</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gres</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1'</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>]</span>
<a name="line-1462"></a>
<a name="line-1463"></a>         <span class='hs-comment'>-- check for blowing our stack:</span>
<a name="line-1464"></a>         <span class='hs-comment'>-- See Note [Newtypes can blow the stack]</span>
<a name="line-1465"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>checkReductionDepth</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty1</span>
<a name="line-1466"></a>
<a name="line-1467"></a>         <span class='hs-comment'>-- Next, we record uses of newtype constructors, since coercing</span>
<a name="line-1468"></a>         <span class='hs-comment'>-- through newtypes is tantamount to using their constructors.</span>
<a name="line-1469"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>addUsedGREs</span> <span class='hs-varid'>gre_list</span>
<a name="line-1470"></a>         <span class='hs-comment'>-- If a newtype constructor was imported, don't warn about not</span>
<a name="line-1471"></a>         <span class='hs-comment'>-- importing it...</span>
<a name="line-1472"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traverse_</span> <span class='hs-varid'>keepAlive</span> <span class='hs-varop'>$</span> <span class='hs-varid'>map</span> <span class='hs-varid'>greMangledName</span> <span class='hs-varid'>gre_list</span>
<a name="line-1473"></a>         <span class='hs-comment'>-- ...and similarly, if a newtype constructor was defined in the same</span>
<a name="line-1474"></a>         <span class='hs-comment'>-- module, don't warn about it being unused.</span>
<a name="line-1475"></a>         <span class='hs-comment'>-- See Note [Tracking unused binding and imports] in GHC.Tc.Utils.</span>
<a name="line-1476"></a>
<a name="line-1477"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1478"></a>                                     <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ps_ty2</span><span class='hs-layout'>)</span>
<a name="line-1479"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-conid'>False</span> <span class='hs-varid'>new_ev</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span>
<a name="line-1480"></a>  <span class='hs-keyword'>where</span>
<a name="line-1481"></a>    <span class='hs-varid'>gre_list</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>gres</span>
<a name="line-1482"></a>
<a name="line-1483"></a><a name="can_eq_app"></a><span class='hs-comment'>---------</span>
<a name="line-1484"></a><span class='hs-comment'>-- ^ Decompose a type application.</span>
<a name="line-1485"></a><span class='hs-comment'>-- All input types must be rewritten. See Note [Canonicalising type applications]</span>
<a name="line-1486"></a><span class='hs-comment'>-- Nominal equality only!</span>
<a name="line-1487"></a><span class='hs-definition'>can_eq_app</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>       <span class='hs-comment'>-- :: s1 t1 ~N s2 t2</span>
<a name="line-1488"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span>         <span class='hs-comment'>-- s1 t1</span>
<a name="line-1489"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Xi</span>         <span class='hs-comment'>-- s2 t2</span>
<a name="line-1490"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1491"></a>
<a name="line-1492"></a><span class='hs-comment'>-- AppTys only decompose for nominal equality, so this case just leads</span>
<a name="line-1493"></a><span class='hs-comment'>-- to an irreducible constraint; see typecheck/should_compile/T10494</span>
<a name="line-1494"></a><span class='hs-comment'>-- See Note [Decomposing AppTy at representational role]</span>
<a name="line-1495"></a><span class='hs-definition'>can_eq_app</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>t2</span>
<a name="line-1496"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtDerived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-1497"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unifyDeriveds</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Nominal</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nominal</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>t1</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>t2</span><span class='hs-keyglyph'>]</span>
<a name="line-1498"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Decomposed [D] AppTy"</span> <span class='hs-layout'>}</span>
<a name="line-1499"></a>
<a name="line-1500"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_dest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dest</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-1501"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co_s</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-1502"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_loc</span>
<a name="line-1503"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNextArgVisible</span> <span class='hs-varid'>s1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span>
<a name="line-1504"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updateCtLocOrigin</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>toInvisibleOrigin</span>
<a name="line-1505"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>co_t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>arg_loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span>
<a name="line-1506"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppCo</span> <span class='hs-varid'>co_s</span> <span class='hs-varid'>co_t</span>
<a name="line-1507"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedEq</span> <span class='hs-varid'>dest</span> <span class='hs-varid'>co</span>
<a name="line-1508"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Decomposed [W] AppTy"</span> <span class='hs-layout'>}</span>
<a name="line-1509"></a>
<a name="line-1510"></a>    <span class='hs-comment'>-- If there is a ForAll/(-&gt;) mismatch, the use of the Left coercion</span>
<a name="line-1511"></a>    <span class='hs-comment'>-- below is ill-typed, potentially leading to a panic in splitTyConApp</span>
<a name="line-1512"></a>    <span class='hs-comment'>-- Test case: typecheck/should_run/Typeable1</span>
<a name="line-1513"></a>    <span class='hs-comment'>-- We could also include this mismatch check above (for W and D), but it's slow</span>
<a name="line-1514"></a>    <span class='hs-comment'>-- and we'll get a better error message not doing it</span>
<a name="line-1515"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>s1k</span> <span class='hs-varop'>`mismatches`</span> <span class='hs-varid'>s2k</span>
<a name="line-1516"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqHardFailure</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span> <span class='hs-varop'>`mkAppTy`</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span> <span class='hs-varop'>`mkAppTy`</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-1517"></a>
<a name="line-1518"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evar</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-1519"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>evar</span>
<a name="line-1520"></a>             <span class='hs-varid'>co_s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcLRCo</span> <span class='hs-conid'>CLeft</span>  <span class='hs-varid'>co</span>
<a name="line-1521"></a>             <span class='hs-varid'>co_t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcLRCo</span> <span class='hs-conid'>CRight</span> <span class='hs-varid'>co</span>
<a name="line-1522"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evar_s</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEvVar</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkTcEqPredLikeEv</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-1523"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>evCoercion</span> <span class='hs-varid'>co_s</span> <span class='hs-layout'>)</span>
<a name="line-1524"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evar_t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEvVar</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkTcEqPredLikeEv</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span>
<a name="line-1525"></a>                                     <span class='hs-layout'>,</span> <span class='hs-varid'>evCoercion</span> <span class='hs-varid'>co_t</span> <span class='hs-layout'>)</span>
<a name="line-1526"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>evar_t</span><span class='hs-keyglyph'>]</span>
<a name="line-1527"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canEqNC</span> <span class='hs-varid'>evar_s</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span> <span class='hs-layout'>}</span>
<a name="line-1528"></a>
<a name="line-1529"></a>  <span class='hs-keyword'>where</span>
<a name="line-1530"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span>
<a name="line-1531"></a>
<a name="line-1532"></a>    <span class='hs-varid'>s1k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>s1</span>
<a name="line-1533"></a>    <span class='hs-varid'>s2k</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>s2</span>
<a name="line-1534"></a>
<a name="line-1535"></a>    <span class='hs-varid'>k1</span> <span class='hs-varop'>`mismatches`</span> <span class='hs-varid'>k2</span>
<a name="line-1536"></a>      <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>isForAllTy</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isForAllTy</span> <span class='hs-varid'>k2</span><span class='hs-layout'>)</span>
<a name="line-1537"></a>      <span class='hs-varop'>||</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isForAllTy</span> <span class='hs-varid'>k1</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isForAllTy</span> <span class='hs-varid'>k2</span>
<a name="line-1538"></a>
<a name="line-1539"></a><a name="canEqCast"></a><span class='hs-comment'>-----------------------</span>
<a name="line-1540"></a><span class='hs-comment'>-- | Break apart an equality over a casted type</span>
<a name="line-1541"></a><span class='hs-comment'>-- looking like   (ty1 |&gt; co1) ~ ty2   (modulo a swap-flag)</span>
<a name="line-1542"></a><span class='hs-definition'>canEqCast</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>         <span class='hs-comment'>-- are both types rewritten?</span>
<a name="line-1543"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-1544"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-1545"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-1546"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Coercion</span>   <span class='hs-comment'>-- LHS (res. RHS), ty1 |&gt; co1</span>
<a name="line-1547"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>     <span class='hs-comment'>-- RHS (res. LHS), ty2 both normal and pretty</span>
<a name="line-1548"></a>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1549"></a><span class='hs-definition'>canEqCast</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1550"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Decomposing cast"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span>
<a name="line-1551"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>text</span> <span class='hs-str'>"|&gt;"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span>
<a name="line-1552"></a>                                           <span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1553"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ps_ty2</span>
<a name="line-1554"></a>                                     <span class='hs-layout'>(</span><span class='hs-varid'>mkTcGReflRightCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span>
<a name="line-1555"></a>                                     <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ps_ty2</span><span class='hs-layout'>)</span>
<a name="line-1556"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>can_eq_nc</span> <span class='hs-varid'>rewritten</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ps_ty2</span> <span class='hs-layout'>}</span>
<a name="line-1557"></a>  <span class='hs-keyword'>where</span>
<a name="line-1558"></a>    <span class='hs-varid'>role</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1559"></a>
<a name="line-1560"></a><a name="canTyConApp"></a><span class='hs-comment'>------------------------</span>
<a name="line-1561"></a><span class='hs-definition'>canTyConApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-1562"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-1563"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-1564"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1565"></a><span class='hs-comment'>-- See Note [Decomposing TyConApps]</span>
<a name="line-1566"></a><span class='hs-comment'>-- Neither tc1 nor tc2 is a saturated funTyCon</span>
<a name="line-1567"></a><span class='hs-definition'>canTyConApp</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span>
<a name="line-1568"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span>
<a name="line-1569"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>tys2</span>
<a name="line-1570"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-1571"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>can_decompose</span> <span class='hs-varid'>inerts</span>
<a name="line-1572"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>canDecomposableTyConAppOK</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1573"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span>
<a name="line-1574"></a>
<a name="line-1575"></a>  <span class='hs-comment'>-- See Note [Skolem abstract data] in GHC.Core.Tycon</span>
<a name="line-1576"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tyConSkolem</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>tyConSkolem</span> <span class='hs-varid'>tc2</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canTyConApp: skolem abstract"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc2</span><span class='hs-layout'>)</span>
<a name="line-1578"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-conid'>AbstractTyConReason</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1579"></a>
<a name="line-1580"></a>  <span class='hs-comment'>-- Fail straight away for better error messages</span>
<a name="line-1581"></a>  <span class='hs-comment'>-- See Note [Use canEqFailure in canDecomposableTyConApp]</span>
<a name="line-1582"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varop'>==</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGenerativeTyCon</span> <span class='hs-varid'>tc1</span> <span class='hs-conid'>Representational</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-1583"></a>                             <span class='hs-varid'>isGenerativeTyCon</span> <span class='hs-varid'>tc2</span> <span class='hs-conid'>Representational</span><span class='hs-layout'>)</span>
<a name="line-1584"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1585"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1586"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqHardFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1587"></a>  <span class='hs-keyword'>where</span>
<a name="line-1588"></a>    <span class='hs-comment'>-- Reconstruct the types for error messages. This would do</span>
<a name="line-1589"></a>    <span class='hs-comment'>-- the wrong thing (from a pretty printing point of view)</span>
<a name="line-1590"></a>    <span class='hs-comment'>-- for functions, because we've lost the AnonArgFlag; but</span>
<a name="line-1591"></a>    <span class='hs-comment'>-- in fact we never call canTyConApp on a saturated FunTyCon</span>
<a name="line-1592"></a>    <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span>
<a name="line-1593"></a>    <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span>
<a name="line-1594"></a>
<a name="line-1595"></a>    <span class='hs-varid'>loc</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span>
<a name="line-1596"></a>    <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span>
<a name="line-1597"></a>
<a name="line-1598"></a>     <span class='hs-comment'>-- See Note [Decomposing equality]</span>
<a name="line-1599"></a>    <span class='hs-varid'>can_decompose</span> <span class='hs-varid'>inerts</span>
<a name="line-1600"></a>      <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>isInjectiveTyCon</span> <span class='hs-varid'>tc1</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span>
<a name="line-1601"></a>      <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>Given</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>matchableGivens</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1602"></a>
<a name="line-1603"></a><span class='hs-comment'>{-
<a name="line-1604"></a>Note [Use canEqFailure in canDecomposableTyConApp]
<a name="line-1605"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1606"></a>We must use canEqFailure, not canEqHardFailure here, because there is
<a name="line-1607"></a>the possibility of success if working with a representational equality.
<a name="line-1608"></a>Here is one case:
<a name="line-1609"></a>
<a name="line-1610"></a>  type family TF a where TF Char = Bool
<a name="line-1611"></a>  data family DF a
<a name="line-1612"></a>  newtype instance DF Bool = MkDF Int
<a name="line-1613"></a>
<a name="line-1614"></a>Suppose we are canonicalising (Int ~R DF (TF a)), where we don't yet
<a name="line-1615"></a>know `a`. This is *not* a hard failure, because we might soon learn
<a name="line-1616"></a>that `a` is, in fact, Char, and then the equality succeeds.
<a name="line-1617"></a>
<a name="line-1618"></a>Here is another case:
<a name="line-1619"></a>
<a name="line-1620"></a>  [G] Age ~R Int
<a name="line-1621"></a>
<a name="line-1622"></a>where Age's constructor is not in scope. We don't want to report
<a name="line-1623"></a>an "inaccessible code" error in the context of this Given!
<a name="line-1624"></a>
<a name="line-1625"></a>For example, see typecheck/should_compile/T10493, repeated here:
<a name="line-1626"></a>
<a name="line-1627"></a>  import Data.Ord (Down)  -- no constructor
<a name="line-1628"></a>
<a name="line-1629"></a>  foo :: Coercible (Down Int) Int =&gt; Down Int -&gt; Int
<a name="line-1630"></a>  foo = coerce
<a name="line-1631"></a>
<a name="line-1632"></a>That should compile, but only because we use canEqFailure and not
<a name="line-1633"></a>canEqHardFailure.
<a name="line-1634"></a>
<a name="line-1635"></a>Note [Decomposing equality]
<a name="line-1636"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1637"></a>If we have a constraint (of any flavour and role) that looks like
<a name="line-1638"></a>T tys1 ~ T tys2, what can we conclude about tys1 and tys2? The answer,
<a name="line-1639"></a>of course, is "it depends". This Note spells it all out.
<a name="line-1640"></a>
<a name="line-1641"></a>In this Note, "decomposition" refers to taking the constraint
<a name="line-1642"></a>  [fl] (T tys1 ~X T tys2)
<a name="line-1643"></a>(for some flavour fl and some role X) and replacing it with
<a name="line-1644"></a>  [fls'] (tys1 ~Xs' tys2)
<a name="line-1645"></a>where that notation indicates a list of new constraints, where the
<a name="line-1646"></a>new constraints may have different flavours and different roles.
<a name="line-1647"></a>
<a name="line-1648"></a>The key property to consider is injectivity. When decomposing a Given, the
<a name="line-1649"></a>decomposition is sound if and only if T is injective in all of its type
<a name="line-1650"></a>arguments. When decomposing a Wanted, the decomposition is sound (assuming the
<a name="line-1651"></a>correct roles in the produced equality constraints), but it may be a guess --
<a name="line-1652"></a>that is, an unforced decision by the constraint solver. Decomposing Wanteds
<a name="line-1653"></a>over injective TyCons does not entail guessing. But sometimes we want to
<a name="line-1654"></a>decompose a Wanted even when the TyCon involved is not injective! (See below.)
<a name="line-1655"></a>
<a name="line-1656"></a>So, in broad strokes, we want this rule:
<a name="line-1657"></a>
<a name="line-1658"></a>(*) Decompose a constraint (T tys1 ~X T tys2) if and only if T is injective
<a name="line-1659"></a>at role X.
<a name="line-1660"></a>
<a name="line-1661"></a>Pursuing the details requires exploring three axes:
<a name="line-1662"></a>* Flavour: Given vs. Derived vs. Wanted
<a name="line-1663"></a>* Role: Nominal vs. Representational
<a name="line-1664"></a>* TyCon species: datatype vs. newtype vs. data family vs. type family vs. type variable
<a name="line-1665"></a>
<a name="line-1666"></a>(A type variable isn't a TyCon, of course, but it's convenient to put the AppTy case
<a name="line-1667"></a>in the same table.)
<a name="line-1668"></a>
<a name="line-1669"></a>Right away, we can say that Derived behaves just as Wanted for the purposes
<a name="line-1670"></a>of decomposition. The difference between Derived and Wanted is the handling of
<a name="line-1671"></a>evidence. Since decomposition in these cases isn't a matter of soundness but of
<a name="line-1672"></a>guessing, we want the same behaviour regardless of evidence.
<a name="line-1673"></a>
<a name="line-1674"></a>Here is a table (discussion following) detailing where decomposition of
<a name="line-1675"></a>   (T s1 ... sn) ~r (T t1 .. tn)
<a name="line-1676"></a>is allowed.  The first four lines (Data types ... type family) refer
<a name="line-1677"></a>to TyConApps with various TyCons T; the last line is for AppTy, covering
<a name="line-1678"></a>both where there is a type variable at the head and the case for an over-
<a name="line-1679"></a>saturated type family.
<a name="line-1680"></a>
<a name="line-1681"></a>NOMINAL               GIVEN        WANTED                         WHERE
<a name="line-1682"></a>
<a name="line-1683"></a>Datatype               YES          YES                           canTyConApp
<a name="line-1684"></a>Newtype                YES          YES                           canTyConApp
<a name="line-1685"></a>Data family            YES          YES                           canTyConApp
<a name="line-1686"></a>Type family            NO{1}        YES, in injective args{1}     canEqCanLHS2
<a name="line-1687"></a>AppTy                  YES          YES                           can_eq_app
<a name="line-1688"></a>
<a name="line-1689"></a>REPRESENTATIONAL      GIVEN        WANTED
<a name="line-1690"></a>
<a name="line-1691"></a>Datatype               YES          YES                           canTyConApp
<a name="line-1692"></a>Newtype                NO{2}       MAYBE{2}                canTyConApp(can_decompose)
<a name="line-1693"></a>Data family            NO{3}       MAYBE{3}                canTyConApp(can_decompose)
<a name="line-1694"></a>Type family            NO           NO                            canEqCanLHS2
<a name="line-1695"></a>AppTy                  NO{4}        NO{4}                         can_eq_nc'
<a name="line-1696"></a>
<a name="line-1697"></a>{1}: Type families can be injective in some, but not all, of their arguments,
<a name="line-1698"></a>so we want to do partial decomposition. This is quite different than the way
<a name="line-1699"></a>other decomposition is done, where the decomposed equalities replace the original
<a name="line-1700"></a>one. We thus proceed much like we do with superclasses, emitting new Deriveds
<a name="line-1701"></a>when "decomposing" a partially-injective type family Wanted. Injective type
<a name="line-1702"></a>families have no corresponding evidence of their injectivity, so we cannot
<a name="line-1703"></a>decompose an injective-type-family Given.
<a name="line-1704"></a>
<a name="line-1705"></a>{2}: See Note [Decomposing newtypes at representational role]
<a name="line-1706"></a>
<a name="line-1707"></a>{3}: Because of the possibility of newtype instances, we must treat
<a name="line-1708"></a>data families like newtypes. See also
<a name="line-1709"></a>Note [Decomposing newtypes at representational role]. See #10534 and
<a name="line-1710"></a>test case typecheck/should_fail/T10534.
<a name="line-1711"></a>
<a name="line-1712"></a>{4}: See Note [Decomposing AppTy at representational role]
<a name="line-1713"></a>
<a name="line-1714"></a>In the implementation of can_eq_nc and friends, we don't directly pattern
<a name="line-1715"></a>match using lines like in the tables above, as those tables don't cover
<a name="line-1716"></a>all cases (what about PrimTyCon? tuples?). Instead we just ask about injectivity,
<a name="line-1717"></a>boiling the tables above down to rule (*). The exceptions to rule (*) are for
<a name="line-1718"></a>injective type families, which are handled separately from other decompositions,
<a name="line-1719"></a>and the MAYBE entries above.
<a name="line-1720"></a>
<a name="line-1721"></a>Note [Decomposing newtypes at representational role]
<a name="line-1722"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1723"></a>This note discusses the 'newtype' line in the REPRESENTATIONAL table
<a name="line-1724"></a>in Note [Decomposing equality]. (At nominal role, newtypes are fully
<a name="line-1725"></a>decomposable.)
<a name="line-1726"></a>
<a name="line-1727"></a>Here is a representative example of why representational equality over
<a name="line-1728"></a>newtypes is tricky:
<a name="line-1729"></a>
<a name="line-1730"></a>  newtype Nt a = Mk Bool         -- NB: a is not used in the RHS,
<a name="line-1731"></a>  type role Nt representational  -- but the user gives it an R role anyway
<a name="line-1732"></a>
<a name="line-1733"></a>If we have [W] Nt alpha ~R Nt beta, we *don't* want to decompose to
<a name="line-1734"></a>[W] alpha ~R beta, because it's possible that alpha and beta aren't
<a name="line-1735"></a>representationally equal. Here's another example.
<a name="line-1736"></a>
<a name="line-1737"></a>  newtype Nt a = MkNt (Id a)
<a name="line-1738"></a>  type family Id a where Id a = a
<a name="line-1739"></a>
<a name="line-1740"></a>  [W] Nt Int ~R Nt Age
<a name="line-1741"></a>
<a name="line-1742"></a>Because of its use of a type family, Nt's parameter will get inferred to have
<a name="line-1743"></a>a nominal role. Thus, decomposing the wanted will yield [W] Int ~N Age, which
<a name="line-1744"></a>is unsatisfiable. Unwrapping, though, leads to a solution.
<a name="line-1745"></a>
<a name="line-1746"></a>Conclusion:
<a name="line-1747"></a> * Unwrap newtypes before attempting to decompose them.
<a name="line-1748"></a>   This is done in can_eq_nc'.
<a name="line-1749"></a>
<a name="line-1750"></a>It all comes from the fact that newtypes aren't necessarily injective
<a name="line-1751"></a>w.r.t. representational equality.
<a name="line-1752"></a>
<a name="line-1753"></a>Furthermore, as explained in Note [NthCo and newtypes] in GHC.Core.TyCo.Rep, we can't use
<a name="line-1754"></a>NthCo on representational coercions over newtypes. NthCo comes into play
<a name="line-1755"></a>only when decomposing givens.
<a name="line-1756"></a>
<a name="line-1757"></a>Conclusion:
<a name="line-1758"></a> * Do not decompose [G] N s ~R N t
<a name="line-1759"></a>
<a name="line-1760"></a>Is it sensible to decompose *Wanted* constraints over newtypes?  Yes!
<a name="line-1761"></a>It's the only way we could ever prove (IO Int ~R IO Age), recalling
<a name="line-1762"></a>that IO is a newtype.
<a name="line-1763"></a>
<a name="line-1764"></a>However we must be careful.  Consider
<a name="line-1765"></a>
<a name="line-1766"></a>  type role Nt representational
<a name="line-1767"></a>
<a name="line-1768"></a>  [G] Nt a ~R Nt b       (1)
<a name="line-1769"></a>  [W] NT alpha ~R Nt b   (2)
<a name="line-1770"></a>  [W] alpha ~ a          (3)
<a name="line-1771"></a>
<a name="line-1772"></a>If we focus on (3) first, we'll substitute in (2), and now it's
<a name="line-1773"></a>identical to the given (1), so we succeed.  But if we focus on (2)
<a name="line-1774"></a>first, and decompose it, we'll get (alpha ~R b), which is not soluble.
<a name="line-1775"></a>This is exactly like the question of overlapping Givens for class
<a name="line-1776"></a>constraints: see Note [Instance and Given overlap] in GHC.Tc.Solver.Interact.
<a name="line-1777"></a>
<a name="line-1778"></a>Conclusion:
<a name="line-1779"></a>  * Decompose [W] N s ~R N t  iff there no given constraint that could
<a name="line-1780"></a>    later solve it.
<a name="line-1781"></a>
<a name="line-1782"></a>Note [Decomposing AppTy at representational role]
<a name="line-1783"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1784"></a>We never decompose AppTy at a representational role. For Givens, doing
<a name="line-1785"></a>so is simply unsound: the LRCo coercion former requires a nominal-roled
<a name="line-1786"></a>arguments. (See (1) for an example of why.) For Wanteds, decomposing
<a name="line-1787"></a>would be sound, but it would be a guess, and a non-confluent one at that.
<a name="line-1788"></a>
<a name="line-1789"></a>Here is an example:
<a name="line-1790"></a>
<a name="line-1791"></a>    [G] g1 :: a ~R b
<a name="line-1792"></a>    [W] w1 :: Maybe b ~R alpha a
<a name="line-1793"></a>    [W] w2 :: alpha ~ Maybe
<a name="line-1794"></a>
<a name="line-1795"></a>Suppose we see w1 before w2. If we were to decompose, we would decompose
<a name="line-1796"></a>this to become
<a name="line-1797"></a>
<a name="line-1798"></a>    [W] w3 :: Maybe ~R alpha
<a name="line-1799"></a>    [W] w4 :: b ~ a
<a name="line-1800"></a>
<a name="line-1801"></a>Note that w4 is *nominal*. A nominal role here is necessary because AppCo
<a name="line-1802"></a>requires a nominal role on its second argument. (See (2) for an example of
<a name="line-1803"></a>why.) If we decomposed w1 to w3,w4, we would then get stuck, because w4
<a name="line-1804"></a>is insoluble. On the other hand, if we see w2 first, setting alpha := Maybe,
<a name="line-1805"></a>all is well, as we can decompose Maybe b ~R Maybe a into b ~R a.
<a name="line-1806"></a>
<a name="line-1807"></a>Another example:
<a name="line-1808"></a>
<a name="line-1809"></a>    newtype Phant x = MkPhant Int
<a name="line-1810"></a>
<a name="line-1811"></a>    [W] w1 :: Phant Int ~R alpha Bool
<a name="line-1812"></a>    [W] w2 :: alpha ~ Phant
<a name="line-1813"></a>
<a name="line-1814"></a>If we see w1 first, decomposing would be disastrous, as we would then try
<a name="line-1815"></a>to solve Int ~ Bool. Instead, spotting w2 allows us to simplify w1 to become
<a name="line-1816"></a>
<a name="line-1817"></a>    [W] w1' :: Phant Int ~R Phant Bool
<a name="line-1818"></a>
<a name="line-1819"></a>which can then (assuming MkPhant is in scope) be simplified to Int ~R Int,
<a name="line-1820"></a>and all will be well. See also Note [Unwrap newtypes first].
<a name="line-1821"></a>
<a name="line-1822"></a>Bottom line: never decompose AppTy with representational roles.
<a name="line-1823"></a>
<a name="line-1824"></a>(1) Decomposing a Given AppTy over a representational role is simply
<a name="line-1825"></a>unsound. For example, if we have co1 :: Phant Int ~R a Bool (for
<a name="line-1826"></a>the newtype Phant, above), then we surely don't want any relationship
<a name="line-1827"></a>between Int and Bool, lest we also have co2 :: Phant ~ a around.
<a name="line-1828"></a>
<a name="line-1829"></a>(2) The role on the AppCo coercion is a conservative choice, because we don't
<a name="line-1830"></a>know the role signature of the function. For example, let's assume we could
<a name="line-1831"></a>have a representational role on the second argument of AppCo. Then, consider
<a name="line-1832"></a>
<a name="line-1833"></a>    data G a where    -- G will have a nominal role, as G is a GADT
<a name="line-1834"></a>      MkG :: G Int
<a name="line-1835"></a>    newtype Age = MkAge Int
<a name="line-1836"></a>
<a name="line-1837"></a>    co1 :: G ~R a        -- by assumption
<a name="line-1838"></a>    co2 :: Age ~R Int    -- by newtype axiom
<a name="line-1839"></a>    co3 = AppCo co1 co2 :: G Age ~R a Int    -- by our broken AppCo
<a name="line-1840"></a>
<a name="line-1841"></a>and now co3 can be used to cast MkG to have type G Age, in violation of
<a name="line-1842"></a>the way GADTs are supposed to work (which is to use nominal equality).
<a name="line-1843"></a>
<a name="line-1844"></a>-}</span>
<a name="line-1845"></a>
<a name="line-1846"></a><a name="canDecomposableTyConAppOK"></a><span class='hs-definition'>canDecomposableTyConAppOK</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-1847"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span>
<a name="line-1848"></a>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1849"></a><span class='hs-comment'>-- Precondition: tys1 and tys2 are the same length, hence "OK"</span>
<a name="line-1850"></a><span class='hs-definition'>canDecomposableTyConAppOK</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1851"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>tys2</span> <span class='hs-layout'>)</span>
<a name="line-1852"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canDecomposableTyConAppOK"</span>
<a name="line-1853"></a>                  <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span>
<a name="line-1854"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ev</span> <span class='hs-keyword'>of</span>
<a name="line-1855"></a>           <span class='hs-conid'>CtDerived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>
<a name="line-1856"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unifyDeriveds</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>tc_roles</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1857"></a>
<a name="line-1858"></a>           <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_dest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dest</span> <span class='hs-layout'>}</span>
<a name="line-1859"></a>                  <span class='hs-comment'>-- new_locs and tc_roles are both infinite, so</span>
<a name="line-1860"></a>                  <span class='hs-comment'>-- we are guaranteed that cos has the same length</span>
<a name="line-1861"></a>                  <span class='hs-comment'>-- as tys1 and tys2</span>
<a name="line-1862"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cos</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWith4M</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>new_locs</span> <span class='hs-varid'>tc_roles</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-1863"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedEq</span> <span class='hs-varid'>dest</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1864"></a>
<a name="line-1865"></a>           <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evar</span> <span class='hs-layout'>}</span>
<a name="line-1866"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ev_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCoVarCo</span> <span class='hs-varid'>evar</span>
<a name="line-1867"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>given_evs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEvVars</span> <span class='hs-varid'>loc</span> <span class='hs-varop'>$</span>
<a name="line-1868"></a>                                  <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkPrimEqPredRole</span> <span class='hs-varid'>r</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1869"></a>                                    <span class='hs-layout'>,</span> <span class='hs-varid'>evCoercion</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkNthCo</span> <span class='hs-varid'>r</span> <span class='hs-varid'>i</span> <span class='hs-varid'>ev_co</span> <span class='hs-layout'>)</span>
<a name="line-1870"></a>                                  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>r</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip4</span> <span class='hs-varid'>tc_roles</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span> <span class='hs-keyglyph'>[</span><span class='hs-num'>0</span><span class='hs-keyglyph'>..</span><span class='hs-keyglyph'>]</span>
<a name="line-1871"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>r</span> <span class='hs-varop'>/=</span> <span class='hs-conid'>Phantom</span>
<a name="line-1872"></a>                                  <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isCoercionTy</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isCoercionTy</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1873"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-varid'>given_evs</span> <span class='hs-layout'>}</span>
<a name="line-1874"></a>
<a name="line-1875"></a>    <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Decomposed TyConApp"</span> <span class='hs-layout'>}</span>
<a name="line-1876"></a>
<a name="line-1877"></a>  <span class='hs-keyword'>where</span>
<a name="line-1878"></a>    <span class='hs-varid'>loc</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span>
<a name="line-1879"></a>    <span class='hs-varid'>role</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-1880"></a>
<a name="line-1881"></a>      <span class='hs-comment'>-- infinite, as tyConRolesX returns an infinite tail of Nominal</span>
<a name="line-1882"></a>    <span class='hs-varid'>tc_roles</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConRolesX</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span>
<a name="line-1883"></a>
<a name="line-1884"></a>      <span class='hs-comment'>-- Add nuances to the location during decomposition:</span>
<a name="line-1885"></a>      <span class='hs-comment'>--  * if the argument is a kind argument, remember this, so that error</span>
<a name="line-1886"></a>      <span class='hs-comment'>--    messages say "kind", not "type". This is determined based on whether</span>
<a name="line-1887"></a>      <span class='hs-comment'>--    the corresponding tyConBinder is named (that is, dependent)</span>
<a name="line-1888"></a>      <span class='hs-comment'>--  * if the argument is invisible, note this as well, again by</span>
<a name="line-1889"></a>      <span class='hs-comment'>--    looking at the corresponding binder</span>
<a name="line-1890"></a>      <span class='hs-comment'>-- For oversaturated tycons, we need the (repeat loc) tail, which doesn't</span>
<a name="line-1891"></a>      <span class='hs-comment'>-- do either of these changes. (Forgetting to do so led to #16188)</span>
<a name="line-1892"></a>      <span class='hs-comment'>--</span>
<a name="line-1893"></a>      <span class='hs-comment'>-- NB: infinite in length</span>
<a name="line-1894"></a>    <span class='hs-varid'>new_locs</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>new_loc</span>
<a name="line-1895"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConBinders</span> <span class='hs-varid'>tc</span>
<a name="line-1896"></a>               <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_loc0</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isNamedTyConBinder</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toKindLoc</span> <span class='hs-varid'>loc</span>
<a name="line-1897"></a>                              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span>
<a name="line-1898"></a>                     <span class='hs-varid'>new_loc</span>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isInvisibleTyConBinder</span> <span class='hs-varid'>bndr</span>
<a name="line-1899"></a>                              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>updateCtLocOrigin</span> <span class='hs-varid'>new_loc0</span> <span class='hs-varid'>toInvisibleOrigin</span>
<a name="line-1900"></a>                              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1901"></a>                              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_loc0</span> <span class='hs-keyglyph'>]</span>
<a name="line-1902"></a>               <span class='hs-varop'>++</span> <span class='hs-varid'>repeat</span> <span class='hs-varid'>loc</span>
<a name="line-1903"></a>
<a name="line-1904"></a><a name="canEqFailure"></a><span class='hs-comment'>-- | Call when canonicalizing an equality fails, but if the equality is</span>
<a name="line-1905"></a><span class='hs-comment'>-- representational, there is some hope for the future.</span>
<a name="line-1906"></a><span class='hs-comment'>-- Examples in Note [Use canEqFailure in canDecomposableTyConApp]</span>
<a name="line-1907"></a><span class='hs-definition'>canEqFailure</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-1908"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1909"></a><span class='hs-definition'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1910"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqHardFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1911"></a><span class='hs-definition'>canEqFailure</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1912"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span>
<a name="line-1913"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty2</span>
<a name="line-1914"></a>            <span class='hs-comment'>-- We must rewrite the types before putting them in the</span>
<a name="line-1915"></a>            <span class='hs-comment'>-- inert set, so that we are sure to kick them out when</span>
<a name="line-1916"></a>            <span class='hs-comment'>-- new equalities become available</span>
<a name="line-1917"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqFailure with ReprEq"</span> <span class='hs-varop'>$</span>
<a name="line-1918"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi2</span> <span class='hs-keyglyph'>]</span>
<a name="line-1919"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-1920"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-conid'>ReprEqReason</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1921"></a>
<a name="line-1922"></a><a name="canEqHardFailure"></a><span class='hs-comment'>-- | Call when canonicalizing an equality fails with utterly no hope.</span>
<a name="line-1923"></a><span class='hs-definition'>canEqHardFailure</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-1924"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-1925"></a><span class='hs-comment'>-- See Note [Make sure that insolubles are fully rewritten]</span>
<a name="line-1926"></a><span class='hs-definition'>canEqHardFailure</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1927"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqHardFailure"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-1928"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>s1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span>
<a name="line-1929"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>s2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewrite</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty2</span>
<a name="line-1930"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span>
<a name="line-1931"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-conid'>ShapeMismatchReason</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1932"></a>
<a name="line-1933"></a><span class='hs-comment'>{-
<a name="line-1934"></a>Note [Decomposing TyConApps]
<a name="line-1935"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1936"></a>If we see (T s1 t1 ~ T s2 t2), then we can just decompose to
<a name="line-1937"></a>  (s1 ~ s2, t1 ~ t2)
<a name="line-1938"></a>and push those back into the work list.  But if
<a name="line-1939"></a>  s1 = K k1    s2 = K k2
<a name="line-1940"></a>then we will just decomopose s1~s2, and it might be better to
<a name="line-1941"></a>do so on the spot.  An important special case is where s1=s2,
<a name="line-1942"></a>and we get just Refl.
<a name="line-1943"></a>
<a name="line-1944"></a>So canDecomposableTyCon is a fast-path decomposition that uses
<a name="line-1945"></a>unifyWanted etc to short-cut that work.
<a name="line-1946"></a>
<a name="line-1947"></a>Note [Canonicalising type applications]
<a name="line-1948"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1949"></a>Given (s1 t1) ~ ty2, how should we proceed?
<a name="line-1950"></a>The simple thing is to see if ty2 is of form (s2 t2), and
<a name="line-1951"></a>decompose.
<a name="line-1952"></a>
<a name="line-1953"></a>However, over-eager decomposition gives bad error messages
<a name="line-1954"></a>for things like
<a name="line-1955"></a>   a b ~ Maybe c
<a name="line-1956"></a>   e f ~ p -&gt; q
<a name="line-1957"></a>Suppose (in the first example) we already know a~Array.  Then if we
<a name="line-1958"></a>decompose the application eagerly, yielding
<a name="line-1959"></a>   a ~ Maybe
<a name="line-1960"></a>   b ~ c
<a name="line-1961"></a>we get an error        "Can't match Array ~ Maybe",
<a name="line-1962"></a>but we'd prefer to get "Can't match Array b ~ Maybe c".
<a name="line-1963"></a>
<a name="line-1964"></a>So instead can_eq_wanted_app rewrites the LHS and RHS, in the hope of
<a name="line-1965"></a>replacing (a b) by (Array b), before using try_decompose_app to
<a name="line-1966"></a>decompose it.
<a name="line-1967"></a>
<a name="line-1968"></a>Note [Make sure that insolubles are fully rewritten]
<a name="line-1969"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1970"></a>When an equality fails, we still want to rewrite the equality
<a name="line-1971"></a>all the way down, so that it accurately reflects
<a name="line-1972"></a> (a) the mutable reference substitution in force at start of solving
<a name="line-1973"></a> (b) any ty-binds in force at this point in solving
<a name="line-1974"></a>See Note [Rewrite insolubles] in GHC.Tc.Solver.Monad.
<a name="line-1975"></a>And if we don't do this there is a bad danger that
<a name="line-1976"></a>GHC.Tc.Solver.applyTyVarDefaulting will find a variable
<a name="line-1977"></a>that has in fact been substituted.
<a name="line-1978"></a>
<a name="line-1979"></a>Note [Do not decompose Given polytype equalities]
<a name="line-1980"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1981"></a>Consider [G] (forall a. t1 ~ forall a. t2).  Can we decompose this?
<a name="line-1982"></a>No -- what would the evidence look like?  So instead we simply discard
<a name="line-1983"></a>this given evidence.
<a name="line-1984"></a>
<a name="line-1985"></a>
<a name="line-1986"></a>Note [Combining insoluble constraints]
<a name="line-1987"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1988"></a>As this point we have an insoluble constraint, like Int~Bool.
<a name="line-1989"></a>
<a name="line-1990"></a> * If it is Wanted, delete it from the cache, so that subsequent
<a name="line-1991"></a>   Int~Bool constraints give rise to separate error messages
<a name="line-1992"></a>
<a name="line-1993"></a> * But if it is Derived, DO NOT delete from cache.  A class constraint
<a name="line-1994"></a>   may get kicked out of the inert set, and then have its functional
<a name="line-1995"></a>   dependency Derived constraints generated a second time. In that
<a name="line-1996"></a>   case we don't want to get two (or more) error messages by
<a name="line-1997"></a>   generating two (or more) insoluble fundep constraints from the same
<a name="line-1998"></a>   class constraint.
<a name="line-1999"></a>
<a name="line-2000"></a>Note [No top-level newtypes on RHS of representational equalities]
<a name="line-2001"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2002"></a>Suppose we're in this situation:
<a name="line-2003"></a>
<a name="line-2004"></a> work item:  [W] c1 : a ~R b
<a name="line-2005"></a>     inert:  [G] c2 : b ~R Id a
<a name="line-2006"></a>
<a name="line-2007"></a>where
<a name="line-2008"></a>  newtype Id a = Id a
<a name="line-2009"></a>
<a name="line-2010"></a>We want to make sure canEqCanLHS sees [W] a ~R a, after b is rewritten
<a name="line-2011"></a>and the Id newtype is unwrapped. This is assured by requiring only rewritten
<a name="line-2012"></a>types in canEqCanLHS *and* having the newtype-unwrapping check above
<a name="line-2013"></a>the tyvar check in can_eq_nc.
<a name="line-2014"></a>
<a name="line-2015"></a>Note [Put touchable variables on the left]
<a name="line-2016"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2017"></a>Ticket #10009, a very nasty example:
<a name="line-2018"></a>
<a name="line-2019"></a>    f :: (UnF (F b) ~ b) =&gt; F b -&gt; ()
<a name="line-2020"></a>
<a name="line-2021"></a>    g :: forall a. (UnF (F a) ~ a) =&gt; a -&gt; ()
<a name="line-2022"></a>    g _ = f (undefined :: F a)
<a name="line-2023"></a>
<a name="line-2024"></a>For g we get [G]  g1 : UnF (F a) ~ a
<a name="line-2025"></a>             [WD] w1 : UnF (F beta) ~ beta
<a name="line-2026"></a>             [WD] w2 : F a ~ F beta
<a name="line-2027"></a>
<a name="line-2028"></a>g1 is canonical (CEqCan). It is oriented as above because a is not touchable.
<a name="line-2029"></a>See canEqTyVarFunEq.
<a name="line-2030"></a>
<a name="line-2031"></a>w1 is similarly canonical, though the occurs-check in canEqTyVarFunEq is key
<a name="line-2032"></a>here.
<a name="line-2033"></a>
<a name="line-2034"></a>w2 is canonical. But which way should it be oriented? As written, we'll be
<a name="line-2035"></a>stuck. When w2 is added to the inert set, nothing gets kicked out: g1 is
<a name="line-2036"></a>a Given (and Wanteds don't rewrite Givens), and w2 doesn't mention the LHS
<a name="line-2037"></a>of w2. We'll thus lose.
<a name="line-2038"></a>
<a name="line-2039"></a>But if w2 is swapped around, to
<a name="line-2040"></a>
<a name="line-2041"></a>    [D] w3 : F beta ~ F a
<a name="line-2042"></a>
<a name="line-2043"></a>then (after emitting shadow Deriveds, etc. See GHC.Tc.Solver.Monad
<a name="line-2044"></a>Note [The improvement story and derived shadows]) we'll kick w1 out of the inert
<a name="line-2045"></a>set (it mentions the LHS of w3). We then rewrite w1 to
<a name="line-2046"></a>
<a name="line-2047"></a>    [D] w4 : UnF (F a) ~ beta
<a name="line-2048"></a>
<a name="line-2049"></a>and then, using g1, to
<a name="line-2050"></a>
<a name="line-2051"></a>    [D] w5 : a ~ beta
<a name="line-2052"></a>
<a name="line-2053"></a>at which point we can unify and go on to glory. (This rewriting actually
<a name="line-2054"></a>happens all at once, in the call to rewrite during canonicalisation.)
<a name="line-2055"></a>
<a name="line-2056"></a>But what about the new LHS makes it better? It mentions a variable (beta)
<a name="line-2057"></a>that can appear in a Wanted -- a touchable metavariable never appears
<a name="line-2058"></a>in a Given. On the other hand, the original LHS mentioned only variables
<a name="line-2059"></a>that appear in Givens. We thus choose to put variables that can appear
<a name="line-2060"></a>in Wanteds on the left.
<a name="line-2061"></a>
<a name="line-2062"></a>Ticket #12526 is another good example of this in action.
<a name="line-2063"></a>
<a name="line-2064"></a>-}</span>
<a name="line-2065"></a>
<a name="line-2066"></a><a name="canEqCanLHS"></a><span class='hs-comment'>---------------------</span>
<a name="line-2067"></a><span class='hs-definition'>canEqCanLHS</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>          <span class='hs-comment'>-- ev :: lhs ~ rhs</span>
<a name="line-2068"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2069"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CanEqLHS</span>              <span class='hs-comment'>-- lhs (or, if swapped, rhs)</span>
<a name="line-2070"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>                <span class='hs-comment'>-- lhs: pretty lhs, already rewritten</span>
<a name="line-2071"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>      <span class='hs-comment'>-- rhs: already rewritten</span>
<a name="line-2072"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-2073"></a><span class='hs-definition'>canEqCanLHS</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ps_xi2</span>
<a name="line-2074"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>k2</span>
<a name="line-2075"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHSHomo</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ps_xi2</span>
<a name="line-2076"></a>
<a name="line-2077"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2078"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHSHetero</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>k1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varid'>k2</span>
<a name="line-2079"></a>
<a name="line-2080"></a>  <span class='hs-keyword'>where</span>
<a name="line-2081"></a>    <span class='hs-varid'>k1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLHSKind</span> <span class='hs-varid'>lhs1</span>
<a name="line-2082"></a>    <span class='hs-varid'>k2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>xi2</span>
<a name="line-2083"></a>
<a name="line-2084"></a><a name="canEqCanLHSHetero"></a><span class='hs-definition'>canEqCanLHSHetero</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>         <span class='hs-comment'>-- :: (xi1 :: ki1) ~ (xi2 :: ki2)</span>
<a name="line-2085"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2086"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CanEqLHS</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-comment'>-- xi1, pretty xi1</span>
<a name="line-2087"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcKind</span>             <span class='hs-comment'>-- ki1</span>
<a name="line-2088"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>   <span class='hs-comment'>-- xi2, pretty xi2 :: ki2</span>
<a name="line-2089"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcKind</span>             <span class='hs-comment'>-- ki2</span>
<a name="line-2090"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-2091"></a><span class='hs-definition'>canEqCanLHSHetero</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>ki1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varid'>ki2</span>
<a name="line-2092"></a>  <span class='hs-comment'>-- See Note [Equalities with incompatible kinds]</span>
<a name="line-2093"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>kind_co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>emit_kind_co</span>   <span class='hs-comment'>-- :: ki2 ~N ki1</span>
<a name="line-2094"></a>
<a name="line-2095"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span>  <span class='hs-comment'>-- kind_co :: (ki2 :: *) ~N (ki1 :: *)   (whether swapped or not)</span>
<a name="line-2096"></a>              <span class='hs-comment'>-- co1     :: kind(tv1) ~N ki1</span>
<a name="line-2097"></a>             <span class='hs-varid'>rhs'</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xi2</span>    <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>   <span class='hs-comment'>-- :: ki1</span>
<a name="line-2098"></a>             <span class='hs-varid'>ps_rhs'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varop'>`mkCastTy`</span> <span class='hs-varid'>kind_co</span>   <span class='hs-comment'>-- :: ki1</span>
<a name="line-2099"></a>             <span class='hs-varid'>rhs_co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcGReflLeftCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>kind_co</span>
<a name="line-2100"></a>               <span class='hs-comment'>-- rhs_co :: (xi2 |&gt; kind_co) ~ xi2</span>
<a name="line-2101"></a>
<a name="line-2102"></a>             <span class='hs-varid'>lhs_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>xi1</span>
<a name="line-2103"></a>
<a name="line-2104"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Hetero equality gives rise to kind equality"</span>
<a name="line-2105"></a>           <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>kind_co</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ki2</span><span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"~#"</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ki1</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-2106"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>type_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>rhs'</span> <span class='hs-varid'>lhs_co</span> <span class='hs-varid'>rhs_co</span>
<a name="line-2107"></a>
<a name="line-2108"></a>          <span class='hs-comment'>-- rewriteEqEvidence carries out the swap, so we're NotSwapped any more</span>
<a name="line-2109"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canEqCanLHSHomo</span> <span class='hs-varid'>type_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>rhs'</span> <span class='hs-varid'>ps_rhs'</span> <span class='hs-layout'>}</span>
<a name="line-2110"></a>  <span class='hs-keyword'>where</span>
<a name="line-2111"></a>    <span class='hs-varid'>emit_kind_co</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>CoercionN</span>
<a name="line-2112"></a>    <span class='hs-varid'>emit_kind_co</span>
<a name="line-2113"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evar</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ev</span>
<a name="line-2114"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>kind_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybe_sym</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTcKindCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>evar</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- :: k2 ~ k1</span>
<a name="line-2115"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>kind_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEvVar</span> <span class='hs-varid'>kind_loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>kind_pty</span><span class='hs-layout'>,</span> <span class='hs-varid'>evCoercion</span> <span class='hs-varid'>kind_co</span><span class='hs-layout'>)</span>
<a name="line-2116"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>emitWorkNC</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>kind_ev</span><span class='hs-keyglyph'>]</span>
<a name="line-2117"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvCoercion</span> <span class='hs-varid'>kind_ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2118"></a>
<a name="line-2119"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2120"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>kind_loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>ki2</span> <span class='hs-varid'>ki1</span>
<a name="line-2121"></a>
<a name="line-2122"></a>    <span class='hs-varid'>xi1</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLHSType</span> <span class='hs-varid'>lhs1</span>
<a name="line-2123"></a>    <span class='hs-varid'>loc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-varid'>ev</span>
<a name="line-2124"></a>    <span class='hs-varid'>role</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-2125"></a>    <span class='hs-varid'>kind_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkKindLoc</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>loc</span>
<a name="line-2126"></a>    <span class='hs-varid'>kind_pty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkHeteroPrimEqPred</span> <span class='hs-varid'>liftedTypeKind</span> <span class='hs-varid'>liftedTypeKind</span> <span class='hs-varid'>ki2</span> <span class='hs-varid'>ki1</span>
<a name="line-2127"></a>
<a name="line-2128"></a>    <span class='hs-varid'>maybe_sym</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>swapped</span> <span class='hs-keyword'>of</span>
<a name="line-2129"></a>          <span class='hs-conid'>IsSwapped</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>id</span>         <span class='hs-comment'>-- if the input is swapped, then we already</span>
<a name="line-2130"></a>                                   <span class='hs-comment'>-- will have k2 ~ k1</span>
<a name="line-2131"></a>          <span class='hs-conid'>NotSwapped</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkTcSymCo</span>
<a name="line-2132"></a>
<a name="line-2133"></a><a name="canEqCanLHSHomo"></a><span class='hs-comment'>-- guaranteed that tcTypeKind lhs == tcTypeKind rhs</span>
<a name="line-2134"></a><span class='hs-definition'>canEqCanLHSHomo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-2135"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2136"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CanEqLHS</span>           <span class='hs-comment'>-- lhs (or, if swapped, rhs)</span>
<a name="line-2137"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>             <span class='hs-comment'>-- pretty lhs</span>
<a name="line-2138"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>   <span class='hs-comment'>-- rhs, pretty rhs</span>
<a name="line-2139"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-2140"></a><span class='hs-definition'>canEqCanLHSHomo</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ps_xi2</span>
<a name="line-2141"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>split_cast_ty</span> <span class='hs-varid'>xi2</span>
<a name="line-2142"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>lhs2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>canEqLHS_maybe</span> <span class='hs-varid'>xi2'</span>
<a name="line-2143"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHS2</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>lhs2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ps_xi2</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>mkTcSymMCo</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span> <span class='hs-varid'>mco</span>
<a name="line-2144"></a>
<a name="line-2145"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2146"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHSFinish</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi2</span>
<a name="line-2147"></a>
<a name="line-2148"></a>  <span class='hs-keyword'>where</span>
<a name="line-2149"></a>    <span class='hs-varid'>split_cast_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-2150"></a>    <span class='hs-varid'>split_cast_ty</span> <span class='hs-varid'>other</span>          <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>other</span><span class='hs-layout'>,</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>
<a name="line-2151"></a>
<a name="line-2152"></a><a name="canEqCanLHS2"></a><span class='hs-comment'>-- This function deals with the case that both LHS and RHS are potential</span>
<a name="line-2153"></a><span class='hs-comment'>-- CanEqLHSs.</span>
<a name="line-2154"></a><span class='hs-definition'>canEqCanLHS2</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>              <span class='hs-comment'>-- lhs ~ (rhs |&gt; mco)</span>
<a name="line-2155"></a>                                        <span class='hs-comment'>-- or, if swapped: (rhs |&gt; mco) ~ lhs</span>
<a name="line-2156"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2157"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CanEqLHS</span>                <span class='hs-comment'>-- lhs (or, if swapped, rhs)</span>
<a name="line-2158"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>                  <span class='hs-comment'>-- pretty lhs</span>
<a name="line-2159"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CanEqLHS</span>                <span class='hs-comment'>-- rhs</span>
<a name="line-2160"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>                  <span class='hs-comment'>-- pretty rhs</span>
<a name="line-2161"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MCoercion</span>               <span class='hs-comment'>-- :: kind(rhs) ~N kind(lhs)</span>
<a name="line-2162"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-2163"></a><span class='hs-definition'>canEqCanLHS2</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>lhs2</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varid'>mco</span>
<a name="line-2164"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>lhs1</span> <span class='hs-varop'>`eqCanEqLHS`</span> <span class='hs-varid'>lhs2</span>
<a name="line-2165"></a>    <span class='hs-comment'>-- It must be the case that mco is reflexive</span>
<a name="line-2166"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqReflexive</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqLHSType</span> <span class='hs-varid'>lhs1</span><span class='hs-layout'>)</span>
<a name="line-2167"></a>
<a name="line-2168"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyVarLHS</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs1</span>
<a name="line-2169"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>TyVarLHS</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs2</span>
<a name="line-2170"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>swapOverTyVars</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>tv2</span>
<a name="line-2171"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqLHS2 swapOver"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tv2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>swapped</span><span class='hs-layout'>)</span>
<a name="line-2172"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>do_swap</span>
<a name="line-2173"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canEqCanLHSFinish</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarLHS</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span>
<a name="line-2174"></a>                                                   <span class='hs-layout'>(</span><span class='hs-varid'>ps_xi1</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>sym_mco</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2175"></a>
<a name="line-2176"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyVarLHS</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs1</span>
<a name="line-2177"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>TyFamLHS</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs2</span>
<a name="line-2178"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqTyVarFunEq</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varid'>mco</span>
<a name="line-2179"></a>
<a name="line-2180"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyFamLHS</span> <span class='hs-varid'>fun_tc1</span> <span class='hs-varid'>fun_args1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs1</span>
<a name="line-2181"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>TyVarLHS</span> <span class='hs-varid'>tv2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs2</span>
<a name="line-2182"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>do_swap</span>
<a name="line-2183"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>canEqTyVarFunEq</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>tv2</span> <span class='hs-varid'>ps_xi2</span>
<a name="line-2184"></a>                                                 <span class='hs-varid'>fun_tc1</span> <span class='hs-varid'>fun_args1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>sym_mco</span> <span class='hs-layout'>}</span>
<a name="line-2185"></a>
<a name="line-2186"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyFamLHS</span> <span class='hs-varid'>fun_tc1</span> <span class='hs-varid'>fun_args1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs1</span>
<a name="line-2187"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>TyFamLHS</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lhs2</span>
<a name="line-2188"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqCanLHS2 two type families"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs2</span><span class='hs-layout'>)</span>
<a name="line-2189"></a>
<a name="line-2190"></a>         <span class='hs-comment'>-- emit derived equalities for injective type families</span>
<a name="line-2191"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>inj_eqns</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TypeEqn</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- TypeEqn = Pair Type</span>
<a name="line-2192"></a>             <span class='hs-varid'>inj_eqns</span>
<a name="line-2193"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eq_rel</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>   <span class='hs-comment'>-- injectivity applies only for nom. eqs.</span>
<a name="line-2194"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fun_tc1</span> <span class='hs-varop'>/=</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>   <span class='hs-comment'>-- if the families don't match, stop.</span>
<a name="line-2195"></a>
<a name="line-2196"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Injective</span> <span class='hs-varid'>inj</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConInjectivityInfo</span> <span class='hs-varid'>fun_tc1</span>
<a name="line-2197"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span> <span class='hs-conid'>Pair</span> <span class='hs-varid'>arg1</span> <span class='hs-varid'>arg2</span>
<a name="line-2198"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg1</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg2</span><span class='hs-layout'>,</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zip3</span> <span class='hs-varid'>fun_args1</span> <span class='hs-varid'>fun_args2</span> <span class='hs-varid'>inj</span> <span class='hs-keyglyph'>]</span>
<a name="line-2199"></a>
<a name="line-2200"></a>                 <span class='hs-comment'>-- built-in synonym families don't have an entry point</span>
<a name="line-2201"></a>                 <span class='hs-comment'>-- for this use case. So, we just use sfInteractInert</span>
<a name="line-2202"></a>                 <span class='hs-comment'>-- and pass two equal RHSs. We *could* add another entry</span>
<a name="line-2203"></a>                 <span class='hs-comment'>-- point, but then there would be a burden to make</span>
<a name="line-2204"></a>                 <span class='hs-comment'>-- sure the new entry point and existing ones were</span>
<a name="line-2205"></a>                 <span class='hs-comment'>-- internally consistent. This is slightly distasteful,</span>
<a name="line-2206"></a>                 <span class='hs-comment'>-- but it works well in practice and localises the</span>
<a name="line-2207"></a>                 <span class='hs-comment'>-- problem.</span>
<a name="line-2208"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ops</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isBuiltInSynFamTyCon_maybe</span> <span class='hs-varid'>fun_tc1</span>
<a name="line-2209"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ki1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLHSKind</span> <span class='hs-varid'>lhs1</span>
<a name="line-2210"></a>                     <span class='hs-varid'>ki2</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MRefl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mco</span>
<a name="line-2211"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ki1</span>   <span class='hs-comment'>-- just a small optimisation</span>
<a name="line-2212"></a>                         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2213"></a>                         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLHSKind</span> <span class='hs-varid'>lhs2</span>
<a name="line-2214"></a>
<a name="line-2215"></a>                     <span class='hs-varid'>fake_rhs1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anyTypeOfKind</span> <span class='hs-varid'>ki1</span>
<a name="line-2216"></a>                     <span class='hs-varid'>fake_rhs2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anyTypeOfKind</span> <span class='hs-varid'>ki2</span>
<a name="line-2217"></a>                 <span class='hs-keyword'>in</span>
<a name="line-2218"></a>                 <span class='hs-varid'>sfInteractInert</span> <span class='hs-varid'>ops</span> <span class='hs-varid'>fun_args1</span> <span class='hs-varid'>fake_rhs1</span> <span class='hs-varid'>fun_args2</span> <span class='hs-varid'>fake_rhs2</span>
<a name="line-2219"></a>
<a name="line-2220"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- ordinary, non-injective type family</span>
<a name="line-2221"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-2222"></a>
<a name="line-2223"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-2224"></a>         <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>unifyDerived</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>inj_eqns</span>
<a name="line-2225"></a>
<a name="line-2226"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tclvl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcLevel</span>
<a name="line-2227"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-2228"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>tvs1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>fun_args1</span>
<a name="line-2229"></a>             <span class='hs-varid'>tvs2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyCoVarsOfTypes</span> <span class='hs-varid'>fun_args2</span>
<a name="line-2230"></a>
<a name="line-2231"></a>             <span class='hs-varid'>swap_for_rewriting</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>anyVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs2</span> <span class='hs-varop'>&amp;&amp;</span>
<a name="line-2232"></a>                          <span class='hs-comment'>-- swap 'em: Note [Put touchable variables on the left]</span>
<a name="line-2233"></a>                                  <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>anyVarSet</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTouchableMetaTyVar</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>tvs1</span><span class='hs-layout'>)</span>
<a name="line-2234"></a>                          <span class='hs-comment'>-- this check is just to avoid unfruitful swapping</span>
<a name="line-2235"></a>
<a name="line-2236"></a>               <span class='hs-comment'>-- If we have F a ~ F (F a), we want to swap.</span>
<a name="line-2237"></a>             <span class='hs-varid'>swap_for_occurs</span>
<a name="line-2238"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>cterHasNoProblem</span>   <span class='hs-varop'>$</span> <span class='hs-varid'>checkTyFamEq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span>
<a name="line-2239"></a>                                                   <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fun_tc1</span> <span class='hs-varid'>fun_args1</span><span class='hs-layout'>)</span>
<a name="line-2240"></a>               <span class='hs-layout'>,</span> <span class='hs-varid'>cterHasOccursCheck</span> <span class='hs-varop'>$</span> <span class='hs-varid'>checkTyFamEq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fun_tc1</span> <span class='hs-varid'>fun_args1</span>
<a name="line-2241"></a>                                                   <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span><span class='hs-layout'>)</span>
<a name="line-2242"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-2243"></a>
<a name="line-2244"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2245"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2246"></a>
<a name="line-2247"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>swap_for_rewriting</span> <span class='hs-varop'>||</span> <span class='hs-varid'>swap_for_occurs</span>
<a name="line-2248"></a>         <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>do_swap</span>
<a name="line-2249"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>canEqCanLHSFinish</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>IsSwapped</span> <span class='hs-varid'>lhs2</span> <span class='hs-layout'>(</span><span class='hs-varid'>ps_xi1</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>sym_mco</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2250"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>finish_without_swapping</span> <span class='hs-layout'>}</span>
<a name="line-2251"></a>
<a name="line-2252"></a>  <span class='hs-comment'>-- that's all the special cases. Now we just figure out which non-special case</span>
<a name="line-2253"></a>  <span class='hs-comment'>-- to continue to.</span>
<a name="line-2254"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2255"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>finish_without_swapping</span>
<a name="line-2256"></a>
<a name="line-2257"></a>  <span class='hs-keyword'>where</span>
<a name="line-2258"></a>    <span class='hs-varid'>sym_mco</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymMCo</span> <span class='hs-varid'>mco</span>
<a name="line-2259"></a>
<a name="line-2260"></a>    <span class='hs-varid'>do_swap</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rewriteCastedEquality</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqLHSType</span> <span class='hs-varid'>lhs1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>canEqLHSType</span> <span class='hs-varid'>lhs2</span><span class='hs-layout'>)</span> <span class='hs-varid'>mco</span>
<a name="line-2261"></a>    <span class='hs-varid'>finish_without_swapping</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqCanLHSFinish</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs1</span> <span class='hs-layout'>(</span><span class='hs-varid'>ps_xi2</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>mco</span><span class='hs-layout'>)</span>
<a name="line-2262"></a>
<a name="line-2263"></a>
<a name="line-2264"></a><a name="canEqTyVarFunEq"></a><span class='hs-comment'>-- This function handles the case where one side is a tyvar and the other is</span>
<a name="line-2265"></a><span class='hs-comment'>-- a type family application. Which to put on the left?</span>
<a name="line-2266"></a><span class='hs-comment'>--   If the tyvar is a touchable meta-tyvar, put it on the left, as this may</span>
<a name="line-2267"></a><span class='hs-comment'>--   be our only shot to unify.</span>
<a name="line-2268"></a><span class='hs-comment'>--   Otherwise, put the function on the left, because it's generally better to</span>
<a name="line-2269"></a><span class='hs-comment'>--   rewrite away function calls. This makes types smaller. And it seems necessary:</span>
<a name="line-2270"></a><span class='hs-comment'>--     [W] F alpha ~ alpha</span>
<a name="line-2271"></a><span class='hs-comment'>--     [W] F alpha ~ beta</span>
<a name="line-2272"></a><span class='hs-comment'>--     [W] G alpha beta ~ Int   ( where we have type instance G a a = a )</span>
<a name="line-2273"></a><span class='hs-comment'>--   If we end up with a stuck alpha ~ F alpha, we won't be able to solve this.</span>
<a name="line-2274"></a><span class='hs-comment'>--   Test case: indexed-types/should_compile/CEqCanOccursCheck</span>
<a name="line-2275"></a><span class='hs-definition'>canEqTyVarFunEq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>               <span class='hs-comment'>-- :: lhs ~ (rhs |&gt; mco)</span>
<a name="line-2276"></a>                                            <span class='hs-comment'>-- or (rhs |&gt; mco) ~ lhs if swapped</span>
<a name="line-2277"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2278"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>          <span class='hs-comment'>-- lhs (or if swapped rhs), pretty lhs</span>
<a name="line-2279"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>  <span class='hs-comment'>-- rhs (or if swapped lhs) fun and args, pretty rhs</span>
<a name="line-2280"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MCoercion</span>                <span class='hs-comment'>-- :: kind(rhs) ~N kind(lhs)</span>
<a name="line-2281"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-2282"></a><span class='hs-definition'>canEqTyVarFunEq</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ps_xi1</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varid'>mco</span>
<a name="line-2283"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_touchable</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>touchabilityTest</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>rhs</span>
<a name="line-2284"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>dflags</span>       <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-2285"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>is_touchable</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span> <span class='hs-conid'>Untouchable</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span><span class='hs-layout'>;</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-2286"></a>            <span class='hs-layout'>,</span> <span class='hs-varid'>cterHasNoProblem</span> <span class='hs-varop'>$</span>
<a name="line-2287"></a>                <span class='hs-varid'>checkTyVarEq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>`cterRemoveProblem`</span> <span class='hs-varid'>cteTypeFamily</span>
<a name="line-2288"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>canEqCanLHSFinish</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarLHS</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span>
<a name="line-2289"></a>
<a name="line-2290"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2291"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteCastedEquality</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span>
<a name="line-2292"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span><span class='hs-layout'>)</span>
<a name="line-2293"></a>                                  <span class='hs-varid'>mco</span>
<a name="line-2294"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>canEqCanLHSFinish</span> <span class='hs-varid'>new_ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-conid'>IsSwapped</span>
<a name="line-2295"></a>                                  <span class='hs-layout'>(</span><span class='hs-conid'>TyFamLHS</span> <span class='hs-varid'>fun_tc2</span> <span class='hs-varid'>fun_args2</span><span class='hs-layout'>)</span>
<a name="line-2296"></a>                                  <span class='hs-layout'>(</span><span class='hs-varid'>ps_xi1</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>sym_mco</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-2297"></a>  <span class='hs-keyword'>where</span>
<a name="line-2298"></a>    <span class='hs-varid'>sym_mco</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymMCo</span> <span class='hs-varid'>mco</span>
<a name="line-2299"></a>    <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ps_xi2</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>mco</span>
<a name="line-2300"></a>
<a name="line-2301"></a><a name="canEqCanLHSFinish"></a><span class='hs-comment'>-- The RHS here is either not CanEqLHS, or it's one that we</span>
<a name="line-2302"></a><span class='hs-comment'>-- want to rewrite the LHS to (as per e.g. swapOverTyVars)</span>
<a name="line-2303"></a><span class='hs-definition'>canEqCanLHSFinish</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-2304"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2305"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CanEqLHS</span>              <span class='hs-comment'>-- lhs (or, if swapped, rhs)</span>
<a name="line-2306"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>          <span class='hs-comment'>-- rhs, pretty rhs</span>
<a name="line-2307"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>
<a name="line-2308"></a><span class='hs-definition'>canEqCanLHSFinish</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs</span> <span class='hs-varid'>rhs</span>
<a name="line-2309"></a><span class='hs-comment'>-- RHS is fully rewritten, but with type synonyms</span>
<a name="line-2310"></a><span class='hs-comment'>-- preserved as much as possible</span>
<a name="line-2311"></a><span class='hs-comment'>-- guaranteed that tyVarKind lhs == typeKind rhs, for (TyEq:K)</span>
<a name="line-2312"></a><span class='hs-comment'>-- (TyEq:N) is checked in can_eq_nc', and (TyEq:TV) is handled in canEqCanLHS2</span>
<a name="line-2313"></a>
<a name="line-2314"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-2315"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs_ty</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>rewrite_co1</span> <span class='hs-varid'>rewrite_co2</span>
<a name="line-2316"></a>
<a name="line-2317"></a>     <span class='hs-comment'>-- by now, (TyEq:K) is already satisfied</span>
<a name="line-2318"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>canEqLHSKind</span> <span class='hs-varid'>lhs</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2319"></a>
<a name="line-2320"></a>     <span class='hs-comment'>-- by now, (TyEq:N) is already satisfied (if applicable)</span>
<a name="line-2321"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varid'>bad_newtype</span><span class='hs-layout'>)</span>
<a name="line-2322"></a>
<a name="line-2323"></a>     <span class='hs-comment'>-- guarantees (TyEq:OC), (TyEq:F)</span>
<a name="line-2324"></a>     <span class='hs-comment'>-- Must do the occurs check even on tyvar/tyvar</span>
<a name="line-2325"></a>     <span class='hs-comment'>-- equalities, in case have  x ~ (y :: ..x...); this is #12593.</span>
<a name="line-2326"></a>     <span class='hs-comment'>-- This next line checks also for coercion holes (TyEq:H); see</span>
<a name="line-2327"></a>     <span class='hs-comment'>-- Note [Equalities with incompatible kinds]</span>
<a name="line-2328"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>result0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>checkTypeEq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>lhs</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>`cterRemoveProblem`</span> <span class='hs-varid'>cteTypeFamily</span>
<a name="line-2329"></a>     <span class='hs-comment'>-- type families are OK here</span>
<a name="line-2330"></a>     <span class='hs-comment'>-- NB: no occCheckExpand here; see Note [Rewriting synonyms] in GHC.Tc.Solver.Rewrite</span>
<a name="line-2331"></a>
<a name="line-2332"></a>              <span class='hs-comment'>-- a ~R# b a is soluble if b later turns out to be Identity</span>
<a name="line-2333"></a>             <span class='hs-varid'>result</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>eq_rel</span> <span class='hs-keyword'>of</span>
<a name="line-2334"></a>                        <span class='hs-conid'>NomEq</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>result0</span>
<a name="line-2335"></a>                        <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>cterSetOccursCheckSoluble</span> <span class='hs-varid'>result0</span>
<a name="line-2336"></a>
<a name="line-2337"></a>             <span class='hs-varid'>reason</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>result</span> <span class='hs-varop'>`cterHasOnlyProblem`</span> <span class='hs-varid'>cteHoleBlocker</span>
<a name="line-2338"></a>                    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HoleBlockerReason</span> <span class='hs-layout'>(</span><span class='hs-varid'>coercionHolesOfType</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2339"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2340"></a>                    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NonCanonicalReason</span> <span class='hs-varid'>result</span>
<a name="line-2341"></a>
<a name="line-2342"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>cterHasNoProblem</span> <span class='hs-varid'>result</span>
<a name="line-2343"></a>         <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"CEqCan"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2344"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs</span>
<a name="line-2345"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2346"></a>
<a name="line-2347"></a>         <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>m_stuff</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>breakTyEqCycle_maybe</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>result</span> <span class='hs-varid'>lhs</span> <span class='hs-varid'>rhs</span>
<a name="line-2348"></a>                           <span class='hs-comment'>-- See Note [Type equality cycles];</span>
<a name="line-2349"></a>                           <span class='hs-comment'>-- returning Nothing is the vastly common case</span>
<a name="line-2350"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m_stuff</span> <span class='hs-keyword'>of</span>
<a name="line-2351"></a>                     <span class='hs-layout'>{</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2352"></a>                         <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqCanLHSFinish can't make a canonical"</span>
<a name="line-2353"></a>                                       <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-2354"></a>                            <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-varid'>reason</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2355"></a>                     <span class='hs-layout'>;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-2356"></a>              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"canEqCanLHSFinish breaking a cycle"</span> <span class='hs-varop'>$</span>
<a name="line-2357"></a>                            <span class='hs-varid'>ppr</span> <span class='hs-varid'>lhs</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs</span>
<a name="line-2358"></a>                 <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"new RHS:"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
<a name="line-2359"></a>
<a name="line-2360"></a>                   <span class='hs-comment'>-- This check is Detail (1) in the Note</span>
<a name="line-2361"></a>                 <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>cterHasOccursCheck</span> <span class='hs-layout'>(</span><span class='hs-varid'>checkTypeEq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>lhs</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
<a name="line-2362"></a>
<a name="line-2363"></a>                   <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Note [Type equality cycles] Detail (1)"</span>
<a name="line-2364"></a>                                      <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>new_rhs</span><span class='hs-layout'>)</span>
<a name="line-2365"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkIrredCt</span> <span class='hs-varid'>reason</span> <span class='hs-varid'>new_ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-2366"></a>
<a name="line-2367"></a>                   <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- See Detail (6) of Note [Type equality cycles]</span>
<a name="line-2368"></a>                             <span class='hs-varid'>new_new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>new_ev</span> <span class='hs-conid'>NotSwapped</span>
<a name="line-2369"></a>                                             <span class='hs-varid'>lhs_ty</span> <span class='hs-varid'>new_rhs</span>
<a name="line-2370"></a>                                             <span class='hs-layout'>(</span><span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>lhs_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span>
<a name="line-2371"></a>
<a name="line-2372"></a>                           <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-conid'>CEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_new_ev</span>
<a name="line-2373"></a>                                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cc_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs</span>
<a name="line-2374"></a>                                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_rhs</span>
<a name="line-2375"></a>                                                  <span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span>
<a name="line-2376"></a>  <span class='hs-keyword'>where</span>
<a name="line-2377"></a>    <span class='hs-varid'>role</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-2378"></a>
<a name="line-2379"></a>    <span class='hs-varid'>lhs_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>canEqLHSType</span> <span class='hs-varid'>lhs</span>
<a name="line-2380"></a>
<a name="line-2381"></a>    <span class='hs-varid'>rewrite_co1</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>lhs_ty</span>
<a name="line-2382"></a>    <span class='hs-varid'>rewrite_co2</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>rhs</span>
<a name="line-2383"></a>
<a name="line-2384"></a>    <span class='hs-comment'>-- This is about (TyEq:N)</span>
<a name="line-2385"></a>    <span class='hs-varid'>bad_newtype</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>eq_rel</span>
<a name="line-2386"></a>                <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tyConAppTyCon_maybe</span> <span class='hs-varid'>rhs</span>
<a name="line-2387"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNewTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-2388"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-2389"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-2390"></a>
<a name="line-2391"></a><a name="canEqReflexive"></a><span class='hs-comment'>-- | Solve a reflexive equality constraint</span>
<a name="line-2392"></a><span class='hs-definition'>canEqReflexive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>    <span class='hs-comment'>-- ty ~ ty</span>
<a name="line-2393"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span>
<a name="line-2394"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>        <span class='hs-comment'>-- ty</span>
<a name="line-2395"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>Ct</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- always Stop</span>
<a name="line-2396"></a><span class='hs-definition'>canEqReflexive</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>ty</span>
<a name="line-2397"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setEvBindIfWanted</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>evCoercion</span> <span class='hs-varop'>$</span>
<a name="line-2398"></a>                               <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-2399"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Solved by reflexivity"</span> <span class='hs-layout'>}</span>
<a name="line-2400"></a>
<a name="line-2401"></a><a name="rewriteCastedEquality"></a><span class='hs-definition'>rewriteCastedEquality</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>     <span class='hs-comment'>-- :: lhs ~ (rhs |&gt; mco), or (rhs |&gt; mco) ~ lhs</span>
<a name="line-2402"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-2403"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>         <span class='hs-comment'>-- lhs</span>
<a name="line-2404"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>         <span class='hs-comment'>-- rhs</span>
<a name="line-2405"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>MCoercion</span>      <span class='hs-comment'>-- mco</span>
<a name="line-2406"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-comment'>-- :: (lhs |&gt; sym mco) ~ rhs</span>
<a name="line-2407"></a>                                        <span class='hs-comment'>-- result is independent of SwapFlag</span>
<a name="line-2408"></a><span class='hs-definition'>rewriteCastedEquality</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>eq_rel</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>lhs</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>mco</span>
<a name="line-2409"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rewriteEqEvidence</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>new_lhs</span> <span class='hs-varid'>new_rhs</span> <span class='hs-varid'>lhs_co</span> <span class='hs-varid'>rhs_co</span>
<a name="line-2410"></a>  <span class='hs-keyword'>where</span>
<a name="line-2411"></a>    <span class='hs-varid'>new_lhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lhs</span> <span class='hs-varop'>`mkCastTyMCo`</span> <span class='hs-varid'>sym_mco</span>
<a name="line-2412"></a>    <span class='hs-varid'>lhs_co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcGReflLeftMCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>lhs</span> <span class='hs-varid'>sym_mco</span>
<a name="line-2413"></a>
<a name="line-2414"></a>    <span class='hs-varid'>new_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span>
<a name="line-2415"></a>    <span class='hs-varid'>rhs_co</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcGReflRightMCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>mco</span>
<a name="line-2416"></a>
<a name="line-2417"></a>    <span class='hs-varid'>sym_mco</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymMCo</span> <span class='hs-varid'>mco</span>
<a name="line-2418"></a>    <span class='hs-varid'>role</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span>
<a name="line-2419"></a>
<a name="line-2420"></a><span class='hs-comment'>{- Note [Equalities with incompatible kinds]
<a name="line-2421"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2422"></a>What do we do when we have an equality
<a name="line-2423"></a>
<a name="line-2424"></a>  (tv :: k1) ~ (rhs :: k2)
<a name="line-2425"></a>
<a name="line-2426"></a>where k1 and k2 differ? Easy: we create a coercion that relates k1 and
<a name="line-2427"></a>k2 and use this to cast. To wit, from
<a name="line-2428"></a>
<a name="line-2429"></a>  [X] (tv :: k1) ~ (rhs :: k2)
<a name="line-2430"></a>
<a name="line-2431"></a>(where [X] is [G], [W], or [D]), we go to
<a name="line-2432"></a>
<a name="line-2433"></a>  [noDerived X] co :: k2 ~ k1
<a name="line-2434"></a>  [X]           (tv :: k1) ~ ((rhs |&gt; co) :: k1)
<a name="line-2435"></a>
<a name="line-2436"></a>where
<a name="line-2437"></a>
<a name="line-2438"></a>  noDerived G = G
<a name="line-2439"></a>  noDerived _ = W
<a name="line-2440"></a>
<a name="line-2441"></a>For reasons described in Wrinkle (2) below, we want the [X] constraint to be "blocked";
<a name="line-2442"></a>that is, it should be put aside, and not used to rewrite any other constraint,
<a name="line-2443"></a>until the kind-equality on which it depends (namely 'co' above) is solved.
<a name="line-2444"></a>To achieve this
<a name="line-2445"></a>* The [X] constraint is a CIrredCan
<a name="line-2446"></a>* With a cc_reason of HoleBlockerReason bchs
<a name="line-2447"></a>* Where 'bchs' is the set of "blocking coercion holes".  The blocking coercion
<a name="line-2448"></a>  holes are the free coercion holes of [X]'s type
<a name="line-2449"></a>* When all the blocking coercion holes in the CIrredCan are filled (solved),
<a name="line-2450"></a>  we convert [X] to a CNonCanonical and put it in the work list.
<a name="line-2451"></a>All this is described in more detail in Wrinkle (2).
<a name="line-2452"></a>
<a name="line-2453"></a>Wrinkles:
<a name="line-2454"></a>
<a name="line-2455"></a> (1) The noDerived step is because Derived equalities have no evidence.
<a name="line-2456"></a>     And yet we absolutely need evidence to be able to proceed here.
<a name="line-2457"></a>     Given evidence will use the KindCo coercion; Wanted evidence will
<a name="line-2458"></a>     be a coercion hole. Even a Derived hetero equality begets a Wanted
<a name="line-2459"></a>     kind equality.
<a name="line-2460"></a>
<a name="line-2461"></a> (2) Though it would be sound to do so, we must not mark the rewritten Wanted
<a name="line-2462"></a>       [W] (tv :: k1) ~ ((rhs |&gt; co) :: k1)
<a name="line-2463"></a>     as canonical in the inert set. In particular, we must not unify tv.
<a name="line-2464"></a>     If we did, the Wanted becomes a Given (effectively), and then can
<a name="line-2465"></a>     rewrite other Wanteds. But that's bad: See Note [Wanteds do not rewrite Wanteds]
<a name="line-2466"></a>     in GHC.Tc.Types.Constraint. The problem is about poor error messages. See #11198 for
<a name="line-2467"></a>     tales of destruction.
<a name="line-2468"></a>
<a name="line-2469"></a>     So, we have an invariant on CEqCan (TyEq:H) that the RHS does not have
<a name="line-2470"></a>     any coercion holes. This is checked in checkTypeEq. Any equalities that
<a name="line-2471"></a>     have such an RHS are turned into CIrredCans with a HoleBlockerReason. We also
<a name="line-2472"></a>     must be sure to kick out any such CIrredCan constraints that mention coercion holes
<a name="line-2473"></a>     when those holes get filled in, so that the unification step can now proceed.
<a name="line-2474"></a>
<a name="line-2475"></a>     The kicking out is done in kickOutAfterFillingCoercionHole, and the inerts
<a name="line-2476"></a>     are stored in the inert_blocked field of InertCans.
<a name="line-2477"></a>
<a name="line-2478"></a>     However, we must be careful: we kick out only when no coercion holes are
<a name="line-2479"></a>     left. The holes in the type are stored in the HoleBlockerReason CtIrredReason.
<a name="line-2480"></a>     The extra check that there are no more remaining holes avoids
<a name="line-2481"></a>     needless work when rewriting evidence (which fills coercion holes) and
<a name="line-2482"></a>     aids efficiency.
<a name="line-2483"></a>
<a name="line-2484"></a>     Moreover, kicking out when there are remaining unfilled holes can
<a name="line-2485"></a>     cause a loop in the solver in this case:
<a name="line-2486"></a>          [W] w1 :: (ty1 :: F a) ~ (ty2 :: s)
<a name="line-2487"></a>     After canonicalisation, we discover that this equality is heterogeneous.
<a name="line-2488"></a>     So we emit
<a name="line-2489"></a>          [W] co_abc :: F a ~ s
<a name="line-2490"></a>     and preserve the original as
<a name="line-2491"></a>          [W] w2 :: (ty1 |&gt; co_abc) ~ ty2    (blocked on co_abc)
<a name="line-2492"></a>     Then, co_abc comes becomes the work item. It gets swapped in
<a name="line-2493"></a>     canEqCanLHS2 and then back again in canEqTyVarFunEq. We thus get
<a name="line-2494"></a>     co_abc := sym co_abd, and then co_abd := sym co_abe, with
<a name="line-2495"></a>          [W] co_abe :: F a ~ s
<a name="line-2496"></a>     This process has filled in co_abc. Suppose w2 were kicked out.
<a name="line-2497"></a>     When it gets processed,
<a name="line-2498"></a>     would get this whole chain going again. The solution is to
<a name="line-2499"></a>     kick out a blocked constraint only when the result of filling
<a name="line-2500"></a>     in the blocking coercion involves no further blocking coercions.
<a name="line-2501"></a>     Alternatively, we could be careful not to do unnecessary swaps during
<a name="line-2502"></a>     canonicalisation, but that seems hard to do, in general.
<a name="line-2503"></a>
<a name="line-2504"></a> (3) Suppose we have [W] (a :: k1) ~ (rhs :: k2). We duly follow the
<a name="line-2505"></a>     algorithm detailed here, producing [W] co :: k2 ~ k1, and adding
<a name="line-2506"></a>     [W] (a :: k1) ~ ((rhs |&gt; co) :: k1) to the irreducibles. Some time
<a name="line-2507"></a>     later, we solve co, and fill in co's coercion hole. This kicks out
<a name="line-2508"></a>     the irreducible as described in (2).
<a name="line-2509"></a>     But now, during canonicalization, we see the cast
<a name="line-2510"></a>     and remove it, in canEqCast. By the time we get into canEqCanLHS, the equality
<a name="line-2511"></a>     is heterogeneous again, and the process repeats.
<a name="line-2512"></a>
<a name="line-2513"></a>     To avoid this, we don't strip casts off a type if the other type
<a name="line-2514"></a>     in the equality is a CanEqLHS (the scenario above can happen with a
<a name="line-2515"></a>     type family, too. testcase: typecheck/should_compile/T13822).
<a name="line-2516"></a>     And this is an improvement regardless:
<a name="line-2517"></a>     because tyvars can, generally, unify with casted types, there's no
<a name="line-2518"></a>     reason to go through the work of stripping off the cast when the
<a name="line-2519"></a>     cast appears opposite a tyvar. This is implemented in the cast case
<a name="line-2520"></a>     of can_eq_nc'.
<a name="line-2521"></a>
<a name="line-2522"></a> (4) Reporting an error for a constraint that is blocked with HoleBlockerReason
<a name="line-2523"></a>     is hard: what would we say to users? And we don't
<a name="line-2524"></a>     really need to report, because if a constraint is blocked, then
<a name="line-2525"></a>     there is unsolved wanted blocking it; that unsolved wanted will
<a name="line-2526"></a>     be reported. We thus push such errors to the bottom of the queue
<a name="line-2527"></a>     in the error-reporting code; they should never be printed.
<a name="line-2528"></a>
<a name="line-2529"></a>     (4a) It would seem possible to do this filtering just based on the
<a name="line-2530"></a>          presence of a blocking coercion hole. However, this is no good,
<a name="line-2531"></a>          as it suppresses e.g. no-instance-found errors. We thus record
<a name="line-2532"></a>          a CtIrredReason in CIrredCan and filter based on this status.
<a name="line-2533"></a>          This happened in T14584. An alternative approach is to expressly
<a name="line-2534"></a>          look for *equalities* with blocking coercion holes, but actually
<a name="line-2535"></a>          recording the blockage in a status field seems nicer.
<a name="line-2536"></a>
<a name="line-2537"></a>     (4b) The error message might be printed with -fdefer-type-errors,
<a name="line-2538"></a>          so it still must exist. This is the only reason why there is
<a name="line-2539"></a>          a message at all. Otherwise, we could simply do nothing.
<a name="line-2540"></a>
<a name="line-2541"></a>Historical note:
<a name="line-2542"></a>
<a name="line-2543"></a>We used to do this via emitting a Derived kind equality and then parking
<a name="line-2544"></a>the heterogeneous equality as irreducible. But this new approach is much
<a name="line-2545"></a>more direct. And it doesn't produce duplicate Deriveds (as the old one did).
<a name="line-2546"></a>
<a name="line-2547"></a>Note [Type synonyms and canonicalization]
<a name="line-2548"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2549"></a>We treat type synonym applications as xi types, that is, they do not
<a name="line-2550"></a>count as type function applications.  However, we do need to be a bit
<a name="line-2551"></a>careful with type synonyms: like type functions they may not be
<a name="line-2552"></a>generative or injective.  However, unlike type functions, they are
<a name="line-2553"></a>parametric, so there is no problem in expanding them whenever we see
<a name="line-2554"></a>them, since we do not need to know anything about their arguments in
<a name="line-2555"></a>order to expand them; this is what justifies not having to treat them
<a name="line-2556"></a>as specially as type function applications.  The thing that causes
<a name="line-2557"></a>some subtleties is that we prefer to leave type synonym applications
<a name="line-2558"></a>*unexpanded* whenever possible, in order to generate better error
<a name="line-2559"></a>messages.
<a name="line-2560"></a>
<a name="line-2561"></a>If we encounter an equality constraint with type synonym applications
<a name="line-2562"></a>on both sides, or a type synonym application on one side and some sort
<a name="line-2563"></a>of type application on the other, we simply must expand out the type
<a name="line-2564"></a>synonyms in order to continue decomposing the equality constraint into
<a name="line-2565"></a>primitive equality constraints.  For example, suppose we have
<a name="line-2566"></a>
<a name="line-2567"></a>  type F a = [Int]
<a name="line-2568"></a>
<a name="line-2569"></a>and we encounter the equality
<a name="line-2570"></a>
<a name="line-2571"></a>  F a ~ [b]
<a name="line-2572"></a>
<a name="line-2573"></a>In order to continue we must expand F a into [Int], giving us the
<a name="line-2574"></a>equality
<a name="line-2575"></a>
<a name="line-2576"></a>  [Int] ~ [b]
<a name="line-2577"></a>
<a name="line-2578"></a>which we can then decompose into the more primitive equality
<a name="line-2579"></a>constraint
<a name="line-2580"></a>
<a name="line-2581"></a>  Int ~ b.
<a name="line-2582"></a>
<a name="line-2583"></a>However, if we encounter an equality constraint with a type synonym
<a name="line-2584"></a>application on one side and a variable on the other side, we should
<a name="line-2585"></a>NOT (necessarily) expand the type synonym, since for the purpose of
<a name="line-2586"></a>good error messages we want to leave type synonyms unexpanded as much
<a name="line-2587"></a>as possible.  Hence the ps_xi1, ps_xi2 argument passed to canEqCanLHS.
<a name="line-2588"></a>
<a name="line-2589"></a>Note [Type equality cycles]
<a name="line-2590"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2591"></a>Consider this situation (from indexed-types/should_compile/GivenLoop):
<a name="line-2592"></a>
<a name="line-2593"></a>  instance C (Maybe b)
<a name="line-2594"></a>  *[G] a ~ Maybe (F a)
<a name="line-2595"></a>  [W] C a
<a name="line-2596"></a>
<a name="line-2597"></a>or (typecheck/should_compile/T19682b):
<a name="line-2598"></a>
<a name="line-2599"></a>  instance C (a -&gt; b)
<a name="line-2600"></a>  *[WD] alpha ~ (Arg alpha -&gt; Res alpha)
<a name="line-2601"></a>  [W] C alpha
<a name="line-2602"></a>
<a name="line-2603"></a>or (typecheck/should_compile/T21515):
<a name="line-2604"></a>
<a name="line-2605"></a>  type family Code a
<a name="line-2606"></a>  *[G] Code a ~ '[ '[ Head (Head (Code a)) ] ]
<a name="line-2607"></a>  [W] Code a ~ '[ '[ alpha ] ]
<a name="line-2608"></a>
<a name="line-2609"></a>In order to solve the final Wanted, we must use the starred constraint
<a name="line-2610"></a>for rewriting. But note that all starred constraints have occurs-check failures,
<a name="line-2611"></a>and so we can't straightforwardly add these to the inert set and
<a name="line-2612"></a>use them for rewriting. (NB: A rigid type constructor is at the
<a name="line-2613"></a>top of all RHSs, preventing reorienting in canEqTyVarFunEq in the tyvar
<a name="line-2614"></a>cases.)
<a name="line-2615"></a>
<a name="line-2616"></a>The key idea is to replace the outermost type family applications in the RHS of the
<a name="line-2617"></a>starred constraints with a fresh variable, which we'll call a cycle-breaker
<a name="line-2618"></a>variable, or cbv. Then, relate the cbv back with the original type family application
<a name="line-2619"></a>via new equality constraints. Our situations thus become:
<a name="line-2620"></a>
<a name="line-2621"></a>  instance C (Maybe b)
<a name="line-2622"></a>  [G] a ~ Maybe cbv
<a name="line-2623"></a>  [G] F a ~ cbv
<a name="line-2624"></a>  [W] C a
<a name="line-2625"></a>
<a name="line-2626"></a>or
<a name="line-2627"></a>
<a name="line-2628"></a>  instance C (a -&gt; b)
<a name="line-2629"></a>  [WD] alpha ~ (cbv1 -&gt; cbv2)
<a name="line-2630"></a>  [WD] Arg alpha ~ cbv1
<a name="line-2631"></a>  [WD] Res alpha ~ cbv2
<a name="line-2632"></a>  [W] C alpha
<a name="line-2633"></a>
<a name="line-2634"></a>or
<a name="line-2635"></a>
<a name="line-2636"></a>  [G] Code a ~ '[ '[ cbv ] ]
<a name="line-2637"></a>  [G] Head (Head (Code a)) ~ cbv
<a name="line-2638"></a>  [W] Code a ~ '[ '[ alpha ] ]
<a name="line-2639"></a>
<a name="line-2640"></a>This transformation (creating the new types and emitting new equality
<a name="line-2641"></a>constraints) is done in breakTyEqCycle_maybe.
<a name="line-2642"></a>
<a name="line-2643"></a>The details depend on whether we're working with a Given or a Derived.
<a name="line-2644"></a>(Note that the Wanteds are really WDs, above. This is because Wanteds
<a name="line-2645"></a>are not used for rewriting.)
<a name="line-2646"></a>
<a name="line-2647"></a>Given
<a name="line-2648"></a>-----
<a name="line-2649"></a>
<a name="line-2650"></a>We emit a new Given, [G] F a ~ cbv, equating the type family application to
<a name="line-2651"></a>our new cbv. Note its orientation: The type family ends up on the left; see
<a name="line-2652"></a>commentary on canEqTyVarFunEq, which decides how to orient such cases. No
<a name="line-2653"></a>special treatment for CycleBreakerTvs is necessary. This scenario is now
<a name="line-2654"></a>easily soluble, by using the first Given to rewrite the Wanted, which can now
<a name="line-2655"></a>be solved.
<a name="line-2656"></a>
<a name="line-2657"></a>(The first Given actually also rewrites the second one, giving
<a name="line-2658"></a>[G] F (Maybe cbv) ~ cbv, but this causes no trouble.)
<a name="line-2659"></a>
<a name="line-2660"></a>Of course, we don't want our fresh variables leaking into e.g. error messages.
<a name="line-2661"></a>So we fill in the metavariables with their original type family applications
<a name="line-2662"></a>after we're done running the solver (in nestImplicTcS and runTcSWithEvBinds).
<a name="line-2663"></a>This is done by restoreTyVarCycles, which uses the inert_cycle_breakers field in
<a name="line-2664"></a>InertSet, which contains the pairings invented in breakTyEqCycle_maybe.
<a name="line-2665"></a>
<a name="line-2666"></a>That is:
<a name="line-2667"></a>
<a name="line-2668"></a>We transform
<a name="line-2669"></a>  [G] g : lhs ~ ...(F lhs)...
<a name="line-2670"></a>to
<a name="line-2671"></a>  [G] (Refl lhs) : F lhs ~ cbv      -- CEqCan
<a name="line-2672"></a>  [G] g          : lhs ~ ...cbv...  -- CEqCan
<a name="line-2673"></a>
<a name="line-2674"></a>Note that
<a name="line-2675"></a>* `cbv` is a fresh cycle breaker variable.
<a name="line-2676"></a>* `cbv` is a is a meta-tyvar, but it is completely untouchable.
<a name="line-2677"></a>* We track the cycle-breaker variables in inert_cycle_breakers in InertSet
<a name="line-2678"></a>* We eventually fill in the cycle-breakers, with `cbv := F lhs`.
<a name="line-2679"></a>  No one else fills in cycle-breakers!
<a name="line-2680"></a>* The evidence for the new `F lhs ~ cbv` constraint is Refl, because we know
<a name="line-2681"></a>  this fill-in is ultimately going to happen.
<a name="line-2682"></a>* In inert_cycle_breakers, we remember the (cbv, F lhs) pair; that is, we
<a name="line-2683"></a>  remember the /original/ type.  The [G] F lhs ~ cbv constraint may be rewritten
<a name="line-2684"></a>  by other givens (eg if we have another [G] lhs ~ (b,c)), but at the end we
<a name="line-2685"></a>  still fill in with cbv := F lhs
<a name="line-2686"></a>* This fill-in is done when solving is complete, by restoreTyVarCycles
<a name="line-2687"></a>  in nestImplicTcS and runTcSWithEvBinds.
<a name="line-2688"></a>
<a name="line-2689"></a>Wanted/Derived
<a name="line-2690"></a>--------------
<a name="line-2691"></a>The fresh cycle-breaker variables here must actually be normal, touchable
<a name="line-2692"></a>metavariables. That is, they are TauTvs. Nothing at all unusual. Repeating
<a name="line-2693"></a>the example from above, we have
<a name="line-2694"></a>
<a name="line-2695"></a>  *[WD] alpha ~ (Arg alpha -&gt; Res alpha)
<a name="line-2696"></a>
<a name="line-2697"></a>and we turn this into
<a name="line-2698"></a>
<a name="line-2699"></a>  *[WD] alpha ~ (cbv1 -&gt; cbv2)
<a name="line-2700"></a>  [WD] Arg alpha ~ cbv1
<a name="line-2701"></a>  [WD] Res alpha ~ cbv2
<a name="line-2702"></a>
<a name="line-2703"></a>where cbv1 and cbv2 are fresh TauTvs. Why TauTvs? See [Why TauTvs] below.
<a name="line-2704"></a>
<a name="line-2705"></a>Critically, we emit the two new constraints (the last two above)
<a name="line-2706"></a>directly instead of calling unifyWanted. (Otherwise, we'd end up unifying cbv1
<a name="line-2707"></a>and cbv2 immediately, achieving nothing.)
<a name="line-2708"></a>Next, we unify alpha := cbv1 -&gt; cbv2, having eliminated the occurs check. This
<a name="line-2709"></a>unification -- which must be the next step after breaking the cycles --
<a name="line-2710"></a>happens in the course of normal behavior of top-level
<a name="line-2711"></a>interactions, later in the solver pipeline. We know this unification will
<a name="line-2712"></a>indeed happen because breakTyEqCycle_maybe, which decides whether to apply
<a name="line-2713"></a>this logic, checks to ensure unification will succeed in its final_check.
<a name="line-2714"></a>(In particular, the LHS must be a touchable tyvar, never a type family. We don't
<a name="line-2715"></a>yet have an example of where this logic is needed with a type family, and it's
<a name="line-2716"></a>unclear how to handle this case, so we're skipping for now.) Now, we're
<a name="line-2717"></a>here (including further context from our original example, from the top of the
<a name="line-2718"></a>Note):
<a name="line-2719"></a>
<a name="line-2720"></a>  instance C (a -&gt; b)
<a name="line-2721"></a>  [WD] Arg (cbv1 -&gt; cbv2) ~ cbv1
<a name="line-2722"></a>  [WD] Res (cbv1 -&gt; cbv2) ~ cbv2
<a name="line-2723"></a>  [W] C (cbv1 -&gt; cbv2)
<a name="line-2724"></a>
<a name="line-2725"></a>The first two WD constraints reduce to reflexivity and are discarded,
<a name="line-2726"></a>and the last is easily soluble.
<a name="line-2727"></a>
<a name="line-2728"></a>[Why TauTvs]:
<a name="line-2729"></a>Let's look at another example (typecheck/should_compile/T19682) where we need
<a name="line-2730"></a>to unify the cbvs:
<a name="line-2731"></a>
<a name="line-2732"></a>  class    (AllEqF xs ys, SameShapeAs xs ys) =&gt; AllEq xs ys
<a name="line-2733"></a>  instance (AllEqF xs ys, SameShapeAs xs ys) =&gt; AllEq xs ys
<a name="line-2734"></a>
<a name="line-2735"></a>  type family SameShapeAs xs ys :: Constraint where
<a name="line-2736"></a>    SameShapeAs '[] ys      = (ys ~ '[])
<a name="line-2737"></a>    SameShapeAs (x : xs) ys = (ys ~ (Head ys : Tail ys))
<a name="line-2738"></a>
<a name="line-2739"></a>  type family AllEqF xs ys :: Constraint where
<a name="line-2740"></a>    AllEqF '[]      '[]      = ()
<a name="line-2741"></a>    AllEqF (x : xs) (y : ys) = (x ~ y, AllEq xs ys)
<a name="line-2742"></a>
<a name="line-2743"></a>  [WD] alpha ~ (Head alpha : Tail alpha)
<a name="line-2744"></a>  [WD] AllEqF '[Bool] alpha
<a name="line-2745"></a>
<a name="line-2746"></a>Without the logic detailed in this Note, we're stuck here, as AllEqF cannot
<a name="line-2747"></a>reduce and alpha cannot unify. Let's instead apply our cycle-breaker approach,
<a name="line-2748"></a>just as described above. We thus invent cbv1 and cbv2 and unify
<a name="line-2749"></a>alpha := cbv1 -&gt; cbv2, yielding (after zonking)
<a name="line-2750"></a>
<a name="line-2751"></a>  [WD] Head (cbv1 : cbv2) ~ cbv1
<a name="line-2752"></a>  [WD] Tail (cbv1 : cbv2) ~ cbv2
<a name="line-2753"></a>  [WD] AllEqF '[Bool] (cbv1 : cbv2)
<a name="line-2754"></a>
<a name="line-2755"></a>The first two WD constraints simplify to reflexivity and are discarded.
<a name="line-2756"></a>But the last reduces:
<a name="line-2757"></a>
<a name="line-2758"></a>  [WD] Bool ~ cbv1
<a name="line-2759"></a>  [WD] AllEq '[] cbv2
<a name="line-2760"></a>
<a name="line-2761"></a>The first of these is solved by unification: cbv1 := Bool. The second
<a name="line-2762"></a>is solved by the instance for AllEq to become
<a name="line-2763"></a>
<a name="line-2764"></a>  [WD] AllEqF '[] cbv2
<a name="line-2765"></a>  [WD] SameShapeAs '[] cbv2
<a name="line-2766"></a>
<a name="line-2767"></a>While the first of these is stuck, the second makes progress, to lead to
<a name="line-2768"></a>
<a name="line-2769"></a>  [WD] AllEqF '[] cbv2
<a name="line-2770"></a>  [WD] cbv2 ~ '[]
<a name="line-2771"></a>
<a name="line-2772"></a>This second constraint is solved by unification: cbv2 := '[]. We now
<a name="line-2773"></a>have
<a name="line-2774"></a>
<a name="line-2775"></a>  [WD] AllEqF '[] '[]
<a name="line-2776"></a>
<a name="line-2777"></a>which reduces to
<a name="line-2778"></a>
<a name="line-2779"></a>  [WD] ()
<a name="line-2780"></a>
<a name="line-2781"></a>which is trivially satisfiable. Hooray!
<a name="line-2782"></a>
<a name="line-2783"></a>Note that we need to unify the cbvs here; if we did not, there would be
<a name="line-2784"></a>no way to solve those constraints. That's why the cycle-breakers are
<a name="line-2785"></a>ordinary TauTvs.
<a name="line-2786"></a>
<a name="line-2787"></a>In all cases
<a name="line-2788"></a>------------
<a name="line-2789"></a>
<a name="line-2790"></a>We detect this scenario by the following characteristics:
<a name="line-2791"></a> - a constraint with a soluble occurs-check failure
<a name="line-2792"></a>   (as indicated by the cteSolubleOccurs bit set in a CheckTyEqResult
<a name="line-2793"></a>   from checkTypeEq)
<a name="line-2794"></a> - and a nominal equality
<a name="line-2795"></a> - and either
<a name="line-2796"></a>    - a Given flavour (but see also Detail (7) below)
<a name="line-2797"></a>    - a Wanted/Derived or just plain Derived flavour, with a touchable metavariable
<a name="line-2798"></a>      on the left
<a name="line-2799"></a>
<a name="line-2800"></a>We don't use this trick for representational equalities, as there is no
<a name="line-2801"></a>concrete use case where it is helpful (unlike for nominal equalities).
<a name="line-2802"></a>Furthermore, because function applications can be CanEqLHSs, but newtype
<a name="line-2803"></a>applications cannot, the disparities between the cases are enough that it
<a name="line-2804"></a>would be effortful to expand the idea to representational equalities. A quick
<a name="line-2805"></a>attempt, with
<a name="line-2806"></a>
<a name="line-2807"></a>      data family N a b
<a name="line-2808"></a>
<a name="line-2809"></a>      f :: (Coercible a (N a b), Coercible (N a b) b) =&gt; a -&gt; b
<a name="line-2810"></a>      f = coerce
<a name="line-2811"></a>
<a name="line-2812"></a>failed with "Could not match 'b' with 'b'." Further work is held off
<a name="line-2813"></a>until when we have a concrete incentive to explore this dark corner.
<a name="line-2814"></a>
<a name="line-2815"></a>Details:
<a name="line-2816"></a>
<a name="line-2817"></a> (1) We don't look under foralls, at all, when substituting away type family
<a name="line-2818"></a>     applications, because doing so can never be fruitful. Recall that we
<a name="line-2819"></a>     are in a case like [G] lhs ~ forall b. ... lhs ....   Until we have a type
<a name="line-2820"></a>     family that can pull the body out from a forall (e.g. type instance F (forall b. ty) = ty),
<a name="line-2821"></a>     this will always be
<a name="line-2822"></a>     insoluble. Note also that the forall cannot be in an argument to a
<a name="line-2823"></a>     type family, or that outer type family application would already have
<a name="line-2824"></a>     been substituted away.
<a name="line-2825"></a>
<a name="line-2826"></a>     However, we still must check to make sure that breakTyEqCycle_maybe actually
<a name="line-2827"></a>     succeeds in getting rid of all occurrences of the offending lhs. If
<a name="line-2828"></a>     one is hidden under a forall, this won't be true. A similar problem can
<a name="line-2829"></a>     happen if the variable appears only in a kind
<a name="line-2830"></a>     (e.g. k ~ ... (a :: k) ...). So we perform an additional check after
<a name="line-2831"></a>     performing the substitution. It is tiresome to re-run all of checkTypeEq
<a name="line-2832"></a>     here, but reimplementing just the occurs-check is even more tiresome.
<a name="line-2833"></a>
<a name="line-2834"></a>     Skipping this check causes typecheck/should_fail/GivenForallLoop and
<a name="line-2835"></a>     polykinds/T18451 to loop.
<a name="line-2836"></a>
<a name="line-2837"></a> (2) Our goal here is to avoid loops in rewriting. We can thus skip looking
<a name="line-2838"></a>     in coercions, as we don't rewrite in coercions in the algorithm in
<a name="line-2839"></a>     GHC.Solver.Rewrite. (This is another reason
<a name="line-2840"></a>     we need to re-check that we've gotten rid of all occurrences of the
<a name="line-2841"></a>     offending variable.)
<a name="line-2842"></a>
<a name="line-2843"></a> (3) As we're substituting as described in this Note, we can build ill-kinded
<a name="line-2844"></a>     types. For example, if we have Proxy (F a) b, where (b :: F a), then
<a name="line-2845"></a>     replacing this with Proxy cbv b is ill-kinded. However, we will later
<a name="line-2846"></a>     set cbv := F a, and so the zonked type will be well-kinded again.
<a name="line-2847"></a>     The temporary ill-kinded type hurts no one, and avoiding this would
<a name="line-2848"></a>     be quite painfully difficult.
<a name="line-2849"></a>
<a name="line-2850"></a>     Specifically, this detail does not contravene the Purely Kinded Type Invariant
<a name="line-2851"></a>     (Note [The Purely Kinded Type Invariant (PKTI)] in GHC.Tc.Gen.HsType).
<a name="line-2852"></a>     The PKTI says that we can call typeKind on any type, without failure.
<a name="line-2853"></a>     It would be violated if we, say, replaced a kind (a -&gt; b) with a kind c,
<a name="line-2854"></a>     because an arrow kind might be consulted in piResultTys. Here, we are
<a name="line-2855"></a>     replacing one opaque type like (F a b c) with another, cbv (opaque in
<a name="line-2856"></a>     that we never assume anything about its structure, like that it has a
<a name="line-2857"></a>     result type or a RuntimeRep argument).
<a name="line-2858"></a>
<a name="line-2859"></a> (4) The evidence for the produced Givens is all just reflexive, because
<a name="line-2860"></a>     we will eventually set the cycle-breaker variable to be the type family,
<a name="line-2861"></a>     and then, after the zonk, all will be well.
<a name="line-2862"></a>
<a name="line-2863"></a> (5) The approach here is inefficient because it replaces every (outermost)
<a name="line-2864"></a>     type family application with a type variable, regardless of whether that
<a name="line-2865"></a>     particular appplication is implicated in the occurs check.  An alternative
<a name="line-2866"></a>     would be to replce only type-family applications that meantion the offending LHS.
<a name="line-2867"></a>     For instance, we could choose to
<a name="line-2868"></a>     affect only type family applications that mention the offending LHS:
<a name="line-2869"></a>     e.g. in a ~ (F b, G a), we need to replace only G a, not F b. Furthermore,
<a name="line-2870"></a>     we could try to detect cases like a ~ (F a, F a) and use the same
<a name="line-2871"></a>     tyvar to replace F a. (Cf.
<a name="line-2872"></a>     Note [Flattening type-family applications when matching instances]
<a name="line-2873"></a>     in GHC.Core.Unify, which
<a name="line-2874"></a>     goes to this extra effort.) There may be other opportunities for
<a name="line-2875"></a>     improvement. However, this is really a very small corner case.
<a name="line-2876"></a>     The investment to craft a clever,
<a name="line-2877"></a>     performant solution seems unworthwhile.
<a name="line-2878"></a>
<a name="line-2879"></a> (6) We often get the predicate associated with a constraint from its
<a name="line-2880"></a>     evidence with ctPred. We thus must not only make sure the generated
<a name="line-2881"></a>     CEqCan's fields have the updated RHS type (that is, the one produced
<a name="line-2882"></a>     by replacing type family applications with fresh variables),
<a name="line-2883"></a>     but we must also update the evidence itself. This is done by the call to rewriteEqEvidence
<a name="line-2884"></a>     in canEqCanLHSFinish.
<a name="line-2885"></a>
<a name="line-2886"></a> (7) We don't wish to apply this magic on the equalities created
<a name="line-2887"></a>     by this very same process.
<a name="line-2888"></a>     Consider this, from typecheck/should_compile/ContextStack2:
<a name="line-2889"></a>
<a name="line-2890"></a>       type instance TF (a, b) = (TF a, TF b)
<a name="line-2891"></a>       t :: (a ~ TF (a, Int)) =&gt; ...
<a name="line-2892"></a>
<a name="line-2893"></a>       [G] a ~ TF (a, Int)
<a name="line-2894"></a>
<a name="line-2895"></a>     The RHS reduces, so we get
<a name="line-2896"></a>
<a name="line-2897"></a>       [G] a ~ (TF a, TF Int)
<a name="line-2898"></a>
<a name="line-2899"></a>     We then break cycles, to get
<a name="line-2900"></a>
<a name="line-2901"></a>       [G] g1 :: a ~ (cbv1, cbv2)
<a name="line-2902"></a>       [G] g2 :: TF a ~ cbv1
<a name="line-2903"></a>       [G] g3 :: TF Int ~ cbv2
<a name="line-2904"></a>
<a name="line-2905"></a>     g1 gets added to the inert set, as written. But then g2 becomes
<a name="line-2906"></a>     the work item. g1 rewrites g2 to become
<a name="line-2907"></a>
<a name="line-2908"></a>       [G] TF (cbv1, cbv2) ~ cbv1
<a name="line-2909"></a>
<a name="line-2910"></a>     which then uses the type instance to become
<a name="line-2911"></a>
<a name="line-2912"></a>       [G] (TF cbv1, TF cbv2) ~ cbv1
<a name="line-2913"></a>
<a name="line-2914"></a>     which looks remarkably like the Given we started with. If left
<a name="line-2915"></a>     unchecked, this will end up breaking cycles again, looping ad
<a name="line-2916"></a>     infinitum (and resulting in a context-stack reduction error,
<a name="line-2917"></a>     not an outright loop). The solution is easy: don't break cycles
<a name="line-2918"></a>     on an equality generated by breaking cycles. Instead, we mark this
<a name="line-2919"></a>     final Given as a CIrredCan with a NonCanonicalReason with the soluble
<a name="line-2920"></a>     occurs-check bit set (only).
<a name="line-2921"></a>
<a name="line-2922"></a>     We track these equalities by giving them a special CtOrigin,
<a name="line-2923"></a>     CycleBreakerOrigin. This works for both Givens and Wanteds, as
<a name="line-2924"></a>     we need the logic in the W case for e.g. typecheck/should_fail/T17139.
<a name="line-2925"></a>
<a name="line-2926"></a> (8) We really want to do this all only when there is a soluble occurs-check
<a name="line-2927"></a>     failure, not when other problems arise (such as an impredicative
<a name="line-2928"></a>     equality like alpha ~ forall a. a -&gt; a). That is why breakTyEqCycle_maybe
<a name="line-2929"></a>     uses cterHasOnlyProblem when looking at the result of checkTypeEq, which
<a name="line-2930"></a>     checks for many of the invariants on a CEqCan.
<a name="line-2931"></a>-}</span>
<a name="line-2932"></a>
<a name="line-2933"></a><span class='hs-comment'>{-
<a name="line-2934"></a>************************************************************************
<a name="line-2935"></a>*                                                                      *
<a name="line-2936"></a>                  Evidence transformation
<a name="line-2937"></a>*                                                                      *
<a name="line-2938"></a>************************************************************************
<a name="line-2939"></a>-}</span>
<a name="line-2940"></a>
<a name="line-2941"></a><a name="StopOrContinue"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>a</span>
<a name="line-2942"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>a</span>    <span class='hs-comment'>-- The constraint was not solved, although it may have</span>
<a name="line-2943"></a>                      <span class='hs-comment'>--   been rewritten</span>
<a name="line-2944"></a>
<a name="line-2945"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Stop</span> <span class='hs-conid'>CtEvidence</span>   <span class='hs-comment'>-- The (rewritten) constraint was solved</span>
<a name="line-2946"></a>         <span class='hs-conid'>SDoc</span>         <span class='hs-comment'>-- Tells how it was solved</span>
<a name="line-2947"></a>                      <span class='hs-comment'>-- Any new sub-goals have been put on the work list</span>
<a name="line-2948"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Functor</span><span class='hs-layout'>)</span>
<a name="line-2949"></a>
<a name="line-2950"></a><a name="instance%20Outputable%20(StopOrContinue%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-2951"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Stop"</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>parens</span> <span class='hs-varid'>s</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span>
<a name="line-2952"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>w</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ContinueWith"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>w</span>
<a name="line-2953"></a>
<a name="line-2954"></a><a name="continueWith"></a><span class='hs-definition'>continueWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-2955"></a><span class='hs-definition'>continueWith</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varop'>.</span> <span class='hs-conid'>ContinueWith</span>
<a name="line-2956"></a>
<a name="line-2957"></a><a name="stopWith"></a><span class='hs-definition'>stopWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-2958"></a><span class='hs-definition'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2959"></a>
<a name="line-2960"></a><a name="andWhenContinue"></a><span class='hs-definition'>andWhenContinue</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-2961"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-2962"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-2963"></a><span class='hs-definition'>andWhenContinue</span> <span class='hs-varid'>tcs1</span> <span class='hs-varid'>tcs2</span>
<a name="line-2964"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcs1</span>
<a name="line-2965"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>of</span>
<a name="line-2966"></a>           <span class='hs-conid'>Stop</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Stop</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-2967"></a>           <span class='hs-conid'>ContinueWith</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tcs2</span> <span class='hs-varid'>ct</span> <span class='hs-layout'>}</span>
<a name="line-2968"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>0</span> <span class='hs-varop'>`andWhenContinue`</span>    <span class='hs-comment'>-- allow chaining with ($)</span>
<a name="line-2969"></a>
<a name="line-2970"></a><a name="rewriteEvidence"></a><span class='hs-definition'>rewriteEvidence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>   <span class='hs-comment'>-- old evidence</span>
<a name="line-2971"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcPredType</span>   <span class='hs-comment'>-- new predicate</span>
<a name="line-2972"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span>   <span class='hs-comment'>-- Of type :: new predicate ~ &lt;type of old evidence&gt;</span>
<a name="line-2973"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>StopOrContinue</span> <span class='hs-conid'>CtEvidence</span><span class='hs-layout'>)</span>
<a name="line-2974"></a><span class='hs-comment'>-- Returns Just new_ev iff either (i)  'co' is reflexivity</span>
<a name="line-2975"></a><span class='hs-comment'>--                             or (ii) 'co' is not reflexivity, and 'new_pred' not cached</span>
<a name="line-2976"></a><span class='hs-comment'>-- In either case, there is nothing new to do with new_ev</span>
<a name="line-2977"></a><span class='hs-comment'>{-
<a name="line-2978"></a>     rewriteEvidence old_ev new_pred co
<a name="line-2979"></a>Main purpose: create new evidence for new_pred;
<a name="line-2980"></a>              unless new_pred is cached already
<a name="line-2981"></a>* Returns a new_ev : new_pred, with same wanted/given/derived flag as old_ev
<a name="line-2982"></a>* If old_ev was wanted, create a binding for old_ev, in terms of new_ev
<a name="line-2983"></a>* If old_ev was given, AND not cached, create a binding for new_ev, in terms of old_ev
<a name="line-2984"></a>* Returns Nothing if new_ev is already cached
<a name="line-2985"></a>
<a name="line-2986"></a>        Old evidence    New predicate is               Return new evidence
<a name="line-2987"></a>        flavour                                        of same flavor
<a name="line-2988"></a>        -------------------------------------------------------------------
<a name="line-2989"></a>        Wanted          Already solved or in inert     Nothing
<a name="line-2990"></a>        or Derived      Not                            Just new_evidence
<a name="line-2991"></a>
<a name="line-2992"></a>        Given           Already in inert               Nothing
<a name="line-2993"></a>                        Not                            Just new_evidence
<a name="line-2994"></a>
<a name="line-2995"></a>Note [Rewriting with Refl]
<a name="line-2996"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-2997"></a>If the coercion is just reflexivity then you may re-use the same
<a name="line-2998"></a>variable.  But be careful!  Although the coercion is Refl, new_pred
<a name="line-2999"></a>may reflect the result of unification alpha := ty, so new_pred might
<a name="line-3000"></a>not _look_ the same as old_pred, and it's vital to proceed from now on
<a name="line-3001"></a>using new_pred.
<a name="line-3002"></a>
<a name="line-3003"></a>The rewriter preserves type synonyms, so they should appear in new_pred
<a name="line-3004"></a>as well as in old_pred; that is important for good error messages.
<a name="line-3005"></a> -}</span>
<a name="line-3006"></a>
<a name="line-3007"></a>
<a name="line-3008"></a><span class='hs-definition'>rewriteEvidence</span> <span class='hs-varid'>old_ev</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CtDerived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_pred</span> <span class='hs-sel'>_co</span>
<a name="line-3009"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- If derived, don't even look at the coercion.</span>
<a name="line-3010"></a>    <span class='hs-comment'>-- This is very important, DO NOT re-order the equations for</span>
<a name="line-3011"></a>    <span class='hs-comment'>-- rewriteEvidence to put the isTcReflCo test first!</span>
<a name="line-3012"></a>    <span class='hs-comment'>-- Why?  Because for *Derived* constraints, c, the coercion, which</span>
<a name="line-3013"></a>    <span class='hs-comment'>-- was produced by rewriting, may contain suspended calls to</span>
<a name="line-3014"></a>    <span class='hs-comment'>-- (ctEvExpr c), which fails for Derived constraints.</span>
<a name="line-3015"></a>    <span class='hs-comment'>-- (Getting this wrong caused #7384.)</span>
<a name="line-3016"></a>    <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>old_ev</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_pred</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3017"></a>
<a name="line-3018"></a><span class='hs-definition'>rewriteEvidence</span> <span class='hs-varid'>old_ev</span> <span class='hs-varid'>new_pred</span> <span class='hs-varid'>co</span>
<a name="line-3019"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTcReflCo</span> <span class='hs-varid'>co</span> <span class='hs-comment'>-- See Note [Rewriting with Refl]</span>
<a name="line-3020"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>continueWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>old_ev</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_pred</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3021"></a>
<a name="line-3022"></a><span class='hs-definition'>rewriteEvidence</span> <span class='hs-varid'>ev</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_evar</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_pred</span> <span class='hs-varid'>co</span>
<a name="line-3023"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newGivenEvVar</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_tm</span><span class='hs-layout'>)</span>
<a name="line-3024"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>continueWith</span> <span class='hs-varid'>new_ev</span> <span class='hs-layout'>}</span>
<a name="line-3025"></a>  <span class='hs-keyword'>where</span>
<a name="line-3026"></a>    <span class='hs-comment'>-- mkEvCast optimises ReflCo</span>
<a name="line-3027"></a>    <span class='hs-varid'>new_tm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkEvCast</span> <span class='hs-layout'>(</span><span class='hs-varid'>evId</span> <span class='hs-varid'>old_evar</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcDowngradeRole</span> <span class='hs-conid'>Representational</span>
<a name="line-3028"></a>                                                       <span class='hs-layout'>(</span><span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-3029"></a>                                                       <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3030"></a>
<a name="line-3031"></a><span class='hs-definition'>rewriteEvidence</span> <span class='hs-varid'>ev</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_dest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dest</span>
<a name="line-3032"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_nosh</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>si</span>
<a name="line-3033"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ctev_loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_pred</span> <span class='hs-varid'>co</span>
<a name="line-3034"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_new_ev</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWanted_SI</span> <span class='hs-varid'>si</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>new_pred</span>
<a name="line-3035"></a>               <span class='hs-comment'>-- The "_SI" variant ensures that we make a new Wanted</span>
<a name="line-3036"></a>               <span class='hs-comment'>-- with the same shadow-info as the existing one</span>
<a name="line-3037"></a>               <span class='hs-comment'>-- with the same shadow-info as the existing one (#16735)</span>
<a name="line-3038"></a>       <span class='hs-layout'>;</span> <span class='hs-conid'>MASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>tcCoercionRole</span> <span class='hs-varid'>co</span> <span class='hs-varop'>==</span> <span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>)</span>
<a name="line-3039"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedEvTerm</span> <span class='hs-varid'>dest</span>
<a name="line-3040"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>mkEvCast</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEvExpr</span> <span class='hs-varid'>mb_new_ev</span><span class='hs-layout'>)</span>
<a name="line-3041"></a>                      <span class='hs-layout'>(</span><span class='hs-varid'>tcDowngradeRole</span> <span class='hs-conid'>Representational</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-3042"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_new_ev</span> <span class='hs-keyword'>of</span>
<a name="line-3043"></a>            <span class='hs-conid'>Fresh</span>  <span class='hs-varid'>new_ev</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>continueWith</span> <span class='hs-varid'>new_ev</span>
<a name="line-3044"></a>            <span class='hs-conid'>Cached</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>stopWith</span> <span class='hs-varid'>ev</span> <span class='hs-str'>"Cached wanted"</span> <span class='hs-layout'>}</span>
<a name="line-3045"></a>
<a name="line-3046"></a>
<a name="line-3047"></a><a name="rewriteEqEvidence"></a><span class='hs-definition'>rewriteEqEvidence</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span>         <span class='hs-comment'>-- Old evidence :: olhs ~ orhs (not swapped)</span>
<a name="line-3048"></a>                                        <span class='hs-comment'>--              or orhs ~ olhs (swapped)</span>
<a name="line-3049"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SwapFlag</span>
<a name="line-3050"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span>   <span class='hs-comment'>-- New predicate  nlhs ~ nrhs</span>
<a name="line-3051"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span>         <span class='hs-comment'>-- lhs_co, of type :: nlhs ~ olhs</span>
<a name="line-3052"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span>         <span class='hs-comment'>-- rhs_co, of type :: nrhs ~ orhs</span>
<a name="line-3053"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>CtEvidence</span>     <span class='hs-comment'>-- Of type nlhs ~ nrhs</span>
<a name="line-3054"></a><span class='hs-comment'>-- For (rewriteEqEvidence (Given g olhs orhs) False nlhs nrhs lhs_co rhs_co)</span>
<a name="line-3055"></a><span class='hs-comment'>-- we generate</span>
<a name="line-3056"></a><span class='hs-comment'>-- If not swapped</span>
<a name="line-3057"></a><span class='hs-comment'>--      g1 : nlhs ~ nrhs = lhs_co ; g ; sym rhs_co</span>
<a name="line-3058"></a><span class='hs-comment'>-- If 'swapped'</span>
<a name="line-3059"></a><span class='hs-comment'>--      g1 : nlhs ~ nrhs = lhs_co ; Sym g ; sym rhs_co</span>
<a name="line-3060"></a><span class='hs-comment'>--</span>
<a name="line-3061"></a><span class='hs-comment'>-- For (Wanted w) we do the dual thing.</span>
<a name="line-3062"></a><span class='hs-comment'>-- New  w1 : nlhs ~ nrhs</span>
<a name="line-3063"></a><span class='hs-comment'>-- If not swapped</span>
<a name="line-3064"></a><span class='hs-comment'>--      w : olhs ~ orhs = sym lhs_co ; w1 ; rhs_co</span>
<a name="line-3065"></a><span class='hs-comment'>-- If swapped</span>
<a name="line-3066"></a><span class='hs-comment'>--      w : orhs ~ olhs = sym rhs_co ; sym w1 ; lhs_co</span>
<a name="line-3067"></a><span class='hs-comment'>--</span>
<a name="line-3068"></a><span class='hs-comment'>-- It's all a form of rewwriteEvidence, specialised for equalities</span>
<a name="line-3069"></a><span class='hs-definition'>rewriteEqEvidence</span> <span class='hs-varid'>old_ev</span> <span class='hs-varid'>swapped</span> <span class='hs-varid'>nlhs</span> <span class='hs-varid'>nrhs</span> <span class='hs-varid'>lhs_co</span> <span class='hs-varid'>rhs_co</span>
<a name="line-3070"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtDerived</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>old_ev</span>  <span class='hs-comment'>-- Don't force the evidence for a Derived</span>
<a name="line-3071"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>old_ev</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_pred</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3072"></a>
<a name="line-3073"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NotSwapped</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>swapped</span>
<a name="line-3074"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isTcReflCo</span> <span class='hs-varid'>lhs_co</span>      <span class='hs-comment'>-- See Note [Rewriting with Refl]</span>
<a name="line-3075"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isTcReflCo</span> <span class='hs-varid'>rhs_co</span>
<a name="line-3076"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>old_ev</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_pred</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3077"></a>
<a name="line-3078"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtGiven</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_evar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_evar</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>old_ev</span>
<a name="line-3079"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_tm</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>evCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>lhs_co</span>
<a name="line-3080"></a>                                  <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>maybeTcSymCo</span> <span class='hs-varid'>swapped</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcCoVarCo</span> <span class='hs-varid'>old_evar</span><span class='hs-layout'>)</span>
<a name="line-3081"></a>                                  <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>rhs_co</span><span class='hs-layout'>)</span>
<a name="line-3082"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>newGivenEvVar</span> <span class='hs-varid'>loc'</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_pred</span><span class='hs-layout'>,</span> <span class='hs-varid'>new_tm</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3083"></a>
<a name="line-3084"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CtWanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctev_dest</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dest</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctev_nosh</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>si</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>old_ev</span>
<a name="line-3085"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>hole_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newWantedEq_SI</span> <span class='hs-varid'>si</span> <span class='hs-varid'>loc'</span>
<a name="line-3086"></a>                                             <span class='hs-layout'>(</span><span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>old_ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>nlhs</span> <span class='hs-varid'>nrhs</span>
<a name="line-3087"></a>               <span class='hs-comment'>-- The "_SI" variant ensures that we make a new Wanted</span>
<a name="line-3088"></a>               <span class='hs-comment'>-- with the same shadow-info as the existing one (#16735)</span>
<a name="line-3089"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>maybeTcSymCo</span> <span class='hs-varid'>swapped</span> <span class='hs-varop'>$</span>
<a name="line-3090"></a>                  <span class='hs-varid'>mkSymCo</span> <span class='hs-varid'>lhs_co</span>
<a name="line-3091"></a>                  <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>hole_co</span>
<a name="line-3092"></a>                  <span class='hs-varop'>`mkTransCo`</span> <span class='hs-varid'>rhs_co</span>
<a name="line-3093"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedEq</span> <span class='hs-varid'>dest</span> <span class='hs-varid'>co</span>
<a name="line-3094"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"rewriteEqEvidence"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>old_ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>nlhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>nrhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-3095"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>new_ev</span> <span class='hs-layout'>}</span>
<a name="line-3096"></a>
<a name="line-3097"></a><span class='hs-cpp'>#if __GLASGOW_HASKELL__ &lt;= 810</span>
<a name="line-3098"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-3099"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"rewriteEvidence"</span>
<a name="line-3100"></a><span class='hs-cpp'>#endif</span>
<a name="line-3101"></a>  <span class='hs-keyword'>where</span>
<a name="line-3102"></a>    <span class='hs-varid'>new_pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcEqPredLikeEv</span> <span class='hs-varid'>old_ev</span> <span class='hs-varid'>nlhs</span> <span class='hs-varid'>nrhs</span>
<a name="line-3103"></a>
<a name="line-3104"></a>      <span class='hs-comment'>-- equality is like a type class. Bumping the depth is necessary because</span>
<a name="line-3105"></a>      <span class='hs-comment'>-- of recursive newtypes, where "reducing" a newtype can actually make</span>
<a name="line-3106"></a>      <span class='hs-comment'>-- it bigger. See Note [Newtypes can blow the stack].</span>
<a name="line-3107"></a>    <span class='hs-varid'>loc</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>old_ev</span>
<a name="line-3108"></a>    <span class='hs-varid'>loc'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bumpCtLocDepth</span> <span class='hs-varid'>loc</span>
<a name="line-3109"></a>
<a name="line-3110"></a><span class='hs-comment'>{-
<a name="line-3111"></a>************************************************************************
<a name="line-3112"></a>*                                                                      *
<a name="line-3113"></a>              Unification
<a name="line-3114"></a>*                                                                      *
<a name="line-3115"></a>************************************************************************
<a name="line-3116"></a>
<a name="line-3117"></a>Note [unifyWanted and unifyDerived]
<a name="line-3118"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-3119"></a>When decomposing equalities we often create new wanted constraints for
<a name="line-3120"></a>(s ~ t).  But what if s=t?  Then it'd be faster to return Refl right away.
<a name="line-3121"></a>Similar remarks apply for Derived.
<a name="line-3122"></a>
<a name="line-3123"></a>Rather than making an equality test (which traverses the structure of the
<a name="line-3124"></a>type, perhaps fruitlessly), unifyWanted traverses the common structure, and
<a name="line-3125"></a>bales out when it finds a difference by creating a new Wanted constraint.
<a name="line-3126"></a>But where it succeeds in finding common structure, it just builds a coercion
<a name="line-3127"></a>to reflect it.
<a name="line-3128"></a>-}</span>
<a name="line-3129"></a>
<a name="line-3130"></a><a name="unifyWanted"></a><span class='hs-definition'>unifyWanted</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span>
<a name="line-3131"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Coercion</span>
<a name="line-3132"></a><span class='hs-comment'>-- Return coercion witnessing the equality of the two types,</span>
<a name="line-3133"></a><span class='hs-comment'>-- emitting new work equalities where necessary to achieve that</span>
<a name="line-3134"></a><span class='hs-comment'>-- Very good short-cut when the two types are equal, or nearly so</span>
<a name="line-3135"></a><span class='hs-comment'>-- See Note [unifyWanted and unifyDerived]</span>
<a name="line-3136"></a><span class='hs-comment'>-- The returned coercion's role matches the input parameter</span>
<a name="line-3137"></a><span class='hs-definition'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-conid'>Phantom</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-3138"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>kind_co</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcTypeKind</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-3139"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkPhantomCo</span> <span class='hs-varid'>kind_co</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3140"></a>
<a name="line-3141"></a><span class='hs-definition'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>orig_ty1</span> <span class='hs-varid'>orig_ty2</span>
<a name="line-3142"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>orig_ty1</span> <span class='hs-varid'>orig_ty2</span>
<a name="line-3143"></a>  <span class='hs-keyword'>where</span>
<a name="line-3144"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2</span>
<a name="line-3145"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2'</span>
<a name="line-3146"></a>
<a name="line-3147"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w1</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w2</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-3148"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>co_s</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-3149"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>co_t</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span>
<a name="line-3150"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>co_w</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>w1</span> <span class='hs-varid'>w2</span>
<a name="line-3151"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFunCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>co_w</span> <span class='hs-varid'>co_s</span> <span class='hs-varid'>co_t</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3152"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span>
<a name="line-3153"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>tys2</span>
<a name="line-3154"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isInjectiveTyCon</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>role</span> <span class='hs-comment'>-- don't look under newtypes at Rep equality</span>
<a name="line-3155"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cos</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zipWith3M</span> <span class='hs-layout'>(</span><span class='hs-varid'>unifyWanted</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span>
<a name="line-3156"></a>                              <span class='hs-layout'>(</span><span class='hs-varid'>tyConRolesX</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc1</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-3157"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-3158"></a>
<a name="line-3159"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span>
<a name="line-3160"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-3161"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span>
<a name="line-3162"></a>                <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2</span>
<a name="line-3163"></a>                <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>}</span>
<a name="line-3164"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-3165"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-3166"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span>
<a name="line-3167"></a>                <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2'</span>
<a name="line-3168"></a>                <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span>
<a name="line-3169"></a>
<a name="line-3170"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-3171"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- we just don't care about coercions!</span>
<a name="line-3172"></a>
<a name="line-3173"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-3174"></a>
<a name="line-3175"></a>    <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-3176"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span>
<a name="line-3177"></a>        <span class='hs-comment'>-- Check for equality; e.g. a ~ a, or (m a) ~ (m a)</span>
<a name="line-3178"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emitNewWantedEq</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>orig_ty1</span> <span class='hs-varid'>orig_ty2</span>
<a name="line-3179"></a>
<a name="line-3180"></a><a name="unifyDeriveds"></a><span class='hs-definition'>unifyDeriveds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-3181"></a><span class='hs-comment'>-- See Note [unifyWanted and unifyDerived]</span>
<a name="line-3182"></a><span class='hs-definition'>unifyDeriveds</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith3M_</span> <span class='hs-layout'>(</span><span class='hs-varid'>unify_derived</span> <span class='hs-varid'>loc</span><span class='hs-layout'>)</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-3183"></a>
<a name="line-3184"></a><a name="unifyDerived"></a><span class='hs-definition'>unifyDerived</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Pair</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-3185"></a><span class='hs-comment'>-- See Note [unifyWanted and unifyDerived]</span>
<a name="line-3186"></a><span class='hs-definition'>unifyDerived</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-layout'>(</span><span class='hs-conid'>Pair</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unify_derived</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-3187"></a>
<a name="line-3188"></a><a name="unify_derived"></a><span class='hs-definition'>unify_derived</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-3189"></a><span class='hs-comment'>-- Create new Derived and put it in the work list</span>
<a name="line-3190"></a><span class='hs-comment'>-- Should do nothing if the two types are equal</span>
<a name="line-3191"></a><span class='hs-comment'>-- See Note [unifyWanted and unifyDerived]</span>
<a name="line-3192"></a><span class='hs-definition'>unify_derived</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>Phantom</span> <span class='hs-keyword'>_</span>        <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-3193"></a><span class='hs-definition'>unify_derived</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span>    <span class='hs-varid'>orig_ty1</span> <span class='hs-varid'>orig_ty2</span>
<a name="line-3194"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>orig_ty1</span> <span class='hs-varid'>orig_ty2</span>
<a name="line-3195"></a>  <span class='hs-keyword'>where</span>
<a name="line-3196"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2</span>
<a name="line-3197"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcView</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2'</span>
<a name="line-3198"></a>
<a name="line-3199"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w1</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>t1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w2</span> <span class='hs-varid'>s2</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-3200"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unify_derived</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>s1</span> <span class='hs-varid'>s2</span>
<a name="line-3201"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>unify_derived</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span>
<a name="line-3202"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>unify_derived</span> <span class='hs-varid'>loc</span> <span class='hs-conid'>Nominal</span> <span class='hs-varid'>w1</span> <span class='hs-varid'>w2</span> <span class='hs-layout'>}</span>
<a name="line-3203"></a>    <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>tys1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc2</span> <span class='hs-varid'>tys2</span><span class='hs-layout'>)</span>
<a name="line-3204"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>tc1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tc2</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys1</span> <span class='hs-varop'>`equalLength`</span> <span class='hs-varid'>tys2</span>
<a name="line-3205"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isInjectiveTyCon</span> <span class='hs-varid'>tc1</span> <span class='hs-varid'>role</span>
<a name="line-3206"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unifyDeriveds</span> <span class='hs-varid'>loc</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRolesX</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc1</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys1</span> <span class='hs-varid'>tys2</span>
<a name="line-3207"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span>
<a name="line-3208"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-3209"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span>
<a name="line-3210"></a>                <span class='hs-conid'>Just</span> <span class='hs-varid'>ty1'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1'</span> <span class='hs-varid'>ty2</span>
<a name="line-3211"></a>                <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span>
<a name="line-3212"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-3213"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-3214"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span>
<a name="line-3215"></a>                <span class='hs-conid'>Just</span> <span class='hs-varid'>ty2'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2'</span>
<a name="line-3216"></a>                <span class='hs-conid'>Nothing</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-layout'>}</span>
<a name="line-3217"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-3218"></a>
<a name="line-3219"></a>    <span class='hs-varid'>bale_out</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-3220"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-3221"></a>        <span class='hs-comment'>-- Check for equality; e.g. a ~ a, or (m a) ~ (m a)</span>
<a name="line-3222"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emitNewDerivedEq</span> <span class='hs-varid'>loc</span> <span class='hs-varid'>role</span> <span class='hs-varid'>orig_ty1</span> <span class='hs-varid'>orig_ty2</span>
</pre></body>
</html>
