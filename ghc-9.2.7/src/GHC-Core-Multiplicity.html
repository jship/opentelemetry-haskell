<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Multiplicity.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE PatternSynonyms    #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-comment'>{-|
<a name="line-4"></a>This module defines the semi-ring of multiplicities, and associated functions.
<a name="line-5"></a>Multiplicities annotate arrow types to indicate the linearity of the
<a name="line-6"></a>arrow (in the sense of linear types).
<a name="line-7"></a>
<a name="line-8"></a>Mult is a type synonym for Type, used only when its kind is Multiplicity.
<a name="line-9"></a>To simplify dealing with multiplicities, functions such as
<a name="line-10"></a>mkMultMul perform simplifications such as Many * x = Many on the fly.
<a name="line-11"></a>-}</span>
<a name="line-12"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-13"></a>  <span class='hs-layout'>(</span> <span class='hs-conid'>Mult</span>
<a name="line-14"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>pattern</span> <span class='hs-conid'>One</span>
<a name="line-15"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>pattern</span> <span class='hs-conid'>Many</span>
<a name="line-16"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>isMultMul</span>
<a name="line-17"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>mkMultAdd</span>
<a name="line-18"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>mkMultMul</span>
<a name="line-19"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>mkMultSup</span>
<a name="line-20"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>Scaled</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-21"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>scaledMult</span>
<a name="line-22"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>scaledThing</span>
<a name="line-23"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>unrestricted</span>
<a name="line-24"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>linear</span>
<a name="line-25"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>tymult</span>
<a name="line-26"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>irrelevantMult</span>
<a name="line-27"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>mkScaled</span>
<a name="line-28"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>scaledSet</span>
<a name="line-29"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>scaleScaled</span>
<a name="line-30"></a>  <span class='hs-layout'>,</span> <span class='hs-conid'>IsSubmult</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-31"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>submult</span>
<a name="line-32"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>mapScaledType</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-33"></a>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-35"></a>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Builtin.Types</span> <span class='hs-layout'>(</span> <span class='hs-varid'>multMulTyCon</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span> <span class='hs-layout'>(</span><span class='hs-varid'>multMulTyConKey</span><span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span> <span class='hs-layout'>(</span><span class='hs-varid'>hasKey</span><span class='hs-layout'>)</span>
<a name="line-42"></a>
<a name="line-43"></a><span class='hs-comment'>{-
<a name="line-44"></a>Note [Linear types]
<a name="line-45"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-46"></a>This module is the entry point for linear types.
<a name="line-47"></a>
<a name="line-48"></a>The detailed design is in the _Linear Haskell_ article
<a name="line-49"></a>[https://arxiv.org/abs/1710.09756]. Other important resources in the linear
<a name="line-50"></a>types implementation wiki page
<a name="line-51"></a>[https://gitlab.haskell.org/ghc/ghc/wikis/linear-types/implementation], and the
<a name="line-52"></a>proposal [https://github.com/ghc-proposals/ghc-proposals/pull/111] which
<a name="line-53"></a>describes the concrete design at length.
<a name="line-54"></a>
<a name="line-55"></a>For the busy developer, though, here is a high-level view of linear types is the following:
<a name="line-56"></a>
<a name="line-57"></a>- Function arrows are annotated with a multiplicity (as defined by type `Mult`
<a name="line-58"></a>  and its smart constructors in this module)
<a name="line-59"></a>    - Because, as a type constructor, the type of function now has an extra
<a name="line-60"></a>      argument, the notation (-&gt;) is no longer suitable. We named the function
<a name="line-61"></a>      type constructor `FUN`.
<a name="line-62"></a>    - (-&gt;) retains its backward compatible meaning: `(-&gt;) a b = a -&gt; b`. To
<a name="line-63"></a>      achieve this, `(-&gt;)` is defined as a type synonym to `FUN Many` (see
<a name="line-64"></a>      below).
<a name="line-65"></a>- Multiplicities can be reified in Haskell as types of kind
<a name="line-66"></a>  `GHC.Types.Multiplicity`
<a name="line-67"></a>- Ground multiplicity (that is, without a variable) can be `One` or `Many`
<a name="line-68"></a>  (`Many` is generally rendered as ω in the scientific literature).
<a name="line-69"></a>  Functions whose type is annotated with `One` are linear functions, functions whose
<a name="line-70"></a>  type is annotated with `Many` are regular functions, often called “unrestricted”
<a name="line-71"></a>  to contrast them with linear functions.
<a name="line-72"></a>- A linear function is defined as a function such that *if* its result is
<a name="line-73"></a>  consumed exactly once, *then* its argument is consumed exactly once. You can
<a name="line-74"></a>  think of “consuming exactly once” as evaluating a value in normal form exactly
<a name="line-75"></a>  once (though not necessarily in one go). The _Linear Haskell_ article (see
<a name="line-76"></a>  infra) has a more precise definition of “consuming exactly once”.
<a name="line-77"></a>- Data types can have unrestricted fields (the canonical example being the
<a name="line-78"></a>  `Unrestricted` data type), then these don't need to be consumed for a value to
<a name="line-79"></a>  be consumed exactly once. So consuming a value of type `Unrestricted` exactly
<a name="line-80"></a>  once means forcing it at least once.
<a name="line-81"></a>- Why “at least once”? Because if `case u of { C x y -&gt; f (C x y) }` is linear
<a name="line-82"></a>  (provided `f` is a linear function). So we might as well have done `case u of
<a name="line-83"></a>  { !z -&gt; f z }`. So, we can observe constructors as many times as we want, and
<a name="line-84"></a>  we are actually allowed to force the same thing several times because laziness
<a name="line-85"></a>  means that we are really forcing a the value once, and observing its
<a name="line-86"></a>  constructor several times. The type checker and the linter recognise some (but
<a name="line-87"></a>  not all) of these multiple forces as indeed linear. Mostly just enough to
<a name="line-88"></a>  support variable patterns.
<a name="line-89"></a>- Multiplicities form a semiring.
<a name="line-90"></a>- Multiplicities can also be variables and we can universally quantify over
<a name="line-91"></a>  these variables. This is referred to as “multiplicity
<a name="line-92"></a>  polymorphism”. Furthermore, multiplicity can be formal semiring expressions
<a name="line-93"></a>  combining variables.
<a name="line-94"></a>- Contrary to the paper, the sum of two multiplicities is always `Many`. This
<a name="line-95"></a>  will have to change, however, if we want to add a multiplicity for 0. Whether
<a name="line-96"></a>  we want to is still debated.
<a name="line-97"></a>- Case expressions have a multiplicity annotation too. A case expression with
<a name="line-98"></a>  multiplicity `One`, consumes its scrutinee exactly once (provided the entire
<a name="line-99"></a>  case expression is consumed exactly once); whereas a case expression with
<a name="line-100"></a>  multiplicity `Many` can consume its scrutinee as many time as it wishes (no
<a name="line-101"></a>  matter how much the case expression is consumed).
<a name="line-102"></a>
<a name="line-103"></a>Note [Usages]
<a name="line-104"></a>~~~~~~~~~~~~~
<a name="line-105"></a>In the _Linear Haskell_ paper, you'll find typing rules such as these:
<a name="line-106"></a>
<a name="line-107"></a>    Γ ⊢ f : A #π-&gt; B  Δ ⊢ u : A
<a name="line-108"></a>    ---------------------------
<a name="line-109"></a>        Γ + kΔ ⊢ f u : B
<a name="line-110"></a>
<a name="line-111"></a>If you read this as a type-checking algorithm going from the bottom up, this
<a name="line-112"></a>reads as: the algorithm has to find a split of some input context Ξ into an
<a name="line-113"></a>appropriate Γ and a Δ such as Ξ = Γ + kΔ, *and the multiplicities are chosen to
<a name="line-114"></a>make f and u typecheck*.
<a name="line-115"></a>
<a name="line-116"></a>This could be achieved by letting the typechecking of `f` use exactly the
<a name="line-117"></a>variable it needs, then passing the remainder, as `Delta` to the typechecking of
<a name="line-118"></a>u. But what does that mean if `x` is bound with multiplicity `p` (a variable)
<a name="line-119"></a>and `f` consumes `x` once? `Delta` would have to contain `x` with multiplicity
<a name="line-120"></a>`p-1`. It's not really clear how to make that works. In summary: bottom-up
<a name="line-121"></a>multiplicity checking forgoes addition and multiplication in favour of
<a name="line-122"></a>subtraction and division. And variables make the latter hard.
<a name="line-123"></a>
<a name="line-124"></a>The alternative is to read multiplicities from the top down: as an *output* from
<a name="line-125"></a>the typechecking algorithm, rather than an input. We call these output
<a name="line-126"></a>multiplicities Usages, to distinguish them from the multiplicities which come,
<a name="line-127"></a>as input, from the types of functions. Usages are checked for compatibility with
<a name="line-128"></a>multiplicity annotations using an ordering relation. In other words, the usage
<a name="line-129"></a>of x in the expression u is the smallest multiplicity which can be ascribed to x
<a name="line-130"></a>for u to typecheck.
<a name="line-131"></a>
<a name="line-132"></a>Usages are usually group in a UsageEnv, as defined in the UsageEnv module.
<a name="line-133"></a>
<a name="line-134"></a>So, in our function application example, the typechecking algorithm would
<a name="line-135"></a>receive usage environements f_ue from the typechecking of f, and u_ue from the
<a name="line-136"></a>typechecking of u. Then the output would be f_ue + (k * u_ue). Addition and
<a name="line-137"></a>scaling of usage environment is the pointwise extension of the semiring
<a name="line-138"></a>operations on multiplicities.
<a name="line-139"></a>
<a name="line-140"></a>Note [Zero as a usage]
<a name="line-141"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-142"></a>In the current presentation usages are not exactly multiplicities, because they
<a name="line-143"></a>can contain 0, and multiplicities can't.
<a name="line-144"></a>
<a name="line-145"></a>Why do we need a 0 usage? A function which doesn't use its argument will be
<a name="line-146"></a>required to annotate it with `Many`:
<a name="line-147"></a>
<a name="line-148"></a>    \(x # Many) -&gt; 0
<a name="line-149"></a>
<a name="line-150"></a>However, we cannot replace absence with Many when computing usages
<a name="line-151"></a>compositionally: in
<a name="line-152"></a>
<a name="line-153"></a>    (x, True)
<a name="line-154"></a>
<a name="line-155"></a>We expect x to have usage 1. But when computing the usage of x in True we would
<a name="line-156"></a>find that x is absent, hence has multiplicity Many. The final multiplicity would
<a name="line-157"></a>be One+Many = Many. Oops!
<a name="line-158"></a>
<a name="line-159"></a>Hence there is a usage Zero for absent variables. Zero is characterised by being
<a name="line-160"></a>the neutral element to usage addition.
<a name="line-161"></a>
<a name="line-162"></a>We may decide to add Zero as a multiplicity in the future. In which case, this
<a name="line-163"></a>distinction will go away.
<a name="line-164"></a>
<a name="line-165"></a>Note [Joining usages]
<a name="line-166"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-167"></a>The usage of a variable is defined, in Note [Usages], as the minimum usage which
<a name="line-168"></a>can be ascribed to a variable.
<a name="line-169"></a>
<a name="line-170"></a>So what is the usage of x in
<a name="line-171"></a>
<a name="line-172"></a>    case … of
<a name="line-173"></a>      { p1 -&gt; u   -- usage env: u_ue
<a name="line-174"></a>      ; p2 -&gt; v } -- usage env: v_ue
<a name="line-175"></a>
<a name="line-176"></a>It must be the least upper bound, or _join_, of u_ue(x) and v_ue(x).
<a name="line-177"></a>
<a name="line-178"></a>So, contrary to a declarative presentation where the correct usage of x can be
<a name="line-179"></a>conjured out of thin air, we need to be able to compute the join of two
<a name="line-180"></a>multiplicities. Join is extended pointwise on usage environments.
<a name="line-181"></a>
<a name="line-182"></a>Note [Bottom as a usage]
<a name="line-183"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-184"></a>What is the usage of x in
<a name="line-185"></a>
<a name="line-186"></a>   case … of {}
<a name="line-187"></a>
<a name="line-188"></a>Per usual linear logic, as well as the _Linear Haskell_ article, x can have
<a name="line-189"></a>every multiplicity.
<a name="line-190"></a>
<a name="line-191"></a>So we need a minimum usage _bottom_, which is also the neutral element for join.
<a name="line-192"></a>
<a name="line-193"></a>In fact, this is not such as nice solution, because it is not clear how to
<a name="line-194"></a>define sum and multiplication with bottom. We give reasonable definitions, but
<a name="line-195"></a>they are not complete (they don't respect the semiring laws, and it's possible
<a name="line-196"></a>to come up with examples of Core transformation which are not well-typed)
<a name="line-197"></a>
<a name="line-198"></a>A better solution would probably be to annotate case expressions with a usage
<a name="line-199"></a>environment, just like they are annotated with a type. Which, probably not
<a name="line-200"></a>coincidentally, is also primarily for empty cases.
<a name="line-201"></a>
<a name="line-202"></a>A side benefit of this approach is that the linter would not need to join
<a name="line-203"></a>multiplicities, anymore; hence would be closer to the presentation in the
<a name="line-204"></a>article. That's because it could use the annotation as the multiplicity for each
<a name="line-205"></a>branch.
<a name="line-206"></a>
<a name="line-207"></a>Note [Data constructors are linear by default]
<a name="line-208"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-209"></a>Data constructors defined without -XLinearTypes (as well as data constructors
<a name="line-210"></a>defined with the Haskell 98 in all circumstances) have all their fields linear.
<a name="line-211"></a>
<a name="line-212"></a>That is, in
<a name="line-213"></a>
<a name="line-214"></a>    data Maybe a = Nothing | Just a
<a name="line-215"></a>
<a name="line-216"></a>We have
<a name="line-217"></a>
<a name="line-218"></a>    Just :: a %1 -&gt; Just a
<a name="line-219"></a>
<a name="line-220"></a>The goal is to maximise reuse of types between linear code and traditional
<a name="line-221"></a>code. This is argued at length in the proposal and the article (links in Note
<a name="line-222"></a>[Linear Types]).
<a name="line-223"></a>
<a name="line-224"></a>Note [Polymorphisation of linear fields]
<a name="line-225"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-226"></a>The choice in Note [Data constructors are linear by default] has an impact on
<a name="line-227"></a>backwards compatibility. Consider
<a name="line-228"></a>
<a name="line-229"></a>    map Just
<a name="line-230"></a>
<a name="line-231"></a>We have
<a name="line-232"></a>
<a name="line-233"></a>    map :: (a -&gt; b) -&gt; f a -&gt; f b
<a name="line-234"></a>    Just :: a %1 -&gt; Just a
<a name="line-235"></a>
<a name="line-236"></a>Types don't match, we should get a type error. But this is legal Haskell 98
<a name="line-237"></a>code! Bad! Bad! Bad!
<a name="line-238"></a>
<a name="line-239"></a>It could be solved with subtyping, but subtyping doesn't combine well with
<a name="line-240"></a>polymorphism.
<a name="line-241"></a>
<a name="line-242"></a>Instead, we generalise the type of Just, when used as term:
<a name="line-243"></a>
<a name="line-244"></a>   Just :: forall {p}. a %p-&gt; Just a
<a name="line-245"></a>
<a name="line-246"></a>This is solely a concern for higher-order code like this: when called fully
<a name="line-247"></a>applied linear constructors are more general than constructors with unrestricted
<a name="line-248"></a>fields. In particular, linear constructors can always be eta-expanded to their
<a name="line-249"></a>Haskell 98 type. This is explained in the paper (but there, we had a different
<a name="line-250"></a>strategy to resolve this type mismatch in higher-order code. It turned out to be
<a name="line-251"></a>insufficient, which is explained in the wiki page as well as the proposal).
<a name="line-252"></a>
<a name="line-253"></a>We only generalise linear fields this way: fields with multiplicity Many, or
<a name="line-254"></a>other multiplicity expressions are exclusive to -XLinearTypes, hence don't have
<a name="line-255"></a>backward compatibility implications.
<a name="line-256"></a>
<a name="line-257"></a>The implementation is described in Note [Linear fields generalization].
<a name="line-258"></a>
<a name="line-259"></a>More details in the proposal.
<a name="line-260"></a>-}</span>
<a name="line-261"></a>
<a name="line-262"></a><span class='hs-comment'>{-
<a name="line-263"></a>Note [Adding new multiplicities]
<a name="line-264"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-265"></a>To add a new multiplicity, you need to:
<a name="line-266"></a>* Add the new type with Multiplicity kind
<a name="line-267"></a>* Update cases in mkMultAdd, mkMultMul, mkMultSup, submult, tcSubMult
<a name="line-268"></a>* Check supUE function that computes sup of a multiplicity
<a name="line-269"></a>  and Zero
<a name="line-270"></a>-}</span>
<a name="line-271"></a>
<a name="line-272"></a><a name="isMultMul"></a><span class='hs-definition'>isMultMul</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Mult</span><span class='hs-layout'>,</span> <span class='hs-conid'>Mult</span><span class='hs-layout'>)</span>
<a name="line-273"></a><span class='hs-definition'>isMultMul</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>splitTyConApp_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-274"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>multMulTyConKey</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-275"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-276"></a>
<a name="line-277"></a><span class='hs-comment'>{-
<a name="line-278"></a>Note [Overapproximating multiplicities]
<a name="line-279"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-280"></a>The functions mkMultAdd, mkMultMul, mkMultSup perform operations
<a name="line-281"></a>on multiplicities. They can return overapproximations: their result
<a name="line-282"></a>is merely guaranteed to be a submultiplicity of the actual value.
<a name="line-283"></a>
<a name="line-284"></a>They should be used only when an upper bound is acceptable.
<a name="line-285"></a>In most cases, they are used in usage environments (UsageEnv);
<a name="line-286"></a>in usage environments, replacing a usage with a larger one can only
<a name="line-287"></a>cause more programs to fail to typecheck.
<a name="line-288"></a>
<a name="line-289"></a>In future work, instead of approximating we might add type families
<a name="line-290"></a>and allow users to write types involving operations on multiplicities.
<a name="line-291"></a>In this case, we could enforce more invariants in Mult, for example,
<a name="line-292"></a>enforce that it is in the form of a sum of products, and even
<a name="line-293"></a>that the sumands and factors are ordered somehow, to have more equalities.
<a name="line-294"></a>-}</span>
<a name="line-295"></a>
<a name="line-296"></a><a name="mkMultAdd"></a><span class='hs-comment'>-- With only two multiplicities One and Many, we can always replace</span>
<a name="line-297"></a><span class='hs-comment'>-- p + q by Many. See Note [Overapproximating multiplicities].</span>
<a name="line-298"></a><span class='hs-definition'>mkMultAdd</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span>
<a name="line-299"></a><span class='hs-definition'>mkMultAdd</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Many</span>
<a name="line-300"></a>
<a name="line-301"></a><a name="mkMultMul"></a><span class='hs-definition'>mkMultMul</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span>
<a name="line-302"></a><span class='hs-definition'>mkMultMul</span> <span class='hs-conid'>One</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span>
<a name="line-303"></a><span class='hs-definition'>mkMultMul</span> <span class='hs-varid'>p</span> <span class='hs-conid'>One</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>p</span>
<a name="line-304"></a><span class='hs-definition'>mkMultMul</span> <span class='hs-conid'>Many</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Many</span>
<a name="line-305"></a><span class='hs-definition'>mkMultMul</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>Many</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Many</span>
<a name="line-306"></a><span class='hs-definition'>mkMultMul</span> <span class='hs-varid'>p</span> <span class='hs-varid'>q</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>multMulTyCon</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>p</span><span class='hs-layout'>,</span> <span class='hs-varid'>q</span><span class='hs-keyglyph'>]</span>
<a name="line-307"></a>
<a name="line-308"></a><a name="scaleScaled"></a><span class='hs-definition'>scaleScaled</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span>
<a name="line-309"></a><span class='hs-definition'>scaleScaled</span> <span class='hs-varid'>m'</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Scaled</span> <span class='hs-layout'>(</span><span class='hs-varid'>m'</span> <span class='hs-varop'>`mkMultMul`</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>t</span>
<a name="line-310"></a>
<a name="line-311"></a><a name="mkMultSup"></a><span class='hs-comment'>-- See Note [Joining usages]</span>
<a name="line-312"></a><span class='hs-comment'>-- | @mkMultSup w1 w2@ returns a multiplicity such that @mkMultSup w1</span>
<a name="line-313"></a><span class='hs-comment'>-- w2 &gt;= w1@ and @mkMultSup w1 w2 &gt;= w2@. See Note [Overapproximating multiplicities].</span>
<a name="line-314"></a><span class='hs-definition'>mkMultSup</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span>
<a name="line-315"></a><span class='hs-definition'>mkMultSup</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMultMul</span>
<a name="line-316"></a><span class='hs-comment'>-- Note: If you are changing this logic, check 'supUE' in UsageEnv as well.</span>
<a name="line-317"></a>
<a name="line-318"></a><span class='hs-comment'>--</span>
<a name="line-319"></a><span class='hs-comment'>-- * Multiplicity ordering</span>
<a name="line-320"></a><span class='hs-comment'>--</span>
<a name="line-321"></a>
<a name="line-322"></a><a name="IsSubmult"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>IsSubmult</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Submult</span>     <span class='hs-comment'>-- Definitely a submult</span>
<a name="line-323"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Unknown</span>     <span class='hs-comment'>-- Could be a submult, need to ask the typechecker</span>
<a name="line-324"></a>               <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-325"></a>
<a name="line-326"></a><a name="instance%20Outputable%20IsSubmult"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>IsSubmult</span> <span class='hs-keyword'>where</span>
<a name="line-327"></a>  <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-varop'>.</span> <span class='hs-varid'>show</span>
<a name="line-328"></a>
<a name="line-329"></a><span class='hs-comment'>-- | @submult w1 w2@ check whether a value of multiplicity @w1@ is allowed where a</span>
<a name="line-330"></a><span class='hs-comment'>-- value of multiplicity @w2@ is expected. This is a partial order.</span>
<a name="line-331"></a>
<a name="line-332"></a><a name="submult"></a><span class='hs-definition'>submult</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IsSubmult</span>
<a name="line-333"></a><span class='hs-definition'>submult</span> <span class='hs-keyword'>_</span>     <span class='hs-conid'>Many</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Submult</span>
<a name="line-334"></a><span class='hs-definition'>submult</span> <span class='hs-conid'>One</span>   <span class='hs-conid'>One</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Submult</span>
<a name="line-335"></a><span class='hs-comment'>-- The 1 &lt;= p rule</span>
<a name="line-336"></a><span class='hs-definition'>submult</span> <span class='hs-conid'>One</span>   <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Submult</span>
<a name="line-337"></a><span class='hs-definition'>submult</span> <span class='hs-keyword'>_</span>     <span class='hs-keyword'>_</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Unknown</span>
</pre></body>
</html>
