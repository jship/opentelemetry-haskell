<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Unfold.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-
<a name="line-2"></a>(c) The University of Glasgow 2006
<a name="line-3"></a>(c) The AQUA Project, Glasgow University, 1994-1998
<a name="line-4"></a>
<a name="line-5"></a>
<a name="line-6"></a>Core-syntax unfoldings
<a name="line-7"></a>
<a name="line-8"></a>Unfoldings (which can travel across module boundaries) are in Core
<a name="line-9"></a>syntax (namely @CoreExpr@s).
<a name="line-10"></a>
<a name="line-11"></a>The type @Unfolding@ sits ``above'' simply-Core-expressions
<a name="line-12"></a>unfoldings, capturing ``higher-level'' things we know about a binding,
<a name="line-13"></a>usually things that the simplifier found out (e.g., ``it's a
<a name="line-14"></a>literal'').  In the corner of a @CoreUnfolding@ unfolding, you will
<a name="line-15"></a>find, unsurprisingly, a Core expression.
<a name="line-16"></a>-}</span>
<a name="line-17"></a>
<a name="line-18"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-19"></a><span class='hs-comment'>{-# LANGUAGE BangPatterns #-}</span>
<a name="line-20"></a>
<a name="line-21"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-record-updates #-}</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Unfold</span> <span class='hs-layout'>(</span>
<a name="line-24"></a>        <span class='hs-conid'>Unfolding</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnfoldingGuidance</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- Abstract types</span>
<a name="line-25"></a>
<a name="line-26"></a>        <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>defaultUnfoldingOpts</span><span class='hs-layout'>,</span>
<a name="line-27"></a>        <span class='hs-varid'>updateCreationThreshold</span><span class='hs-layout'>,</span> <span class='hs-varid'>updateUseThreshold</span><span class='hs-layout'>,</span>
<a name="line-28"></a>        <span class='hs-varid'>updateFunAppDiscount</span><span class='hs-layout'>,</span> <span class='hs-varid'>updateDictDiscount</span><span class='hs-layout'>,</span>
<a name="line-29"></a>        <span class='hs-varid'>updateVeryAggressive</span><span class='hs-layout'>,</span> <span class='hs-varid'>updateCaseScaling</span><span class='hs-layout'>,</span> <span class='hs-varid'>updateCaseThreshold</span><span class='hs-layout'>,</span>
<a name="line-30"></a>
<a name="line-31"></a>        <span class='hs-conid'>ArgSummary</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-32"></a>
<a name="line-33"></a>        <span class='hs-varid'>couldBeSmallEnoughToInline</span><span class='hs-layout'>,</span> <span class='hs-varid'>inlineBoringOk</span><span class='hs-layout'>,</span>
<a name="line-34"></a>        <span class='hs-varid'>certainlyWillInline</span><span class='hs-layout'>,</span> <span class='hs-varid'>smallEnoughToInline</span><span class='hs-layout'>,</span>
<a name="line-35"></a>
<a name="line-36"></a>        <span class='hs-varid'>callSiteInline</span><span class='hs-layout'>,</span> <span class='hs-conid'>CallCtxt</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-37"></a>        <span class='hs-varid'>calcUnfoldingGuidance</span>
<a name="line-38"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-39"></a>
<a name="line-40"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-43"></a>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span> <span class='hs-layout'>(</span> <span class='hs-varid'>isDeadEndSig</span> <span class='hs-layout'>)</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Literal</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.PrimOps</span>
<a name="line-53"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span>
<a name="line-54"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>  <span class='hs-layout'>(</span> <span class='hs-conid'>Arity</span><span class='hs-layout'>,</span> <span class='hs-conid'>InlineSpec</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>inlinePragmaSpec</span> <span class='hs-layout'>)</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span>
<a name="line-57"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Types.Prim</span> <span class='hs-layout'>(</span> <span class='hs-varid'>realWorldStatePrimTy</span> <span class='hs-layout'>)</span>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Bag</span>
<a name="line-59"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Logger</span>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-62"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.ForeignCall</span>
<a name="line-63"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-64"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-65"></a>
<a name="line-66"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.ByteString</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>BS</span>
<a name="line-67"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span> <span class='hs-layout'>(</span><span class='hs-varid'>isPrefixOf</span><span class='hs-layout'>)</span>
<a name="line-68"></a>
<a name="line-69"></a>
<a name="line-70"></a><a name="UnfoldingOpts"></a><span class='hs-comment'>-- | Unfolding options</span>
<a name="line-71"></a><a name="UnfoldingOpts"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-72"></a>   <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingCreationThreshold</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-73"></a>      <span class='hs-comment'>-- ^ Threshold above which unfoldings are not *created*</span>
<a name="line-74"></a>
<a name="line-75"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingUseThreshold</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-76"></a>      <span class='hs-comment'>-- ^ Threshold above which unfoldings are not *inlined*</span>
<a name="line-77"></a>
<a name="line-78"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingFunAppDiscount</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-79"></a>      <span class='hs-comment'>-- ^ Discount for lambdas that are used (applied)</span>
<a name="line-80"></a>
<a name="line-81"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingDictDiscount</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-82"></a>      <span class='hs-comment'>-- ^ Discount for dictionaries</span>
<a name="line-83"></a>
<a name="line-84"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingVeryAggressive</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Bool</span>
<a name="line-85"></a>      <span class='hs-comment'>-- ^ Force inlining in many more cases</span>
<a name="line-86"></a>
<a name="line-87"></a>      <span class='hs-comment'>-- Don't consider depth up to x</span>
<a name="line-88"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingCaseThreshold</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-89"></a>
<a name="line-90"></a>      <span class='hs-comment'>-- Penalize depth with 1/x</span>
<a name="line-91"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingCaseScaling</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-92"></a>   <span class='hs-layout'>}</span>
<a name="line-93"></a>
<a name="line-94"></a><a name="defaultUnfoldingOpts"></a><span class='hs-definition'>defaultUnfoldingOpts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-95"></a><span class='hs-definition'>defaultUnfoldingOpts</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-96"></a>   <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingCreationThreshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>750</span>
<a name="line-97"></a>      <span class='hs-comment'>-- The unfoldingCreationThreshold threshold must be reasonably high</span>
<a name="line-98"></a>      <span class='hs-comment'>-- to take account of possible discounts.</span>
<a name="line-99"></a>      <span class='hs-comment'>-- E.g. 450 is not enough in 'fulsom' for Interval.sqr to</span>
<a name="line-100"></a>      <span class='hs-comment'>-- inline into Csg.calc (The unfolding for sqr never makes it</span>
<a name="line-101"></a>      <span class='hs-comment'>-- into the interface file.)</span>
<a name="line-102"></a>
<a name="line-103"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingUseThreshold</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>90</span>
<a name="line-104"></a>      <span class='hs-comment'>-- Last adjusted upwards in #18282, when I reduced</span>
<a name="line-105"></a>      <span class='hs-comment'>-- the result discount for constructors.</span>
<a name="line-106"></a>
<a name="line-107"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingFunAppDiscount</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>60</span>
<a name="line-108"></a>      <span class='hs-comment'>-- Be fairly keen to inline a function if that means</span>
<a name="line-109"></a>      <span class='hs-comment'>-- we'll be able to pick the right method from a dictionary</span>
<a name="line-110"></a>
<a name="line-111"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingDictDiscount</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>30</span>
<a name="line-112"></a>      <span class='hs-comment'>-- Be fairly keen to inline a function if that means</span>
<a name="line-113"></a>      <span class='hs-comment'>-- we'll be able to pick the right method from a dictionary</span>
<a name="line-114"></a>
<a name="line-115"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingVeryAggressive</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-116"></a>
<a name="line-117"></a>      <span class='hs-comment'>-- Only apply scaling once we are deeper than threshold cases</span>
<a name="line-118"></a>      <span class='hs-comment'>-- in an RHS.</span>
<a name="line-119"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingCaseThreshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>
<a name="line-120"></a>
<a name="line-121"></a>      <span class='hs-comment'>-- Penalize depth with (size*depth)/scaling</span>
<a name="line-122"></a>   <span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingCaseScaling</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>30</span>
<a name="line-123"></a>   <span class='hs-layout'>}</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-comment'>-- Helpers for "GHC.Driver.Session"</span>
<a name="line-126"></a>
<a name="line-127"></a><a name="updateCreationThreshold"></a><span class='hs-definition'>updateCreationThreshold</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-128"></a><span class='hs-definition'>updateCreationThreshold</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingCreationThreshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-129"></a>
<a name="line-130"></a><a name="updateUseThreshold"></a><span class='hs-definition'>updateUseThreshold</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-131"></a><span class='hs-definition'>updateUseThreshold</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingUseThreshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-132"></a>
<a name="line-133"></a><a name="updateFunAppDiscount"></a><span class='hs-definition'>updateFunAppDiscount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-134"></a><span class='hs-definition'>updateFunAppDiscount</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingFunAppDiscount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-135"></a>
<a name="line-136"></a><a name="updateDictDiscount"></a><span class='hs-definition'>updateDictDiscount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-137"></a><span class='hs-definition'>updateDictDiscount</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingDictDiscount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-138"></a>
<a name="line-139"></a><a name="updateVeryAggressive"></a><span class='hs-definition'>updateVeryAggressive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-140"></a><span class='hs-definition'>updateVeryAggressive</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingVeryAggressive</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-141"></a>
<a name="line-142"></a>
<a name="line-143"></a><a name="updateCaseThreshold"></a><span class='hs-definition'>updateCaseThreshold</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-144"></a><span class='hs-definition'>updateCaseThreshold</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingCaseThreshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-145"></a>
<a name="line-146"></a><a name="updateCaseScaling"></a><span class='hs-definition'>updateCaseScaling</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-147"></a><span class='hs-definition'>updateCaseScaling</span> <span class='hs-varid'>n</span> <span class='hs-varid'>opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>{</span> <span class='hs-varid'>unfoldingCaseScaling</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n</span> <span class='hs-layout'>}</span>
<a name="line-148"></a>
<a name="line-149"></a><span class='hs-comment'>{-
<a name="line-150"></a>Note [Occurrence analysis of unfoldings]
<a name="line-151"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-152"></a>We do occurrence-analysis of unfoldings once and for all, when the
<a name="line-153"></a>unfolding is built, rather than each time we inline them.
<a name="line-154"></a>
<a name="line-155"></a>But given this decision it's vital that we do
<a name="line-156"></a>*always* do it.  Consider this unfolding
<a name="line-157"></a>    \x -&gt; letrec { f = ...g...; g* = f } in body
<a name="line-158"></a>where g* is (for some strange reason) the loop breaker.  If we don't
<a name="line-159"></a>occ-anal it when reading it in, we won't mark g as a loop breaker, and
<a name="line-160"></a>we may inline g entirely in body, dropping its binding, and leaving
<a name="line-161"></a>the occurrence in f out of scope. This happened in #8892, where
<a name="line-162"></a>the unfolding in question was a DFun unfolding.
<a name="line-163"></a>
<a name="line-164"></a>But more generally, the simplifier is designed on the
<a name="line-165"></a>basis that it is looking at occurrence-analysed expressions, so better
<a name="line-166"></a>ensure that they actually are.
<a name="line-167"></a>
<a name="line-168"></a>Note [Calculate unfolding guidance on the non-occ-anal'd expression]
<a name="line-169"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-170"></a>Notice that we give the non-occur-analysed expression to
<a name="line-171"></a>calcUnfoldingGuidance.  In some ways it'd be better to occur-analyse
<a name="line-172"></a>first; for example, sometimes during simplification, there's a large
<a name="line-173"></a>let-bound thing which has been substituted, and so is now dead; so
<a name="line-174"></a>'expr' contains two copies of the thing while the occurrence-analysed
<a name="line-175"></a>expression doesn't.
<a name="line-176"></a>
<a name="line-177"></a>Nevertheless, we *don't* and *must not* occ-analyse before computing
<a name="line-178"></a>the size because
<a name="line-179"></a>
<a name="line-180"></a>a) The size computation bales out after a while, whereas occurrence
<a name="line-181"></a>   analysis does not.
<a name="line-182"></a>
<a name="line-183"></a>b) Residency increases sharply if you occ-anal first.  I'm not
<a name="line-184"></a>   100% sure why, but it's a large effect.  Compiling Cabal went
<a name="line-185"></a>   from residency of 534M to over 800M with this one change.
<a name="line-186"></a>
<a name="line-187"></a>This can occasionally mean that the guidance is very pessimistic;
<a name="line-188"></a>it gets fixed up next round.  And it should be rare, because large
<a name="line-189"></a>let-bound things that are dead are usually caught by preInlineUnconditionally
<a name="line-190"></a>
<a name="line-191"></a>
<a name="line-192"></a>************************************************************************
<a name="line-193"></a>*                                                                      *
<a name="line-194"></a>\subsection{The UnfoldingGuidance type}
<a name="line-195"></a>*                                                                      *
<a name="line-196"></a>************************************************************************
<a name="line-197"></a>-}</span>
<a name="line-198"></a>
<a name="line-199"></a><a name="inlineBoringOk"></a><span class='hs-definition'>inlineBoringOk</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-200"></a><span class='hs-comment'>-- See Note [INLINE for small functions]</span>
<a name="line-201"></a><span class='hs-comment'>-- True =&gt; the result of inlining the expression is</span>
<a name="line-202"></a><span class='hs-comment'>--         no bigger than the expression itself</span>
<a name="line-203"></a><span class='hs-comment'>--     eg      (\x y -&gt; f y x)</span>
<a name="line-204"></a><span class='hs-comment'>-- This is a quick and dirty version. It doesn't attempt</span>
<a name="line-205"></a><span class='hs-comment'>-- to deal with  (\x y z -&gt; x (y z))</span>
<a name="line-206"></a><span class='hs-comment'>-- The really important one is (x `cast` c)</span>
<a name="line-207"></a><span class='hs-definition'>inlineBoringOk</span> <span class='hs-varid'>e</span>
<a name="line-208"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-num'>0</span> <span class='hs-varid'>e</span>
<a name="line-209"></a>  <span class='hs-keyword'>where</span>
<a name="line-210"></a>    <span class='hs-varid'>go</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-211"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>x</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>x</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>credit</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>e</span>
<a name="line-212"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-varid'>e</span>
<a name="line-213"></a>        <span class='hs-comment'>-- See Note [Count coercion arguments in boring contexts]</span>
<a name="line-214"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-varid'>f</span>
<a name="line-215"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>f</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>credit</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>
<a name="line-216"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-layout'>(</span><span class='hs-varid'>credit</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>f</span>
<a name="line-217"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-varid'>e</span> <span class='hs-comment'>-- dubious</span>
<a name="line-218"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-varid'>e</span>
<a name="line-219"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Alt</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>rhs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [Inline unsafeCoerce]</span>
<a name="line-220"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnsafeEqualityProof</span> <span class='hs-varid'>scrut</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go</span> <span class='hs-varid'>credit</span> <span class='hs-varid'>rhs</span>
<a name="line-221"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>      <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>boringCxtOk</span>
<a name="line-222"></a>    <span class='hs-varid'>go</span> <span class='hs-keyword'>_</span>      <span class='hs-keyword'>_</span>                            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>boringCxtNotOk</span>
<a name="line-223"></a>
<a name="line-224"></a><a name="calcUnfoldingGuidance"></a><span class='hs-definition'>calcUnfoldingGuidance</span>
<a name="line-225"></a>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-226"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>          <span class='hs-comment'>-- Definitely a top-level, bottoming binding</span>
<a name="line-227"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>      <span class='hs-comment'>-- Expression to look at</span>
<a name="line-228"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingGuidance</span>
<a name="line-229"></a><span class='hs-definition'>calcUnfoldingGuidance</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>is_top_bottoming</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span>
<a name="line-230"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tickishIsCode</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- non-code ticks don't matter for unfolding</span>
<a name="line-231"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>calcUnfoldingGuidance</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>is_top_bottoming</span> <span class='hs-varid'>expr</span>
<a name="line-232"></a><span class='hs-definition'>calcUnfoldingGuidance</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>is_top_bottoming</span> <span class='hs-varid'>expr</span>
<a name="line-233"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sizeExpr</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>bOMB_OUT_SIZE</span> <span class='hs-varid'>val_bndrs</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span>
<a name="line-234"></a>      <span class='hs-conid'>TooBig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfNever</span>
<a name="line-235"></a>      <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>size</span> <span class='hs-varid'>cased_bndrs</span> <span class='hs-varid'>scrut_discount</span>
<a name="line-236"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>uncondInline</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>n_val_bndrs</span> <span class='hs-varid'>size</span>
<a name="line-237"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_unsat_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unSaturatedOk</span>
<a name="line-238"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>=</span>  <span class='hs-varid'>boringCxtOk</span>
<a name="line-239"></a>                   <span class='hs-layout'>,</span> <span class='hs-varid'>ug_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_val_bndrs</span> <span class='hs-layout'>}</span>   <span class='hs-comment'>-- Note [INLINE for small functions]</span>
<a name="line-240"></a>
<a name="line-241"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_top_bottoming</span>
<a name="line-242"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfNever</span>   <span class='hs-comment'>-- See Note [Do not inline top-level bottoming functions]</span>
<a name="line-243"></a>
<a name="line-244"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-245"></a>        <span class='hs-keyglyph'>-&gt;</span>
<a name="line-246"></a>
<a name="line-247"></a>          <span class='hs-comment'>-- If you don't force this then we retain all the Ids</span>
<a name="line-248"></a>          <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>discounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>strictMap</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_discount</span> <span class='hs-varid'>cased_bndrs</span><span class='hs-layout'>)</span> <span class='hs-varid'>val_bndrs</span>
<a name="line-249"></a>          <span class='hs-keyword'>in</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_args</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discounts</span>
<a name="line-250"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>ug_size</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span>
<a name="line-251"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>ug_res</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>scrut_discount</span> <span class='hs-layout'>}</span>
<a name="line-252"></a>
<a name="line-253"></a>  <span class='hs-keyword'>where</span>
<a name="line-254"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>expr</span>
<a name="line-255"></a>    <span class='hs-varid'>bOMB_OUT_SIZE</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingCreationThreshold</span> <span class='hs-varid'>opts</span>
<a name="line-256"></a>           <span class='hs-comment'>-- Bomb out if size gets bigger than this</span>
<a name="line-257"></a>    <span class='hs-varid'>val_bndrs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndrs</span>
<a name="line-258"></a>    <span class='hs-varid'>n_val_bndrs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>val_bndrs</span>
<a name="line-259"></a>
<a name="line-260"></a>    <span class='hs-varid'>mk_discount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-261"></a>    <span class='hs-varid'>mk_discount</span> <span class='hs-varid'>cbs</span> <span class='hs-varid'>bndr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>combine</span> <span class='hs-num'>0</span> <span class='hs-varid'>cbs</span>
<a name="line-262"></a>           <span class='hs-keyword'>where</span>
<a name="line-263"></a>             <span class='hs-varid'>combine</span> <span class='hs-varid'>acc</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr'</span><span class='hs-layout'>,</span> <span class='hs-varid'>disc</span><span class='hs-layout'>)</span>
<a name="line-264"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>bndr</span> <span class='hs-varop'>==</span> <span class='hs-varid'>bndr'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>acc</span> <span class='hs-varop'>`plus_disc`</span> <span class='hs-varid'>disc</span>
<a name="line-265"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>acc</span>
<a name="line-266"></a>
<a name="line-267"></a>             <span class='hs-varid'>plus_disc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-268"></a>             <span class='hs-varid'>plus_disc</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFunTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>max</span>
<a name="line-269"></a>                       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>             <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span>
<a name="line-270"></a>             <span class='hs-comment'>-- See Note [Function and non-function discounts]</span>
<a name="line-271"></a>
<a name="line-272"></a><span class='hs-comment'>{- Note [Inline unsafeCoerce]
<a name="line-273"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-274"></a>We really want to inline unsafeCoerce, even when applied to boring
<a name="line-275"></a>arguments.  It doesn't look as if its RHS is smaller than the call
<a name="line-276"></a>   unsafeCoerce x = case unsafeEqualityProof @a @b of UnsafeRefl -&gt; x
<a name="line-277"></a>but that case is discarded -- see Note [Implementing unsafeCoerce]
<a name="line-278"></a>in base:Unsafe.Coerce.
<a name="line-279"></a>
<a name="line-280"></a>Moreover, if we /don't/ inline it, we may be left with
<a name="line-281"></a>          f (unsafeCoerce x)
<a name="line-282"></a>which will build a thunk -- bad, bad, bad.
<a name="line-283"></a>
<a name="line-284"></a>Conclusion: we really want inlineBoringOk to be True of the RHS of
<a name="line-285"></a>unsafeCoerce.  This is (U4) in Note [Implementing unsafeCoerce].
<a name="line-286"></a>
<a name="line-287"></a>Note [Computing the size of an expression]
<a name="line-288"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-289"></a>The basic idea of sizeExpr is obvious enough: count nodes.  But getting the
<a name="line-290"></a>heuristics right has taken a long time.  Here's the basic strategy:
<a name="line-291"></a>
<a name="line-292"></a>    * Variables, literals: 0
<a name="line-293"></a>      (Exception for string literals, see litSize.)
<a name="line-294"></a>
<a name="line-295"></a>    * Function applications (f e1 .. en): 1 + #value args
<a name="line-296"></a>
<a name="line-297"></a>    * Constructor applications: 1, regardless of #args
<a name="line-298"></a>
<a name="line-299"></a>    * Let(rec): 1 + size of components
<a name="line-300"></a>
<a name="line-301"></a>    * Note, cast: 0
<a name="line-302"></a>
<a name="line-303"></a>Examples
<a name="line-304"></a>
<a name="line-305"></a>  Size  Term
<a name="line-306"></a>  --------------
<a name="line-307"></a>    0     42#
<a name="line-308"></a>    0     x
<a name="line-309"></a>    0     True
<a name="line-310"></a>    2     f x
<a name="line-311"></a>    1     Just x
<a name="line-312"></a>    4     f (g x)
<a name="line-313"></a>
<a name="line-314"></a>Notice that 'x' counts 0, while (f x) counts 2.  That's deliberate: there's
<a name="line-315"></a>a function call to account for.  Notice also that constructor applications
<a name="line-316"></a>are very cheap, because exposing them to a caller is so valuable.
<a name="line-317"></a>
<a name="line-318"></a>[25/5/11] All sizes are now multiplied by 10, except for primops
<a name="line-319"></a>(which have sizes like 1 or 4.  This makes primops look fantastically
<a name="line-320"></a>cheap, and seems to be almost universally beneficial.  Done partly as a
<a name="line-321"></a>result of #4978.
<a name="line-322"></a>
<a name="line-323"></a>Note [Do not inline top-level bottoming functions]
<a name="line-324"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-325"></a>The FloatOut pass has gone to some trouble to float out calls to 'error'
<a name="line-326"></a>and similar friends.  See Note [Bottoming floats] in GHC.Core.Opt.SetLevels.
<a name="line-327"></a>Do not re-inline them!  But we *do* still inline if they are very small
<a name="line-328"></a>(the uncondInline stuff).
<a name="line-329"></a>
<a name="line-330"></a>Note [INLINE for small functions]
<a name="line-331"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-332"></a>Consider        {-# INLINE f #-}
<a name="line-333"></a>                f x = Just x
<a name="line-334"></a>                g y = f y
<a name="line-335"></a>Then f's RHS is no larger than its LHS, so we should inline it into
<a name="line-336"></a>even the most boring context.  In general, f the function is
<a name="line-337"></a>sufficiently small that its body is as small as the call itself, the
<a name="line-338"></a>inline unconditionally, regardless of how boring the context is.
<a name="line-339"></a>
<a name="line-340"></a>Things to note:
<a name="line-341"></a>
<a name="line-342"></a>(1) We inline *unconditionally* if inlined thing is smaller (using sizeExpr)
<a name="line-343"></a>    than the thing it's replacing.  Notice that
<a name="line-344"></a>      (f x) --&gt; (g 3)             -- YES, unconditionally
<a name="line-345"></a>      (f x) --&gt; x : []            -- YES, *even though* there are two
<a name="line-346"></a>                                  --      arguments to the cons
<a name="line-347"></a>      x     --&gt; g 3               -- NO
<a name="line-348"></a>      x     --&gt; Just v            -- NO
<a name="line-349"></a>
<a name="line-350"></a>    It's very important not to unconditionally replace a variable by
<a name="line-351"></a>    a non-atomic term.
<a name="line-352"></a>
<a name="line-353"></a>(2) We do this even if the thing isn't saturated, else we end up with the
<a name="line-354"></a>    silly situation that
<a name="line-355"></a>       f x y = x
<a name="line-356"></a>       ...map (f 3)...
<a name="line-357"></a>    doesn't inline.  Even in a boring context, inlining without being
<a name="line-358"></a>    saturated will give a lambda instead of a PAP, and will be more
<a name="line-359"></a>    efficient at runtime.
<a name="line-360"></a>
<a name="line-361"></a>(3) However, when the function's arity &gt; 0, we do insist that it
<a name="line-362"></a>    has at least one value argument at the call site.  (This check is
<a name="line-363"></a>    made in the UnfWhen case of callSiteInline.) Otherwise we find this:
<a name="line-364"></a>         f = /\a \x:a. x
<a name="line-365"></a>         d = /\b. MkD (f b)
<a name="line-366"></a>    If we inline f here we get
<a name="line-367"></a>         d = /\b. MkD (\x:b. x)
<a name="line-368"></a>    and then prepareRhs floats out the argument, abstracting the type
<a name="line-369"></a>    variables, so we end up with the original again!
<a name="line-370"></a>
<a name="line-371"></a>(4) We must be much more cautious about arity-zero things. Consider
<a name="line-372"></a>       let x = y +# z in ...
<a name="line-373"></a>    In *size* terms primops look very small, because the generate a
<a name="line-374"></a>    single instruction, but we do not want to unconditionally replace
<a name="line-375"></a>    every occurrence of x with (y +# z).  So we only do the
<a name="line-376"></a>    unconditional-inline thing for *trivial* expressions.
<a name="line-377"></a>
<a name="line-378"></a>    NB: you might think that PostInlineUnconditionally would do this
<a name="line-379"></a>    but it doesn't fire for top-level things; see GHC.Core.Opt.Simplify.Utils
<a name="line-380"></a>    Note [Top level and postInlineUnconditionally]
<a name="line-381"></a>
<a name="line-382"></a>Note [Count coercion arguments in boring contexts]
<a name="line-383"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-384"></a>In inlineBoringOK, we ignore type arguments when deciding whether an
<a name="line-385"></a>expression is okay to inline into boring contexts. This is good, since
<a name="line-386"></a>if we have a definition like
<a name="line-387"></a>
<a name="line-388"></a>  let y = x @Int in f y y
<a name="line-389"></a>
<a name="line-390"></a>there’s no reason not to inline y at both use sites — no work is
<a name="line-391"></a>actually duplicated. It may seem like the same reasoning applies to
<a name="line-392"></a>coercion arguments, and indeed, in #17182 we changed inlineBoringOK to
<a name="line-393"></a>treat coercions the same way.
<a name="line-394"></a>
<a name="line-395"></a>However, this isn’t a good idea: unlike type arguments, which have
<a name="line-396"></a>no runtime representation, coercion arguments *do* have a runtime
<a name="line-397"></a>representation (albeit the zero-width VoidRep, see Note [Coercion tokens]
<a name="line-398"></a>in "GHC.CoreToStg"). This caused trouble in #17787 for DataCon wrappers for
<a name="line-399"></a>nullary GADT constructors: the wrappers would be inlined and each use of
<a name="line-400"></a>the constructor would lead to a separate allocation instead of just
<a name="line-401"></a>sharing the wrapper closure.
<a name="line-402"></a>
<a name="line-403"></a>The solution: don’t ignore coercion arguments after all.
<a name="line-404"></a>-}</span>
<a name="line-405"></a>
<a name="line-406"></a><a name="uncondInline"></a><span class='hs-definition'>uncondInline</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-407"></a><span class='hs-comment'>-- Inline unconditionally if there no size increase</span>
<a name="line-408"></a><span class='hs-comment'>-- Size of call is arity (+1 for the function)</span>
<a name="line-409"></a><span class='hs-comment'>-- See Note [INLINE for small functions]</span>
<a name="line-410"></a><span class='hs-definition'>uncondInline</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>size</span>
<a name="line-411"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span> <span class='hs-varop'>&lt;=</span> <span class='hs-num'>10</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-varid'>arity</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- See Note [INLINE for small functions] (1)</span>
<a name="line-412"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>exprIsTrivial</span> <span class='hs-varid'>rhs</span>        <span class='hs-comment'>-- See Note [INLINE for small functions] (4)</span>
<a name="line-413"></a>
<a name="line-414"></a><a name="sizeExpr"></a><span class='hs-definition'>sizeExpr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span>
<a name="line-415"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>             <span class='hs-comment'>-- Bomb out if it gets bigger than this</span>
<a name="line-416"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- Arguments; we're interested in which of these</span>
<a name="line-417"></a>                            <span class='hs-comment'>-- get case'd</span>
<a name="line-418"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-419"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-420"></a>
<a name="line-421"></a><span class='hs-comment'>-- Note [Computing the size of an expression]</span>
<a name="line-422"></a>
<a name="line-423"></a><span class='hs-comment'>-- Forcing bOMB_OUT_SIZE early prevents repeated</span>
<a name="line-424"></a><span class='hs-comment'>-- unboxing of the Int argument.</span>
<a name="line-425"></a><span class='hs-definition'>sizeExpr</span> <span class='hs-varid'>opts</span> <span class='hs-varop'>!</span><span class='hs-varid'>bOMB_OUT_SIZE</span> <span class='hs-varid'>top_args</span> <span class='hs-varid'>expr</span>
<a name="line-426"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>expr</span>
<a name="line-427"></a>  <span class='hs-keyword'>where</span>
<a name="line-428"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>e</span>
<a name="line-429"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>e</span>
<a name="line-430"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeZero</span>           <span class='hs-comment'>-- Types cost nothing</span>
<a name="line-431"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeZero</span>
<a name="line-432"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeN</span> <span class='hs-layout'>(</span><span class='hs-varid'>litSize</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-433"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRealWorldId</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeZero</span>
<a name="line-434"></a>                      <span class='hs-comment'>-- Make sure we get constructor discounts even</span>
<a name="line-435"></a>                      <span class='hs-comment'>-- on nullary constructors</span>
<a name="line-436"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_call</span> <span class='hs-varid'>f</span> <span class='hs-conid'>[]</span> <span class='hs-num'>0</span>
<a name="line-437"></a>
<a name="line-438"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-439"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyCoArg</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>fun</span>
<a name="line-440"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>arg</span>  <span class='hs-varop'>`addSizeNSD`</span>
<a name="line-441"></a>                        <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>fun</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>isRealWorldExpr</span> <span class='hs-varid'>arg</span> <span class='hs-keyword'>then</span> <span class='hs-num'>1</span> <span class='hs-keyword'>else</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<a name="line-442"></a>
<a name="line-443"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>b</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-444"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>b</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isRealWorldId</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lamScrutDiscount</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>(</span><span class='hs-varid'>size_up</span> <span class='hs-varid'>e</span> <span class='hs-varop'>`addSizeN`</span> <span class='hs-num'>10</span><span class='hs-layout'>)</span>
<a name="line-445"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>e</span>
<a name="line-446"></a>
<a name="line-447"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>binder</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-448"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>binder</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varop'>`addSizeNSD`</span>
<a name="line-449"></a>        <span class='hs-varid'>size_up</span> <span class='hs-varid'>body</span>              <span class='hs-varop'>`addSizeN`</span>
<a name="line-450"></a>        <span class='hs-varid'>size_up_alloc</span> <span class='hs-varid'>binder</span>
<a name="line-451"></a>
<a name="line-452"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-453"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>addSizeNSD</span> <span class='hs-varop'>.</span> <span class='hs-varid'>size_up_rhs</span><span class='hs-layout'>)</span>
<a name="line-454"></a>              <span class='hs-layout'>(</span><span class='hs-varid'>size_up</span> <span class='hs-varid'>body</span> <span class='hs-varop'>`addSizeN`</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>size_up_alloc</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-455"></a>              <span class='hs-varid'>pairs</span>
<a name="line-456"></a>
<a name="line-457"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-458"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>alts</span>
<a name="line-459"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>e</span>    <span class='hs-comment'>-- case e of {} never returns, so take size of scrutinee</span>
<a name="line-460"></a>
<a name="line-461"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-462"></a>        <span class='hs-comment'>-- Now alts is non-empty</span>
<a name="line-463"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>is_top_arg</span> <span class='hs-varid'>e</span> <span class='hs-comment'>-- We are scrutinising an argument variable</span>
<a name="line-464"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span>
<a name="line-465"></a>            <span class='hs-varid'>alt_sizes</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>size_up_alt</span> <span class='hs-varid'>alts</span>
<a name="line-466"></a>
<a name="line-467"></a>                  <span class='hs-comment'>-- alts_size tries to compute a good discount for</span>
<a name="line-468"></a>                  <span class='hs-comment'>-- the case when we are scrutinising an argument variable</span>
<a name="line-469"></a>            <span class='hs-varid'>alts_size</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>tot</span> <span class='hs-varid'>tot_disc</span> <span class='hs-varid'>tot_scrut</span><span class='hs-layout'>)</span>
<a name="line-470"></a>                          <span class='hs-comment'>-- Size of all alternatives</span>
<a name="line-471"></a>                      <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>max</span> <span class='hs-keyword'>_</span>        <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-472"></a>                          <span class='hs-comment'>-- Size of biggest alternative</span>
<a name="line-473"></a>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>tot</span> <span class='hs-layout'>(</span><span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-num'>20</span> <span class='hs-varop'>+</span> <span class='hs-varid'>tot</span> <span class='hs-comment'>-</span> <span class='hs-varid'>max</span><span class='hs-layout'>)</span>
<a name="line-474"></a>                      <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>tot_disc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tot_scrut</span>
<a name="line-475"></a>                          <span class='hs-comment'>-- If the variable is known, we produce a</span>
<a name="line-476"></a>                          <span class='hs-comment'>-- discount that will take us back to 'max',</span>
<a name="line-477"></a>                          <span class='hs-comment'>-- the size of the largest alternative The</span>
<a name="line-478"></a>                          <span class='hs-comment'>-- 1+ is a little discount for reduced</span>
<a name="line-479"></a>                          <span class='hs-comment'>-- allocation in the caller</span>
<a name="line-480"></a>                          <span class='hs-comment'>--</span>
<a name="line-481"></a>                          <span class='hs-comment'>-- Notice though, that we return tot_disc,</span>
<a name="line-482"></a>                          <span class='hs-comment'>-- the total discount from all branches.  I</span>
<a name="line-483"></a>                          <span class='hs-comment'>-- think that's right.</span>
<a name="line-484"></a>
<a name="line-485"></a>            <span class='hs-varid'>alts_size</span> <span class='hs-varid'>tot_size</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tot_size</span>
<a name="line-486"></a>          <span class='hs-keyword'>in</span>
<a name="line-487"></a>          <span class='hs-varid'>alts_size</span> <span class='hs-layout'>(</span><span class='hs-varid'>foldr1</span> <span class='hs-varid'>addAltSize</span> <span class='hs-varid'>alt_sizes</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- alts is non-empty</span>
<a name="line-488"></a>                    <span class='hs-layout'>(</span><span class='hs-varid'>foldr1</span> <span class='hs-varid'>maxSize</span>    <span class='hs-varid'>alt_sizes</span><span class='hs-layout'>)</span>
<a name="line-489"></a>                <span class='hs-comment'>-- Good to inline if an arg is scrutinised, because</span>
<a name="line-490"></a>                <span class='hs-comment'>-- that may eliminate allocation in the caller</span>
<a name="line-491"></a>                <span class='hs-comment'>-- And it eliminates the case itself</span>
<a name="line-492"></a>        <span class='hs-keyword'>where</span>
<a name="line-493"></a>          <span class='hs-varid'>is_top_arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>top_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>v</span>
<a name="line-494"></a>          <span class='hs-varid'>is_top_arg</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_top_arg</span> <span class='hs-varid'>e</span>
<a name="line-495"></a>          <span class='hs-varid'>is_top_arg</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-496"></a>
<a name="line-497"></a>
<a name="line-498"></a>    <span class='hs-varid'>size_up</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>e</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>e</span>  <span class='hs-varop'>`addSizeNSD`</span>
<a name="line-499"></a>                                <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>addAltSize</span> <span class='hs-varop'>.</span> <span class='hs-varid'>size_up_alt</span><span class='hs-layout'>)</span> <span class='hs-varid'>case_size</span> <span class='hs-varid'>alts</span>
<a name="line-500"></a>      <span class='hs-keyword'>where</span>
<a name="line-501"></a>          <span class='hs-varid'>case_size</span>
<a name="line-502"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_inline_scrut</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>lengthAtMost</span> <span class='hs-varid'>alts</span> <span class='hs-num'>1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeN</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>10</span><span class='hs-layout'>)</span>
<a name="line-503"></a>           <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeZero</span>
<a name="line-504"></a>                <span class='hs-comment'>-- Normally we don't charge for the case itself, but</span>
<a name="line-505"></a>                <span class='hs-comment'>-- we charge one per alternative (see size_up_alt,</span>
<a name="line-506"></a>                <span class='hs-comment'>-- below) to account for the cost of the info table</span>
<a name="line-507"></a>                <span class='hs-comment'>-- and comparisons.</span>
<a name="line-508"></a>                <span class='hs-comment'>--</span>
<a name="line-509"></a>                <span class='hs-comment'>-- However, in certain cases (see is_inline_scrut</span>
<a name="line-510"></a>                <span class='hs-comment'>-- below), no code is generated for the case unless</span>
<a name="line-511"></a>                <span class='hs-comment'>-- there are multiple alts.  In these cases we</span>
<a name="line-512"></a>                <span class='hs-comment'>-- subtract one, making the first alt free.</span>
<a name="line-513"></a>                <span class='hs-comment'>-- e.g. case x# +# y# of _ -&gt; ...   should cost 1</span>
<a name="line-514"></a>                <span class='hs-comment'>--      case touch# x# of _ -&gt; ...  should cost 0</span>
<a name="line-515"></a>                <span class='hs-comment'>-- (see #4978)</span>
<a name="line-516"></a>                <span class='hs-comment'>--</span>
<a name="line-517"></a>                <span class='hs-comment'>-- I would like to not have the "lengthAtMost alts 1"</span>
<a name="line-518"></a>                <span class='hs-comment'>-- condition above, but without that some programs got worse</span>
<a name="line-519"></a>                <span class='hs-comment'>-- (spectral/hartel/event and spectral/para).  I don't fully</span>
<a name="line-520"></a>                <span class='hs-comment'>-- understand why. (SDM 24/5/11)</span>
<a name="line-521"></a>
<a name="line-522"></a>                <span class='hs-comment'>-- unboxed variables, inline primops and unsafe foreign calls</span>
<a name="line-523"></a>                <span class='hs-comment'>-- are all "inline" things:</span>
<a name="line-524"></a>          <span class='hs-varid'>is_inline_scrut</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-525"></a>          <span class='hs-varid'>is_inline_scrut</span> <span class='hs-varid'>scrut</span>
<a name="line-526"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>f</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectArgs</span> <span class='hs-varid'>scrut</span>
<a name="line-527"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>idDetails</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>of</span>
<a name="line-528"></a>                    <span class='hs-conid'>FCallId</span> <span class='hs-varid'>fc</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isSafeForeignCall</span> <span class='hs-varid'>fc</span><span class='hs-layout'>)</span>
<a name="line-529"></a>                    <span class='hs-conid'>PrimOpId</span> <span class='hs-varid'>op</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>primOpOutOfLine</span> <span class='hs-varid'>op</span><span class='hs-layout'>)</span>
<a name="line-530"></a>                    <span class='hs-sel'>_other</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-531"></a>              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-532"></a>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-533"></a>
<a name="line-534"></a>    <span class='hs-varid'>size_up_rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>bndr</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-535"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>join_arity</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isJoinId_maybe</span> <span class='hs-varid'>bndr</span>
<a name="line-536"></a>        <span class='hs-comment'>-- Skip arguments to join point</span>
<a name="line-537"></a>      <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-sel'>_bndrs</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>collectNBinders</span> <span class='hs-varid'>join_arity</span> <span class='hs-varid'>rhs</span>
<a name="line-538"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>body</span>
<a name="line-539"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-540"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>rhs</span>
<a name="line-541"></a>
<a name="line-542"></a>    <span class='hs-comment'>------------</span>
<a name="line-543"></a>    <span class='hs-comment'>-- size_up_app is used when there's ONE OR MORE value args</span>
<a name="line-544"></a>    <span class='hs-varid'>size_up_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>App</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span>
<a name="line-545"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyCoArg</span> <span class='hs-varid'>arg</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span>
<a name="line-546"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRealWorldExpr</span> <span class='hs-varid'>arg</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-conop'>:</span><span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>voids</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span>
<a name="line-547"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>arg</span>  <span class='hs-varop'>`addSizeNSD`</span>
<a name="line-548"></a>                                           <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-conop'>:</span><span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>voids</span>
<a name="line-549"></a>    <span class='hs-varid'>size_up_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span>     <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_call</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span>
<a name="line-550"></a>    <span class='hs-varid'>size_up_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>expr</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span>
<a name="line-551"></a>    <span class='hs-varid'>size_up_app</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>expr</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span>
<a name="line-552"></a>    <span class='hs-varid'>size_up_app</span> <span class='hs-varid'>other</span>         <span class='hs-varid'>args</span> <span class='hs-varid'>voids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>other</span> <span class='hs-varop'>`addSizeN`</span>
<a name="line-553"></a>                                           <span class='hs-varid'>callSize</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-varid'>voids</span>
<a name="line-554"></a>       <span class='hs-comment'>-- if the lhs is not an App or a Var, or an invisible thing like a</span>
<a name="line-555"></a>       <span class='hs-comment'>-- Tick or Cast, then we should charge for a complete call plus the</span>
<a name="line-556"></a>       <span class='hs-comment'>-- size of the lhs itself.</span>
<a name="line-557"></a>
<a name="line-558"></a>    <span class='hs-comment'>------------</span>
<a name="line-559"></a>    <span class='hs-varid'>size_up_call</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-560"></a>    <span class='hs-varid'>size_up_call</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>val_args</span> <span class='hs-varid'>voids</span>
<a name="line-561"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>idDetails</span> <span class='hs-varid'>fun</span> <span class='hs-keyword'>of</span>
<a name="line-562"></a>           <span class='hs-conid'>FCallId</span> <span class='hs-keyword'>_</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>sizeN</span> <span class='hs-layout'>(</span><span class='hs-varid'>callSize</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>)</span> <span class='hs-varid'>voids</span><span class='hs-layout'>)</span>
<a name="line-563"></a>           <span class='hs-conid'>DataConWorkId</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>conSize</span>    <span class='hs-varid'>dc</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>)</span>
<a name="line-564"></a>           <span class='hs-conid'>PrimOpId</span> <span class='hs-varid'>op</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>primOpSize</span> <span class='hs-varid'>op</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>)</span>
<a name="line-565"></a>           <span class='hs-conid'>ClassOpId</span> <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>classOpSize</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>top_args</span> <span class='hs-varid'>val_args</span>
<a name="line-566"></a>           <span class='hs-keyword'>_</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>funSize</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>top_args</span> <span class='hs-varid'>fun</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>val_args</span><span class='hs-layout'>)</span> <span class='hs-varid'>voids</span>
<a name="line-567"></a>
<a name="line-568"></a>    <span class='hs-comment'>------------</span>
<a name="line-569"></a>    <span class='hs-varid'>size_up_alt</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-sel'>_con</span> <span class='hs-sel'>_bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size_up</span> <span class='hs-varid'>rhs</span> <span class='hs-varop'>`addSizeN`</span> <span class='hs-num'>10</span>
<a name="line-570"></a>        <span class='hs-comment'>-- Don't charge for args, so that wrappers look cheap</span>
<a name="line-571"></a>        <span class='hs-comment'>-- (See comments about wrappers with Case)</span>
<a name="line-572"></a>        <span class='hs-comment'>--</span>
<a name="line-573"></a>        <span class='hs-comment'>-- IMPORTANT: *do* charge 1 for the alternative, else we</span>
<a name="line-574"></a>        <span class='hs-comment'>-- find that giant case nests are treated as practically free</span>
<a name="line-575"></a>        <span class='hs-comment'>-- A good example is Foreign.C.Error.errnoToIOError</span>
<a name="line-576"></a>
<a name="line-577"></a>    <span class='hs-comment'>------------</span>
<a name="line-578"></a>    <span class='hs-comment'>-- Cost to allocate binding with given binder</span>
<a name="line-579"></a>    <span class='hs-varid'>size_up_alloc</span> <span class='hs-varid'>bndr</span>
<a name="line-580"></a>      <span class='hs-keyglyph'>|</span>  <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>bndr</span>                 <span class='hs-comment'>-- Doesn't exist at runtime</span>
<a name="line-581"></a>      <span class='hs-varop'>||</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>bndr</span>                <span class='hs-comment'>-- Not allocated at all</span>
<a name="line-582"></a>      <span class='hs-varop'>||</span> <span class='hs-varid'>isUnliftedType</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>bndr</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Doesn't live in heap</span>
<a name="line-583"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-584"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-585"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>10</span>
<a name="line-586"></a>
<a name="line-587"></a>    <span class='hs-comment'>------------</span>
<a name="line-588"></a>        <span class='hs-comment'>-- These addSize things have to be here because</span>
<a name="line-589"></a>        <span class='hs-comment'>-- I don't want to give them bOMB_OUT_SIZE as an argument</span>
<a name="line-590"></a>    <span class='hs-varid'>addSizeN</span> <span class='hs-conid'>TooBig</span>          <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-591"></a>    <span class='hs-varid'>addSizeN</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-varid'>m</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSizeIs</span> <span class='hs-varid'>bOMB_OUT_SIZE</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-varop'>+</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>d</span>
<a name="line-592"></a>
<a name="line-593"></a>        <span class='hs-comment'>-- addAltSize is used to add the sizes of case alternatives</span>
<a name="line-594"></a>    <span class='hs-varid'>addAltSize</span> <span class='hs-conid'>TooBig</span>            <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-595"></a>    <span class='hs-varid'>addAltSize</span> <span class='hs-keyword'>_</span>                 <span class='hs-conid'>TooBig</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-596"></a>    <span class='hs-varid'>addAltSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n1</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>d1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n2</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>d2</span><span class='hs-layout'>)</span>
<a name="line-597"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSizeIs</span> <span class='hs-varid'>bOMB_OUT_SIZE</span> <span class='hs-layout'>(</span><span class='hs-varid'>n1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n2</span><span class='hs-layout'>)</span>
<a name="line-598"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>xs</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<a name="line-599"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>d1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>d2</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Note [addAltSize result discounts]</span>
<a name="line-600"></a>
<a name="line-601"></a>        <span class='hs-comment'>-- This variant ignores the result discount from its LEFT argument</span>
<a name="line-602"></a>        <span class='hs-comment'>-- It's used when the second argument isn't part of the result</span>
<a name="line-603"></a>    <span class='hs-varid'>addSizeNSD</span> <span class='hs-conid'>TooBig</span>            <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-604"></a>    <span class='hs-varid'>addSizeNSD</span> <span class='hs-keyword'>_</span>                 <span class='hs-conid'>TooBig</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-605"></a>    <span class='hs-varid'>addSizeNSD</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n1</span> <span class='hs-varid'>xs</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n2</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>d2</span><span class='hs-layout'>)</span>
<a name="line-606"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkSizeIs</span> <span class='hs-varid'>bOMB_OUT_SIZE</span> <span class='hs-layout'>(</span><span class='hs-varid'>n1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n2</span><span class='hs-layout'>)</span>
<a name="line-607"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>xs</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<a name="line-608"></a>                                 <span class='hs-varid'>d2</span>  <span class='hs-comment'>-- Ignore d1</span>
<a name="line-609"></a>
<a name="line-610"></a>    <span class='hs-varid'>isRealWorldId</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>idType</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`eqType`</span> <span class='hs-varid'>realWorldStatePrimTy</span>
<a name="line-611"></a>
<a name="line-612"></a>    <span class='hs-comment'>-- an expression of type State# RealWorld must be a variable</span>
<a name="line-613"></a>    <span class='hs-varid'>isRealWorldExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Var</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isRealWorldId</span> <span class='hs-varid'>id</span>
<a name="line-614"></a>    <span class='hs-varid'>isRealWorldExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isRealWorldExpr</span> <span class='hs-varid'>e</span>
<a name="line-615"></a>    <span class='hs-varid'>isRealWorldExpr</span> <span class='hs-keyword'>_</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-616"></a>
<a name="line-617"></a><a name="litSize"></a><span class='hs-comment'>-- | Finds a nominal size of a string literal.</span>
<a name="line-618"></a><span class='hs-definition'>litSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Literal</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-619"></a><span class='hs-comment'>-- Used by GHC.Core.Unfold.sizeExpr</span>
<a name="line-620"></a><span class='hs-definition'>litSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitNumber</span> <span class='hs-conid'>LitNumInteger</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>100</span>   <span class='hs-comment'>-- Note [Size of literal integers]</span>
<a name="line-621"></a><span class='hs-definition'>litSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitNumber</span> <span class='hs-conid'>LitNumNatural</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>100</span>
<a name="line-622"></a><span class='hs-definition'>litSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitString</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>10</span> <span class='hs-varop'>+</span> <span class='hs-num'>10</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-conid'>BS.length</span> <span class='hs-varid'>str</span> <span class='hs-varop'>+</span> <span class='hs-num'>3</span><span class='hs-layout'>)</span> <span class='hs-varop'>`div`</span> <span class='hs-num'>4</span><span class='hs-layout'>)</span>
<a name="line-623"></a>        <span class='hs-comment'>-- If size could be 0 then @f "x"@ might be too small</span>
<a name="line-624"></a>        <span class='hs-comment'>-- [Sept03: make literal strings a bit bigger to avoid fruitless</span>
<a name="line-625"></a>        <span class='hs-comment'>--  duplication of little strings]</span>
<a name="line-626"></a><span class='hs-definition'>litSize</span> <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>    <span class='hs-comment'>-- Must match size of nullary constructors</span>
<a name="line-627"></a>                      <span class='hs-comment'>-- Key point: if  x |-&gt; 4, then x must inline unconditionally</span>
<a name="line-628"></a>                      <span class='hs-comment'>--            (eg via case binding)</span>
<a name="line-629"></a>
<a name="line-630"></a><a name="classOpSize"></a><span class='hs-definition'>classOpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreExpr</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-631"></a><span class='hs-comment'>-- See Note [Conlike is interesting]</span>
<a name="line-632"></a><span class='hs-definition'>classOpSize</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-conid'>[]</span>
<a name="line-633"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sizeZero</span>
<a name="line-634"></a><span class='hs-definition'>classOpSize</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>top_args</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg1</span> <span class='hs-conop'>:</span> <span class='hs-varid'>other_args</span><span class='hs-layout'>)</span>
<a name="line-635"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>size</span> <span class='hs-varid'>arg_discount</span> <span class='hs-num'>0</span>
<a name="line-636"></a>  <span class='hs-keyword'>where</span>
<a name="line-637"></a>    <span class='hs-varid'>size</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>20</span> <span class='hs-varop'>+</span> <span class='hs-layout'>(</span><span class='hs-num'>10</span> <span class='hs-varop'>*</span> <span class='hs-varid'>length</span> <span class='hs-varid'>other_args</span><span class='hs-layout'>)</span>
<a name="line-638"></a>    <span class='hs-comment'>-- If the class op is scrutinising a lambda bound dictionary then</span>
<a name="line-639"></a>    <span class='hs-comment'>-- give it a discount, to encourage the inlining of this function</span>
<a name="line-640"></a>    <span class='hs-comment'>-- The actual discount is rather arbitrarily chosen</span>
<a name="line-641"></a>    <span class='hs-varid'>arg_discount</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>arg1</span> <span class='hs-keyword'>of</span>
<a name="line-642"></a>                     <span class='hs-conid'>Var</span> <span class='hs-varid'>dict</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dict</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>top_args</span>
<a name="line-643"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>dict</span><span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingDictDiscount</span> <span class='hs-varid'>opts</span><span class='hs-layout'>)</span>
<a name="line-644"></a>                     <span class='hs-sel'>_other</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>emptyBag</span>
<a name="line-645"></a>
<a name="line-646"></a><a name="callSize"></a><span class='hs-comment'>-- | The size of a function call</span>
<a name="line-647"></a><span class='hs-definition'>callSize</span>
<a name="line-648"></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>  <span class='hs-comment'>-- ^ number of value args</span>
<a name="line-649"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>  <span class='hs-comment'>-- ^ number of value args that are void</span>
<a name="line-650"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-651"></a><span class='hs-definition'>callSize</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>voids</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>10</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n_val_args</span> <span class='hs-comment'>-</span> <span class='hs-varid'>voids</span><span class='hs-layout'>)</span>
<a name="line-652"></a>        <span class='hs-comment'>-- The 1+ is for the function itself</span>
<a name="line-653"></a>        <span class='hs-comment'>-- Add 1 for each non-trivial arg;</span>
<a name="line-654"></a>        <span class='hs-comment'>-- the allocation cost, as in let(rec)</span>
<a name="line-655"></a>
<a name="line-656"></a><a name="jumpSize"></a><span class='hs-comment'>-- | The size of a jump to a join point</span>
<a name="line-657"></a><span class='hs-definition'>jumpSize</span>
<a name="line-658"></a> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>  <span class='hs-comment'>-- ^ number of value args</span>
<a name="line-659"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>  <span class='hs-comment'>-- ^ number of value args that are void</span>
<a name="line-660"></a> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-661"></a><span class='hs-definition'>jumpSize</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>voids</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n_val_args</span> <span class='hs-comment'>-</span> <span class='hs-varid'>voids</span><span class='hs-layout'>)</span>
<a name="line-662"></a>  <span class='hs-comment'>-- A jump is 20% the size of a function call. Making jumps free reopens</span>
<a name="line-663"></a>  <span class='hs-comment'>-- bug #6048, but making them any more expensive loses a 21% improvement in</span>
<a name="line-664"></a>  <span class='hs-comment'>-- spectral/puzzle. TODO Perhaps adjusting the default threshold would be a</span>
<a name="line-665"></a>  <span class='hs-comment'>-- better solution?</span>
<a name="line-666"></a>
<a name="line-667"></a><a name="funSize"></a><span class='hs-definition'>funSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-668"></a><span class='hs-comment'>-- Size for functions that are not constructors or primops</span>
<a name="line-669"></a><span class='hs-comment'>-- Note [Function applications]</span>
<a name="line-670"></a><span class='hs-definition'>funSize</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>top_args</span> <span class='hs-varid'>fun</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>voids</span>
<a name="line-671"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>buildIdKey</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>buildSize</span>
<a name="line-672"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>augmentIdKey</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>augmentSize</span>
<a name="line-673"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>size</span> <span class='hs-varid'>arg_discount</span> <span class='hs-varid'>res_discount</span>
<a name="line-674"></a>  <span class='hs-keyword'>where</span>
<a name="line-675"></a>    <span class='hs-varid'>some_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>
<a name="line-676"></a>    <span class='hs-varid'>is_join</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isJoinId</span> <span class='hs-varid'>fun</span>
<a name="line-677"></a>
<a name="line-678"></a>    <span class='hs-varid'>size</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_join</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>jumpSize</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>voids</span>
<a name="line-679"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>some_val_args</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-680"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>callSize</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varid'>voids</span>
<a name="line-681"></a>
<a name="line-682"></a>        <span class='hs-comment'>--                  DISCOUNTS</span>
<a name="line-683"></a>        <span class='hs-comment'>--  See Note [Function and non-function discounts]</span>
<a name="line-684"></a>    <span class='hs-varid'>arg_discount</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>some_val_args</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>top_args</span>
<a name="line-685"></a>                 <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>fun</span><span class='hs-layout'>,</span> <span class='hs-varid'>unfoldingFunAppDiscount</span> <span class='hs-varid'>opts</span><span class='hs-layout'>)</span>
<a name="line-686"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>
<a name="line-687"></a>        <span class='hs-comment'>-- If the function is an argument and is applied</span>
<a name="line-688"></a>        <span class='hs-comment'>-- to some values, give it an arg-discount</span>
<a name="line-689"></a>
<a name="line-690"></a>    <span class='hs-varid'>res_discount</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>idArity</span> <span class='hs-varid'>fun</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingFunAppDiscount</span> <span class='hs-varid'>opts</span>
<a name="line-691"></a>                 <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-692"></a>        <span class='hs-comment'>-- If the function is partially applied, show a result discount</span>
<a name="line-693"></a><span class='hs-comment'>-- XXX maybe behave like ConSize for eval'd variable</span>
<a name="line-694"></a>
<a name="line-695"></a><a name="conSize"></a><span class='hs-definition'>conSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DataCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-696"></a><span class='hs-definition'>conSize</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>n_val_args</span>
<a name="line-697"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-num'>0</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>10</span>    <span class='hs-comment'>-- Like variables</span>
<a name="line-698"></a>
<a name="line-699"></a><span class='hs-comment'>-- See Note [Unboxed tuple size and result discount]</span>
<a name="line-700"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isUnboxedTupleDataCon</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-num'>0</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>10</span>
<a name="line-701"></a>
<a name="line-702"></a><span class='hs-comment'>-- See Note [Constructor size and result discount]</span>
<a name="line-703"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-num'>10</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>10</span>
<a name="line-704"></a>
<a name="line-705"></a><span class='hs-comment'>{- Note [Constructor size and result discount]
<a name="line-706"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-707"></a>Treat a constructors application as size 10, regardless of how many
<a name="line-708"></a>arguments it has; we are keen to expose them (and we charge separately
<a name="line-709"></a>for their args).  We can't treat them as size zero, else we find that
<a name="line-710"></a>(Just x) has size 0, which is the same as a lone variable; and hence
<a name="line-711"></a>'v' will always be replaced by (Just x), where v is bound to Just x.
<a name="line-712"></a>
<a name="line-713"></a>The "result discount" is applied if the result of the call is
<a name="line-714"></a>scrutinised (say by a case).  For a constructor application that will
<a name="line-715"></a>mean the constructor application will disappear, so we don't need to
<a name="line-716"></a>charge it to the function.  So the discount should at least match the
<a name="line-717"></a>cost of the constructor application, namely 10.
<a name="line-718"></a>
<a name="line-719"></a>Historical note 1: Until Jun 2020 we gave it a "bit of extra
<a name="line-720"></a>incentive" via a discount of 10*(1 + n_val_args), but that was FAR too
<a name="line-721"></a>much (#18282).  In particular, consider a huge case tree like
<a name="line-722"></a>
<a name="line-723"></a>   let r = case y1 of
<a name="line-724"></a>          Nothing -&gt; B1 a b c
<a name="line-725"></a>          Just v1 -&gt; case y2 of
<a name="line-726"></a>                      Nothing -&gt; B1 c b a
<a name="line-727"></a>                      Just v2 -&gt; ...
<a name="line-728"></a>
<a name="line-729"></a>If conSize gives a cost of 10 (regardless of n_val_args) and a
<a name="line-730"></a>discount of 10, that'll make each alternative RHS cost zero.  We
<a name="line-731"></a>charge 10 for each case alternative (see size_up_alt).  If we give a
<a name="line-732"></a>bigger discount (say 20) in conSize, we'll make the case expression
<a name="line-733"></a>cost *nothing*, and that can make a huge case tree cost nothing. This
<a name="line-734"></a>leads to massive, sometimes exponenial inlinings (#18282).  In short,
<a name="line-735"></a>don't give a discount that give a negative size to a sub-expression!
<a name="line-736"></a>
<a name="line-737"></a>Historical note 2: Much longer ago, Simon M tried a MUCH bigger
<a name="line-738"></a>discount: (10 * (10 + n_val_args)), and said it was an "unambiguous
<a name="line-739"></a>win", but its terribly dangerous because a function with many many
<a name="line-740"></a>case branches, each finishing with a constructor, can have an
<a name="line-741"></a>arbitrarily large discount.  This led to terrible code bloat: see #6099.
<a name="line-742"></a>
<a name="line-743"></a>Note [Unboxed tuple size and result discount]
<a name="line-744"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-745"></a>However, unboxed tuples count as size zero. I found occasions where we had
<a name="line-746"></a>        f x y z = case op# x y z of { s -&gt; (# s, () #) }
<a name="line-747"></a>and f wasn't getting inlined.
<a name="line-748"></a>
<a name="line-749"></a>I tried giving unboxed tuples a *result discount* of zero (see the
<a name="line-750"></a>commented-out line).  Why?  When returned as a result they do not
<a name="line-751"></a>allocate, so maybe we don't want to charge so much for them. If you
<a name="line-752"></a>have a non-zero discount here, we find that workers often get inlined
<a name="line-753"></a>back into wrappers, because it look like
<a name="line-754"></a>    f x = case $wf x of (# a,b #) -&gt; (a,b)
<a name="line-755"></a>and we are keener because of the case.  However while this change
<a name="line-756"></a>shrank binary sizes by 0.5% it also made spectral/boyer allocate 5%
<a name="line-757"></a>more. All other changes were very small. So it's not a big deal but I
<a name="line-758"></a>didn't adopt the idea.
<a name="line-759"></a>
<a name="line-760"></a>When fixing #18282 (see Note [Constructor size and result discount])
<a name="line-761"></a>I changed the result discount to be just 10, not 10*(1+n_val_args).
<a name="line-762"></a>
<a name="line-763"></a>Note [Function and non-function discounts]
<a name="line-764"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-765"></a>We want a discount if the function is applied. A good example is
<a name="line-766"></a>monadic combinators with continuation arguments, where inlining is
<a name="line-767"></a>quite important.
<a name="line-768"></a>
<a name="line-769"></a>But we don't want a big discount when a function is called many times
<a name="line-770"></a>(see the detailed comments with #6048) because if the function is
<a name="line-771"></a>big it won't be inlined at its many call sites and no benefit results.
<a name="line-772"></a>Indeed, we can get exponentially big inlinings this way; that is what
<a name="line-773"></a>#6048 is about.
<a name="line-774"></a>
<a name="line-775"></a>On the other hand, for data-valued arguments, if there are lots of
<a name="line-776"></a>case expressions in the body, each one will get smaller if we apply
<a name="line-777"></a>the function to a constructor application, so we *want* a big discount
<a name="line-778"></a>if the argument is scrutinised by many case expressions.
<a name="line-779"></a>
<a name="line-780"></a>Conclusion:
<a name="line-781"></a>  - For functions, take the max of the discounts
<a name="line-782"></a>  - For data values, take the sum of the discounts
<a name="line-783"></a>
<a name="line-784"></a>
<a name="line-785"></a>Note [Literal integer size]
<a name="line-786"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-787"></a>Literal integers *can* be big (mkInteger [...coefficients...]), but
<a name="line-788"></a>need not be (IS n).  We just use an arbitrary big-ish constant here
<a name="line-789"></a>so that, in particular, we don't inline top-level defns like
<a name="line-790"></a>   n = IS 5
<a name="line-791"></a>There's no point in doing so -- any optimisations will see the IS
<a name="line-792"></a>through n's unfolding.  Nor will a big size inhibit unfoldings functions
<a name="line-793"></a>that mention a literal Integer, because the float-out pass will float
<a name="line-794"></a>all those constants to top level.
<a name="line-795"></a>-}</span>
<a name="line-796"></a>
<a name="line-797"></a><a name="primOpSize"></a><span class='hs-definition'>primOpSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>PrimOp</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-798"></a><span class='hs-definition'>primOpSize</span> <span class='hs-varid'>op</span> <span class='hs-varid'>n_val_args</span>
<a name="line-799"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>primOpOutOfLine</span> <span class='hs-varid'>op</span>
<a name="line-800"></a>      <span class='hs-keyword'>then</span> <span class='hs-varid'>sizeN</span> <span class='hs-layout'>(</span><span class='hs-varid'>op_size</span> <span class='hs-varop'>+</span> <span class='hs-varid'>n_val_args</span><span class='hs-layout'>)</span>
<a name="line-801"></a>      <span class='hs-keyword'>else</span> <span class='hs-varid'>sizeN</span> <span class='hs-varid'>op_size</span>
<a name="line-802"></a> <span class='hs-keyword'>where</span>
<a name="line-803"></a>   <span class='hs-varid'>op_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>primOpCodeSize</span> <span class='hs-varid'>op</span>
<a name="line-804"></a>
<a name="line-805"></a>
<a name="line-806"></a><a name="buildSize"></a><span class='hs-definition'>buildSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExprSize</span>
<a name="line-807"></a><span class='hs-definition'>buildSize</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-num'>0</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>40</span>
<a name="line-808"></a>        <span class='hs-comment'>-- We really want to inline applications of build</span>
<a name="line-809"></a>        <span class='hs-comment'>-- build t (\cn -&gt; e) should cost only the cost of e (because build will be inlined later)</span>
<a name="line-810"></a>        <span class='hs-comment'>-- Indeed, we should add a result_discount because build is</span>
<a name="line-811"></a>        <span class='hs-comment'>-- very like a constructor.  We don't bother to check that the</span>
<a name="line-812"></a>        <span class='hs-comment'>-- build is saturated (it usually is).  The "-2" discounts for the \c n,</span>
<a name="line-813"></a>        <span class='hs-comment'>-- The "4" is rather arbitrary.</span>
<a name="line-814"></a>
<a name="line-815"></a><a name="augmentSize"></a><span class='hs-definition'>augmentSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExprSize</span>
<a name="line-816"></a><span class='hs-definition'>augmentSize</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-num'>0</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>40</span>
<a name="line-817"></a>        <span class='hs-comment'>-- Ditto (augment t (\cn -&gt; e) ys) should cost only the cost of</span>
<a name="line-818"></a>        <span class='hs-comment'>-- e plus ys. The -2 accounts for the \cn</span>
<a name="line-819"></a>
<a name="line-820"></a><a name="lamScrutDiscount"></a><span class='hs-comment'>-- When we return a lambda, give a discount if it's used (applied)</span>
<a name="line-821"></a><span class='hs-definition'>lamScrutDiscount</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-822"></a><span class='hs-definition'>lamScrutDiscount</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>vs</span> <span class='hs-layout'>(</span><span class='hs-varid'>unfoldingFunAppDiscount</span> <span class='hs-varid'>opts</span><span class='hs-layout'>)</span>
<a name="line-823"></a><span class='hs-definition'>lamScrutDiscount</span> <span class='hs-keyword'>_</span>      <span class='hs-conid'>TooBig</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-824"></a>
<a name="line-825"></a><span class='hs-comment'>{-
<a name="line-826"></a>Note [addAltSize result discounts]
<a name="line-827"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-828"></a>When adding the size of alternatives, we *add* the result discounts
<a name="line-829"></a>too, rather than take the *maximum*.  For a multi-branch case, this
<a name="line-830"></a>gives a discount for each branch that returns a constructor, making us
<a name="line-831"></a>keener to inline.  I did try using 'max' instead, but it makes nofib
<a name="line-832"></a>'rewrite' and 'puzzle' allocate significantly more, and didn't make
<a name="line-833"></a>binary sizes shrink significantly either.
<a name="line-834"></a>
<a name="line-835"></a>Note [Discounts and thresholds]
<a name="line-836"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-837"></a>
<a name="line-838"></a>Constants for discounts and thresholds are defined in 'UnfoldingOpts'. They are:
<a name="line-839"></a>
<a name="line-840"></a>unfoldingCreationThreshold
<a name="line-841"></a>     At a definition site, if the unfolding is bigger than this, we
<a name="line-842"></a>     may discard it altogether
<a name="line-843"></a>
<a name="line-844"></a>unfoldingUseThreshold
<a name="line-845"></a>     At a call site, if the unfolding, less discounts, is smaller than
<a name="line-846"></a>     this, then it's small enough inline
<a name="line-847"></a>
<a name="line-848"></a>unfoldingDictDiscount
<a name="line-849"></a>     The discount for each occurrence of a dictionary argument
<a name="line-850"></a>     as an argument of a class method.  Should be pretty small
<a name="line-851"></a>     else big functions may get inlined
<a name="line-852"></a>
<a name="line-853"></a>unfoldingFunAppDiscount
<a name="line-854"></a>     Discount for a function argument that is applied.  Quite
<a name="line-855"></a>     large, because if we inline we avoid the higher-order call.
<a name="line-856"></a>
<a name="line-857"></a>unfoldingVeryAggressive
<a name="line-858"></a>     If True, the compiler ignores all the thresholds and inlines very
<a name="line-859"></a>     aggressively. It still adheres to arity, simplifier phase control and
<a name="line-860"></a>     loop breakers.
<a name="line-861"></a>
<a name="line-862"></a>
<a name="line-863"></a>Historical Note: Before April 2020 we had another factor,
<a name="line-864"></a>ufKeenessFactor, which would scale the discounts before they were subtracted
<a name="line-865"></a>from the size. This was justified with the following comment:
<a name="line-866"></a>
<a name="line-867"></a>  -- We multiply the raw discounts (args_discount and result_discount)
<a name="line-868"></a>  -- ty opt_UnfoldingKeenessFactor because the former have to do with
<a name="line-869"></a>  --  *size* whereas the discounts imply that there's some extra
<a name="line-870"></a>  --  *efficiency* to be gained (e.g. beta reductions, case reductions)
<a name="line-871"></a>  -- by inlining.
<a name="line-872"></a>
<a name="line-873"></a>However, this is highly suspect since it means that we subtract a *scaled* size
<a name="line-874"></a>from an absolute size, resulting in crazy (e.g. negative) scores in some cases
<a name="line-875"></a>(#15304). We consequently killed off ufKeenessFactor and bumped up the
<a name="line-876"></a>ufUseThreshold to compensate.
<a name="line-877"></a>
<a name="line-878"></a>
<a name="line-879"></a>Note [Function applications]
<a name="line-880"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-881"></a>In a function application (f a b)
<a name="line-882"></a>
<a name="line-883"></a>  - If 'f' is an argument to the function being analysed,
<a name="line-884"></a>    and there's at least one value arg, record a FunAppDiscount for f
<a name="line-885"></a>
<a name="line-886"></a>  - If the application if a PAP (arity &gt; 2 in this example)
<a name="line-887"></a>    record a *result* discount (because inlining
<a name="line-888"></a>    with "extra" args in the call may mean that we now
<a name="line-889"></a>    get a saturated application)
<a name="line-890"></a>
<a name="line-891"></a>Code for manipulating sizes
<a name="line-892"></a>-}</span>
<a name="line-893"></a>
<a name="line-894"></a><a name="ExprSize"></a><span class='hs-comment'>-- | The size of a candidate expression for unfolding</span>
<a name="line-895"></a><a name="ExprSize"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ExprSize</span>
<a name="line-896"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-897"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SizeIs</span> <span class='hs-layout'>{</span> <span class='hs-sel'>_es_size_is</span>  <span class='hs-keyglyph'>::</span> <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span> <span class='hs-comment'>-- ^ Size found</span>
<a name="line-898"></a>             <span class='hs-layout'>,</span> <span class='hs-sel'>_es_args</span>     <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>Int</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-899"></a>               <span class='hs-comment'>-- ^ Arguments cased herein, and discount for each such</span>
<a name="line-900"></a>             <span class='hs-layout'>,</span> <span class='hs-sel'>_es_discount</span> <span class='hs-keyglyph'>::</span> <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>Int</span>
<a name="line-901"></a>               <span class='hs-comment'>-- ^ Size to subtract if result is scrutinised by a case</span>
<a name="line-902"></a>               <span class='hs-comment'>-- expression</span>
<a name="line-903"></a>             <span class='hs-layout'>}</span>
<a name="line-904"></a>
<a name="line-905"></a><a name="instance%20Outputable%20ExprSize"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ExprSize</span> <span class='hs-keyword'>where</span>
<a name="line-906"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>TooBig</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"TooBig"</span>
<a name="line-907"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>brackets</span> <span class='hs-layout'>(</span><span class='hs-varid'>int</span> <span class='hs-varid'>a</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-908"></a>
<a name="line-909"></a><a name="mkSizeIs"></a><span class='hs-comment'>-- subtract the discount before deciding whether to bale out. eg. we</span>
<a name="line-910"></a><span class='hs-comment'>-- want to inline a large constructor application into a selector:</span>
<a name="line-911"></a><span class='hs-comment'>--      tup = (a_1, ..., a_99)</span>
<a name="line-912"></a><span class='hs-comment'>--      x = case tup of ...</span>
<a name="line-913"></a><span class='hs-comment'>--</span>
<a name="line-914"></a><span class='hs-definition'>mkSizeIs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>Int</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-915"></a><span class='hs-definition'>mkSizeIs</span> <span class='hs-varid'>max</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>d</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span> <span class='hs-comment'>-</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>max</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-916"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>     <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>xs</span> <span class='hs-varid'>d</span>
<a name="line-917"></a>
<a name="line-918"></a><a name="maxSize"></a><span class='hs-definition'>maxSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExprSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-919"></a><span class='hs-definition'>maxSize</span> <span class='hs-conid'>TooBig</span>         <span class='hs-keyword'>_</span>                                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-920"></a><span class='hs-definition'>maxSize</span> <span class='hs-keyword'>_</span>              <span class='hs-conid'>TooBig</span>                             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TooBig</span>
<a name="line-921"></a><span class='hs-definition'>maxSize</span> <span class='hs-varid'>s1</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n1</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>s2</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n2</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n1</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>n2</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s1</span>
<a name="line-922"></a>                                              <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>s2</span>
<a name="line-923"></a>
<a name="line-924"></a><a name="sizeZero"></a><span class='hs-definition'>sizeZero</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ExprSize</span>
<a name="line-925"></a><a name="sizeN"></a><span class='hs-definition'>sizeN</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ExprSize</span>
<a name="line-926"></a>
<a name="line-927"></a><span class='hs-definition'>sizeZero</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-num'>0</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>0</span>
<a name="line-928"></a><span class='hs-definition'>sizeN</span> <span class='hs-varid'>n</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SizeIs</span> <span class='hs-varid'>n</span> <span class='hs-varid'>emptyBag</span> <span class='hs-num'>0</span>
<a name="line-929"></a>
<a name="line-930"></a><span class='hs-comment'>{-
<a name="line-931"></a>************************************************************************
<a name="line-932"></a>*                                                                      *
<a name="line-933"></a>\subsection[considerUnfolding]{Given all the info, do (not) do the unfolding}
<a name="line-934"></a>*                                                                      *
<a name="line-935"></a>************************************************************************
<a name="line-936"></a>
<a name="line-937"></a>We use 'couldBeSmallEnoughToInline' to avoid exporting inlinings that
<a name="line-938"></a>we ``couldn't possibly use'' on the other side.  Can be overridden w/
<a name="line-939"></a>flaggery.  Just the same as smallEnoughToInline, except that it has no
<a name="line-940"></a>actual arguments.
<a name="line-941"></a>-}</span>
<a name="line-942"></a>
<a name="line-943"></a><a name="couldBeSmallEnoughToInline"></a><span class='hs-definition'>couldBeSmallEnoughToInline</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-944"></a><span class='hs-definition'>couldBeSmallEnoughToInline</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>threshold</span> <span class='hs-varid'>rhs</span>
<a name="line-945"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>sizeExpr</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>threshold</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>body</span> <span class='hs-keyword'>of</span>
<a name="line-946"></a>       <span class='hs-conid'>TooBig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-947"></a>       <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-948"></a>  <span class='hs-keyword'>where</span>
<a name="line-949"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>collectBinders</span> <span class='hs-varid'>rhs</span>
<a name="line-950"></a>
<a name="line-951"></a><a name="smallEnoughToInline"></a><span class='hs-comment'>----------------</span>
<a name="line-952"></a><span class='hs-definition'>smallEnoughToInline</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-953"></a><span class='hs-definition'>smallEnoughToInline</span> <span class='hs-varid'>opts</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span><span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span><span class='hs-varid'>ug_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span><span class='hs-layout'>}</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-954"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>unfoldingUseThreshold</span> <span class='hs-varid'>opts</span>
<a name="line-955"></a><span class='hs-definition'>smallEnoughToInline</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>
<a name="line-956"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-957"></a>
<a name="line-958"></a><span class='hs-comment'>----------------</span>
<a name="line-959"></a>
<a name="line-960"></a><a name="certainlyWillInline"></a><span class='hs-definition'>certainlyWillInline</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnfoldingOpts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IdInfo</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Unfolding</span>
<a name="line-961"></a><span class='hs-comment'>-- ^ Sees if the unfolding is pretty certain to inline.</span>
<a name="line-962"></a><span class='hs-comment'>-- If so, return a *stable* unfolding for it, that will always inline.</span>
<a name="line-963"></a><span class='hs-definition'>certainlyWillInline</span> <span class='hs-varid'>opts</span> <span class='hs-varid'>fn_info</span>
<a name="line-964"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fn_unf</span> <span class='hs-keyword'>of</span>
<a name="line-965"></a>      <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>expr</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>guidance</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src</span> <span class='hs-layout'>}</span>
<a name="line-966"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>loop_breaker</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>       <span class='hs-comment'>-- Won't inline, so try w/w</span>
<a name="line-967"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>noinline</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>       <span class='hs-comment'>-- See Note [Worker-wrapper for NOINLINE functions]</span>
<a name="line-968"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-969"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>guidance</span> <span class='hs-keyword'>of</span>
<a name="line-970"></a>             <span class='hs-conid'>UnfNever</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-971"></a>             <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_unf</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src'</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-972"></a>                             <span class='hs-comment'>-- INLINE functions have UnfWhen</span>
<a name="line-973"></a>             <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span><span class='hs-layout'>,</span> <span class='hs-varid'>ug_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>args</span> <span class='hs-layout'>}</span>
<a name="line-974"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>do_cunf</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>size</span> <span class='hs-varid'>args</span> <span class='hs-varid'>src'</span>
<a name="line-975"></a>        <span class='hs-keyword'>where</span>
<a name="line-976"></a>          <span class='hs-varid'>src'</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>src</span> <span class='hs-keyword'>of</span>
<a name="line-977"></a>                   <span class='hs-conid'>InlineRhs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>InlineStable</span>
<a name="line-978"></a>                   <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>src</span>  <span class='hs-comment'>-- Do not change InlineCompulsory!</span>
<a name="line-979"></a>
<a name="line-980"></a>      <span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>fn_unf</span>  <span class='hs-comment'>-- Don't w/w DFuns; it never makes sense</span>
<a name="line-981"></a>                                       <span class='hs-comment'>-- to do so, and even if it is currently a</span>
<a name="line-982"></a>                                       <span class='hs-comment'>-- loop breaker, it may not be later</span>
<a name="line-983"></a>
<a name="line-984"></a>      <span class='hs-sel'>_other_unf</span>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-985"></a>
<a name="line-986"></a>  <span class='hs-keyword'>where</span>
<a name="line-987"></a>    <span class='hs-varid'>loop_breaker</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStrongLoopBreaker</span> <span class='hs-layout'>(</span><span class='hs-varid'>occInfo</span> <span class='hs-varid'>fn_info</span><span class='hs-layout'>)</span>
<a name="line-988"></a>    <span class='hs-varid'>noinline</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inlinePragmaSpec</span> <span class='hs-layout'>(</span><span class='hs-varid'>inlinePragInfo</span> <span class='hs-varid'>fn_info</span><span class='hs-layout'>)</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NoInline</span>
<a name="line-989"></a>    <span class='hs-varid'>fn_unf</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingInfo</span> <span class='hs-varid'>fn_info</span>
<a name="line-990"></a>
<a name="line-991"></a>        <span class='hs-comment'>-- The UnfIfGoodArgs case seems important.  If we w/w small functions</span>
<a name="line-992"></a>        <span class='hs-comment'>-- binary sizes go up by 10%!  (This is with SplitObjs.)</span>
<a name="line-993"></a>        <span class='hs-comment'>-- I'm not totally sure why.</span>
<a name="line-994"></a>        <span class='hs-comment'>-- INLINABLE functions come via this path</span>
<a name="line-995"></a>        <span class='hs-comment'>--    See Note [certainlyWillInline: INLINABLE]</span>
<a name="line-996"></a>    <span class='hs-varid'>do_cunf</span> <span class='hs-varid'>expr</span> <span class='hs-varid'>size</span> <span class='hs-varid'>args</span> <span class='hs-varid'>src'</span>
<a name="line-997"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>arityInfo</span> <span class='hs-varid'>fn_info</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>  <span class='hs-comment'>-- See Note [certainlyWillInline: be careful of thunks]</span>
<a name="line-998"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDeadEndSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>strictnessInfo</span> <span class='hs-varid'>fn_info</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-999"></a>              <span class='hs-comment'>-- Do not unconditionally inline a bottoming functions even if</span>
<a name="line-1000"></a>              <span class='hs-comment'>-- it seems smallish. We've carefully lifted it out to top level,</span>
<a name="line-1001"></a>              <span class='hs-comment'>-- so we don't want to re-inline it.</span>
<a name="line-1002"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>unf_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>args</span>
<a name="line-1003"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>size</span> <span class='hs-comment'>-</span> <span class='hs-layout'>(</span><span class='hs-num'>10</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-varid'>unf_arity</span> <span class='hs-varop'>+</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>unfoldingUseThreshold</span> <span class='hs-varid'>opts</span>
<a name="line-1004"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>fn_unf</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_src</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>src'</span>
<a name="line-1005"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_arity</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unf_arity</span>
<a name="line-1006"></a>                                             <span class='hs-layout'>,</span> <span class='hs-varid'>ug_unsat_ok</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unSaturatedOk</span>
<a name="line-1007"></a>                                             <span class='hs-layout'>,</span> <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inlineBoringOk</span> <span class='hs-varid'>expr</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1008"></a>             <span class='hs-comment'>-- Note the "unsaturatedOk". A function like  f = \ab. a</span>
<a name="line-1009"></a>             <span class='hs-comment'>-- will certainly inline, even if partially applied (f e), so we'd</span>
<a name="line-1010"></a>             <span class='hs-comment'>-- better make sure that the transformed inlining has the same property</span>
<a name="line-1011"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1012"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-1013"></a>
<a name="line-1014"></a><span class='hs-comment'>{- Note [certainlyWillInline: be careful of thunks]
<a name="line-1015"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1016"></a>Don't claim that thunks will certainly inline, because that risks work
<a name="line-1017"></a>duplication.  Even if the work duplication is not great (eg is_cheap
<a name="line-1018"></a>holds), it can make a big difference in an inner loop In #5623 we
<a name="line-1019"></a>found that the WorkWrap phase thought that
<a name="line-1020"></a>       y = case x of F# v -&gt; F# (v +# v)
<a name="line-1021"></a>was certainlyWillInline, so the addition got duplicated.
<a name="line-1022"></a>
<a name="line-1023"></a>Note that we check arityInfo instead of the arity of the unfolding to detect
<a name="line-1024"></a>this case. This is so that we don't accidentally fail to inline small partial
<a name="line-1025"></a>applications, like `f = g 42` (where `g` recurses into `f`) where g has arity 2
<a name="line-1026"></a>(say). Here there is no risk of work duplication, and the RHS is tiny, so
<a name="line-1027"></a>certainlyWillInline should return True. But `unf_arity` is zero! However f's
<a name="line-1028"></a>arity, gotten from `arityInfo fn_info`, is 1.
<a name="line-1029"></a>
<a name="line-1030"></a>Failing to say that `f` will inline forces W/W to generate a potentially huge
<a name="line-1031"></a>worker for f that will immediately cancel with `g`'s wrapper anyway, causing
<a name="line-1032"></a>unnecessary churn in the Simplifier while arriving at the same result.
<a name="line-1033"></a>
<a name="line-1034"></a>Note [certainlyWillInline: INLINABLE]
<a name="line-1035"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1036"></a>certainlyWillInline /must/ return Nothing for a large INLINABLE thing,
<a name="line-1037"></a>even though we have a stable inlining, so that strictness w/w takes
<a name="line-1038"></a>place.  It makes a big difference to efficiency, and the w/w pass knows
<a name="line-1039"></a>how to transfer the INLINABLE info to the worker; see WorkWrap
<a name="line-1040"></a>Note [Worker-wrapper for INLINABLE functions]
<a name="line-1041"></a>
<a name="line-1042"></a>************************************************************************
<a name="line-1043"></a>*                                                                      *
<a name="line-1044"></a>\subsection{callSiteInline}
<a name="line-1045"></a>*                                                                      *
<a name="line-1046"></a>************************************************************************
<a name="line-1047"></a>
<a name="line-1048"></a>This is the key function.  It decides whether to inline a variable at a call site
<a name="line-1049"></a>
<a name="line-1050"></a>callSiteInline is used at call sites, so it is a bit more generous.
<a name="line-1051"></a>It's a very important function that embodies lots of heuristics.
<a name="line-1052"></a>A non-WHNF can be inlined if it doesn't occur inside a lambda,
<a name="line-1053"></a>and occurs exactly once or
<a name="line-1054"></a>    occurs once in each branch of a case and is small
<a name="line-1055"></a>
<a name="line-1056"></a>If the thing is in WHNF, there's no danger of duplicating work,
<a name="line-1057"></a>so we can inline if it occurs once, or is small
<a name="line-1058"></a>
<a name="line-1059"></a>NOTE: we don't want to inline top-level functions that always diverge.
<a name="line-1060"></a>It just makes the code bigger.  Tt turns out that the convenient way to prevent
<a name="line-1061"></a>them inlining is to give them a NOINLINE pragma, which we do in
<a name="line-1062"></a>StrictAnal.addStrictnessInfoToTopId
<a name="line-1063"></a>-}</span>
<a name="line-1064"></a>
<a name="line-1065"></a><a name="callSiteInline"></a><span class='hs-definition'>callSiteInline</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Logger</span>
<a name="line-1066"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span>
<a name="line-1067"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>                   <span class='hs-comment'>-- Case depth</span>
<a name="line-1068"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>                    <span class='hs-comment'>-- The Id</span>
<a name="line-1069"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>                  <span class='hs-comment'>-- True &lt;=&gt; unfolding is active</span>
<a name="line-1070"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>                  <span class='hs-comment'>-- True if there are no arguments at all (incl type args)</span>
<a name="line-1071"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSummary</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- One for each value arg; True if it is interesting</span>
<a name="line-1072"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>              <span class='hs-comment'>-- True &lt;=&gt; continuation is interesting</span>
<a name="line-1073"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>        <span class='hs-comment'>-- Unfolding, if any</span>
<a name="line-1074"></a>
<a name="line-1075"></a><a name="ArgSummary"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArgSummary</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TrivArg</span>       <span class='hs-comment'>-- Nothing interesting</span>
<a name="line-1076"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NonTrivArg</span>    <span class='hs-comment'>-- Arg has structure</span>
<a name="line-1077"></a>                <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ValueArg</span>      <span class='hs-comment'>-- Arg is a con-app or PAP</span>
<a name="line-1078"></a>                                <span class='hs-comment'>-- ..or con-like. Note [Conlike is interesting]</span>
<a name="line-1079"></a>
<a name="line-1080"></a><a name="instance%20Outputable%20ArgSummary"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>ArgSummary</span> <span class='hs-keyword'>where</span>
<a name="line-1081"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>TrivArg</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"TrivArg"</span>
<a name="line-1082"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>NonTrivArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"NonTrivArg"</span>
<a name="line-1083"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ValueArg"</span>
<a name="line-1084"></a>
<a name="line-1085"></a><a name="nonTriv"></a><span class='hs-definition'>nonTriv</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>ArgSummary</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1086"></a><span class='hs-definition'>nonTriv</span> <span class='hs-conid'>TrivArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1087"></a><span class='hs-definition'>nonTriv</span> <span class='hs-keyword'>_</span>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1088"></a>
<a name="line-1089"></a><a name="CallCtxt"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-1090"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>BoringCtxt</span>
<a name="line-1091"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RhsCtxt</span>             <span class='hs-comment'>-- Rhs of a let-binding; see Note [RHS of lets]</span>
<a name="line-1092"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DiscArgCtxt</span>         <span class='hs-comment'>-- Argument of a function with non-zero arg discount</span>
<a name="line-1093"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RuleArgCtxt</span>         <span class='hs-comment'>-- We are somewhere in the argument of a function with rules</span>
<a name="line-1094"></a>
<a name="line-1095"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ValAppCtxt</span>          <span class='hs-comment'>-- We're applied to at least one value arg</span>
<a name="line-1096"></a>                        <span class='hs-comment'>-- This arises when we have ((f x |&gt; co) y)</span>
<a name="line-1097"></a>                        <span class='hs-comment'>-- Then the (f x) has argument 'x' but in a ValAppCtxt</span>
<a name="line-1098"></a>
<a name="line-1099"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CaseCtxt</span>            <span class='hs-comment'>-- We're the scrutinee of a case</span>
<a name="line-1100"></a>                        <span class='hs-comment'>-- that decomposes its scrutinee</span>
<a name="line-1101"></a>
<a name="line-1102"></a><a name="instance%20Outputable%20CallCtxt"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>CallCtxt</span> <span class='hs-keyword'>where</span>
<a name="line-1103"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>CaseCtxt</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"CaseCtxt"</span>
<a name="line-1104"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>ValAppCtxt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ValAppCtxt"</span>
<a name="line-1105"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>BoringCtxt</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"BoringCtxt"</span>
<a name="line-1106"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>RhsCtxt</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"RhsCtxt"</span>
<a name="line-1107"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>DiscArgCtxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"DiscArgCtxt"</span>
<a name="line-1108"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>RuleArgCtxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"RuleArgCtxt"</span>
<a name="line-1109"></a>
<a name="line-1110"></a><span class='hs-definition'>callSiteInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>!</span><span class='hs-varid'>case_depth</span> <span class='hs-varid'>id</span> <span class='hs-varid'>active_unfolding</span> <span class='hs-varid'>lone_variable</span> <span class='hs-varid'>arg_infos</span> <span class='hs-varid'>cont_info</span>
<a name="line-1111"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>id</span> <span class='hs-keyword'>of</span>
<a name="line-1112"></a>      <span class='hs-comment'>-- idUnfolding checks for loop-breakers, returning NoUnfolding</span>
<a name="line-1113"></a>      <span class='hs-comment'>-- Things with an INLINE pragma may have an unfolding *and*</span>
<a name="line-1114"></a>      <span class='hs-comment'>-- be a loop breaker  (maybe the knot is not yet untied)</span>
<a name="line-1115"></a>        <span class='hs-conid'>CoreUnfolding</span> <span class='hs-layout'>{</span> <span class='hs-varid'>uf_tmpl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unf_template</span>
<a name="line-1116"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>uf_is_work_free</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_wf</span>
<a name="line-1117"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>uf_guidance</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>guidance</span><span class='hs-layout'>,</span> <span class='hs-varid'>uf_expandable</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_exp</span> <span class='hs-layout'>}</span>
<a name="line-1118"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>active_unfolding</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tryUnfolding</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>case_depth</span> <span class='hs-varid'>id</span> <span class='hs-varid'>lone_variable</span>
<a name="line-1119"></a>                                    <span class='hs-varid'>arg_infos</span> <span class='hs-varid'>cont_info</span> <span class='hs-varid'>unf_template</span>
<a name="line-1120"></a>                                    <span class='hs-varid'>is_wf</span> <span class='hs-varid'>is_exp</span> <span class='hs-varid'>guidance</span>
<a name="line-1121"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-str'>"Inactive unfolding:"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-1122"></a>        <span class='hs-conid'>NoUnfolding</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-1123"></a>        <span class='hs-conid'>BootUnfolding</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-1124"></a>        <span class='hs-conid'>OtherCon</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-1125"></a>        <span class='hs-conid'>DFunUnfolding</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>     <span class='hs-comment'>-- Never unfold a DFun</span>
<a name="line-1126"></a>
<a name="line-1127"></a><a name="traceInline"></a><span class='hs-comment'>-- | Report the inlining of an identifier's RHS to the user, if requested.</span>
<a name="line-1128"></a><span class='hs-definition'>traceInline</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Logger</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1129"></a><span class='hs-definition'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>inline_id</span> <span class='hs-varid'>str</span> <span class='hs-varid'>doc</span> <span class='hs-varid'>result</span>
<a name="line-1130"></a>  <span class='hs-comment'>-- We take care to ensure that doc is used in only one branch, ensuring that</span>
<a name="line-1131"></a>  <span class='hs-comment'>-- the simplifier can push its allocation into the branch. See Note [INLINE</span>
<a name="line-1132"></a>  <span class='hs-comment'>-- conditional tracing utilities].</span>
<a name="line-1133"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>enable</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>putTraceMsg</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>str</span> <span class='hs-varid'>doc</span> <span class='hs-varid'>result</span>
<a name="line-1134"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>result</span>
<a name="line-1135"></a>  <span class='hs-keyword'>where</span>
<a name="line-1136"></a>    <span class='hs-varid'>enable</span>
<a name="line-1137"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_dump_inlinings</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>dopt</span> <span class='hs-conid'>Opt_D_verbose_core2core</span> <span class='hs-varid'>dflags</span>
<a name="line-1138"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1139"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>prefix</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>inlineCheck</span> <span class='hs-varid'>dflags</span>
<a name="line-1140"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prefix</span> <span class='hs-varop'>`isPrefixOf`</span> <span class='hs-varid'>occNameString</span> <span class='hs-layout'>(</span><span class='hs-varid'>getOccName</span> <span class='hs-varid'>inline_id</span><span class='hs-layout'>)</span>
<a name="line-1141"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1142"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1143"></a><span class='hs-comment'>{-# INLINE traceInline #-}</span> <span class='hs-comment'>-- see Note [INLINE conditional tracing utilities]</span>
<a name="line-1144"></a>
<a name="line-1145"></a><span class='hs-comment'>{- Note [Avoid inlining into deeply nested cases]
<a name="line-1146"></a>   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1147"></a>
<a name="line-1148"></a>Consider a function f like this:
<a name="line-1149"></a>
<a name="line-1150"></a>  f arg1 arg2 =
<a name="line-1151"></a>    case ...
<a name="line-1152"></a>      ... -&gt; g arg1
<a name="line-1153"></a>      ... -&gt; g arg2
<a name="line-1154"></a>
<a name="line-1155"></a>This function is small. So should be safe to inline.
<a name="line-1156"></a>However sometimes this doesn't quite work out like that.
<a name="line-1157"></a>Consider this code:
<a name="line-1158"></a>
<a name="line-1159"></a>f1 arg1 arg2 ... = ...
<a name="line-1160"></a>    case _foo of
<a name="line-1161"></a>      alt1 -&gt; ... f2 arg1 ...
<a name="line-1162"></a>      alt2 -&gt; ... f2 arg2 ...
<a name="line-1163"></a>
<a name="line-1164"></a>f2 arg1 arg2 ... = ...
<a name="line-1165"></a>    case _foo of
<a name="line-1166"></a>      alt1 -&gt; ... f3 arg1 ...
<a name="line-1167"></a>      alt2 -&gt; ... f3 arg2 ...
<a name="line-1168"></a>
<a name="line-1169"></a>f3 arg1 arg2 ... = ...
<a name="line-1170"></a>
<a name="line-1171"></a>... repeats up to n times. And then f1 is
<a name="line-1172"></a>applied to some arguments:
<a name="line-1173"></a>
<a name="line-1174"></a>foo = ... f1 &lt;interestingArgs&gt; ...
<a name="line-1175"></a>
<a name="line-1176"></a>Initially f2..fn are not interesting to inline so we don't.
<a name="line-1177"></a>However we see that f1 is applied to interesting args.
<a name="line-1178"></a>So it's an obvious choice to inline those:
<a name="line-1179"></a>
<a name="line-1180"></a>foo =
<a name="line-1181"></a>    ...
<a name="line-1182"></a>      case _foo of
<a name="line-1183"></a>        alt1 -&gt; ... f2 &lt;interestingArg&gt; ...
<a name="line-1184"></a>        alt2 -&gt; ... f2 &lt;interestingArg&gt; ...
<a name="line-1185"></a>
<a name="line-1186"></a>As a result we go and inline f2 both mentions of f2 in turn are now applied to interesting
<a name="line-1187"></a>arguments and f2 is small:
<a name="line-1188"></a>
<a name="line-1189"></a>foo =
<a name="line-1190"></a>    ...
<a name="line-1191"></a>      case _foo of
<a name="line-1192"></a>        alt1 -&gt; ... case _foo of
<a name="line-1193"></a>            alt1 -&gt; ... f3 &lt;interestingArg&gt; ...
<a name="line-1194"></a>            alt2 -&gt; ... f3 &lt;interestingArg&gt; ...
<a name="line-1195"></a>
<a name="line-1196"></a>        alt2 -&gt; ... case _foo of
<a name="line-1197"></a>            alt1 -&gt; ... f3 &lt;interestingArg&gt; ...
<a name="line-1198"></a>            alt2 -&gt; ... f3 &lt;interestingArg&gt; ...
<a name="line-1199"></a>
<a name="line-1200"></a>The same thing happens for each binding up to f_n, duplicating the amount of inlining
<a name="line-1201"></a>done in each step. Until at some point we are either done or run out of simplifier
<a name="line-1202"></a>ticks/RAM. This pattern happened #18730.
<a name="line-1203"></a>
<a name="line-1204"></a>To combat this we introduce one more heuristic when weighing inlining decision.
<a name="line-1205"></a>We keep track of a "case-depth". Which increases each time we look inside a case
<a name="line-1206"></a>expression with more than one alternative.
<a name="line-1207"></a>
<a name="line-1208"></a>We then apply a penalty to inlinings based on the case-depth at which they would
<a name="line-1209"></a>be inlined. Bounding the number of inlinings in such a scenario.
<a name="line-1210"></a>
<a name="line-1211"></a>The heuristic can be tuned in two ways:
<a name="line-1212"></a>
<a name="line-1213"></a>* We can ignore the first n levels of case nestings for inlining decisions using
<a name="line-1214"></a>  -funfolding-case-threshold.
<a name="line-1215"></a>* The penalty grows linear with the depth. It's computed as size*(depth-threshold)/scaling.
<a name="line-1216"></a>  Scaling can be set with -funfolding-case-scaling.
<a name="line-1217"></a>
<a name="line-1218"></a>Some guidance on setting these defaults:
<a name="line-1219"></a>
<a name="line-1220"></a>* A low treshold (&lt;= 2) is needed to prevent exponential cases from spiraling out of
<a name="line-1221"></a>  control. We picked 2 for no particular reason.
<a name="line-1222"></a>* Scaling the penalty by any more than 30 means the reproducer from
<a name="line-1223"></a>  T18730 won't compile even with reasonably small values of n. Instead
<a name="line-1224"></a>  it will run out of runs/ticks. This means to positively affect the reproducer
<a name="line-1225"></a>  a scaling &lt;= 30 is required.
<a name="line-1226"></a>* A scaling of &gt;= 15 still causes a few very large regressions on some nofib benchmarks.
<a name="line-1227"></a>  (+80% for gc/fulsom, +90% for real/ben-raytrace, +20% for spectral/fibheaps)
<a name="line-1228"></a>* A scaling of &gt;= 25 showed no regressions on nofib. However it showed a number of
<a name="line-1229"></a>  (small) regression for compiler perf benchmarks.
<a name="line-1230"></a>
<a name="line-1231"></a>The end result is that we are settling for a scaling of 30, with a threshold of 2.
<a name="line-1232"></a>This gives us minimal compiler perf regressions. No nofib runtime regressions and
<a name="line-1233"></a>will still avoid this pattern sometimes. This is a "safe" default, where we err on
<a name="line-1234"></a>the side of compiler blowup instead of risking runtime regressions.
<a name="line-1235"></a>
<a name="line-1236"></a>For cases where the default falls short the flag can be changed to allow more/less inlining as
<a name="line-1237"></a>needed on a per-module basis.
<a name="line-1238"></a>
<a name="line-1239"></a>-}</span>
<a name="line-1240"></a>
<a name="line-1241"></a><a name="tryUnfolding"></a><span class='hs-definition'>tryUnfolding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Logger</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSummary</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-1242"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>UnfoldingGuidance</span>
<a name="line-1243"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-1244"></a><span class='hs-definition'>tryUnfolding</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varop'>!</span><span class='hs-varid'>case_depth</span> <span class='hs-varid'>id</span> <span class='hs-varid'>lone_variable</span>
<a name="line-1245"></a>             <span class='hs-varid'>arg_infos</span> <span class='hs-varid'>cont_info</span> <span class='hs-varid'>unf_template</span>
<a name="line-1246"></a>             <span class='hs-varid'>is_wf</span> <span class='hs-varid'>is_exp</span> <span class='hs-varid'>guidance</span>
<a name="line-1247"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>guidance</span> <span class='hs-keyword'>of</span>
<a name="line-1248"></a>     <span class='hs-conid'>UnfNever</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"UnfNever"</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-1249"></a>
<a name="line-1250"></a>     <span class='hs-conid'>UnfWhen</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_arity</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>uf_arity</span><span class='hs-layout'>,</span> <span class='hs-varid'>ug_unsat_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsat_ok</span><span class='hs-layout'>,</span> <span class='hs-varid'>ug_boring_ok</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>boring_ok</span> <span class='hs-layout'>}</span>
<a name="line-1251"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>enough_args</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>boring_ok</span> <span class='hs-varop'>||</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varop'>||</span> <span class='hs-varid'>unfoldingVeryAggressive</span> <span class='hs-varid'>uf_opts</span><span class='hs-layout'>)</span>
<a name="line-1252"></a>                <span class='hs-comment'>-- See Note [INLINE for small functions (3)]</span>
<a name="line-1253"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_doc</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varid'>empty</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>unf_template</span><span class='hs-layout'>)</span>
<a name="line-1254"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1255"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_doc</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varid'>empty</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-1256"></a>        <span class='hs-keyword'>where</span>
<a name="line-1257"></a>          <span class='hs-varid'>some_benefit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>calc_some_benefit</span> <span class='hs-varid'>uf_arity</span>
<a name="line-1258"></a>          <span class='hs-varid'>enough_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>uf_arity</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsat_ok</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span><span class='hs-layout'>)</span>
<a name="line-1259"></a>
<a name="line-1260"></a>     <span class='hs-conid'>UnfIfGoodArgs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ug_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg_discounts</span><span class='hs-layout'>,</span> <span class='hs-varid'>ug_res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res_discount</span><span class='hs-layout'>,</span> <span class='hs-varid'>ug_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span> <span class='hs-layout'>}</span>
<a name="line-1261"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>unfoldingVeryAggressive</span> <span class='hs-varid'>uf_opts</span>
<a name="line-1262"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_doc</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varid'>extra_doc</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>unf_template</span><span class='hs-layout'>)</span>
<a name="line-1263"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>is_wf</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>small_enough</span>
<a name="line-1264"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_doc</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varid'>extra_doc</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>unf_template</span><span class='hs-layout'>)</span>
<a name="line-1265"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1266"></a>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>traceInline</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>id</span> <span class='hs-varid'>str</span> <span class='hs-layout'>(</span><span class='hs-varid'>mk_doc</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varid'>extra_doc</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-conid'>Nothing</span>
<a name="line-1267"></a>        <span class='hs-keyword'>where</span>
<a name="line-1268"></a>          <span class='hs-varid'>some_benefit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>calc_some_benefit</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>arg_discounts</span><span class='hs-layout'>)</span>
<a name="line-1269"></a>          <span class='hs-varid'>extra_doc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"case depth ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>case_depth</span>
<a name="line-1270"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"depth based penalty ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>depth_penalty</span>
<a name="line-1271"></a>                           <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"discounted size ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>int</span> <span class='hs-varid'>adjusted_size</span> <span class='hs-keyglyph'>]</span>
<a name="line-1272"></a>          <span class='hs-comment'>-- See Note [Avoid inlining into deeply nested cases]</span>
<a name="line-1273"></a>          <span class='hs-varid'>depth_treshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingCaseThreshold</span> <span class='hs-varid'>uf_opts</span>
<a name="line-1274"></a>          <span class='hs-varid'>depth_scaling</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingCaseScaling</span> <span class='hs-varid'>uf_opts</span>
<a name="line-1275"></a>          <span class='hs-varid'>depth_penalty</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>case_depth</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>depth_treshold</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-1276"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>       <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>size</span> <span class='hs-varop'>*</span> <span class='hs-layout'>(</span><span class='hs-varid'>case_depth</span> <span class='hs-comment'>-</span> <span class='hs-varid'>depth_treshold</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>`div`</span> <span class='hs-varid'>depth_scaling</span>
<a name="line-1277"></a>          <span class='hs-varid'>adjusted_size</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>size</span> <span class='hs-varop'>+</span> <span class='hs-varid'>depth_penalty</span> <span class='hs-comment'>-</span> <span class='hs-varid'>discount</span>
<a name="line-1278"></a>          <span class='hs-varid'>small_enough</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>adjusted_size</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>unfoldingUseThreshold</span> <span class='hs-varid'>uf_opts</span>
<a name="line-1279"></a>          <span class='hs-varid'>discount</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>computeDiscount</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-varid'>res_discount</span> <span class='hs-varid'>arg_infos</span> <span class='hs-varid'>cont_info</span>
<a name="line-1280"></a>
<a name="line-1281"></a>  <span class='hs-keyword'>where</span>
<a name="line-1282"></a>    <span class='hs-varid'>uf_opts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unfoldingOpts</span> <span class='hs-varid'>dflags</span>
<a name="line-1283"></a>    <span class='hs-varid'>mk_doc</span> <span class='hs-varid'>some_benefit</span> <span class='hs-varid'>extra_doc</span> <span class='hs-varid'>yes_or_no</span>
<a name="line-1284"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"arg infos"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>arg_infos</span>
<a name="line-1285"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"interesting continuation"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cont_info</span>
<a name="line-1286"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"some_benefit"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>some_benefit</span>
<a name="line-1287"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"is exp:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>is_exp</span>
<a name="line-1288"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"is work-free:"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>is_wf</span>
<a name="line-1289"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"guidance"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>guidance</span>
<a name="line-1290"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>extra_doc</span>
<a name="line-1291"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ANSWER ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>yes_or_no</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>text</span> <span class='hs-str'>"YES"</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>text</span> <span class='hs-str'>"NO"</span><span class='hs-keyglyph'>]</span>
<a name="line-1292"></a>
<a name="line-1293"></a>    <span class='hs-varid'>ctx</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initSDocContext</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>defaultDumpStyle</span>
<a name="line-1294"></a>    <span class='hs-varid'>str</span> <span class='hs-keyglyph'>=</span> <span class='hs-str'>"Considering inlining: "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>showSDocDump</span> <span class='hs-varid'>ctx</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1295"></a>    <span class='hs-varid'>n_val_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>arg_infos</span>
<a name="line-1296"></a>
<a name="line-1297"></a>           <span class='hs-comment'>-- some_benefit is used when the RHS is small enough</span>
<a name="line-1298"></a>           <span class='hs-comment'>-- and the call has enough (or too many) value</span>
<a name="line-1299"></a>           <span class='hs-comment'>-- arguments (ie n_val_args &gt;= arity). But there must</span>
<a name="line-1300"></a>           <span class='hs-comment'>-- be *something* interesting about some argument, or the</span>
<a name="line-1301"></a>           <span class='hs-comment'>-- result context, to make it worth inlining</span>
<a name="line-1302"></a>    <span class='hs-varid'>calc_some_benefit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Arity</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- The Arity is the number of args</span>
<a name="line-1303"></a>                                         <span class='hs-comment'>-- expected by the unfolding</span>
<a name="line-1304"></a>    <span class='hs-varid'>calc_some_benefit</span> <span class='hs-varid'>uf_arity</span>
<a name="line-1305"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>saturated</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting_args</span>       <span class='hs-comment'>-- Under-saturated</span>
<a name="line-1306"></a>                                        <span class='hs-comment'>-- Note [Unsaturated applications]</span>
<a name="line-1307"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>interesting_args</span>   <span class='hs-comment'>-- Saturated or over-saturated</span>
<a name="line-1308"></a>                  <span class='hs-varop'>||</span> <span class='hs-varid'>interesting_call</span>
<a name="line-1309"></a>      <span class='hs-keyword'>where</span>
<a name="line-1310"></a>        <span class='hs-varid'>saturated</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&gt;=</span> <span class='hs-varid'>uf_arity</span>
<a name="line-1311"></a>        <span class='hs-varid'>over_saturated</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>n_val_args</span> <span class='hs-varop'>&gt;</span> <span class='hs-varid'>uf_arity</span>
<a name="line-1312"></a>        <span class='hs-varid'>interesting_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>nonTriv</span> <span class='hs-varid'>arg_infos</span>
<a name="line-1313"></a>                <span class='hs-comment'>-- NB: (any nonTriv arg_infos) looks at the</span>
<a name="line-1314"></a>                <span class='hs-comment'>-- over-saturated args too which is "wrong";</span>
<a name="line-1315"></a>                <span class='hs-comment'>-- but if over-saturated we inline anyway.</span>
<a name="line-1316"></a>
<a name="line-1317"></a>        <span class='hs-varid'>interesting_call</span>
<a name="line-1318"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>over_saturated</span>
<a name="line-1319"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1320"></a>          <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1321"></a>          <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cont_info</span> <span class='hs-keyword'>of</span>
<a name="line-1322"></a>              <span class='hs-conid'>CaseCtxt</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>lone_variable</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>is_exp</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Note [Lone variables]</span>
<a name="line-1323"></a>              <span class='hs-conid'>ValAppCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>                           <span class='hs-comment'>-- Note [Cast then apply]</span>
<a name="line-1324"></a>              <span class='hs-conid'>RuleArgCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>uf_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>  <span class='hs-comment'>-- See Note [Unfold info lazy contexts]</span>
<a name="line-1325"></a>              <span class='hs-conid'>DiscArgCtxt</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>uf_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>  <span class='hs-comment'>-- Note [Inlining in ArgCtxt]</span>
<a name="line-1326"></a>              <span class='hs-conid'>RhsCtxt</span>     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>uf_arity</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span>  <span class='hs-comment'>--</span>
<a name="line-1327"></a>              <span class='hs-sel'>_other</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>         <span class='hs-comment'>-- See Note [Nested functions]</span>
<a name="line-1328"></a>
<a name="line-1329"></a>
<a name="line-1330"></a><span class='hs-comment'>{-
<a name="line-1331"></a>Note [Unfold into lazy contexts], Note [RHS of lets]
<a name="line-1332"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1333"></a>When the call is the argument of a function with a RULE, or the RHS of a let,
<a name="line-1334"></a>we are a little bit keener to inline.  For example
<a name="line-1335"></a>     f y = (y,y,y)
<a name="line-1336"></a>     g y = let x = f y in ...(case x of (a,b,c) -&gt; ...) ...
<a name="line-1337"></a>We'd inline 'f' if the call was in a case context, and it kind-of-is,
<a name="line-1338"></a>only we can't see it.  Also
<a name="line-1339"></a>     x = f v
<a name="line-1340"></a>could be expensive whereas
<a name="line-1341"></a>     x = case v of (a,b) -&gt; a
<a name="line-1342"></a>is patently cheap and may allow more eta expansion.
<a name="line-1343"></a>So we treat the RHS of a let as not-totally-boring.
<a name="line-1344"></a>
<a name="line-1345"></a>Note [Unsaturated applications]
<a name="line-1346"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1347"></a>When a call is not saturated, we *still* inline if one of the
<a name="line-1348"></a>arguments has interesting structure.  That's sometimes very important.
<a name="line-1349"></a>A good example is the Ord instance for Bool in Base:
<a name="line-1350"></a>
<a name="line-1351"></a> Rec {
<a name="line-1352"></a>    $fOrdBool =GHC.Classes.D:Ord
<a name="line-1353"></a>                 @ Bool
<a name="line-1354"></a>                 ...
<a name="line-1355"></a>                 $cmin_ajX
<a name="line-1356"></a>
<a name="line-1357"></a>    $cmin_ajX [Occ=LoopBreaker] :: Bool -&gt; Bool -&gt; Bool
<a name="line-1358"></a>    $cmin_ajX = GHC.Classes.$dmmin @ Bool $fOrdBool
<a name="line-1359"></a>  }
<a name="line-1360"></a>
<a name="line-1361"></a>But the defn of GHC.Classes.$dmmin is:
<a name="line-1362"></a>
<a name="line-1363"></a>  $dmmin :: forall a. GHC.Classes.Ord a =&gt; a -&gt; a -&gt; a
<a name="line-1364"></a>    {- Arity: 3, HasNoCafRefs, Strictness: SLL,
<a name="line-1365"></a>       Unfolding: (\ @ a $dOrd :: GHC.Classes.Ord a x :: a y :: a -&gt;
<a name="line-1366"></a>                   case @ a GHC.Classes.&lt;= @ a $dOrd x y of wild {
<a name="line-1367"></a>                     GHC.Types.False -&gt; y GHC.Types.True -&gt; x }) -}
<a name="line-1368"></a>
<a name="line-1369"></a>We *really* want to inline $dmmin, even though it has arity 3, in
<a name="line-1370"></a>order to unravel the recursion.
<a name="line-1371"></a>
<a name="line-1372"></a>
<a name="line-1373"></a>Note [Things to watch]
<a name="line-1374"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1375"></a>*   { y = I# 3; x = y `cast` co; ...case (x `cast` co) of ... }
<a name="line-1376"></a>    Assume x is exported, so not inlined unconditionally.
<a name="line-1377"></a>    Then we want x to inline unconditionally; no reason for it
<a name="line-1378"></a>    not to, and doing so avoids an indirection.
<a name="line-1379"></a>
<a name="line-1380"></a>*   { x = I# 3; ....f x.... }
<a name="line-1381"></a>    Make sure that x does not inline unconditionally!
<a name="line-1382"></a>    Lest we get extra allocation.
<a name="line-1383"></a>
<a name="line-1384"></a>Note [Inlining an InlineRule]
<a name="line-1385"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1386"></a>An InlineRules is used for
<a name="line-1387"></a>  (a) programmer INLINE pragmas
<a name="line-1388"></a>  (b) inlinings from worker/wrapper
<a name="line-1389"></a>
<a name="line-1390"></a>For (a) the RHS may be large, and our contract is that we *only* inline
<a name="line-1391"></a>when the function is applied to all the arguments on the LHS of the
<a name="line-1392"></a>source-code defn.  (The uf_arity in the rule.)
<a name="line-1393"></a>
<a name="line-1394"></a>However for worker/wrapper it may be worth inlining even if the
<a name="line-1395"></a>arity is not satisfied (as we do in the CoreUnfolding case) so we don't
<a name="line-1396"></a>require saturation.
<a name="line-1397"></a>
<a name="line-1398"></a>Note [Nested functions]
<a name="line-1399"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1400"></a>At one time we treated a call of a non-top-level function as
<a name="line-1401"></a>"interesting" (regardless of how boring the context) in the hope
<a name="line-1402"></a>that inlining it would eliminate the binding, and its allocation.
<a name="line-1403"></a>Specifically, in the default case of interesting_call we had
<a name="line-1404"></a>   _other -&gt; not is_top &amp;&amp; uf_arity &gt; 0
<a name="line-1405"></a>
<a name="line-1406"></a>But actually postInlineUnconditionally does some of this and overall
<a name="line-1407"></a>it makes virtually no difference to nofib.  So I simplified away this
<a name="line-1408"></a>special case
<a name="line-1409"></a>
<a name="line-1410"></a>Note [Cast then apply]
<a name="line-1411"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1412"></a>Consider
<a name="line-1413"></a>   myIndex = __inline_me ( (/\a. &lt;blah&gt;) |&gt; co )
<a name="line-1414"></a>   co :: (forall a. a -&gt; a) ~ (forall a. T a)
<a name="line-1415"></a>     ... /\a.\x. case ((myIndex a) |&gt; sym co) x of { ... } ...
<a name="line-1416"></a>
<a name="line-1417"></a>We need to inline myIndex to unravel this; but the actual call (myIndex a) has
<a name="line-1418"></a>no value arguments.  The ValAppCtxt gives it enough incentive to inline.
<a name="line-1419"></a>
<a name="line-1420"></a>Note [Inlining in ArgCtxt]
<a name="line-1421"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1422"></a>The condition (arity &gt; 0) here is very important, because otherwise
<a name="line-1423"></a>we end up inlining top-level stuff into useless places; eg
<a name="line-1424"></a>   x = I# 3#
<a name="line-1425"></a>   f = \y.  g x
<a name="line-1426"></a>This can make a very big difference: it adds 16% to nofib 'integer' allocs,
<a name="line-1427"></a>and 20% to 'power'.
<a name="line-1428"></a>
<a name="line-1429"></a>At one stage I replaced this condition by 'True' (leading to the above
<a name="line-1430"></a>slow-down).  The motivation was test eyeball/inline1.hs; but that seems
<a name="line-1431"></a>to work ok now.
<a name="line-1432"></a>
<a name="line-1433"></a>NOTE: arguably, we should inline in ArgCtxt only if the result of the
<a name="line-1434"></a>call is at least CONLIKE.  At least for the cases where we use ArgCtxt
<a name="line-1435"></a>for the RHS of a 'let', we only profit from the inlining if we get a
<a name="line-1436"></a>CONLIKE thing (modulo lets).
<a name="line-1437"></a>
<a name="line-1438"></a>Note [Lone variables]   See also Note [Interaction of exprIsWorkFree and lone variables]
<a name="line-1439"></a>~~~~~~~~~~~~~~~~~~~~~   which appears below
<a name="line-1440"></a>The "lone-variable" case is important.  I spent ages messing about
<a name="line-1441"></a>with unsatisfactory variants, but this is nice.  The idea is that if a
<a name="line-1442"></a>variable appears all alone
<a name="line-1443"></a>
<a name="line-1444"></a>        as an arg of lazy fn, or rhs    BoringCtxt
<a name="line-1445"></a>        as scrutinee of a case          CaseCtxt
<a name="line-1446"></a>        as arg of a fn                  ArgCtxt
<a name="line-1447"></a>AND
<a name="line-1448"></a>        it is bound to a cheap expression
<a name="line-1449"></a>
<a name="line-1450"></a>then we should not inline it (unless there is some other reason,
<a name="line-1451"></a>e.g. it is the sole occurrence).  That is what is happening at
<a name="line-1452"></a>the use of 'lone_variable' in 'interesting_call'.
<a name="line-1453"></a>
<a name="line-1454"></a>Why?  At least in the case-scrutinee situation, turning
<a name="line-1455"></a>        let x = (a,b) in case x of y -&gt; ...
<a name="line-1456"></a>into
<a name="line-1457"></a>        let x = (a,b) in case (a,b) of y -&gt; ...
<a name="line-1458"></a>and thence to
<a name="line-1459"></a>        let x = (a,b) in let y = (a,b) in ...
<a name="line-1460"></a>is bad if the binding for x will remain.
<a name="line-1461"></a>
<a name="line-1462"></a>Another example: I discovered that strings
<a name="line-1463"></a>were getting inlined straight back into applications of 'error'
<a name="line-1464"></a>because the latter is strict.
<a name="line-1465"></a>        s = "foo"
<a name="line-1466"></a>        f = \x -&gt; ...(error s)...
<a name="line-1467"></a>
<a name="line-1468"></a>Fundamentally such contexts should not encourage inlining because, provided
<a name="line-1469"></a>the RHS is "expandable" (see Note [exprIsExpandable] in GHC.Core.Utils) the
<a name="line-1470"></a>context can ``see'' the unfolding of the variable (e.g. case or a
<a name="line-1471"></a>RULE) so there's no gain.
<a name="line-1472"></a>
<a name="line-1473"></a>However, watch out:
<a name="line-1474"></a>
<a name="line-1475"></a> * Consider this:
<a name="line-1476"></a>        foo = _inline_ (\n. [n])
<a name="line-1477"></a>        bar = _inline_ (foo 20)
<a name="line-1478"></a>        baz = \n. case bar of { (m:_) -&gt; m + n }
<a name="line-1479"></a>   Here we really want to inline 'bar' so that we can inline 'foo'
<a name="line-1480"></a>   and the whole thing unravels as it should obviously do.  This is
<a name="line-1481"></a>   important: in the NDP project, 'bar' generates a closure data
<a name="line-1482"></a>   structure rather than a list.
<a name="line-1483"></a>
<a name="line-1484"></a>   So the non-inlining of lone_variables should only apply if the
<a name="line-1485"></a>   unfolding is regarded as cheap; because that is when exprIsConApp_maybe
<a name="line-1486"></a>   looks through the unfolding.  Hence the "&amp;&amp; is_wf" in the
<a name="line-1487"></a>   InlineRule branch.
<a name="line-1488"></a>
<a name="line-1489"></a> * Even a type application or coercion isn't a lone variable.
<a name="line-1490"></a>   Consider
<a name="line-1491"></a>        case $fMonadST @ RealWorld of { :DMonad a b c -&gt; c }
<a name="line-1492"></a>   We had better inline that sucker!  The case won't see through it.
<a name="line-1493"></a>
<a name="line-1494"></a>   For now, I'm treating treating a variable applied to types
<a name="line-1495"></a>   in a *lazy* context "lone". The motivating example was
<a name="line-1496"></a>        f = /\a. \x. BIG
<a name="line-1497"></a>        g = /\a. \y.  h (f a)
<a name="line-1498"></a>   There's no advantage in inlining f here, and perhaps
<a name="line-1499"></a>   a significant disadvantage.  Hence some_val_args in the Stop case
<a name="line-1500"></a>
<a name="line-1501"></a>Note [Interaction of exprIsWorkFree and lone variables]
<a name="line-1502"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1503"></a>The lone-variable test says "don't inline if a case expression
<a name="line-1504"></a>scrutinises a lone variable whose unfolding is cheap".  It's very
<a name="line-1505"></a>important that, under these circumstances, exprIsConApp_maybe
<a name="line-1506"></a>can spot a constructor application. So, for example, we don't
<a name="line-1507"></a>consider
<a name="line-1508"></a>        let x = e in (x,x)
<a name="line-1509"></a>to be cheap, and that's good because exprIsConApp_maybe doesn't
<a name="line-1510"></a>think that expression is a constructor application.
<a name="line-1511"></a>
<a name="line-1512"></a>In the 'not (lone_variable &amp;&amp; is_wf)' test, I used to test is_value
<a name="line-1513"></a>rather than is_wf, which was utterly wrong, because the above
<a name="line-1514"></a>expression responds True to exprIsHNF, which is what sets is_value.
<a name="line-1515"></a>
<a name="line-1516"></a>This kind of thing can occur if you have
<a name="line-1517"></a>
<a name="line-1518"></a>        {-# INLINE foo #-}
<a name="line-1519"></a>        foo = let x = e in (x,x)
<a name="line-1520"></a>
<a name="line-1521"></a>which Roman did.
<a name="line-1522"></a>
<a name="line-1523"></a>
<a name="line-1524"></a>-}</span>
<a name="line-1525"></a>
<a name="line-1526"></a><a name="computeDiscount"></a><span class='hs-definition'>computeDiscount</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Int</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ArgSummary</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CallCtxt</span>
<a name="line-1527"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1528"></a><span class='hs-definition'>computeDiscount</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-varid'>res_discount</span> <span class='hs-varid'>arg_infos</span> <span class='hs-varid'>cont_info</span>
<a name="line-1529"></a>
<a name="line-1530"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>10</span>          <span class='hs-comment'>-- Discount of 10 because the result replaces the call</span>
<a name="line-1531"></a>                <span class='hs-comment'>-- so we count 10 for the function itself</span>
<a name="line-1532"></a>
<a name="line-1533"></a>    <span class='hs-varop'>+</span> <span class='hs-num'>10</span> <span class='hs-varop'>*</span> <span class='hs-varid'>length</span> <span class='hs-varid'>actual_arg_discounts</span>
<a name="line-1534"></a>               <span class='hs-comment'>-- Discount of 10 for each arg supplied,</span>
<a name="line-1535"></a>               <span class='hs-comment'>-- because the result replaces the call</span>
<a name="line-1536"></a>
<a name="line-1537"></a>    <span class='hs-varop'>+</span> <span class='hs-varid'>total_arg_discount</span> <span class='hs-varop'>+</span> <span class='hs-varid'>res_discount'</span>
<a name="line-1538"></a>  <span class='hs-keyword'>where</span>
<a name="line-1539"></a>    <span class='hs-varid'>actual_arg_discounts</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-varid'>mk_arg_discount</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-varid'>arg_infos</span>
<a name="line-1540"></a>    <span class='hs-varid'>total_arg_discount</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sum</span> <span class='hs-varid'>actual_arg_discounts</span>
<a name="line-1541"></a>
<a name="line-1542"></a>    <span class='hs-varid'>mk_arg_discount</span> <span class='hs-keyword'>_</span>        <span class='hs-conid'>TrivArg</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-1543"></a>    <span class='hs-varid'>mk_arg_discount</span> <span class='hs-keyword'>_</span>        <span class='hs-conid'>NonTrivArg</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>10</span>
<a name="line-1544"></a>    <span class='hs-varid'>mk_arg_discount</span> <span class='hs-varid'>discount</span> <span class='hs-conid'>ValueArg</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>discount</span>
<a name="line-1545"></a>
<a name="line-1546"></a>    <span class='hs-varid'>res_discount'</span>
<a name="line-1547"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LT</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>arg_discounts</span> <span class='hs-varop'>`compareLength`</span> <span class='hs-varid'>arg_infos</span>
<a name="line-1548"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res_discount</span>   <span class='hs-comment'>-- Over-saturated</span>
<a name="line-1549"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1550"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>cont_info</span> <span class='hs-keyword'>of</span>
<a name="line-1551"></a>           <span class='hs-conid'>BoringCtxt</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-num'>0</span>
<a name="line-1552"></a>           <span class='hs-conid'>CaseCtxt</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>res_discount</span>  <span class='hs-comment'>-- Presumably a constructor</span>
<a name="line-1553"></a>           <span class='hs-conid'>ValAppCtxt</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>res_discount</span>  <span class='hs-comment'>-- Presumably a function</span>
<a name="line-1554"></a>           <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-num'>40</span> <span class='hs-varop'>`min`</span> <span class='hs-varid'>res_discount</span>
<a name="line-1555"></a>                <span class='hs-comment'>-- ToDo: this 40 `min` res_discount doesn't seem right</span>
<a name="line-1556"></a>                <span class='hs-comment'>--   for DiscArgCtxt it shouldn't matter because the function will</span>
<a name="line-1557"></a>                <span class='hs-comment'>--       get the arg discount for any non-triv arg</span>
<a name="line-1558"></a>                <span class='hs-comment'>--   for RuleArgCtxt we do want to be keener to inline; but not only</span>
<a name="line-1559"></a>                <span class='hs-comment'>--       constructor results</span>
<a name="line-1560"></a>                <span class='hs-comment'>--   for RhsCtxt I suppose that exposing a data con is good in general</span>
<a name="line-1561"></a>                <span class='hs-comment'>--   And 40 seems very arbitrary</span>
<a name="line-1562"></a>                <span class='hs-comment'>--</span>
<a name="line-1563"></a>                <span class='hs-comment'>-- res_discount can be very large when a function returns</span>
<a name="line-1564"></a>                <span class='hs-comment'>-- constructors; but we only want to invoke that large discount</span>
<a name="line-1565"></a>                <span class='hs-comment'>-- when there's a case continuation.</span>
<a name="line-1566"></a>                <span class='hs-comment'>-- Otherwise we, rather arbitrarily, threshold it.  Yuk.</span>
<a name="line-1567"></a>                <span class='hs-comment'>-- But we want to avoid inlining large functions that return</span>
<a name="line-1568"></a>                <span class='hs-comment'>-- constructors into contexts that are simply "interesting"</span>
</pre></body>
</html>
