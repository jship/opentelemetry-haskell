<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="local-6989586621681077665"><span id="local-6989586621681077666"><span id="local-6989586621681077667"><span id="local-6989586621681077668"><span id="local-6989586621681077669"></span></span></span></span></span><span class="hs-pragma">{-# LANGUAGE ConstraintKinds #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-3"></span><span class="hs-pragma">{-# LANGUAGE FlexibleContexts #-}</span><span>
</span><span id="line-4"></span><span class="hs-pragma">{-# LANGUAGE FlexibleInstances #-}</span><span>
</span><span id="line-5"></span><span class="hs-pragma">{-# LANGUAGE ScopedTypeVariables #-}</span><span>
</span><span id="line-6"></span><span class="hs-pragma">{-# LANGUAGE TypeApplications #-}</span><span>
</span><span id="line-7"></span><span class="hs-pragma">{-# LANGUAGE TypeFamilies #-}</span><span>
</span><span id="line-8"></span><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span> </span><span class="hs-comment">-- Wrinkle in Note [Trees That Grow]</span><span>
</span><span id="line-9"></span><span>                                      </span><span class="hs-comment">-- in module Language.Haskell.Syntax.Extension</span><span>
</span><span id="line-10"></span><span class="hs-pragma">{-# LANGUAGE ViewPatterns #-}</span><span>
</span><span id="line-11"></span><span>
</span><span id="line-12"></span><span>
</span><span id="line-13"></span><span class="hs-comment">{-
(c) The University of Glasgow 2006
(c) The GRASP/AQUA Project, Glasgow University, 1992-1998

\section[HsBinds]{Abstract syntax: top-level bindings and signatures}

Datatype for: @BindGroup@, @Bind@, @Sig@, @Bind@.
-}</span><span>
</span><span id="line-21"></span><span>
</span><span id="line-22"></span><span class="hs-comment">-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span><span>
</span><span id="line-23"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Syntax.Binds</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-24"></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Prelude.html"><span class="hs-identifier">GHC.Prelude</span></a></span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html"><span class="hs-identifier">Language.Haskell.Syntax.Expr</span></a></span><span>
</span><span id="line-28"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier">LHsExpr</span></a></span><span>
</span><span id="line-29"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier">MatchGroup</span></a></span><span>
</span><span id="line-30"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier">GRHSs</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-31"></span><span class="hs-keyword">import</span><span> </span><span class="hs-pragma">{-# SOURCE</span><span> </span><span class="hs-pragma">#-}</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html"><span class="hs-identifier">Language.Haskell.Syntax.Pat</span></a></span><span>
</span><span id="line-32"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier">LPat</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html"><span class="hs-identifier">Language.Haskell.Syntax.Extension</span></a></span><span>
</span><span id="line-35"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html"><span class="hs-identifier">Language.Haskell.Syntax.Type</span></a></span><span>
</span><span id="line-36"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html"><span class="hs-identifier">GHC.Tc.Types.Evidence</span></a></span><span>
</span><span id="line-37"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Core.Type.html"><span class="hs-identifier">GHC.Core.Type</span></a></span><span>
</span><span id="line-38"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Basic.html"><span class="hs-identifier">GHC.Types.Basic</span></a></span><span>
</span><span id="line-39"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html"><span class="hs-identifier">GHC.Types.SourceText</span></a></span><span>
</span><span id="line-40"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html"><span class="hs-identifier">GHC.Types.SrcLoc</span></a></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">SrcLoc</span></span><span>
</span><span id="line-41"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Tickish.html"><span class="hs-identifier">GHC.Types.Tickish</span></a></span><span>
</span><span id="line-42"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Var.html"><span class="hs-identifier">GHC.Types.Var</span></a></span><span>
</span><span id="line-43"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html"><span class="hs-identifier">GHC.Types.Fixity</span></a></span><span>
</span><span id="line-44"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html"><span class="hs-identifier">GHC.Data.Bag</span></a></span><span>
</span><span id="line-45"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Data.BooleanFormula.html"><span class="hs-identifier">GHC.Data.BooleanFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.BooleanFormula.html#LBooleanFormula"><span class="hs-identifier">LBooleanFormula</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-46"></span><span>
</span><span id="line-47"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html"><span class="hs-identifier">GHC.Utils.Outputable</span></a></span><span>
</span><span id="line-48"></span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#"><span class="hs-identifier">Data.Data</span></a></span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Data.html#Fixity"><span class="hs-identifier">Fixity</span></a></span><span> </span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Void.html#"><span class="hs-identifier">Data.Void</span></a></span><span>
</span><span id="line-51"></span><span>
</span><span id="line-52"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{Bindings: @BindGroup@}
*                                                                      *
************************************************************************

Global bindings (where clauses)
-}</span><span>
</span><span id="line-61"></span><span>
</span><span id="line-62"></span><span class="hs-comment">-- During renaming, we need bindings where the left-hand sides</span><span>
</span><span id="line-63"></span><span class="hs-comment">-- have been renamed but the right-hand sides have not.</span><span>
</span><span id="line-64"></span><span class="hs-comment">-- Other than during renaming, these will be the same.</span><span>
</span><span id="line-65"></span><span>
</span><span id="line-66"></span><span class="hs-comment">-- | Haskell Local Bindings</span><span>
</span><span id="line-67"></span><span class="hs-keyword">type</span><span> </span><span id="HsLocalBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-var">HsLocalBinds</span></a></span></span><span> </span><span id="local-6989586621681077659"><span class="annot"><a href="#local-6989586621681077659"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-type">HsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077659"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077659"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span class="hs-comment">-- | Located Haskell local bindings</span><span>
</span><span id="line-70"></span><span class="hs-keyword">type</span><span> </span><span id="LHsLocalBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsLocalBinds"><span class="hs-identifier hs-var">LHsLocalBinds</span></a></span></span><span> </span><span id="local-6989586621681077656"><span class="annot"><a href="#local-6989586621681077656"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077656"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBinds"><span class="hs-identifier hs-type">HsLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077656"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-71"></span><span>
</span><span id="line-72"></span><span class="hs-comment">-- | Haskell Local Bindings with separate Left and Right identifier types</span><span>
</span><span id="line-73"></span><span class="hs-comment">--</span><span>
</span><span id="line-74"></span><span class="hs-comment">-- Bindings in a 'let' expression</span><span>
</span><span id="line-75"></span><span class="hs-comment">-- or a 'where' clause</span><span>
</span><span id="line-76"></span><span class="hs-keyword">data</span><span> </span><span id="HsLocalBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-var">HsLocalBindsLR</span></a></span></span><span> </span><span id="local-6989586621681077655"><span class="annot"><a href="#local-6989586621681077655"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077654"><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-77"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="HsValBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBinds"><span class="hs-identifier hs-var">HsValBinds</span></a></span></span><span>
</span><span id="line-78"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsValBinds"><span class="hs-identifier hs-type">XHsValBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077655"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-79"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBindsLR"><span class="hs-identifier hs-type">HsValBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077655"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-80"></span><span>      </span><span class="hs-comment">-- ^ Haskell Value Bindings</span><span>
</span><span id="line-81"></span><span>
</span><span id="line-82"></span><span>         </span><span class="hs-comment">-- There should be no pattern synonyms in the HsValBindsLR</span><span>
</span><span id="line-83"></span><span>         </span><span class="hs-comment">-- These are *local* (not top level) bindings</span><span>
</span><span id="line-84"></span><span>         </span><span class="hs-comment">-- The parser accepts them, however, leaving the</span><span>
</span><span id="line-85"></span><span>         </span><span class="hs-comment">-- renamer to report them</span><span>
</span><span id="line-86"></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HsIPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsIPBinds"><span class="hs-identifier hs-var">HsIPBinds</span></a></span></span><span>
</span><span id="line-88"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XHsIPBinds"><span class="hs-identifier hs-type">XHsIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077655"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-89"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsIPBinds"><span class="hs-identifier hs-type">HsIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-90"></span><span>      </span><span class="hs-comment">-- ^ Haskell Implicit Parameter Bindings</span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="EmptyLocalBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#EmptyLocalBinds"><span class="hs-identifier hs-var">EmptyLocalBinds</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XEmptyLocalBinds"><span class="hs-identifier hs-type">XEmptyLocalBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077655"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-93"></span><span>      </span><span class="hs-comment">-- ^ Empty Local Bindings</span><span>
</span><span id="line-94"></span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsLocalBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsLocalBindsLR"><span class="hs-identifier hs-var">XHsLocalBindsLR</span></a></span></span><span>
</span><span id="line-96"></span><span>        </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsLocalBindsLR"><span class="hs-identifier hs-type">XXHsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077655"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077654"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span class="hs-keyword">type</span><span> </span><span id="LHsLocalBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsLocalBindsLR"><span class="hs-identifier hs-var">LHsLocalBindsLR</span></a></span></span><span> </span><span id="local-6989586621681077642"><span class="annot"><a href="#local-6989586621681077642"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077641"><span class="annot"><a href="#local-6989586621681077641"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077642"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsLocalBindsLR"><span class="hs-identifier hs-type">HsLocalBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077642"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077641"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span class="hs-comment">-- | Haskell Value Bindings</span><span>
</span><span id="line-102"></span><span class="hs-keyword">type</span><span> </span><span id="HsValBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBinds"><span class="hs-identifier hs-var">HsValBinds</span></a></span></span><span> </span><span id="local-6989586621681077639"><span class="annot"><a href="#local-6989586621681077639"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBindsLR"><span class="hs-identifier hs-type">HsValBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077639"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077639"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-103"></span><span>
</span><span id="line-104"></span><span class="hs-comment">-- | Haskell Value bindings with separate Left and Right identifier types</span><span>
</span><span id="line-105"></span><span class="hs-comment">-- (not implicit parameters)</span><span>
</span><span id="line-106"></span><span class="hs-comment">-- Used for both top level and nested bindings</span><span>
</span><span id="line-107"></span><span class="hs-comment">-- May contain pattern synonym bindings</span><span>
</span><span id="line-108"></span><span class="hs-keyword">data</span><span> </span><span id="HsValBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsValBindsLR"><span class="hs-identifier hs-var">HsValBindsLR</span></a></span></span><span> </span><span id="local-6989586621681077638"><span class="annot"><a href="#local-6989586621681077638"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077637"><span class="annot"><a href="#local-6989586621681077637"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-109"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Value Bindings In</span><span>
</span><span id="line-110"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-111"></span><span>    </span><span class="hs-comment">-- Before renaming RHS; idR is always RdrName</span><span>
</span><span id="line-112"></span><span>    </span><span class="hs-comment">-- Not dependency analysed</span><span>
</span><span id="line-113"></span><span>    </span><span class="hs-comment">-- Recursive by default</span><span>
</span><span id="line-114"></span><span>    </span><span id="ValBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ValBinds"><span class="hs-identifier hs-var">ValBinds</span></a></span></span><span>
</span><span id="line-115"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XValBinds"><span class="hs-identifier hs-type">XValBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077638"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077637"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-116"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindsLR"><span class="hs-identifier hs-type">LHsBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077638"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077637"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077637"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span>    </span><span class="hs-comment">-- | Value Bindings Out</span><span>
</span><span id="line-119"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-120"></span><span>    </span><span class="hs-comment">-- After renaming RHS; idR can be Name or Id Dependency analysed,</span><span>
</span><span id="line-121"></span><span>    </span><span class="hs-comment">-- later bindings in the list may depend on earlier ones.</span><span>
</span><span id="line-122"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XValBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XValBindsLR"><span class="hs-identifier hs-var">XValBindsLR</span></a></span></span><span>
</span><span id="line-123"></span><span>      </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXValBindsLR"><span class="hs-identifier hs-type">XXValBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077638"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077637"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span>
</span><span id="line-125"></span><span class="hs-comment">-- ---------------------------------------------------------------------</span><span>
</span><span id="line-126"></span><span>
</span><span id="line-127"></span><span class="hs-comment">-- | Located Haskell Binding</span><span>
</span><span id="line-128"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBind"><span class="hs-identifier hs-var">LHsBind</span></a></span></span><span>  </span><span id="local-6989586621681077630"><span class="annot"><a href="#local-6989586621681077630"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindLR"><span class="hs-identifier hs-type">LHsBindLR</span></a></span><span>  </span><span class="annot"><a href="#local-6989586621681077630"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077630"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span class="hs-comment">-- | Located Haskell Bindings</span><span>
</span><span id="line-131"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-var">LHsBinds</span></a></span></span><span> </span><span id="local-6989586621681077628"><span class="annot"><a href="#local-6989586621681077628"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindsLR"><span class="hs-identifier hs-type">LHsBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077628"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077628"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="hs-comment">-- | Haskell Binding</span><span>
</span><span id="line-134"></span><span class="hs-keyword">type</span><span> </span><span id="HsBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBind"><span class="hs-identifier hs-var">HsBind</span></a></span></span><span>   </span><span id="local-6989586621681077626"><span class="annot"><a href="#local-6989586621681077626"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBindLR"><span class="hs-identifier hs-type">HsBindLR</span></a></span><span>   </span><span class="annot"><a href="#local-6989586621681077626"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077626"><span class="hs-identifier hs-type">id</span></a></span><span>
</span><span id="line-135"></span><span>
</span><span id="line-136"></span><span class="hs-comment">-- | Located Haskell Bindings with separate Left and Right identifier types</span><span>
</span><span id="line-137"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindsLR"><span class="hs-identifier hs-var">LHsBindsLR</span></a></span></span><span> </span><span id="local-6989586621681077625"><span class="annot"><a href="#local-6989586621681077625"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077624"><span class="annot"><a href="#local-6989586621681077624"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Data.Bag.html#Bag"><span class="hs-identifier hs-type">Bag</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindLR"><span class="hs-identifier hs-type">LHsBindLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077625"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077624"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-138"></span><span>
</span><span id="line-139"></span><span class="hs-comment">-- | Located Haskell Binding with separate Left and Right identifier types</span><span>
</span><span id="line-140"></span><span class="hs-keyword">type</span><span> </span><span id="LHsBindLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBindLR"><span class="hs-identifier hs-var">LHsBindLR</span></a></span></span><span>  </span><span id="local-6989586621681077622"><span class="annot"><a href="#local-6989586621681077622"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077621"><span class="annot"><a href="#local-6989586621681077621"><span class="hs-identifier hs-type">idR</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077622"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBindLR"><span class="hs-identifier hs-type">HsBindLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077622"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077621"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-141"></span><span>
</span><span id="line-142"></span><span class="hs-comment">{- Note [FunBind vs PatBind]
   ~~~~~~~~~~~~~~~~~~~~~~~~~
The distinction between FunBind and PatBind is a bit subtle. FunBind covers
patterns which resemble function bindings and simple variable bindings.

    f x = e
    f !x = e
    f = e
    !x = e          -- FunRhs has SrcStrict
    x `f` y = e     -- FunRhs has Infix

The actual patterns and RHSs of a FunBind are encoding in fun_matches.
The m_ctxt field of each Match in fun_matches will be FunRhs and carries
two bits of information about the match,

  * The mc_fixity field on each Match describes the fixity of the
    function binder in that match.  E.g. this is legal:
         f True False  = e1
         True `f` True = e2

  * The mc_strictness field is used /only/ for nullary FunBinds: ones
    with one Match, which has no pats. For these, it describes whether
    the match is decorated with a bang (e.g. `!x = e`).

By contrast, PatBind represents data constructor patterns, as well as a few
other interesting cases. Namely,

    Just x = e
    (x) = e
    x :: Ty = e
-}</span><span>
</span><span id="line-173"></span><span>
</span><span id="line-174"></span><span class="hs-comment">-- | Haskell Binding with separate Left and Right id's</span><span>
</span><span id="line-175"></span><span class="hs-keyword">data</span><span> </span><span id="HsBindLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsBindLR"><span class="hs-identifier hs-var">HsBindLR</span></a></span></span><span> </span><span id="local-6989586621681077913"><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077912"><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-comment">-- | Function-like Binding</span><span>
</span><span id="line-177"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-178"></span><span>    </span><span class="hs-comment">-- FunBind is used for both functions     @f x = e@</span><span>
</span><span id="line-179"></span><span>    </span><span class="hs-comment">-- and variables                          @f = \x -&gt; e@</span><span>
</span><span id="line-180"></span><span>    </span><span class="hs-comment">-- and strict variables                   @!x = x + 1@</span><span>
</span><span id="line-181"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-182"></span><span>    </span><span class="hs-comment">-- Reason 1: Special case for type inference: see 'GHC.Tc.Gen.Bind.tcMonoBinds'.</span><span>
</span><span id="line-183"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-184"></span><span>    </span><span class="hs-comment">-- Reason 2: Instance decls can only have FunBinds, which is convenient.</span><span>
</span><span id="line-185"></span><span>    </span><span class="hs-comment">--           If you change this, you'll need to change e.g. rnMethodBinds</span><span>
</span><span id="line-186"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-187"></span><span>    </span><span class="hs-comment">-- But note that the form                 @f :: a-&gt;a = ...@</span><span>
</span><span id="line-188"></span><span>    </span><span class="hs-comment">-- parses as a pattern binding, just like</span><span>
</span><span id="line-189"></span><span>    </span><span class="hs-comment">--                                        @(f :: a -&gt; a) = ... @</span><span>
</span><span id="line-190"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-191"></span><span>    </span><span class="hs-comment">-- Strict bindings have their strictness recorded in the 'SrcStrictness' of their</span><span>
</span><span id="line-192"></span><span>    </span><span class="hs-comment">-- 'MatchContext'. See Note [FunBind vs PatBind] for</span><span>
</span><span id="line-193"></span><span>    </span><span class="hs-comment">-- details about the relationship between FunBind and PatBind.</span><span>
</span><span id="line-194"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-195"></span><span>    </span><span class="hs-comment">--  'GHC.Parser.Annotation.AnnKeywordId's</span><span>
</span><span id="line-196"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-197"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnFunId', attached to each element of fun_matches</span><span>
</span><span id="line-198"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-199"></span><span>    </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-200"></span><span>    </span><span class="hs-comment">--    'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-201"></span><span>
</span><span id="line-202"></span><span>    </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-203"></span><span>    </span><span id="FunBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FunBind"><span class="hs-identifier hs-var">FunBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-204"></span><span>
</span><span id="line-205"></span><span>        </span><span id="fun_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XFunBind idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#fun_ext"><span class="hs-identifier hs-var hs-var">fun_ext</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFunBind"><span class="hs-identifier hs-type">XFunBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span>          </span><span class="hs-comment">-- ^ After the renamer (but before the type-checker), this contains the</span><span>
</span><span id="line-208"></span><span>          </span><span class="hs-comment">-- locally-bound free variables of this defn. See Note [Bind free vars]</span><span>
</span><span id="line-209"></span><span>          </span><span class="hs-comment">--</span><span>
</span><span id="line-210"></span><span>          </span><span class="hs-comment">-- After the type-checker, this contains a coercion from the type of</span><span>
</span><span id="line-211"></span><span>          </span><span class="hs-comment">-- the MatchGroup to the type of the Id. Example:</span><span>
</span><span id="line-212"></span><span>          </span><span class="hs-comment">--</span><span>
</span><span id="line-213"></span><span>          </span><span class="hs-comment">-- @</span><span>
</span><span id="line-214"></span><span>          </span><span class="hs-comment">--      f :: Int -&gt; forall a. a -&gt; a</span><span>
</span><span id="line-215"></span><span>          </span><span class="hs-comment">--      f x y = y</span><span>
</span><span id="line-216"></span><span>          </span><span class="hs-comment">-- @</span><span>
</span><span id="line-217"></span><span>          </span><span class="hs-comment">--</span><span>
</span><span id="line-218"></span><span>          </span><span class="hs-comment">-- Then the MatchGroup will have type (Int -&gt; a' -&gt; a')</span><span>
</span><span id="line-219"></span><span>          </span><span class="hs-comment">-- (with a free type variable a').  The coercion will take</span><span>
</span><span id="line-220"></span><span>          </span><span class="hs-comment">-- a CoreExpr of this type and convert it to a CoreExpr of</span><span>
</span><span id="line-221"></span><span>          </span><span class="hs-comment">-- type         Int -&gt; forall a'. a' -&gt; a'</span><span>
</span><span id="line-222"></span><span>          </span><span class="hs-comment">-- Notice that the coercion captures the free a'.</span><span>
</span><span id="line-223"></span><span>
</span><span id="line-224"></span><span>        </span><span id="fun_id"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LIdP idL
</span><a href="Language.Haskell.Syntax.Binds.html#fun_id"><span class="hs-identifier hs-var hs-var">fun_id</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- Note [fun_id in Match] in GHC.Hs.Expr</span><span>
</span><span id="line-225"></span><span>
</span><span id="line-226"></span><span>        </span><span id="fun_matches"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; MatchGroup idR (LHsExpr idR)
</span><a href="Language.Haskell.Syntax.Binds.html#fun_matches"><span class="hs-identifier hs-var hs-var">fun_matches</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>  </span><span class="hs-comment">-- ^ The payload</span><span>
</span><span id="line-227"></span><span>
</span><span id="line-228"></span><span>        </span><span id="fun_tick"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; [CoreTickish]
</span><a href="Language.Haskell.Syntax.Binds.html#fun_tick"><span class="hs-identifier hs-var hs-var">fun_tick</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Tickish.html#CoreTickish"><span class="hs-identifier hs-type">CoreTickish</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ Ticks to put on the rhs, if any</span><span>
</span><span id="line-229"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span>  </span><span class="hs-comment">-- | Pattern Binding</span><span>
</span><span id="line-232"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-233"></span><span>  </span><span class="hs-comment">-- The pattern is never a simple variable;</span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-comment">-- That case is done by FunBind.</span><span>
</span><span id="line-235"></span><span>  </span><span class="hs-comment">-- See Note [FunBind vs PatBind] for details about the</span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-comment">-- relationship between FunBind and PatBind.</span><span>
</span><span id="line-237"></span><span>
</span><span id="line-238"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnBang',</span><span>
</span><span id="line-240"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span><span>
</span><span id="line-241"></span><span>  </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span>  </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-244"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatBind"><span class="hs-identifier hs-var">PatBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-245"></span><span>        </span><span id="pat_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XPatBind idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#pat_ext"><span class="hs-identifier hs-var hs-var">pat_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatBind"><span class="hs-identifier hs-type">XPatBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-comment">-- ^ See Note [Bind free vars]</span><span>
</span><span id="line-246"></span><span>        </span><span id="pat_lhs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LPat idL
</span><a href="Language.Haskell.Syntax.Binds.html#pat_lhs"><span class="hs-identifier hs-var hs-var">pat_lhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-247"></span><span>        </span><span id="pat_rhs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; GRHSs idR (LHsExpr idR)
</span><a href="Language.Haskell.Syntax.Binds.html#pat_rhs"><span class="hs-identifier hs-var hs-var">pat_rhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#GRHSs"><span class="hs-identifier hs-type">GRHSs</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-248"></span><span>        </span><span id="pat_ticks"><span class="annot"><span class="annottext">forall idL idR.
HsBindLR idL idR -&gt; ([CoreTickish], [[CoreTickish]])
</span><a href="Language.Haskell.Syntax.Binds.html#pat_ticks"><span class="hs-identifier hs-var hs-var">pat_ticks</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Tickish.html#CoreTickish"><span class="hs-identifier hs-type">CoreTickish</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Tickish.html#CoreTickish"><span class="hs-identifier hs-type">CoreTickish</span></a></span><span class="hs-special">]</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-249"></span><span>               </span><span class="hs-comment">-- ^ Ticks to put on the rhs, if any, and ticks to put on</span><span>
</span><span id="line-250"></span><span>               </span><span class="hs-comment">-- the bound variables.</span><span>
</span><span id="line-251"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-252"></span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-comment">-- | Variable Binding</span><span>
</span><span id="line-254"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-255"></span><span>  </span><span class="hs-comment">-- Dictionary binding and suchlike.</span><span>
</span><span id="line-256"></span><span>  </span><span class="hs-comment">-- All VarBinds are introduced by the type checker</span><span>
</span><span id="line-257"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="VarBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#VarBind"><span class="hs-identifier hs-var">VarBind</span></a></span></span><span> </span><span class="hs-special">{</span><span>
</span><span id="line-258"></span><span>        </span><span id="var_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XVarBind idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#var_ext"><span class="hs-identifier hs-var hs-var">var_ext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XVarBind"><span class="hs-identifier hs-type">XVarBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-259"></span><span>        </span><span id="var_id"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; IdP idL
</span><a href="Language.Haskell.Syntax.Binds.html#var_id"><span class="hs-identifier hs-var hs-var">var_id</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-260"></span><span>        </span><span id="var_rhs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LHsExpr idR
</span><a href="Language.Haskell.Syntax.Binds.html#var_rhs"><span class="hs-identifier hs-var hs-var">var_rhs</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span>    </span><span class="hs-comment">-- ^ Located only for consistency</span><span>
</span><span id="line-261"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-262"></span><span>
</span><span id="line-263"></span><span>  </span><span class="hs-comment">-- | Abstraction Bindings</span><span>
</span><span id="line-264"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="AbsBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#AbsBinds"><span class="hs-identifier hs-var">AbsBinds</span></a></span></span><span> </span><span class="hs-special">{</span><span>                      </span><span class="hs-comment">-- Binds abstraction; TRANSLATION</span><span>
</span><span id="line-265"></span><span>        </span><span id="abs_ext"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; XAbsBinds idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#abs_ext"><span class="hs-identifier hs-var hs-var">abs_ext</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XAbsBinds"><span class="hs-identifier hs-type">XAbsBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-266"></span><span>        </span><span id="abs_tvs"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; [TyVar]
</span><a href="Language.Haskell.Syntax.Binds.html#abs_tvs"><span class="hs-identifier hs-var hs-var">abs_tvs</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#TyVar"><span class="hs-identifier hs-type">TyVar</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-267"></span><span>        </span><span id="abs_ev_vars"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; [TyVar]
</span><a href="Language.Haskell.Syntax.Binds.html#abs_ev_vars"><span class="hs-identifier hs-var hs-var">abs_ev_vars</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Types.Var.html#EvVar"><span class="hs-identifier hs-type">EvVar</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>  </span><span class="hs-comment">-- ^ Includes equality constraints</span><span>
</span><span id="line-268"></span><span>
</span><span id="line-269"></span><span>       </span><span class="hs-comment">-- | AbsBinds only gets used when idL = idR after renaming,</span><span>
</span><span id="line-270"></span><span>       </span><span class="hs-comment">-- but these need to be idL's for the collect... code in HsUtil</span><span>
</span><span id="line-271"></span><span>       </span><span class="hs-comment">-- to have the right type</span><span>
</span><span id="line-272"></span><span>        </span><span id="abs_exports"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; [ABExport idL]
</span><a href="Language.Haskell.Syntax.Binds.html#abs_exports"><span class="hs-identifier hs-var hs-var">abs_exports</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ABExport"><span class="hs-identifier hs-type">ABExport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-273"></span><span>
</span><span id="line-274"></span><span>        </span><span class="hs-comment">-- | Evidence bindings</span><span>
</span><span id="line-275"></span><span>        </span><span class="hs-comment">-- Why a list? See &quot;GHC.Tc.TyCl.Instance&quot;</span><span>
</span><span id="line-276"></span><span>        </span><span class="hs-comment">-- Note [Typechecking plan for instance declarations]</span><span>
</span><span id="line-277"></span><span>        </span><span id="abs_ev_binds"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; [TcEvBinds]
</span><a href="Language.Haskell.Syntax.Binds.html#abs_ev_binds"><span class="hs-identifier hs-var hs-var">abs_ev_binds</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#TcEvBinds"><span class="hs-identifier hs-type">TcEvBinds</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span>
</span><span id="line-278"></span><span>
</span><span id="line-279"></span><span>        </span><span class="hs-comment">-- | Typechecked user bindings</span><span>
</span><span id="line-280"></span><span>        </span><span id="abs_binds"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; LHsBinds idL
</span><a href="Language.Haskell.Syntax.Binds.html#abs_binds"><span class="hs-identifier hs-var hs-var">abs_binds</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LHsBinds"><span class="hs-identifier hs-type">LHsBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-281"></span><span>
</span><span id="line-282"></span><span>        </span><span id="abs_sig"><span class="annot"><span class="annottext">forall idL idR. HsBindLR idL idR -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#abs_sig"><span class="hs-identifier hs-var hs-var">abs_sig</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>  </span><span class="hs-comment">-- See Note [The abs_sig field of AbsBinds]</span><span>
</span><span id="line-283"></span><span>    </span><span class="hs-special">}</span><span>
</span><span id="line-284"></span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-comment">-- | Patterns Synonym Binding</span><span>
</span><span id="line-286"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynBind"><span class="hs-identifier hs-var">PatSynBind</span></a></span></span><span>
</span><span id="line-287"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatSynBind"><span class="hs-identifier hs-type">XPatSynBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-288"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynBind"><span class="hs-identifier hs-type">PatSynBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-289"></span><span>        </span><span class="hs-comment">-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnPattern',</span><span>
</span><span id="line-290"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnLarrow','GHC.Parser.Annotation.AnnEqual',</span><span>
</span><span id="line-291"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnWhere'</span><span>
</span><span id="line-292"></span><span>        </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnOpen' @'{'@,'GHC.Parser.Annotation.AnnClose' @'}'@</span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span>        </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-295"></span><span>
</span><span id="line-296"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsBindsLR"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsBindsLR"><span class="hs-identifier hs-var">XHsBindsLR</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsBindsLR"><span class="hs-identifier hs-type">XXHsBindsLR</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077913"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077912"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span>
</span><span id="line-299"></span><span>        </span><span class="hs-comment">-- Consider (AbsBinds tvs ds [(ftvs, poly_f, mono_f) binds]</span><span>
</span><span id="line-300"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-301"></span><span>        </span><span class="hs-comment">-- Creates bindings for (polymorphic, overloaded) poly_f</span><span>
</span><span id="line-302"></span><span>        </span><span class="hs-comment">-- in terms of monomorphic, non-overloaded mono_f</span><span>
</span><span id="line-303"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-304"></span><span>        </span><span class="hs-comment">-- Invariants:</span><span>
</span><span id="line-305"></span><span>        </span><span class="hs-comment">--      1. 'binds' binds mono_f</span><span>
</span><span id="line-306"></span><span>        </span><span class="hs-comment">--      2. ftvs is a subset of tvs</span><span>
</span><span id="line-307"></span><span>        </span><span class="hs-comment">--      3. ftvs includes all tyvars free in ds</span><span>
</span><span id="line-308"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-309"></span><span>        </span><span class="hs-comment">-- See Note [AbsBinds]</span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span class="hs-comment">-- | Abstraction Bindings Export</span><span>
</span><span id="line-312"></span><span class="hs-keyword">data</span><span> </span><span id="ABExport"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ABExport"><span class="hs-identifier hs-var">ABExport</span></a></span></span><span> </span><span id="local-6989586621681077857"><span class="annot"><a href="#local-6989586621681077857"><span class="hs-identifier hs-type">p</span></a></span></span><span>
</span><span id="line-313"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="ABE"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ABE"><span class="hs-identifier hs-var">ABE</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="abe_ext"><span class="annot"><span class="annottext">forall p. ABExport p -&gt; XABE p
</span><a href="Language.Haskell.Syntax.Binds.html#abe_ext"><span class="hs-identifier hs-var hs-var">abe_ext</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XABE"><span class="hs-identifier hs-type">XABE</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077857"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-314"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="abe_poly"><span class="annot"><span class="annottext">forall p. ABExport p -&gt; IdP p
</span><a href="Language.Haskell.Syntax.Binds.html#abe_poly"><span class="hs-identifier hs-var hs-var">abe_poly</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077857"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-comment">-- ^ Any INLINE pragma is attached to this Id</span><span>
</span><span id="line-315"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="abe_mono"><span class="annot"><span class="annottext">forall p. ABExport p -&gt; IdP p
</span><a href="Language.Haskell.Syntax.Binds.html#abe_mono"><span class="hs-identifier hs-var hs-var">abe_mono</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077857"><span class="hs-identifier hs-type">p</span></a></span><span>
</span><span id="line-316"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="abe_wrap"><span class="annot"><span class="annottext">forall p. ABExport p -&gt; HsWrapper
</span><a href="Language.Haskell.Syntax.Binds.html#abe_wrap"><span class="hs-identifier hs-var hs-var">abe_wrap</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>    </span><span class="hs-comment">-- ^ See Note [ABExport wrapper]</span><span>
</span><span id="line-317"></span><span>             </span><span class="hs-comment">-- Shape: (forall abs_tvs. abs_ev_vars =&gt; abe_mono) ~ abe_poly</span><span>
</span><span id="line-318"></span><span>        </span><span class="hs-special">,</span><span> </span><span id="abe_prags"><span class="annot"><span class="annottext">forall p. ABExport p -&gt; TcSpecPrags
</span><a href="Language.Haskell.Syntax.Binds.html#abe_prags"><span class="hs-identifier hs-var hs-var">abe_prags</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrags"><span class="hs-identifier hs-type">TcSpecPrags</span></a></span><span>  </span><span class="hs-comment">-- ^ SPECIALISE pragmas</span><span>
</span><span id="line-319"></span><span>        </span><span class="hs-special">}</span><span>
</span><span id="line-320"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="XABExport"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XABExport"><span class="hs-identifier hs-var">XABExport</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXABExport"><span class="hs-identifier hs-type">XXABExport</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077857"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span>
</span><span id="line-323"></span><span class="hs-comment">-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnPattern',</span><span>
</span><span id="line-324"></span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnLarrow',</span><span>
</span><span id="line-325"></span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnWhere','GHC.Parser.Annotation.AnnOpen' @'{'@,</span><span>
</span><span id="line-326"></span><span class="hs-comment">--             'GHC.Parser.Annotation.AnnClose' @'}'@,</span><span>
</span><span id="line-327"></span><span>
</span><span id="line-328"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-329"></span><span>
</span><span id="line-330"></span><span class="hs-comment">-- | Pattern Synonym binding</span><span>
</span><span id="line-331"></span><span class="hs-keyword">data</span><span> </span><span id="PatSynBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynBind"><span class="hs-identifier hs-var">PatSynBind</span></a></span></span><span> </span><span id="local-6989586621681077849"><span class="annot"><a href="#local-6989586621681077849"><span class="hs-identifier hs-type">idL</span></a></span></span><span> </span><span id="local-6989586621681077848"><span class="annot"><a href="#local-6989586621681077848"><span class="hs-identifier hs-type">idR</span></a></span></span><span>
</span><span id="line-332"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="PSB"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PSB"><span class="hs-identifier hs-var">PSB</span></a></span></span><span> </span><span class="hs-special">{</span><span> </span><span id="psb_ext"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; XPSB idL idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_ext"><span class="hs-identifier hs-var hs-var">psb_ext</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPSB"><span class="hs-identifier hs-type">XPSB</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077849"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077848"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>            </span><span class="hs-comment">-- ^ Post renaming, FVs.</span><span>
</span><span id="line-333"></span><span>                                               </span><span class="hs-comment">-- See Note [Bind free vars]</span><span>
</span><span id="line-334"></span><span>          </span><span id="psb_id"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; LIdP idL
</span><a href="Language.Haskell.Syntax.Binds.html#psb_id"><span class="hs-identifier hs-var hs-var">psb_id</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077849"><span class="hs-identifier hs-type">idL</span></a></span><span class="hs-special">,</span><span>                </span><span class="hs-comment">-- ^ Name of the pattern synonym</span><span>
</span><span id="line-335"></span><span>          </span><span id="psb_args"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; HsPatSynDetails idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_args"><span class="hs-identifier hs-var hs-var">psb_args</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDetails"><span class="hs-identifier hs-type">HsPatSynDetails</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077848"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>     </span><span class="hs-comment">-- ^ Formal parameter names</span><span>
</span><span id="line-336"></span><span>          </span><span id="psb_def"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; LPat idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_def"><span class="hs-identifier hs-var hs-var">psb_def</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Pat.html#LPat"><span class="hs-identifier hs-type">LPat</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077848"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">,</span><span>                </span><span class="hs-comment">-- ^ Right-hand side</span><span>
</span><span id="line-337"></span><span>          </span><span id="psb_dir"><span class="annot"><span class="annottext">forall idL idR. PatSynBind idL idR -&gt; HsPatSynDir idR
</span><a href="Language.Haskell.Syntax.Binds.html#psb_dir"><span class="hs-identifier hs-var hs-var">psb_dir</span></a></span></span><span>  </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDir"><span class="hs-identifier hs-type">HsPatSynDir</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077848"><span class="hs-identifier hs-type">idR</span></a></span><span>          </span><span class="hs-comment">-- ^ Directionality</span><span>
</span><span id="line-338"></span><span>     </span><span class="hs-special">}</span><span>
</span><span id="line-339"></span><span>   </span><span class="hs-glyph">|</span><span> </span><span id="XPatSynBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XPatSynBind"><span class="hs-identifier hs-var">XPatSynBind</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXPatSynBind"><span class="hs-identifier hs-type">XXPatSynBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077849"><span class="hs-identifier hs-type">idL</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077848"><span class="hs-identifier hs-type">idR</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-340"></span><span>
</span><span id="line-341"></span><span class="hs-comment">{-
Note [AbsBinds]
~~~~~~~~~~~~~~~
The AbsBinds constructor is used in the output of the type checker, to
record *typechecked* and *generalised* bindings.  Specifically

         AbsBinds { abs_tvs      = tvs
                  , abs_ev_vars  = [d1,d2]
                  , abs_exports  = [ABE { abe_poly = fp, abe_mono = fm
                                        , abe_wrap = fwrap }
                                    ABE { slly for g } ]
                  , abs_ev_binds = DBINDS
                  , abs_binds    = BIND[fm,gm] }

where 'BIND' binds the monomorphic Ids 'fm' and 'gm', means

        fp = fwrap [/\ tvs. \d1 d2. letrec { DBINDS        ]
                   [                       ; BIND[fm,gm] } ]
                   [                 in fm                 ]

        gp = ...same again, with gm instead of fm

The 'fwrap' is an impedance-matcher that typically does nothing; see
Note [ABExport wrapper].

This is a pretty bad translation, because it duplicates all the bindings.
So the desugarer tries to do a better job:

        fp = /\ [a,b] -&gt; \ [d1,d2] -&gt; case tp [a,b] [d1,d2] of
                                        (fm,gm) -&gt; fm
        ..ditto for gp..

        tp = /\ [a,b] -&gt; \ [d1,d2] -&gt; letrec { DBINDS; BIND }
                                      in (fm,gm)

In general:

  * abs_tvs are the type variables over which the binding group is
    generalised
  * abs_ev_var are the evidence variables (usually dictionaries)
    over which the binding group is generalised
  * abs_binds are the monomorphic bindings
  * abs_ex_binds are the evidence bindings that wrap the abs_binds
  * abs_exports connects the monomorphic Ids bound by abs_binds
    with the polymorphic Ids bound by the AbsBinds itself.

For example, consider a module M, with this top-level binding, where
there is no type signature for M.reverse,
    M.reverse []     = []
    M.reverse (x:xs) = M.reverse xs ++ [x]

In Hindley-Milner, a recursive binding is typechecked with the
*recursive* uses being *monomorphic*.  So after typechecking *and*
desugaring we will get something like this

    M.reverse :: forall a. [a] -&gt; [a]
      = /\a. letrec
                reverse :: [a] -&gt; [a] = \xs -&gt; case xs of
                                                []     -&gt; []
                                                (x:xs) -&gt; reverse xs ++ [x]
             in reverse

Notice that 'M.reverse' is polymorphic as expected, but there is a local
definition for plain 'reverse' which is *monomorphic*.  The type variable
'a' scopes over the entire letrec.

That's after desugaring.  What about after type checking but before
desugaring?  That's where AbsBinds comes in.  It looks like this:

   AbsBinds { abs_tvs     = [a]
            , abs_ev_vars = []
            , abs_exports = [ABE { abe_poly = M.reverse :: forall a. [a] -&gt; [a],
                                 , abe_mono = reverse :: [a] -&gt; [a]}]
            , abs_ev_binds = {}
            , abs_binds = { reverse :: [a] -&gt; [a]
                               = \xs -&gt; case xs of
                                            []     -&gt; []
                                            (x:xs) -&gt; reverse xs ++ [x] } }

Here,

  * abs_tvs says what type variables are abstracted over the binding
    group, just 'a' in this case.
  * abs_binds is the *monomorphic* bindings of the group
  * abs_exports describes how to get the polymorphic Id 'M.reverse'
    from the monomorphic one 'reverse'

Notice that the *original* function (the polymorphic one you thought
you were defining) appears in the abe_poly field of the
abs_exports. The bindings in abs_binds are for fresh, local, Ids with
a *monomorphic* Id.

If there is a group of mutually recursive (see Note [Polymorphic
recursion]) functions without type signatures, we get one AbsBinds
with the monomorphic versions of the bindings in abs_binds, and one
element of abe_exports for each variable bound in the mutually
recursive group.  This is true even for pattern bindings.  Example:
        (f,g) = (\x -&gt; x, f)
After type checking we get
   AbsBinds { abs_tvs     = [a]
            , abs_exports = [ ABE { abe_poly = M.f :: forall a. a -&gt; a
                                  , abe_mono = f :: a -&gt; a }
                            , ABE { abe_poly = M.g :: forall a. a -&gt; a
                                  , abe_mono = g :: a -&gt; a }]
            , abs_binds = { (f,g) = (\x -&gt; x, f) }

Note [Polymorphic recursion]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Consider
   Rec { f x = ...(g ef)...

       ; g :: forall a. [a] -&gt; [a]
       ; g y = ...(f eg)...  }

These bindings /are/ mutually recursive (f calls g, and g calls f).
But we can use the type signature for g to break the recursion,
like this:

  1. Add g :: forall a. [a] -&gt; [a] to the type environment

  2. Typecheck the definition of f, all by itself,
     including generalising it to find its most general
     type, say f :: forall b. b -&gt; b -&gt; [b]

  3. Extend the type environment with that type for f

  4. Typecheck the definition of g, all by itself,
     checking that it has the type claimed by its signature

Steps 2 and 4 each generate a separate AbsBinds, so we end
up with
   Rec { AbsBinds { ...for f ... }
       ; AbsBinds { ...for g ... } }

This approach allows both f and to call each other
polymorphically, even though only g has a signature.

We get an AbsBinds that encompasses multiple source-program
bindings only when
 * Each binding in the group has at least one binder that
   lacks a user type signature
 * The group forms a strongly connected component


Note [The abs_sig field of AbsBinds]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The abs_sig field supports a couple of special cases for bindings.
Consider

  x :: Num a =&gt; (# a, a #)
  x = (# 3, 4 #)

The general desugaring for AbsBinds would give

  x = /\a. \ ($dNum :: Num a) -&gt;
      letrec xm = (# fromInteger $dNum 3, fromInteger $dNum 4 #) in
      xm

But that has an illegal let-binding for an unboxed tuple.  In this
case we'd prefer to generate the (more direct)

  x = /\ a. \ ($dNum :: Num a) -&gt;
     (# fromInteger $dNum 3, fromInteger $dNum 4 #)

A similar thing happens with representation-polymorphic defns
(#11405):

  undef :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack =&gt; a
  undef = error &quot;undef&quot;

Again, the vanilla desugaring gives a local let-binding for a
representation-polymorphic (undefm :: a), which is illegal.  But
again we can desugar without a let:

  undef = /\ a. \ (d:HasCallStack) -&gt; error a d &quot;undef&quot;

The abs_sig field supports this direct desugaring, with no local
let-binding.  When abs_sig = True

 * the abs_binds is single FunBind

 * the abs_exports is a singleton

 * we have a complete type sig for binder
   and hence the abs_binds is non-recursive
   (it binds the mono_id but refers to the poly_id

These properties are exploited in GHC.HsToCore.Binds.dsAbsBinds to
generate code without a let-binding.

Note [ABExport wrapper]
~~~~~~~~~~~~~~~~~~~~~~~
Consider
   (f,g) = (\x.x, \y.y)
This ultimately desugars to something like this:
   tup :: forall a b. (a-&gt;a, b-&gt;b)
   tup = /\a b. (\x:a.x, \y:b.y)
   f :: forall a. a -&gt; a
   f = /\a. case tup a Any of
               (fm::a-&gt;a,gm:Any-&gt;Any) -&gt; fm
   ...similarly for g...

The abe_wrap field deals with impedance-matching between
    (/\a b. case tup a b of { (f,g) -&gt; f })
and the thing we really want, which may have fewer type
variables.  The action happens in GHC.Tc.Gen.Bind.mkExport.

Note [Bind free vars]
~~~~~~~~~~~~~~~~~~~~~
The bind_fvs field of FunBind and PatBind records the free variables
of the definition.  It is used for the following purposes

a) Dependency analysis prior to type checking
    (see GHC.Tc.Gen.Bind.tc_group)

b) Deciding whether we can do generalisation of the binding
    (see GHC.Tc.Gen.Bind.decideGeneralisationPlan)

c) Deciding whether the binding can be used in static forms
    (see GHC.Tc.Gen.Expr.checkClosedInStaticForm for the HsStatic case and
     GHC.Tc.Gen.Bind.isClosedBndrGroup).

Specifically,

  * bind_fvs includes all free vars that are defined in this module
    (including top-level things and lexically scoped type variables)

  * bind_fvs excludes imported vars; this is just to keep the set smaller

  * Before renaming, and after typechecking, the field is unused;
    it's just an error thunk
-}</span><span>
</span><span id="line-573"></span><span>
</span><span id="line-574"></span><span>
</span><span id="line-575"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
                Implicit parameter bindings
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-582"></span><span>
</span><span id="line-583"></span><span class="hs-comment">-- | Haskell Implicit Parameter Bindings</span><span>
</span><span id="line-584"></span><span class="hs-keyword">data</span><span> </span><span id="HsIPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsIPBinds"><span class="hs-identifier hs-var">HsIPBinds</span></a></span></span><span> </span><span id="local-6989586621681077577"><span class="annot"><a href="#local-6989586621681077577"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-585"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="IPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBinds"><span class="hs-identifier hs-var">IPBinds</span></a></span></span><span>
</span><span id="line-586"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIPBinds"><span class="hs-identifier hs-type">XIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077577"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-587"></span><span>        </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LIPBind"><span class="hs-identifier hs-type">LIPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077577"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-588"></span><span>        </span><span class="hs-comment">-- TcEvBinds       -- Only in typechecker output; binds</span><span>
</span><span id="line-589"></span><span>        </span><span class="hs-comment">--                 -- uses of the implicit parameters</span><span>
</span><span id="line-590"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XHsIPBinds"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XHsIPBinds"><span class="hs-identifier hs-var">XHsIPBinds</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXHsIPBinds"><span class="hs-identifier hs-type">XXHsIPBinds</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077577"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-591"></span><span>
</span><span id="line-592"></span><span>
</span><span id="line-593"></span><span class="hs-comment">-- | Located Implicit Parameter Binding</span><span>
</span><span id="line-594"></span><span class="hs-keyword">type</span><span> </span><span id="LIPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LIPBind"><span class="hs-identifier hs-var">LIPBind</span></a></span></span><span> </span><span id="local-6989586621681077571"><span class="annot"><a href="#local-6989586621681077571"><span class="hs-identifier hs-type">id</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077571"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBind"><span class="hs-identifier hs-type">IPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077571"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-595"></span><span class="hs-comment">-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a</span><span>
</span><span id="line-596"></span><span class="hs-comment">--   list</span><span>
</span><span id="line-597"></span><span>
</span><span id="line-598"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-599"></span><span>
</span><span id="line-600"></span><span class="hs-comment">-- | Implicit parameter bindings.</span><span>
</span><span id="line-601"></span><span class="hs-comment">--</span><span>
</span><span id="line-602"></span><span class="hs-comment">-- These bindings start off as (Left &quot;x&quot;) in the parser and stay</span><span>
</span><span id="line-603"></span><span class="hs-comment">-- that way until after type-checking when they are replaced with</span><span>
</span><span id="line-604"></span><span class="hs-comment">-- (Right d), where &quot;d&quot; is the name of the dictionary holding the</span><span>
</span><span id="line-605"></span><span class="hs-comment">-- evidence for the implicit parameter.</span><span>
</span><span id="line-606"></span><span class="hs-comment">--</span><span>
</span><span id="line-607"></span><span class="hs-comment">-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnEqual'</span><span>
</span><span id="line-608"></span><span>
</span><span id="line-609"></span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-610"></span><span class="hs-keyword">data</span><span> </span><span id="IPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span></span><span> </span><span id="local-6989586621681077569"><span class="annot"><a href="#local-6989586621681077569"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-611"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="IPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IPBind"><span class="hs-identifier hs-var">IPBind</span></a></span></span><span>
</span><span id="line-612"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCIPBind"><span class="hs-identifier hs-type">XCIPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077569"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-613"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Either.html#Either"><span class="hs-identifier hs-type">Either</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077569"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsIPName"><span class="hs-identifier hs-type">HsIPName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#IdP"><span class="hs-identifier hs-type">IdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077569"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-614"></span><span>        </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077569"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-615"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XIPBind"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XIPBind"><span class="hs-identifier hs-var">XIPBind</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXIPBind"><span class="hs-identifier hs-type">XXIPBind</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077569"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-616"></span><span>
</span><span id="line-617"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection{@Sig@: type signatures and value-modifying user pragmas}
*                                                                      *
************************************************************************

It is convenient to lump ``value-modifying'' user-pragmas (e.g.,
``specialise this function to these four types...'') in with type
signatures.  Then all the machinery to move them into place, etc.,
serves for both.
-}</span><span>
</span><span id="line-629"></span><span>
</span><span id="line-630"></span><span class="hs-comment">-- | Located Signature</span><span>
</span><span id="line-631"></span><span class="hs-keyword">type</span><span> </span><span id="LSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-var">LSig</span></a></span></span><span> </span><span id="local-6989586621681077563"><span class="annot"><a href="#local-6989586621681077563"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077563"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Sig"><span class="hs-identifier hs-type">Sig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077563"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-632"></span><span>
</span><span id="line-633"></span><span class="hs-comment">-- | Signatures and pragmas</span><span>
</span><span id="line-634"></span><span class="hs-keyword">data</span><span> </span><span id="Sig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Sig"><span class="hs-identifier hs-var">Sig</span></a></span></span><span> </span><span id="local-6989586621681077562"><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-635"></span><span>  </span><span class="hs-glyph">=</span><span>   </span><span class="hs-comment">-- | An ordinary type signature</span><span>
</span><span id="line-636"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-637"></span><span>      </span><span class="hs-comment">-- &gt; f :: Num a =&gt; a -&gt; a</span><span>
</span><span id="line-638"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-639"></span><span>      </span><span class="hs-comment">-- After renaming, this list of Names contains the named</span><span>
</span><span id="line-640"></span><span>      </span><span class="hs-comment">-- wildcards brought into scope by this signature. For a signature</span><span>
</span><span id="line-641"></span><span>      </span><span class="hs-comment">-- @_ -&gt; _a -&gt; Bool@, the renamer will leave the unnamed wildcard @_@</span><span>
</span><span id="line-642"></span><span>      </span><span class="hs-comment">-- untouched, and the named wildcard @_a@ is then replaced with</span><span>
</span><span id="line-643"></span><span>      </span><span class="hs-comment">-- fresh meta vars in the type. Their names are stored in the type</span><span>
</span><span id="line-644"></span><span>      </span><span class="hs-comment">-- signature that brought them into scope, in this third field to be</span><span>
</span><span id="line-645"></span><span>      </span><span class="hs-comment">-- more specific.</span><span>
</span><span id="line-646"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-647"></span><span>      </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon',</span><span>
</span><span id="line-648"></span><span>      </span><span class="hs-comment">--          'GHC.Parser.Annotation.AnnComma'</span><span>
</span><span id="line-649"></span><span>
</span><span id="line-650"></span><span>      </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-651"></span><span>    </span><span id="TypeSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TypeSig"><span class="hs-identifier hs-var">TypeSig</span></a></span></span><span>
</span><span id="line-652"></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XTypeSig"><span class="hs-identifier hs-type">XTypeSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-653"></span><span>       </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>           </span><span class="hs-comment">-- LHS of the signature; e.g.  f,g,h :: blah</span><span>
</span><span id="line-654"></span><span>       </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigWcType"><span class="hs-identifier hs-type">LHsSigWcType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- RHS of the signature; can have wildcards</span><span>
</span><span id="line-655"></span><span>
</span><span id="line-656"></span><span>      </span><span class="hs-comment">-- | A pattern synonym type signature</span><span>
</span><span id="line-657"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-658"></span><span>      </span><span class="hs-comment">-- &gt; pattern Single :: () =&gt; (Show a) =&gt; a -&gt; [a]</span><span>
</span><span id="line-659"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-660"></span><span>      </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnPattern',</span><span>
</span><span id="line-661"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDcolon','GHC.Parser.Annotation.AnnForall'</span><span>
</span><span id="line-662"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDot','GHC.Parser.Annotation.AnnDarrow'</span><span>
</span><span id="line-663"></span><span>
</span><span id="line-664"></span><span>      </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-665"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatSynSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynSig"><span class="hs-identifier hs-var">PatSynSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XPatSynSig"><span class="hs-identifier hs-type">XPatSynSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-666"></span><span>      </span><span class="hs-comment">-- P :: forall a b. Req =&gt; Prov =&gt; ty</span><span>
</span><span id="line-667"></span><span>
</span><span id="line-668"></span><span>      </span><span class="hs-comment">-- | A signature for a class method</span><span>
</span><span id="line-669"></span><span>      </span><span class="hs-comment">--   False: ordinary class-method signature</span><span>
</span><span id="line-670"></span><span>      </span><span class="hs-comment">--   True:  generic-default class method signature</span><span>
</span><span id="line-671"></span><span>      </span><span class="hs-comment">-- e.g.   class C a where</span><span>
</span><span id="line-672"></span><span>      </span><span class="hs-comment">--          op :: a -&gt; a                   -- Ordinary</span><span>
</span><span id="line-673"></span><span>      </span><span class="hs-comment">--          default op :: Eq a =&gt; a -&gt; a   -- Generic default</span><span>
</span><span id="line-674"></span><span>      </span><span class="hs-comment">-- No wildcards allowed here</span><span>
</span><span id="line-675"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-676"></span><span>      </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDefault',</span><span>
</span><span id="line-677"></span><span>      </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-678"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ClassOpSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ClassOpSig"><span class="hs-identifier hs-var">ClassOpSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XClassOpSig"><span class="hs-identifier hs-type">XClassOpSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-679"></span><span>
</span><span id="line-680"></span><span>        </span><span class="hs-comment">-- | A type signature in generated code, notably the code</span><span>
</span><span id="line-681"></span><span>        </span><span class="hs-comment">-- generated for record selectors.  We simply record</span><span>
</span><span id="line-682"></span><span>        </span><span class="hs-comment">-- the desired Id itself, replete with its name, type</span><span>
</span><span id="line-683"></span><span>        </span><span class="hs-comment">-- and IdDetails.  Otherwise it's just like a type</span><span>
</span><span id="line-684"></span><span>        </span><span class="hs-comment">-- signature: there should be an accompanying binding</span><span>
</span><span id="line-685"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IdSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IdSig"><span class="hs-identifier hs-var">IdSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XIdSig"><span class="hs-identifier hs-type">XIdSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span><span>
</span><span id="line-686"></span><span>
</span><span id="line-687"></span><span>        </span><span class="hs-comment">-- | An ordinary fixity declaration</span><span>
</span><span id="line-688"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-689"></span><span>        </span><span class="hs-comment">-- &gt;     infixl 8 ***</span><span>
</span><span id="line-690"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-691"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-692"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnInfix',</span><span>
</span><span id="line-693"></span><span>        </span><span class="hs-comment">--           'GHC.Parser.Annotation.AnnVal'</span><span>
</span><span id="line-694"></span><span>
</span><span id="line-695"></span><span>        </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-696"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FixSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixSig"><span class="hs-identifier hs-var">FixSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFixSig"><span class="hs-identifier hs-type">XFixSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-type">FixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-697"></span><span>
</span><span id="line-698"></span><span>        </span><span class="hs-comment">-- | An inline pragma</span><span>
</span><span id="line-699"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-700"></span><span>        </span><span class="hs-comment">-- &gt; {#- INLINE f #-}</span><span>
</span><span id="line-701"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-702"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' :</span><span>
</span><span id="line-703"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnOpen' @'{-\# INLINE'@ and @'['@,</span><span>
</span><span id="line-704"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose','GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-705"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnTilde',</span><span>
</span><span id="line-706"></span><span>        </span><span class="hs-comment">--       'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-707"></span><span>
</span><span id="line-708"></span><span>        </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-709"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InlineSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-var">InlineSig</span></a></span></span><span>   </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XInlineSig"><span class="hs-identifier hs-type">XInlineSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-710"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Function name</span><span>
</span><span id="line-711"></span><span>                </span><span class="annot"><a href="GHC.Types.Basic.html#InlinePragma"><span class="hs-identifier hs-type">InlinePragma</span></a></span><span>       </span><span class="hs-comment">-- Never defaultInlinePragma</span><span>
</span><span id="line-712"></span><span>
</span><span id="line-713"></span><span>        </span><span class="hs-comment">-- | A specialisation pragma</span><span>
</span><span id="line-714"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-715"></span><span>        </span><span class="hs-comment">-- &gt; {-# SPECIALISE f :: Int -&gt; Int #-}</span><span>
</span><span id="line-716"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-717"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-718"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnOpen' @'{-\# SPECIALISE'@ and @'['@,</span><span>
</span><span id="line-719"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnTilde',</span><span>
</span><span id="line-720"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnVal',</span><span>
</span><span id="line-721"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnClose' @']'@ and @'\#-}'@,</span><span>
</span><span id="line-722"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnDcolon'</span><span>
</span><span id="line-723"></span><span>
</span><span id="line-724"></span><span>        </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-725"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SpecSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-var">SpecSig</span></a></span></span><span>     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpecSig"><span class="hs-identifier hs-type">XSpecSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-726"></span><span>                </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>        </span><span class="hs-comment">-- Specialise a function or datatype  ...</span><span>
</span><span id="line-727"></span><span>                </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ... to these types</span><span>
</span><span id="line-728"></span><span>                </span><span class="annot"><a href="GHC.Types.Basic.html#InlinePragma"><span class="hs-identifier hs-type">InlinePragma</span></a></span><span>       </span><span class="hs-comment">-- The pragma on SPECIALISE_INLINE form.</span><span>
</span><span id="line-729"></span><span>                                   </span><span class="hs-comment">-- If it's just defaultInlinePragma, then we said</span><span>
</span><span id="line-730"></span><span>                                   </span><span class="hs-comment">--    SPECIALISE, not SPECIALISE_INLINE</span><span>
</span><span id="line-731"></span><span>
</span><span id="line-732"></span><span>        </span><span class="hs-comment">-- | A specialisation pragma for instance declarations only</span><span>
</span><span id="line-733"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-734"></span><span>        </span><span class="hs-comment">-- &gt; {-# SPECIALISE instance Eq [Int] #-}</span><span>
</span><span id="line-735"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-736"></span><span>        </span><span class="hs-comment">-- (Class tys); should be a specialisation of the</span><span>
</span><span id="line-737"></span><span>        </span><span class="hs-comment">-- current instance declaration</span><span>
</span><span id="line-738"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-739"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-740"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnInstance','GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-741"></span><span>
</span><span id="line-742"></span><span>        </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-743"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SpecInstSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecInstSig"><span class="hs-identifier hs-var">SpecInstSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSpecInstSig"><span class="hs-identifier hs-type">XSpecInstSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#LHsSigType"><span class="hs-identifier hs-type">LHsSigType</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-744"></span><span>                  </span><span class="hs-comment">-- Note [Pragma source text] in GHC.Types.SourceText</span><span>
</span><span id="line-745"></span><span>
</span><span id="line-746"></span><span>        </span><span class="hs-comment">-- | A minimal complete definition pragma</span><span>
</span><span id="line-747"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-748"></span><span>        </span><span class="hs-comment">-- &gt; {-# MINIMAL a | (b, c | (d | e)) #-}</span><span>
</span><span id="line-749"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-750"></span><span>        </span><span class="hs-comment">--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span><span>
</span><span id="line-751"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnVbar','GHC.Parser.Annotation.AnnComma',</span><span>
</span><span id="line-752"></span><span>        </span><span class="hs-comment">--      'GHC.Parser.Annotation.AnnClose'</span><span>
</span><span id="line-753"></span><span>
</span><span id="line-754"></span><span>        </span><span class="hs-comment">-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span><span>
</span><span id="line-755"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MinimalSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#MinimalSig"><span class="hs-identifier hs-var">MinimalSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XMinimalSig"><span class="hs-identifier hs-type">XMinimalSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-756"></span><span>               </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="GHC.Data.BooleanFormula.html#LBooleanFormula"><span class="hs-identifier hs-type">LBooleanFormula</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-757"></span><span>               </span><span class="hs-comment">-- Note [Pragma source text] in GHC.Types.SourceText</span><span>
</span><span id="line-758"></span><span>
</span><span id="line-759"></span><span>        </span><span class="hs-comment">-- | A &quot;set cost centre&quot; pragma for declarations</span><span>
</span><span id="line-760"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-761"></span><span>        </span><span class="hs-comment">-- &gt; {-# SCC funName #-}</span><span>
</span><span id="line-762"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-763"></span><span>        </span><span class="hs-comment">-- or</span><span>
</span><span id="line-764"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-765"></span><span>        </span><span class="hs-comment">-- &gt; {-# SCC funName &quot;cost_centre_name&quot; #-}</span><span>
</span><span id="line-766"></span><span>
</span><span id="line-767"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SCCFunSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-var">SCCFunSig</span></a></span></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XSCCFunSig"><span class="hs-identifier hs-type">XSCCFunSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-768"></span><span>               </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span>     </span><span class="hs-comment">-- Note [Pragma source text] in GHC.Types.SourceText</span><span>
</span><span id="line-769"></span><span>               </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>    </span><span class="hs-comment">-- Function name</span><span>
</span><span id="line-770"></span><span>               </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="annot"><a href="GHC.Types.SourceText.html#StringLiteral"><span class="hs-identifier hs-type">StringLiteral</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-771"></span><span>       </span><span class="hs-comment">-- | A complete match pragma</span><span>
</span><span id="line-772"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-773"></span><span>       </span><span class="hs-comment">-- &gt; {-# COMPLETE C, D [:: T] #-}</span><span>
</span><span id="line-774"></span><span>       </span><span class="hs-comment">--</span><span>
</span><span id="line-775"></span><span>       </span><span class="hs-comment">-- Used to inform the pattern match checker about additional</span><span>
</span><span id="line-776"></span><span>       </span><span class="hs-comment">-- complete matchings which, for example, arise from pattern</span><span>
</span><span id="line-777"></span><span>       </span><span class="hs-comment">-- synonym definitions.</span><span>
</span><span id="line-778"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CompleteMatchSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-var">CompleteMatchSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XCompleteMatchSig"><span class="hs-identifier hs-type">XCompleteMatchSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-779"></span><span>                     </span><span class="annot"><a href="GHC.Types.SourceText.html#SourceText"><span class="hs-identifier hs-type">SourceText</span></a></span><span>
</span><span id="line-780"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-781"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><a href="../../base-4.16.4.0/src/GHC-Maybe.html#Maybe"><span class="hs-identifier hs-type">Maybe</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-782"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XSig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XSig"><span class="hs-identifier hs-var">XSig</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXSig"><span class="hs-identifier hs-type">XXSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077562"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-783"></span><span>
</span><span id="line-784"></span><span class="hs-comment">-- | Located Fixity Signature</span><span>
</span><span id="line-785"></span><span class="hs-keyword">type</span><span> </span><span id="LFixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LFixitySig"><span class="hs-identifier hs-var">LFixitySig</span></a></span></span><span> </span><span id="local-6989586621681077536"><span class="annot"><a href="#local-6989586621681077536"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XRec"><span class="hs-identifier hs-type">XRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077536"><span class="hs-identifier hs-type">pass</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-type">FixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077536"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-786"></span><span>
</span><span id="line-787"></span><span class="hs-comment">-- | Fixity Signature</span><span>
</span><span id="line-788"></span><span class="hs-keyword">data</span><span> </span><span id="FixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-var">FixitySig</span></a></span></span><span> </span><span id="local-6989586621681077535"><span class="annot"><a href="#local-6989586621681077535"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixitySig"><span class="hs-identifier hs-var">FixitySig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XFixitySig"><span class="hs-identifier hs-type">XFixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077535"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077535"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><a href="GHC.Types.Fixity.html#Fixity"><span class="hs-identifier hs-type">Fixity</span></a></span><span>
</span><span id="line-789"></span><span>                    </span><span class="hs-glyph">|</span><span> </span><span id="XFixitySig"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XFixitySig"><span class="hs-identifier hs-var">XFixitySig</span></a></span></span><span> </span><span class="hs-glyph">!</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#XXFixitySig"><span class="hs-identifier hs-type">XXFixitySig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077535"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-790"></span><span>
</span><span id="line-791"></span><span class="hs-comment">-- | Type checker Specialisation Pragmas</span><span>
</span><span id="line-792"></span><span class="hs-comment">--</span><span>
</span><span id="line-793"></span><span class="hs-comment">-- 'TcSpecPrags' conveys @SPECIALISE@ pragmas from the type checker to the desugarer</span><span>
</span><span id="line-794"></span><span class="hs-keyword">data</span><span> </span><span id="TcSpecPrags"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrags"><span class="hs-identifier hs-var">TcSpecPrags</span></a></span></span><span>
</span><span id="line-795"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="IsDefaultMethod"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IsDefaultMethod"><span class="hs-identifier hs-var">IsDefaultMethod</span></a></span></span><span>     </span><span class="hs-comment">-- ^ Super-specialised: a default method should</span><span>
</span><span id="line-796"></span><span>                        </span><span class="hs-comment">-- be macro-expanded at every call site</span><span>
</span><span id="line-797"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SpecPrags"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecPrags"><span class="hs-identifier hs-var">SpecPrags</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LTcSpecPrag"><span class="hs-identifier hs-type">LTcSpecPrag</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-798"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681077493"><span id="local-6989586621681077495"><span id="local-6989586621681077497"><span id="local-6989586621681077499"><span id="local-6989586621681077501"><span id="local-6989586621681077503"><span id="local-6989586621681077505"><span id="local-6989586621681077507"><span id="local-6989586621681077509"><span id="local-6989586621681077511"><span id="local-6989586621681077513"><span id="local-6989586621681077515"><span id="local-6989586621681077519"><span id="local-6989586621681077524"><span class="annot"><span class="annottext">Typeable TcSpecPrags
TcSpecPrags -&gt; DataType
TcSpecPrags -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; TcSpecPrags -&gt; TcSpecPrags
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrags -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrags -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrags -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrags -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TcSpecPrags
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TcSpecPrags -&gt; c TcSpecPrags
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TcSpecPrags)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c TcSpecPrags)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrags -&gt; m TcSpecPrags
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrags -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrags -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrags -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrags -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrags -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrags -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrags -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrags -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TcSpecPrags -&gt; TcSpecPrags
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TcSpecPrags -&gt; TcSpecPrags
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c TcSpecPrags)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c TcSpecPrags)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TcSpecPrags)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TcSpecPrags)
dataTypeOf :: TcSpecPrags -&gt; DataType
$cdataTypeOf :: TcSpecPrags -&gt; DataType
toConstr :: TcSpecPrags -&gt; Constr
$ctoConstr :: TcSpecPrags -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TcSpecPrags
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TcSpecPrags
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TcSpecPrags -&gt; c TcSpecPrags
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TcSpecPrags -&gt; c TcSpecPrags
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-799"></span><span>
</span><span id="line-800"></span><span class="hs-comment">-- | Located Type checker Specification Pragmas</span><span>
</span><span id="line-801"></span><span class="hs-keyword">type</span><span> </span><span id="LTcSpecPrag"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LTcSpecPrag"><span class="hs-identifier hs-var">LTcSpecPrag</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="GHC.Types.SrcLoc.html#Located"><span class="hs-identifier hs-type">Located</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrag"><span class="hs-identifier hs-type">TcSpecPrag</span></a></span><span>
</span><span id="line-802"></span><span>
</span><span id="line-803"></span><span class="hs-comment">-- | Type checker Specification Pragma</span><span>
</span><span id="line-804"></span><span class="hs-keyword">data</span><span> </span><span id="TcSpecPrag"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrag"><span class="hs-identifier hs-var">TcSpecPrag</span></a></span></span><span>
</span><span id="line-805"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="SpecPrag"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecPrag"><span class="hs-identifier hs-var">SpecPrag</span></a></span></span><span>
</span><span id="line-806"></span><span>        </span><span class="annot"><a href="GHC.Types.Var.html#Id"><span class="hs-identifier hs-type">Id</span></a></span><span>
</span><span id="line-807"></span><span>        </span><span class="annot"><a href="GHC.Tc.Types.Evidence.html#HsWrapper"><span class="hs-identifier hs-type">HsWrapper</span></a></span><span>
</span><span id="line-808"></span><span>        </span><span class="annot"><a href="GHC.Types.Basic.html#InlinePragma"><span class="hs-identifier hs-type">InlinePragma</span></a></span><span>
</span><span id="line-809"></span><span>  </span><span class="hs-comment">-- ^ The Id to be specialised, a wrapper that specialises the</span><span>
</span><span id="line-810"></span><span>  </span><span class="hs-comment">-- polymorphic function, and inlining spec for the specialised function</span><span>
</span><span id="line-811"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span id="local-6989586621681077445"><span id="local-6989586621681077447"><span id="local-6989586621681077449"><span id="local-6989586621681077451"><span id="local-6989586621681077453"><span id="local-6989586621681077455"><span id="local-6989586621681077457"><span id="local-6989586621681077459"><span id="local-6989586621681077461"><span id="local-6989586621681077463"><span id="local-6989586621681077465"><span id="local-6989586621681077467"><span id="local-6989586621681077472"><span id="local-6989586621681077480"><span class="annot"><span class="annottext">Typeable TcSpecPrag
TcSpecPrag -&gt; DataType
TcSpecPrag -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; TcSpecPrag -&gt; TcSpecPrag
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrag -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrag -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrag -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrag -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TcSpecPrag
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TcSpecPrag -&gt; c TcSpecPrag
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TcSpecPrag)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TcSpecPrag)
gmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
gmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
gmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; TcSpecPrag -&gt; m TcSpecPrag
gmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrag -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrag -&gt; u
gmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrag -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; TcSpecPrag -&gt; [u]
gmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrag -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrag -&gt; r
gmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrag -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; TcSpecPrag -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TcSpecPrag -&gt; TcSpecPrag
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; TcSpecPrag -&gt; TcSpecPrag
dataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TcSpecPrag)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c TcSpecPrag)
dataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TcSpecPrag)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c TcSpecPrag)
dataTypeOf :: TcSpecPrag -&gt; DataType
$cdataTypeOf :: TcSpecPrag -&gt; DataType
toConstr :: TcSpecPrag -&gt; Constr
$ctoConstr :: TcSpecPrag -&gt; Constr
gunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TcSpecPrag
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c TcSpecPrag
gfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TcSpecPrag -&gt; c TcSpecPrag
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; TcSpecPrag -&gt; c TcSpecPrag
</span><a href="../../base-4.16.4.0/src/Data-Data.html#Data"><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span>
</span><span id="line-812"></span><span>
</span><span id="line-813"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#noSpecPrags"><span class="hs-identifier hs-type">noSpecPrags</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrags"><span class="hs-identifier hs-type">TcSpecPrags</span></a></span><span>
</span><span id="line-814"></span><span id="noSpecPrags"><span class="annot"><span class="annottext">noSpecPrags :: TcSpecPrags
</span><a href="Language.Haskell.Syntax.Binds.html#noSpecPrags"><span class="hs-identifier hs-var hs-var">noSpecPrags</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[LTcSpecPrag] -&gt; TcSpecPrags
</span><a href="Language.Haskell.Syntax.Binds.html#SpecPrags"><span class="hs-identifier hs-var">SpecPrags</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-815"></span><span>
</span><span id="line-816"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hasSpecPrags"><span class="hs-identifier hs-type">hasSpecPrags</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrags"><span class="hs-identifier hs-type">TcSpecPrags</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-817"></span><span id="hasSpecPrags"><span class="annot"><span class="annottext">hasSpecPrags :: TcSpecPrags -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#hasSpecPrags"><span class="hs-identifier hs-var hs-var">hasSpecPrags</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecPrags"><span class="hs-identifier hs-type">SpecPrags</span></a></span><span> </span><span id="local-6989586621681077442"><span class="annot"><span class="annottext">[LTcSpecPrag]
</span><a href="#local-6989586621681077442"><span class="hs-identifier hs-var">ps</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><a href="../../base-4.16.4.0/src/Data-Foldable.html#null"><span class="hs-identifier hs-var">null</span></a></span><span> </span><span class="annot"><span class="annottext">[LTcSpecPrag]
</span><a href="#local-6989586621681077442"><span class="hs-identifier hs-var">ps</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-818"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hasSpecPrags"><span class="hs-identifier hs-var">hasSpecPrags</span></a></span><span> </span><span class="annot"><span class="annottext">TcSpecPrags
</span><a href="Language.Haskell.Syntax.Binds.html#IsDefaultMethod"><span class="hs-identifier hs-var">IsDefaultMethod</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-819"></span><span>
</span><span id="line-820"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isDefaultMethod"><span class="hs-identifier hs-type">isDefaultMethod</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TcSpecPrags"><span class="hs-identifier hs-type">TcSpecPrags</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-821"></span><span id="isDefaultMethod"><span class="annot"><span class="annottext">isDefaultMethod :: TcSpecPrags -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isDefaultMethod"><span class="hs-identifier hs-var hs-var">isDefaultMethod</span></a></span></span><span> </span><span class="annot"><span class="annottext">TcSpecPrags
</span><a href="Language.Haskell.Syntax.Binds.html#IsDefaultMethod"><span class="hs-identifier hs-var">IsDefaultMethod</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-822"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isDefaultMethod"><span class="hs-identifier hs-var">isDefaultMethod</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecPrags"><span class="hs-identifier hs-type">SpecPrags</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-823"></span><span>
</span><span id="line-824"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isFixityLSig"><span class="hs-identifier hs-type">isFixityLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077791"><span class="annot"><a href="#local-6989586621681077791"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-825"></span><span id="isFixityLSig"><span class="annot"><span class="annottext">isFixityLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isFixityLSig"><span class="hs-identifier hs-var hs-var">isFixityLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077791"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixSig"><span class="hs-identifier hs-type">FixSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-826"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isFixityLSig"><span class="hs-identifier hs-var">isFixityLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-827"></span><span>
</span><span id="line-828"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-type">isTypeLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077433"><span class="annot"><a href="#local-6989586621681077433"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077433"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077433"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>  </span><span class="hs-comment">-- Type signatures</span><span>
</span><span id="line-829"></span><span id="isTypeLSig"><span class="annot"><span class="annottext">isTypeLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var hs-var">isTypeLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077433"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TypeSig"><span class="hs-identifier hs-type">TypeSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-830"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var">isTypeLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077433"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ClassOpSig"><span class="hs-identifier hs-type">ClassOpSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-831"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var">isTypeLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077433"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IdSig"><span class="hs-identifier hs-type">IdSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-832"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isTypeLSig"><span class="hs-identifier hs-var">isTypeLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-833"></span><span>
</span><span id="line-834"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecLSig"><span class="hs-identifier hs-type">isSpecLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077427"><span class="annot"><a href="#local-6989586621681077427"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077427"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077427"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-835"></span><span id="isSpecLSig"><span class="annot"><span class="annottext">isSpecLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isSpecLSig"><span class="hs-identifier hs-var hs-var">isSpecLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077427"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-836"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecLSig"><span class="hs-identifier hs-var">isSpecLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-837"></span><span>
</span><span id="line-838"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecInstLSig"><span class="hs-identifier hs-type">isSpecInstLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077423"><span class="annot"><a href="#local-6989586621681077423"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077423"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077423"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-839"></span><span id="isSpecInstLSig"><span class="annot"><span class="annottext">isSpecInstLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isSpecInstLSig"><span class="hs-identifier hs-var hs-var">isSpecInstLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077423"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecInstSig"><span class="hs-identifier hs-type">SpecInstSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-840"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSpecInstLSig"><span class="hs-identifier hs-var">isSpecInstLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-841"></span><span>
</span><span id="line-842"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-type">isPragLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077419"><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-843"></span><span class="hs-comment">-- Identifies pragmas</span><span>
</span><span id="line-844"></span><span id="isPragLSig"><span class="annot"><span class="annottext">isPragLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var hs-var">isPragLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-845"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-846"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-type">SCCFunSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-847"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077419"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-type">CompleteMatchSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-848"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isPragLSig"><span class="hs-identifier hs-var">isPragLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-849"></span><span>
</span><span id="line-850"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isInlineLSig"><span class="hs-identifier hs-type">isInlineLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077412"><span class="annot"><a href="#local-6989586621681077412"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077412"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077412"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-851"></span><span class="hs-comment">-- Identifies inline pragmas</span><span>
</span><span id="line-852"></span><span id="isInlineLSig"><span class="annot"><span class="annottext">isInlineLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isInlineLSig"><span class="hs-identifier hs-var hs-var">isInlineLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077412"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-853"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isInlineLSig"><span class="hs-identifier hs-var">isInlineLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-854"></span><span>
</span><span id="line-855"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isMinimalLSig"><span class="hs-identifier hs-type">isMinimalLSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077408"><span class="annot"><a href="#local-6989586621681077408"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077408"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077408"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-856"></span><span id="isMinimalLSig"><span class="annot"><span class="annottext">isMinimalLSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isMinimalLSig"><span class="hs-identifier hs-var hs-var">isMinimalLSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077408"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#MinimalSig"><span class="hs-identifier hs-type">MinimalSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-857"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isMinimalLSig"><span class="hs-identifier hs-var">isMinimalLSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-858"></span><span>
</span><span id="line-859"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSCCFunSig"><span class="hs-identifier hs-type">isSCCFunSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077404"><span class="annot"><a href="#local-6989586621681077404"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077404"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077404"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-860"></span><span id="isSCCFunSig"><span class="annot"><span class="annottext">isSCCFunSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isSCCFunSig"><span class="hs-identifier hs-var hs-var">isSCCFunSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077404"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-type">SCCFunSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-861"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isSCCFunSig"><span class="hs-identifier hs-var">isSCCFunSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-862"></span><span>
</span><span id="line-863"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isCompleteMatchSig"><span class="hs-identifier hs-type">isCompleteMatchSig</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621681077400"><span class="annot"><a href="#local-6989586621681077400"><span class="hs-identifier hs-type">p</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#UnXRec"><span class="hs-identifier hs-type">UnXRec</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077400"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#LSig"><span class="hs-identifier hs-type">LSig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077400"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-864"></span><span id="isCompleteMatchSig"><span class="annot"><span class="annottext">isCompleteMatchSig :: forall p. UnXRec p =&gt; LSig p -&gt; Bool
</span><a href="Language.Haskell.Syntax.Binds.html#isCompleteMatchSig"><span class="hs-identifier hs-var hs-var">isCompleteMatchSig</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">forall p a. UnXRec p =&gt; XRec p a -&gt; a
</span><a href="Language.Haskell.Syntax.Extension.html#unXRec"><span class="hs-identifier hs-var">unXRec</span></a></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621681077400"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-type">CompleteMatchSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-865"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#isCompleteMatchSig"><span class="hs-identifier hs-var">isCompleteMatchSig</span></a></span><span> </span><span class="annot"><span class="annottext">LSig p
</span><span class="hs-identifier">_</span></span><span>                            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-866"></span><span>
</span><span id="line-867"></span><span id="local-6989586621681077775"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-type">hsSigDoc</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Sig"><span class="hs-identifier hs-type">Sig</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077775"><span class="hs-identifier hs-type">name</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="GHC.Utils.Outputable.html#SDoc"><span class="hs-identifier hs-type">SDoc</span></a></span></span><span>
</span><span id="line-868"></span><span id="hsSigDoc"><span class="annot"><span class="annottext">hsSigDoc :: forall name. Sig name -&gt; SDoc
</span><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var hs-var">hsSigDoc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#TypeSig"><span class="hs-identifier hs-type">TypeSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>           </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;type signature&quot;</span></span><span>
</span><span id="line-869"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#PatSynSig"><span class="hs-identifier hs-type">PatSynSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pattern synonym signature&quot;</span></span><span>
</span><span id="line-870"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ClassOpSig"><span class="hs-identifier hs-type">ClassOpSig</span></a></span><span> </span><span class="annot"><span class="annottext">XClassOpSig name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681077391"><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681077391"><span class="hs-identifier hs-var">is_deflt</span></a></span></span><span> </span><span class="annot"><span class="annottext">[LIdP name]
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LHsSigType name
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-871"></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621681077391"><span class="hs-identifier hs-var">is_deflt</span></a></span><span>                     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;default type signature&quot;</span></span><span>
</span><span id="line-872"></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="../../base-4.16.4.0/src/GHC-Base.html#otherwise"><span class="hs-identifier hs-var">otherwise</span></a></span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;class method signature&quot;</span></span><span>
</span><span id="line-873"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#IdSig"><span class="hs-identifier hs-type">IdSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;id signature&quot;</span></span><span>
</span><span id="line-874"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecSig"><span class="hs-identifier hs-type">SpecSig</span></a></span><span> </span><span class="annot"><span class="annottext">XSpecSig name
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP name
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">[LHsSigType name]
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681077390"><span class="annot"><span class="annottext">InlinePragma
</span><a href="#local-6989586621681077390"><span class="hs-identifier hs-var">inl</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-875"></span><span>                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">InlinePragma
</span><a href="#local-6989586621681077390"><span class="hs-identifier hs-var">inl</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pragma&quot;</span></span><span>
</span><span id="line-876"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#InlineSig"><span class="hs-identifier hs-type">InlineSig</span></a></span><span> </span><span class="annot"><span class="annottext">XInlineSig name
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="annottext">LIdP name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681077387"><span class="annot"><span class="annottext">InlinePragma
</span><a href="#local-6989586621681077387"><span class="hs-identifier hs-var">prag</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InlinePragma -&gt; InlineSpec
</span><a href="GHC.Types.Basic.html#inlinePragmaSpec"><span class="hs-identifier hs-var">inlinePragmaSpec</span></a></span><span> </span><span class="annot"><span class="annottext">InlinePragma
</span><a href="#local-6989586621681077387"><span class="hs-identifier hs-var">prag</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;pragma&quot;</span></span><span>
</span><span id="line-877"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SpecInstSig"><span class="hs-identifier hs-type">SpecInstSig</span></a></span><span> </span><span class="annot"><span class="annottext">XSpecInstSig name
</span><span class="hs-identifier">_</span></span><span> </span><span id="local-6989586621681077385"><span class="annot"><span class="annottext">SourceText
</span><a href="#local-6989586621681077385"><span class="hs-identifier hs-var">src</span></a></span></span><span> </span><span class="annot"><span class="annottext">LHsSigType name
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-878"></span><span>                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">SourceText -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Types.SourceText.html#pprWithSourceText"><span class="hs-identifier hs-var">pprWithSourceText</span></a></span><span> </span><span class="annot"><span class="annottext">SourceText
</span><a href="#local-6989586621681077385"><span class="hs-identifier hs-var">src</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc
</span><a href="GHC.Utils.Outputable.html#empty"><span class="hs-identifier hs-var">empty</span></a></span><span> </span><span class="annot"><span class="annottext">SDoc -&gt; SDoc -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#%3C%2B%3E"><span class="hs-operator hs-var">&lt;+&gt;</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;instance pragma&quot;</span></span><span>
</span><span id="line-879"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#FixSig"><span class="hs-identifier hs-type">FixSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;fixity declaration&quot;</span></span><span>
</span><span id="line-880"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#MinimalSig"><span class="hs-identifier hs-type">MinimalSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;MINIMAL pragma&quot;</span></span><span>
</span><span id="line-881"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#SCCFunSig"><span class="hs-identifier hs-type">SCCFunSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;SCC pragma&quot;</span></span><span>
</span><span id="line-882"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#CompleteMatchSig"><span class="hs-identifier hs-type">CompleteMatchSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;COMPLETE pragma&quot;</span></span><span>
</span><span id="line-883"></span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#hsSigDoc"><span class="hs-identifier hs-var">hsSigDoc</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#XSig"><span class="hs-identifier hs-type">XSig</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#text"><span class="hs-identifier hs-var">text</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;XSIG TTG extension&quot;</span></span><span>
</span><span id="line-884"></span><span>
</span><span id="line-885"></span><span class="hs-comment">{-
************************************************************************
*                                                                      *
\subsection[PatSynBind]{A pattern synonym definition}
*                                                                      *
************************************************************************
-}</span><span>
</span><span id="line-892"></span><span>
</span><span id="line-893"></span><span class="hs-comment">-- | Haskell Pattern Synonym Details</span><span>
</span><span id="line-894"></span><span class="hs-keyword">type</span><span> </span><span id="HsPatSynDetails"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDetails"><span class="hs-identifier hs-var">HsPatSynDetails</span></a></span></span><span> </span><span id="local-6989586621681077382"><span class="annot"><a href="#local-6989586621681077382"><span class="hs-identifier hs-type">pass</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#HsConDetails"><span class="hs-identifier hs-type">HsConDetails</span></a></span><span> </span><span class="annot"><a href="../../base-4.16.4.0/src/Data-Void.html#Void"><span class="hs-identifier hs-type">Void</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077382"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-type">RecordPatSynField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077382"><span class="hs-identifier hs-type">pass</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-895"></span><span>
</span><span id="line-896"></span><span class="hs-comment">-- See Note [Record PatSyn Fields]</span><span>
</span><span id="line-897"></span><span class="hs-comment">-- | Record Pattern Synonym Field</span><span>
</span><span id="line-898"></span><span class="hs-keyword">data</span><span> </span><span id="RecordPatSynField"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-var">RecordPatSynField</span></a></span></span><span> </span><span id="local-6989586621681077763"><span class="annot"><a href="#local-6989586621681077763"><span class="hs-identifier hs-type">pass</span></a></span></span><span>
</span><span id="line-899"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="RecordPatSynField"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-var">RecordPatSynField</span></a></span></span><span>
</span><span id="line-900"></span><span>      </span><span class="hs-special">{</span><span> </span><span id="recordPatSynField"><span class="annot"><span class="annottext">forall pass. RecordPatSynField pass -&gt; FieldOcc pass
</span><a href="Language.Haskell.Syntax.Binds.html#recordPatSynField"><span class="hs-identifier hs-var hs-var">recordPatSynField</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Type.html#FieldOcc"><span class="hs-identifier hs-type">FieldOcc</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077763"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-901"></span><span>      </span><span class="hs-comment">-- ^ Field label visible in rest of the file</span><span>
</span><span id="line-902"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="recordPatSynPatVar"><span class="annot"><span class="annottext">forall pass. RecordPatSynField pass -&gt; LIdP pass
</span><a href="Language.Haskell.Syntax.Binds.html#recordPatSynPatVar"><span class="hs-identifier hs-var hs-var">recordPatSynPatVar</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Syntax.Extension.html#LIdP"><span class="hs-identifier hs-type">LIdP</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077763"><span class="hs-identifier hs-type">pass</span></a></span><span>
</span><span id="line-903"></span><span>      </span><span class="hs-comment">-- ^ Filled in by renamer, the name used internally by the pattern</span><span>
</span><span id="line-904"></span><span>      </span><span class="hs-special">}</span><span>
</span><span id="line-905"></span><span>
</span><span id="line-906"></span><span>
</span><span id="line-907"></span><span class="hs-comment">{-
Note [Record PatSyn Fields]
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Consider the following two pattern synonyms.

  pattern P x y = ([x,True], [y,'v'])
  pattern Q{ x, y } =([x,True], [y,'v'])

In P, we just have two local binders, x and y.

In Q, we have local binders but also top-level record selectors
  x :: ([Bool], [Char]) -&gt; Bool
  y :: ([Bool], [Char]) -&gt; Char

Both are recorded in the `RecordPatSynField`s for `x` and `y`:
* recordPatSynField: the top-level record selector
* recordPatSynPatVar: the local `x`, bound only in the RHS of the pattern synonym.

It would make sense to support record-like syntax

  pattern Q{ x=x1, y=y1 } = ([x1,True], [y1,'v'])

when we have a different name for the local and top-level binder,
making the distinction between the two names clear.

-}</span><span>
</span><span id="line-934"></span><span class="hs-keyword">instance</span><span> </span><span id="local-6989586621681077757"><span class="annot"><a href="GHC.Utils.Outputable.html#Outputable"><span class="hs-identifier hs-type">Outputable</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-type">RecordPatSynField</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077757"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-935"></span><span>    </span><span id="local-6989586621681077371"><span class="annot"><span class="annottext">ppr :: RecordPatSynField a -&gt; SDoc
</span><a href="#local-6989586621681077371"><span class="hs-identifier hs-var hs-var hs-var hs-var">ppr</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#RecordPatSynField"><span class="hs-identifier hs-type">RecordPatSynField</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">recordPatSynField :: forall pass. RecordPatSynField pass -&gt; FieldOcc pass
</span><a href="Language.Haskell.Syntax.Binds.html#recordPatSynField"><span class="hs-identifier hs-var">recordPatSynField</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621681077370"><span class="annot"><span class="annottext">FieldOcc a
</span><a href="#local-6989586621681077370"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">forall a. Outputable a =&gt; a -&gt; SDoc
</span><a href="GHC.Utils.Outputable.html#ppr"><span class="hs-identifier hs-var">ppr</span></a></span><span> </span><span class="annot"><span class="annottext">FieldOcc a
</span><a href="#local-6989586621681077370"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-936"></span><span>
</span><span id="line-937"></span><span>
</span><span id="line-938"></span><span class="hs-comment">-- | Haskell Pattern Synonym Direction</span><span>
</span><span id="line-939"></span><span class="hs-keyword">data</span><span> </span><span id="HsPatSynDir"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#HsPatSynDir"><span class="hs-identifier hs-var">HsPatSynDir</span></a></span></span><span> </span><span id="local-6989586621681077369"><span class="annot"><a href="#local-6989586621681077369"><span class="hs-identifier hs-type">id</span></a></span></span><span>
</span><span id="line-940"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Unidirectional"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#Unidirectional"><span class="hs-identifier hs-var">Unidirectional</span></a></span></span><span>
</span><span id="line-941"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitBidirectional"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ImplicitBidirectional"><span class="hs-identifier hs-var">ImplicitBidirectional</span></a></span></span><span>
</span><span id="line-942"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitBidirectional"><span class="annot"><a href="Language.Haskell.Syntax.Binds.html#ExplicitBidirectional"><span class="hs-identifier hs-var">ExplicitBidirectional</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#MatchGroup"><span class="hs-identifier hs-type">MatchGroup</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077369"><span class="hs-identifier hs-type">id</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Syntax.Expr.html#LHsExpr"><span class="hs-identifier hs-type">LHsExpr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621681077369"><span class="hs-identifier hs-type">id</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-943"></span></pre></body></html>