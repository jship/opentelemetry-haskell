<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/Opt/CprAnal.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-comment'>-- | Constructed Product Result analysis. Identifies functions that surely</span>
<a name="line-4"></a><span class='hs-comment'>-- return heap-allocated records on every code path, so that we can eliminate</span>
<a name="line-5"></a><span class='hs-comment'>-- said heap allocation by performing a worker/wrapper split.</span>
<a name="line-6"></a><span class='hs-comment'>--</span>
<a name="line-7"></a><span class='hs-comment'>-- See https://www.microsoft.com/en-us/research/publication/constructed-product-result-analysis-haskell/.</span>
<a name="line-8"></a><span class='hs-comment'>-- CPR analysis should happen after strictness analysis.</span>
<a name="line-9"></a><span class='hs-comment'>-- See Note [Phase ordering].</span>
<a name="line-10"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.Opt.CprAnal</span> <span class='hs-layout'>(</span> <span class='hs-varid'>cprAnalProgram</span> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Session</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Demand</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Cpr</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Seq</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Builtin.Names</span> <span class='hs-layout'>(</span> <span class='hs-varid'>runRWKey</span> <span class='hs-layout'>)</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Env</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Id.Info</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Multiplicity</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Utils</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>exprIsHNF</span><span class='hs-layout'>,</span> <span class='hs-varid'>dumpIdInfoOfProgram</span> <span class='hs-layout'>)</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.FamInstEnv</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Opt.WorkWrap.Utils</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Logger</span>  <span class='hs-layout'>(</span> <span class='hs-conid'>Logger</span><span class='hs-layout'>,</span> <span class='hs-varid'>dumpIfSet_dyn</span><span class='hs-layout'>,</span> <span class='hs-conid'>DumpFormat</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Graph.UnVar</span> <span class='hs-comment'>-- for UnVarSet</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.Maybe</span>   <span class='hs-layout'>(</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>)</span>
<a name="line-38"></a>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control.Monad</span> <span class='hs-layout'>(</span> <span class='hs-varid'>guard</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-layout'>)</span>
<a name="line-41"></a>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Driver.Ppr</span>
<a name="line-43"></a><span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprTrace</span> <span class='hs-comment'>-- Tired of commenting out the import all the time</span>
<a name="line-44"></a>
<a name="line-45"></a><span class='hs-comment'>{- Note [Constructed Product Result]
<a name="line-46"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-47"></a>The goal of Constructed Product Result analysis is to identify functions that
<a name="line-48"></a>surely return heap-allocated records on every code path, so that we can
<a name="line-49"></a>eliminate said heap allocation by performing a worker/wrapper split.
<a name="line-50"></a>
<a name="line-51"></a>@swap@ below is such a function:
<a name="line-52"></a>
<a name="line-53"></a>  swap (a, b) = (b, a)
<a name="line-54"></a>
<a name="line-55"></a>A @case@ on an application of @swap@, like
<a name="line-56"></a>@case swap (10, 42) of (a, b) -&gt; a + b@ could cancel away
<a name="line-57"></a>(by case-of-known-constructor) if we "inlined" @swap@ and simplified. We then
<a name="line-58"></a>say that @swap@ has the CPR property.
<a name="line-59"></a>
<a name="line-60"></a>We can't inline recursive functions, but similar reasoning applies there:
<a name="line-61"></a>
<a name="line-62"></a>  f x n = case n of
<a name="line-63"></a>    0 -&gt; (x, 0)
<a name="line-64"></a>    _ -&gt; f (x+1) (n-1)
<a name="line-65"></a>
<a name="line-66"></a>Inductively, @case f 1 2 of (a, b) -&gt; a + b@ could cancel away the constructed
<a name="line-67"></a>product with the case. So @f@, too, has the CPR property. But we can't really
<a name="line-68"></a>"inline" @f@, because it's recursive. Also, non-recursive functions like @swap@
<a name="line-69"></a>might be too big to inline (or even marked NOINLINE). We still want to exploit
<a name="line-70"></a>the CPR property, and that is exactly what the worker/wrapper transformation
<a name="line-71"></a>can do for us:
<a name="line-72"></a>
<a name="line-73"></a>  $wf x n = case n of
<a name="line-74"></a>    0 -&gt; case (x, 0) of -&gt; (a, b) -&gt; (# a, b #)
<a name="line-75"></a>    _ -&gt; case f (x+1) (n-1) of (a, b) -&gt; (# a, b #)
<a name="line-76"></a>  f x n = case $wf x n of (# a, b #) -&gt; (a, b)
<a name="line-77"></a>
<a name="line-78"></a>where $wf readily simplifies (by case-of-known-constructor and inlining @f@) to:
<a name="line-79"></a>
<a name="line-80"></a>  $wf x n = case n of
<a name="line-81"></a>    0 -&gt; (# x, 0 #)
<a name="line-82"></a>    _ -&gt; $wf (x+1) (n-1)
<a name="line-83"></a>
<a name="line-84"></a>Now, a call site like @case f 1 2 of (a, b) -&gt; a + b@ can inline @f@ and
<a name="line-85"></a>eliminate the heap-allocated pair constructor.
<a name="line-86"></a>
<a name="line-87"></a>Note [Phase ordering]
<a name="line-88"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-89"></a>We need to perform strictness analysis before CPR analysis, because that might
<a name="line-90"></a>unbox some arguments, in turn leading to more constructed products.
<a name="line-91"></a>Ideally, we would want the following pipeline:
<a name="line-92"></a>
<a name="line-93"></a>1. Strictness
<a name="line-94"></a>2. worker/wrapper (for strictness)
<a name="line-95"></a>3. CPR
<a name="line-96"></a>4. worker/wrapper (for CPR)
<a name="line-97"></a>
<a name="line-98"></a>Currently, we omit 2. and anticipate the results of worker/wrapper.
<a name="line-99"></a>See Note [CPR for binders that will be unboxed]
<a name="line-100"></a>and Note [Optimistic field binder CPR].
<a name="line-101"></a>An additional w/w pass would simplify things, but probably add slight overhead.
<a name="line-102"></a>So currently we have
<a name="line-103"></a>
<a name="line-104"></a>1. Strictness
<a name="line-105"></a>2. CPR
<a name="line-106"></a>3. worker/wrapper (for strictness and CPR)
<a name="line-107"></a>-}</span>
<a name="line-108"></a>
<a name="line-109"></a><span class='hs-comment'>--</span>
<a name="line-110"></a><span class='hs-comment'>-- * Analysing programs</span>
<a name="line-111"></a><span class='hs-comment'>--</span>
<a name="line-112"></a>
<a name="line-113"></a><a name="cprAnalProgram"></a><span class='hs-definition'>cprAnalProgram</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Logger</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreProgram</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>IO</span> <span class='hs-conid'>CoreProgram</span>
<a name="line-114"></a><span class='hs-definition'>cprAnalProgram</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fam_envs</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-115"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>env</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyAnalEnv</span> <span class='hs-varid'>fam_envs</span>
<a name="line-116"></a>  <span class='hs-keyword'>let</span> <span class='hs-varid'>binds_plus_cpr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>snd</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>cprAnalTopBind</span> <span class='hs-varid'>env</span> <span class='hs-varid'>binds</span>
<a name="line-117"></a>  <span class='hs-varid'>dumpIfSet_dyn</span> <span class='hs-varid'>logger</span> <span class='hs-varid'>dflags</span> <span class='hs-conid'>Opt_D_dump_cpr_signatures</span> <span class='hs-str'>"Cpr signatures"</span> <span class='hs-conid'>FormatText</span> <span class='hs-varop'>$</span>
<a name="line-118"></a>    <span class='hs-varid'>dumpIdInfoOfProgram</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>cprInfo</span><span class='hs-layout'>)</span> <span class='hs-varid'>binds_plus_cpr</span>
<a name="line-119"></a>  <span class='hs-comment'>-- See Note [Stamp out space leaks in demand analysis] in GHC.Core.Opt.DmdAnal</span>
<a name="line-120"></a>  <span class='hs-varid'>seqBinds</span> <span class='hs-varid'>binds_plus_cpr</span> <span class='hs-varop'>`seq`</span> <span class='hs-varid'>return</span> <span class='hs-varid'>binds_plus_cpr</span>
<a name="line-121"></a>
<a name="line-122"></a><a name="cprAnalTopBind"></a><span class='hs-comment'>-- Analyse a (group of) top-level binding(s)</span>
<a name="line-123"></a><span class='hs-definition'>cprAnalTopBind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-124"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreBind</span>
<a name="line-125"></a>               <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreBind</span><span class='hs-layout'>)</span>
<a name="line-126"></a><span class='hs-definition'>cprAnalTopBind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-127"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-conid'>NonRec</span> <span class='hs-varid'>id'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-128"></a>  <span class='hs-keyword'>where</span>
<a name="line-129"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalBind</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-130"></a>
<a name="line-131"></a><span class='hs-definition'>cprAnalTopBind</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span>
<a name="line-132"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-133"></a>  <span class='hs-keyword'>where</span>
<a name="line-134"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprFix</span> <span class='hs-conid'>TopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span>
<a name="line-135"></a>
<a name="line-136"></a><span class='hs-comment'>--</span>
<a name="line-137"></a><span class='hs-comment'>-- * Analysing expressions</span>
<a name="line-138"></a><span class='hs-comment'>--</span>
<a name="line-139"></a>
<a name="line-140"></a><a name="cprAnal"></a><span class='hs-comment'>-- | The abstract semantic function ⟦_⟧ : Expr -&gt; Env -&gt; A from</span>
<a name="line-141"></a><span class='hs-comment'>-- "Constructed Product Result Analysis for Haskell"</span>
<a name="line-142"></a><span class='hs-definition'>cprAnal</span><span class='hs-layout'>,</span> <span class='hs-varid'>cprAnal'</span>
<a name="line-143"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-144"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>            <span class='hs-comment'>-- ^ expression to be denoted by a 'CprType'</span>
<a name="line-145"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>CprType</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ the updated expression and its 'CprType'</span>
<a name="line-146"></a>
<a name="line-147"></a><span class='hs-definition'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTraceWith "cprAnal" (\res -&gt; ppr (fst (res)) $$ ppr e) $</span>
<a name="line-148"></a>                  <span class='hs-varid'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-149"></a>
<a name="line-150"></a><a name="cprAnal'"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>topCprType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lit</span> <span class='hs-varid'>lit</span><span class='hs-layout'>)</span>
<a name="line-151"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>topCprType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Type</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- Doesn't happen, in fact</span>
<a name="line-152"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>topCprType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-153"></a>
<a name="line-154"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cast</span> <span class='hs-varid'>e</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-155"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>cpr_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Cast</span> <span class='hs-varid'>e'</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-156"></a>  <span class='hs-keyword'>where</span>
<a name="line-157"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>cpr_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-158"></a>
<a name="line-159"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e</span><span class='hs-layout'>)</span>
<a name="line-160"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>cpr_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Tick</span> <span class='hs-varid'>t</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span>
<a name="line-161"></a>  <span class='hs-keyword'>where</span>
<a name="line-162"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>cpr_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-163"></a>
<a name="line-164"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Var</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-165"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-166"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>App</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-167"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>[]</span>
<a name="line-168"></a>
<a name="line-169"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-170"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>var</span>
<a name="line-171"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>body</span>
<a name="line-172"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-173"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-174"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>lam_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Lam</span> <span class='hs-varid'>var</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-175"></a>  <span class='hs-keyword'>where</span>
<a name="line-176"></a>    <span class='hs-comment'>-- See Note [CPR for binders that will be unboxed]</span>
<a name="line-177"></a>    <span class='hs-varid'>env'</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnvForArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>var</span>
<a name="line-178"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body</span>
<a name="line-179"></a>    <span class='hs-varid'>lam_ty</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>abstractCprTy</span> <span class='hs-varid'>body_ty</span>
<a name="line-180"></a>
<a name="line-181"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Case</span> <span class='hs-varid'>scrut</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts</span><span class='hs-layout'>)</span>
<a name="line-182"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>res_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Case</span> <span class='hs-varid'>scrut'</span> <span class='hs-varid'>case_bndr</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>
<a name="line-183"></a>  <span class='hs-keyword'>where</span>
<a name="line-184"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>scrut_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>scrut'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut</span>
<a name="line-185"></a>    <span class='hs-varid'>env'</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>case_bndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CprSig</span> <span class='hs-varid'>scrut_ty</span><span class='hs-layout'>)</span>
<a name="line-186"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>alt_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>alts'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAndUnzip</span> <span class='hs-layout'>(</span><span class='hs-varid'>cprAnalAlt</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>scrut_ty</span><span class='hs-layout'>)</span> <span class='hs-varid'>alts</span>
<a name="line-187"></a>    <span class='hs-varid'>res_ty</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-varid'>lubCprType</span> <span class='hs-varid'>botCprType</span> <span class='hs-varid'>alt_tys</span>
<a name="line-188"></a>
<a name="line-189"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-190"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>NonRec</span> <span class='hs-varid'>id'</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-191"></a>  <span class='hs-keyword'>where</span>
<a name="line-192"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalBind</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-193"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body</span>
<a name="line-194"></a>
<a name="line-195"></a><span class='hs-definition'>cprAnal'</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs</span><span class='hs-layout'>)</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-196"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>body_ty</span> <span class='hs-varop'>`seq`</span> <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Rec</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span>
<a name="line-197"></a>  <span class='hs-keyword'>where</span>
<a name="line-198"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprFix</span> <span class='hs-conid'>NotTopLevel</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span>
<a name="line-199"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>body_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>body'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>body</span>
<a name="line-200"></a>
<a name="line-201"></a><a name="cprAnalAlt"></a><span class='hs-definition'>cprAnalAlt</span>
<a name="line-202"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-203"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CprType</span> <span class='hs-comment'>-- ^ CPR type of the scrutinee</span>
<a name="line-204"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>Var</span> <span class='hs-comment'>-- ^ current alternative</span>
<a name="line-205"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>CprType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-conid'>Var</span><span class='hs-layout'>)</span>
<a name="line-206"></a><span class='hs-definition'>cprAnalAlt</span> <span class='hs-varid'>env</span> <span class='hs-varid'>scrut_ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-207"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-conid'>Alt</span> <span class='hs-varid'>con</span> <span class='hs-varid'>bndrs</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>
<a name="line-208"></a>  <span class='hs-keyword'>where</span>
<a name="line-209"></a>    <span class='hs-varid'>env_alt</span>
<a name="line-210"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DataAlt</span> <span class='hs-varid'>dc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>con</span>
<a name="line-211"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ids</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isId</span> <span class='hs-varid'>bndrs</span>
<a name="line-212"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>CprType</span> <span class='hs-varid'>arity</span> <span class='hs-varid'>cpr</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>scrut_ty</span>
<a name="line-213"></a>      <span class='hs-layout'>,</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>arity</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-layout'>)</span> <span class='hs-conid'>True</span>
<a name="line-214"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>unpackConFieldsCpr</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>cpr</span> <span class='hs-keyword'>of</span>
<a name="line-215"></a>          <span class='hs-conid'>AllFieldsSame</span> <span class='hs-varid'>field_cpr</span>
<a name="line-216"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCprSig</span> <span class='hs-num'>0</span> <span class='hs-varid'>field_cpr</span>
<a name="line-217"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendSigEnvAllSame</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>sig</span>
<a name="line-218"></a>          <span class='hs-conid'>ForeachField</span> <span class='hs-varid'>field_cprs</span>
<a name="line-219"></a>            <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zipWith</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkCprSig</span> <span class='hs-varop'>.</span> <span class='hs-varid'>idArity</span><span class='hs-layout'>)</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>field_cprs</span>
<a name="line-220"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendSigEnvList</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipEqual</span> <span class='hs-str'>"cprAnalAlt"</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>sigs</span><span class='hs-layout'>)</span>
<a name="line-221"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-222"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span>
<a name="line-223"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env_alt</span> <span class='hs-varid'>rhs</span>
<a name="line-224"></a>
<a name="line-225"></a><span class='hs-comment'>--</span>
<a name="line-226"></a><span class='hs-comment'>-- * CPR transformer</span>
<a name="line-227"></a><span class='hs-comment'>--</span>
<a name="line-228"></a>
<a name="line-229"></a><a name="cprAnalApp"></a><span class='hs-definition'>cprAnalApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CoreArg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CprType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>CprType</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span>
<a name="line-230"></a><span class='hs-definition'>cprAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span> <span class='hs-varid'>args'</span> <span class='hs-varid'>arg_tys</span>
<a name="line-231"></a>  <span class='hs-comment'>-- Collect CprTypes for (value) args (inlined collectArgs):</span>
<a name="line-232"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>App</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>e</span><span class='hs-layout'>,</span> <span class='hs-varid'>isTypeArg</span> <span class='hs-varid'>arg</span> <span class='hs-comment'>-- Don't analyse Type args</span>
<a name="line-233"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg</span><span class='hs-conop'>:</span><span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg_tys</span>
<a name="line-234"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>App</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>e</span>
<a name="line-235"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>arg'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg</span>
<a name="line-236"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalApp</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg'</span><span class='hs-conop'>:</span><span class='hs-varid'>args'</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>arg_ty</span><span class='hs-conop'>:</span><span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span>
<a name="line-237"></a>
<a name="line-238"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Var</span> <span class='hs-varid'>fn</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>e</span>
<a name="line-239"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>cprTransform</span> <span class='hs-varid'>env</span> <span class='hs-varid'>fn</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>e</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>
<a name="line-240"></a>
<a name="line-241"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-comment'>-- e is not an App and not a Var</span>
<a name="line-242"></a>  <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>e_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>e'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>e</span>
<a name="line-243"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyCprTy</span> <span class='hs-varid'>e_ty</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>arg_tys</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkApps</span> <span class='hs-varid'>e'</span> <span class='hs-varid'>args'</span><span class='hs-layout'>)</span>
<a name="line-244"></a>
<a name="line-245"></a><a name="cprTransform"></a><span class='hs-definition'>cprTransform</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span>   <span class='hs-comment'>-- ^ The analysis environment</span>
<a name="line-246"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>        <span class='hs-comment'>-- ^ The function</span>
<a name="line-247"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CprType</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- ^ info about incoming /value/ arguments</span>
<a name="line-248"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CprType</span>   <span class='hs-comment'>-- ^ The demand type of the application</span>
<a name="line-249"></a><span class='hs-definition'>cprTransform</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>args</span>
<a name="line-250"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- pprTrace "cprTransform" (vcat [ppr id, ppr args, ppr sig])</span>
<a name="line-251"></a>    <span class='hs-varid'>sig</span>
<a name="line-252"></a>  <span class='hs-keyword'>where</span>
<a name="line-253"></a>    <span class='hs-varid'>sig</span>
<a name="line-254"></a>      <span class='hs-comment'>-- Top-level binding, local let-binding, lambda arg or case binder</span>
<a name="line-255"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>sig</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span>
<a name="line-256"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyCprTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>getCprSig</span> <span class='hs-varid'>sig</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-257"></a>      <span class='hs-comment'>-- CPR transformers for special Ids</span>
<a name="line-258"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>cpr_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cprTransformSpecial</span> <span class='hs-varid'>id</span> <span class='hs-varid'>args</span>
<a name="line-259"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cpr_ty</span>
<a name="line-260"></a>      <span class='hs-comment'>-- See Note [CPR for data structures]</span>
<a name="line-261"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>cprDataStructureUnfolding_maybe</span> <span class='hs-varid'>id</span>
<a name="line-262"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fst</span> <span class='hs-varop'>$</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs</span>
<a name="line-263"></a>      <span class='hs-comment'>-- Imported function or data con worker</span>
<a name="line-264"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isGlobalId</span> <span class='hs-varid'>id</span>
<a name="line-265"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>applyCprTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>getCprSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>idCprInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-266"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-267"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topCprType</span>
<a name="line-268"></a>
<a name="line-269"></a><a name="cprTransformSpecial"></a><span class='hs-comment'>-- | CPR transformers for special Ids</span>
<a name="line-270"></a><span class='hs-definition'>cprTransformSpecial</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CprType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CprType</span>
<a name="line-271"></a><span class='hs-definition'>cprTransformSpecial</span> <span class='hs-varid'>id</span> <span class='hs-varid'>args</span>
<a name="line-272"></a>  <span class='hs-comment'>-- See Note [Simplification of runRW#] in GHC.CoreToStg.Prep</span>
<a name="line-273"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>idUnique</span> <span class='hs-varid'>id</span> <span class='hs-varop'>==</span> <span class='hs-varid'>runRWKey</span> <span class='hs-comment'>-- `runRW (\s -&gt; e)`</span>
<a name="line-274"></a>  <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>arg</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>args</span>           <span class='hs-comment'>-- `\s -&gt; e` has CPR type `arg` (e.g. `. -&gt; 2`)</span>
<a name="line-275"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varop'>$</span> <span class='hs-varid'>applyCprTy</span> <span class='hs-varid'>arg</span> <span class='hs-num'>1</span> <span class='hs-comment'>-- `e` has CPR type `2`</span>
<a name="line-276"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-277"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-278"></a>
<a name="line-279"></a><span class='hs-comment'>--</span>
<a name="line-280"></a><span class='hs-comment'>-- * Bindings</span>
<a name="line-281"></a><span class='hs-comment'>--</span>
<a name="line-282"></a>
<a name="line-283"></a><a name="cprFix"></a><span class='hs-comment'>-- Recursive bindings</span>
<a name="line-284"></a><span class='hs-definition'>cprFix</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-285"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>                    <span class='hs-comment'>-- Does not include bindings for this binding</span>
<a name="line-286"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-287"></a>       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Binders annotated with CPR info</span>
<a name="line-288"></a><span class='hs-definition'>cprFix</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>orig_env</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-289"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-num'>1</span> <span class='hs-varid'>init_env</span> <span class='hs-varid'>init_pairs</span>
<a name="line-290"></a>  <span class='hs-keyword'>where</span>
<a name="line-291"></a>    <span class='hs-varid'>init_sig</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-292"></a>      <span class='hs-comment'>-- See Note [CPR for data structures]</span>
<a name="line-293"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDataStructure</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topCprSig</span>
<a name="line-294"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCprSig</span> <span class='hs-num'>0</span> <span class='hs-varid'>botCpr</span>
<a name="line-295"></a>    <span class='hs-comment'>-- See Note [Initialising strictness] in GHC.Core.Opt.DmdAnal</span>
<a name="line-296"></a>    <span class='hs-varid'>orig_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-varid'>orig_env</span>
<a name="line-297"></a>    <span class='hs-varid'>init_pairs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>orig_virgin</span>  <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>setIdCprInfo</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>init_sig</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>orig_pairs</span> <span class='hs-keyglyph'>]</span>
<a name="line-298"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_pairs</span>
<a name="line-299"></a>    <span class='hs-varid'>init_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnvFromIds</span> <span class='hs-varid'>orig_env</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fst</span> <span class='hs-varid'>init_pairs</span><span class='hs-layout'>)</span>
<a name="line-300"></a>
<a name="line-301"></a>    <span class='hs-comment'>-- The fixed-point varies the idCprInfo field of the binders and and their</span>
<a name="line-302"></a>    <span class='hs-comment'>-- entries in the AnalEnv, and terminates if that annotation does not change</span>
<a name="line-303"></a>    <span class='hs-comment'>-- any more.</span>
<a name="line-304"></a>    <span class='hs-varid'>loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span><span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-305"></a>    <span class='hs-varid'>loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span>
<a name="line-306"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>found_fixpoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>reset_env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span>
<a name="line-307"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>pairs'</span>
<a name="line-308"></a>      <span class='hs-keyword'>where</span>
<a name="line-309"></a>        <span class='hs-comment'>-- In all but the first iteration, delete the virgin flag</span>
<a name="line-310"></a>        <span class='hs-comment'>-- See Note [Initialising strictness] in GHC.Core.Opt.DmdAnal</span>
<a name="line-311"></a>        <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-varid'>pairs'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>step</span> <span class='hs-layout'>(</span><span class='hs-varid'>applyWhen</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>/=</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>nonVirgin</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span>
<a name="line-312"></a>        <span class='hs-comment'>-- Make sure we reset the virgin flag to what it was when we are stable</span>
<a name="line-313"></a>        <span class='hs-varid'>reset_env'</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env'</span><span class='hs-layout'>{</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>orig_virgin</span> <span class='hs-layout'>}</span>
<a name="line-314"></a>        <span class='hs-varid'>found_fixpoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>idCprInfo</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>idCprInfo</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fst</span><span class='hs-layout'>)</span> <span class='hs-varid'>pairs</span>
<a name="line-315"></a>
<a name="line-316"></a>    <span class='hs-varid'>step</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>AnalEnv</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-317"></a>    <span class='hs-varid'>step</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapAccumL</span> <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-varid'>pairs</span>
<a name="line-318"></a>      <span class='hs-keyword'>where</span>
<a name="line-319"></a>        <span class='hs-varid'>go</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>env'</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-320"></a>          <span class='hs-keyword'>where</span>
<a name="line-321"></a>            <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnalBind</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-322"></a>
<a name="line-323"></a><a name="cprAnalBind"></a><span class='hs-comment'>-- | Process the RHS of the binding for a sensible arity, add the CPR signature</span>
<a name="line-324"></a><span class='hs-comment'>-- to the Id, and augment the environment with the signature as well.</span>
<a name="line-325"></a><span class='hs-definition'>cprAnalBind</span>
<a name="line-326"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TopLevelFlag</span>
<a name="line-327"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-328"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span>
<a name="line-329"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-330"></a>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoreExpr</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnalEnv</span><span class='hs-layout'>)</span>
<a name="line-331"></a><span class='hs-definition'>cprAnalBind</span> <span class='hs-varid'>top_lvl</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-332"></a>  <span class='hs-comment'>-- See Note [CPR for data structures]</span>
<a name="line-333"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isDataStructure</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span>
<a name="line-334"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span>  <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span>  <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Data structure =&gt; no code =&gt; need to analyse rhs</span>
<a name="line-335"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-336"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>id'</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>,</span> <span class='hs-varid'>env'</span><span class='hs-layout'>)</span>
<a name="line-337"></a>  <span class='hs-keyword'>where</span>
<a name="line-338"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs'</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cprAnal</span> <span class='hs-varid'>env</span> <span class='hs-varid'>rhs</span>
<a name="line-339"></a>    <span class='hs-comment'>-- possibly trim thunk CPR info</span>
<a name="line-340"></a>    <span class='hs-varid'>rhs_ty'</span>
<a name="line-341"></a>      <span class='hs-comment'>-- See Note [CPR for thunks]</span>
<a name="line-342"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>stays_thunk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trimCprTy</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-343"></a>      <span class='hs-comment'>-- See Note [CPR for sum types]</span>
<a name="line-344"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>returns_sum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trimCprTy</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-345"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-346"></a>    <span class='hs-comment'>-- See Note [Arity trimming for CPR signatures]</span>
<a name="line-347"></a>    <span class='hs-varid'>sig</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkCprSigForArity</span> <span class='hs-layout'>(</span><span class='hs-varid'>idArity</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs_ty'</span>
<a name="line-348"></a>    <span class='hs-varid'>id'</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setIdCprInfo</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span>
<a name="line-349"></a>    <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span>
<a name="line-350"></a>
<a name="line-351"></a>    <span class='hs-comment'>-- See Note [CPR for thunks]</span>
<a name="line-352"></a>    <span class='hs-varid'>stays_thunk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_thunk</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not_strict</span>
<a name="line-353"></a>    <span class='hs-varid'>is_thunk</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>exprIsHNF</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isJoinId</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-354"></a>    <span class='hs-varid'>not_strict</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isStrUsedDmd</span> <span class='hs-layout'>(</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-355"></a>    <span class='hs-comment'>-- See Note [CPR for sum types]</span>
<a name="line-356"></a>    <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-varid'>ret_ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitPiTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-357"></a>    <span class='hs-varid'>not_a_prod</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNothing</span> <span class='hs-layout'>(</span><span class='hs-varid'>splitArgType_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>ret_ty</span><span class='hs-layout'>)</span>
<a name="line-358"></a>    <span class='hs-varid'>returns_sum</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTopLevel</span> <span class='hs-varid'>top_lvl</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not_a_prod</span>
<a name="line-359"></a>
<a name="line-360"></a><a name="isDataStructure"></a><span class='hs-definition'>isDataStructure</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoreExpr</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-361"></a><span class='hs-comment'>-- See Note [CPR for data structures]</span>
<a name="line-362"></a><span class='hs-definition'>isDataStructure</span> <span class='hs-varid'>id</span> <span class='hs-varid'>rhs</span> <span class='hs-keyglyph'>=</span>
<a name="line-363"></a>  <span class='hs-varid'>idArity</span> <span class='hs-varid'>id</span> <span class='hs-varop'>==</span> <span class='hs-num'>0</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>exprIsHNF</span> <span class='hs-varid'>rhs</span>
<a name="line-364"></a>
<a name="line-365"></a><a name="cprDataStructureUnfolding_maybe"></a><span class='hs-comment'>-- | Returns an expandable unfolding</span>
<a name="line-366"></a><span class='hs-comment'>-- (See Note [exprIsExpandable] in "GHC.Core.Utils") that has</span>
<a name="line-367"></a><span class='hs-comment'>-- So effectively is a constructor application.</span>
<a name="line-368"></a><span class='hs-definition'>cprDataStructureUnfolding_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CoreExpr</span>
<a name="line-369"></a><span class='hs-definition'>cprDataStructureUnfolding_maybe</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span>
<a name="line-370"></a>  <span class='hs-comment'>-- There are only FinalPhase Simplifier runs after CPR analysis</span>
<a name="line-371"></a>  <span class='hs-varid'>guard</span> <span class='hs-layout'>(</span><span class='hs-varid'>activeInFinalPhase</span> <span class='hs-layout'>(</span><span class='hs-varid'>idInlineActivation</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-372"></a>  <span class='hs-varid'>unf</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>expandUnfolding_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>idUnfolding</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-373"></a>  <span class='hs-varid'>guard</span> <span class='hs-layout'>(</span><span class='hs-varid'>isDataStructure</span> <span class='hs-varid'>id</span> <span class='hs-varid'>unf</span><span class='hs-layout'>)</span>
<a name="line-374"></a>  <span class='hs-varid'>return</span> <span class='hs-varid'>unf</span>
<a name="line-375"></a>
<a name="line-376"></a><span class='hs-comment'>{- Note [Arity trimming for CPR signatures]
<a name="line-377"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-378"></a>Although it doesn't affect correctness of the analysis per se, we have to trim
<a name="line-379"></a>CPR signatures to idArity. Here's what might happen if we don't:
<a name="line-380"></a>
<a name="line-381"></a>  f x = if expensive
<a name="line-382"></a>          then \y. Box y
<a name="line-383"></a>          else \z. Box z
<a name="line-384"></a>  g a b = f a b
<a name="line-385"></a>
<a name="line-386"></a>The two lambdas will have a CPR type of @1m@ (so construct a product after
<a name="line-387"></a>applied to one argument). Thus, @f@ will have a CPR signature of @2m@
<a name="line-388"></a>(constructs a product after applied to two arguments).
<a name="line-389"></a>But WW will never eta-expand @f@! In this case that would amount to possibly
<a name="line-390"></a>duplicating @expensive@ work.
<a name="line-391"></a>
<a name="line-392"></a>(Side note: Even if @f@'s 'idArity' happened to be 2, it would not do so, see
<a name="line-393"></a>Note [Don't eta expand in w/w].)
<a name="line-394"></a>
<a name="line-395"></a>So @f@ will not be worker/wrappered. But @g@ also inherited its CPR signature
<a name="line-396"></a>from @f@'s, so it *will* be WW'd:
<a name="line-397"></a>
<a name="line-398"></a>  f x = if expensive
<a name="line-399"></a>          then \y. Box y
<a name="line-400"></a>          else \z. Box z
<a name="line-401"></a>  $wg a b = case f a b of Box x -&gt; x
<a name="line-402"></a>  g a b = Box ($wg a b)
<a name="line-403"></a>
<a name="line-404"></a>And the case in @g@ can never cancel away, thus we introduced extra reboxing.
<a name="line-405"></a>Hence we always trim the CPR signature of a binding to idArity.
<a name="line-406"></a>-}</span>
<a name="line-407"></a>
<a name="line-408"></a><a name="AnalEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-409"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span>
<a name="line-410"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SigEnv</span>
<a name="line-411"></a>  <span class='hs-comment'>-- ^ Current approximation of signatures for local ids</span>
<a name="line-412"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-413"></a>  <span class='hs-comment'>-- ^ True only on every first iteration in a fixed-point</span>
<a name="line-414"></a>  <span class='hs-comment'>-- iteration. See Note [Initialising strictness] in "GHC.Core.Opt.DmdAnal"</span>
<a name="line-415"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span>
<a name="line-416"></a>  <span class='hs-comment'>-- ^ Needed when expanding type families and synonyms of product types.</span>
<a name="line-417"></a>  <span class='hs-layout'>}</span>
<a name="line-418"></a>
<a name="line-419"></a><a name="instance%20Outputable%20AnalEnv"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyword'>where</span>
<a name="line-420"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>AE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>virgin</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-421"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"AE"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-422"></a>         <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_virgin ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>virgin</span>
<a name="line-423"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"ae_sigs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-424"></a>
<a name="line-425"></a><a name="SigEnv"></a><span class='hs-comment'>-- | An environment storing 'CprSig's for local Ids.</span>
<a name="line-426"></a><a name="SigEnv"></a><span class='hs-comment'>-- Puts binders with 'topCprSig' in a space-saving 'IntSet'.</span>
<a name="line-427"></a><a name="SigEnv"></a><span class='hs-comment'>-- See Note [Efficient Top sigs in SigEnv].</span>
<a name="line-428"></a><a name="SigEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SigEnv</span>
<a name="line-429"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SE</span>
<a name="line-430"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>se_tops</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-conid'>UnVarSet</span>
<a name="line-431"></a>  <span class='hs-comment'>-- ^ All these Ids have 'topCprSig'. Like a 'VarSet', but more efficient.</span>
<a name="line-432"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>se_sigs</span> <span class='hs-keyglyph'>::</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>VarEnv</span> <span class='hs-conid'>CprSig</span><span class='hs-layout'>)</span>
<a name="line-433"></a>  <span class='hs-comment'>-- ^ Ids that have something other than 'topCprSig'.</span>
<a name="line-434"></a>  <span class='hs-layout'>}</span>
<a name="line-435"></a>
<a name="line-436"></a><a name="instance%20Outputable%20SigEnv"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>SigEnv</span> <span class='hs-keyword'>where</span>
<a name="line-437"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>SE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>se_tops</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tops</span><span class='hs-layout'>,</span> <span class='hs-varid'>se_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>sigs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-438"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"SE"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span>
<a name="line-439"></a>         <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"se_tops ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tops</span>
<a name="line-440"></a>         <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"se_sigs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>sigs</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-441"></a>
<a name="line-442"></a><a name="emptyAnalEnv"></a><span class='hs-definition'>emptyAnalEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FamInstEnvs</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-443"></a><span class='hs-definition'>emptyAnalEnv</span> <span class='hs-varid'>fam_envs</span>
<a name="line-444"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>AE</span>
<a name="line-445"></a>  <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SE</span> <span class='hs-varid'>emptyUnVarSet</span> <span class='hs-varid'>emptyVarEnv</span>
<a name="line-446"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-447"></a>  <span class='hs-layout'>,</span> <span class='hs-varid'>ae_fam_envs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fam_envs</span>
<a name="line-448"></a>  <span class='hs-layout'>}</span>
<a name="line-449"></a>
<a name="line-450"></a><a name="modifySigEnv"></a><span class='hs-definition'>modifySigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>SigEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SigEnv</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-451"></a><span class='hs-definition'>modifySigEnv</span> <span class='hs-varid'>f</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_sigs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-452"></a>
<a name="line-453"></a><a name="lookupSigEnv"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>CprSig</span>
<a name="line-454"></a><span class='hs-comment'>-- See Note [Efficient Top sigs in SigEnv]</span>
<a name="line-455"></a><span class='hs-definition'>lookupSigEnv</span> <span class='hs-conid'>AE</span><span class='hs-layout'>{</span><span class='hs-varid'>ae_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>SE</span> <span class='hs-varid'>tops</span> <span class='hs-varid'>sigs</span><span class='hs-layout'>}</span> <span class='hs-varid'>id</span>
<a name="line-456"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>id</span> <span class='hs-varop'>`elemUnVarSet`</span> <span class='hs-varid'>tops</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>topCprSig</span>
<a name="line-457"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>sigs</span> <span class='hs-varid'>id</span>
<a name="line-458"></a>
<a name="line-459"></a><a name="extendSigEnv"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CprSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-460"></a><span class='hs-comment'>-- See Note [Efficient Top sigs in SigEnv]</span>
<a name="line-461"></a><span class='hs-definition'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span>
<a name="line-462"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTopCprSig</span> <span class='hs-varid'>sig</span>
<a name="line-463"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifySigEnv</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>se</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>se</span><span class='hs-layout'>{</span><span class='hs-varid'>se_tops</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendUnVarSet</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>se_tops</span> <span class='hs-varid'>se</span><span class='hs-layout'>)</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span>
<a name="line-464"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-465"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>modifySigEnv</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>se</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>se</span><span class='hs-layout'>{</span><span class='hs-varid'>se_sigs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendVarEnv</span> <span class='hs-layout'>(</span><span class='hs-varid'>se_sigs</span> <span class='hs-varid'>se</span><span class='hs-layout'>)</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span>
<a name="line-466"></a>
<a name="line-467"></a><a name="extendSigEnvList"></a><span class='hs-comment'>-- | Extend an environment with the (Id, CPR sig) pairs</span>
<a name="line-468"></a><span class='hs-definition'>extendSigEnvList</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Id</span><span class='hs-layout'>,</span> <span class='hs-conid'>CprSig</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-469"></a><span class='hs-definition'>extendSigEnvList</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids_cprs</span>
<a name="line-470"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>id</span><span class='hs-layout'>,</span> <span class='hs-varid'>sig</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids_cprs</span>
<a name="line-471"></a>
<a name="line-472"></a><a name="extendSigEnvFromIds"></a><span class='hs-comment'>-- | Extend an environment with the CPR sigs attached to the ids</span>
<a name="line-473"></a><span class='hs-definition'>extendSigEnvFromIds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-474"></a><span class='hs-definition'>extendSigEnvFromIds</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids</span>
<a name="line-475"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-varid'>idCprInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids</span>
<a name="line-476"></a>
<a name="line-477"></a><a name="extendSigEnvAllSame"></a><span class='hs-comment'>-- | Extend an environment with the same CPR sig for all ids</span>
<a name="line-478"></a><span class='hs-definition'>extendSigEnvAllSame</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Id</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CprSig</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-479"></a><span class='hs-definition'>extendSigEnvAllSame</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids</span> <span class='hs-varid'>sig</span>
<a name="line-480"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl'</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-varid'>sig</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ids</span>
<a name="line-481"></a>
<a name="line-482"></a><a name="nonVirgin"></a><span class='hs-definition'>nonVirgin</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-483"></a><span class='hs-definition'>nonVirgin</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ae_virgin</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span>
<a name="line-484"></a>
<a name="line-485"></a><a name="extendSigEnvForArg"></a><span class='hs-comment'>-- | A version of 'extendSigEnv' for a binder of which we don't see the RHS</span>
<a name="line-486"></a><span class='hs-comment'>-- needed to compute a 'CprSig' (e.g. lambdas and DataAlt field binders).</span>
<a name="line-487"></a><span class='hs-comment'>-- In this case, we can still look at their demand to attach CPR signatures</span>
<a name="line-488"></a><span class='hs-comment'>-- anticipating the unboxing done by worker/wrapper.</span>
<a name="line-489"></a><span class='hs-comment'>-- See Note [CPR for binders that will be unboxed].</span>
<a name="line-490"></a><span class='hs-definition'>extendSigEnvForArg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>AnalEnv</span>
<a name="line-491"></a><span class='hs-definition'>extendSigEnvForArg</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span>
<a name="line-492"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extendSigEnv</span> <span class='hs-varid'>env</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>CprSig</span> <span class='hs-layout'>(</span><span class='hs-varid'>argCprType</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>idDemandInfo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-493"></a>
<a name="line-494"></a><a name="argCprType"></a><span class='hs-comment'>-- | Produces a 'CprType' according to how a strict argument will be unboxed.</span>
<a name="line-495"></a><span class='hs-comment'>-- Examples:</span>
<a name="line-496"></a><span class='hs-comment'>--</span>
<a name="line-497"></a><span class='hs-comment'>--   * A head-strict demand @1L@ on @Int@ would translate to @1@</span>
<a name="line-498"></a><span class='hs-comment'>--   * A product demand @1P(1L,L)@ on @(Int, Bool)@ would translate to @1(1,)@</span>
<a name="line-499"></a><span class='hs-comment'>--   * A product demand @1P(1L,L)@ on @(a , Bool)@ would translate to @1(,)@,</span>
<a name="line-500"></a><span class='hs-comment'>--     because the unboxing strategy would not unbox the @a@.</span>
<a name="line-501"></a><span class='hs-definition'>argCprType</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnalEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Demand</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CprType</span>
<a name="line-502"></a><span class='hs-definition'>argCprType</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>dmd</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CprType</span> <span class='hs-num'>0</span> <span class='hs-layout'>(</span><span class='hs-varid'>go</span> <span class='hs-varid'>arg_ty</span> <span class='hs-varid'>dmd</span><span class='hs-layout'>)</span>
<a name="line-503"></a>  <span class='hs-keyword'>where</span>
<a name="line-504"></a>    <span class='hs-varid'>go</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>dmd</span>
<a name="line-505"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Unbox</span> <span class='hs-layout'>(</span><span class='hs-conid'>DataConPatContext</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dcpc_dc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dc</span><span class='hs-layout'>,</span> <span class='hs-varid'>dcpc_tc_args</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_args</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>ds</span>
<a name="line-506"></a>          <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>wantToUnbox</span> <span class='hs-layout'>(</span><span class='hs-varid'>ae_fam_envs</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>no_inlineable_prag</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>dmd</span>
<a name="line-507"></a>      <span class='hs-comment'>-- No existentials; see Note [Which types are unboxed?])</span>
<a name="line-508"></a>      <span class='hs-comment'>-- Otherwise we'd need to call dataConRepInstPat here and thread a</span>
<a name="line-509"></a>      <span class='hs-comment'>-- UniqSupply. So argCprType is a bit less aggressive than it could</span>
<a name="line-510"></a>      <span class='hs-comment'>-- be, for the sake of coding convenience.</span>
<a name="line-511"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>null</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConExTyCoVars</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span>
<a name="line-512"></a>      <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>arg_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>scaledThing</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConInstArgTys</span> <span class='hs-varid'>dc</span> <span class='hs-varid'>tc_args</span><span class='hs-layout'>)</span>
<a name="line-513"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ConCpr</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataConTag</span> <span class='hs-varid'>dc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>zipWith</span> <span class='hs-varid'>go</span> <span class='hs-varid'>arg_tys</span> <span class='hs-varid'>ds</span><span class='hs-layout'>)</span>
<a name="line-514"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-515"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>topCpr</span>
<a name="line-516"></a>    <span class='hs-comment'>-- Rather than maintaining in AnalEnv whether we are in an INLINEABLE</span>
<a name="line-517"></a>    <span class='hs-comment'>-- function, we just assume that we aren't. That flag is only relevant</span>
<a name="line-518"></a>    <span class='hs-comment'>-- to Note [Do not unpack class dictionaries], the few unboxing</span>
<a name="line-519"></a>    <span class='hs-comment'>-- opportunities on dicts it prohibits are probably irrelevant to CPR.</span>
<a name="line-520"></a>    <span class='hs-varid'>no_inlineable_prag</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-521"></a>
<a name="line-522"></a><span class='hs-comment'>{- Note [Safe abortion in the fixed-point iteration]
<a name="line-523"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-524"></a>Fixed-point iteration may fail to terminate. But we cannot simply give up and
<a name="line-525"></a>return the environment and code unchanged! We still need to do one additional
<a name="line-526"></a>round, to ensure that all expressions have been traversed at least once, and any
<a name="line-527"></a>unsound CPR annotations have been updated.
<a name="line-528"></a>
<a name="line-529"></a>Note [Efficient Top sigs in SigEnv]
<a name="line-530"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-531"></a>It's pretty common for binders in the SigEnv to have a 'topCprSig'.
<a name="line-532"></a>Wide records with 100 fields like in T9675 even will generate code where the
<a name="line-533"></a>majority of binders has Top signature. To save some allocations, we store
<a name="line-534"></a>those binders with a Top signature in a separate UnVarSet (which is an IntSet
<a name="line-535"></a>with a convenient Var-tailored API).
<a name="line-536"></a>
<a name="line-537"></a>Why store top signatures at all in the SigEnv? After all, when 'cprTransform'
<a name="line-538"></a>encounters a locally-bound Id without an entry in the SigEnv, it should behave
<a name="line-539"></a>as if that binder has a Top signature!
<a name="line-540"></a>Well, the problem is when case binders should have a Top signatures. They always
<a name="line-541"></a>have an unfolding and thus look to 'cprTransform' as if they bind a data
<a name="line-542"></a>structure, Note [CPR for data structures], and thus would always have the CPR
<a name="line-543"></a>property. So we need some mechanism to separate data structures from case
<a name="line-544"></a>binders with a Top signature, and the UnVarSet provides that in the least
<a name="line-545"></a>convoluted way I can think of.
<a name="line-546"></a>
<a name="line-547"></a>Note [CPR for binders that will be unboxed]
<a name="line-548"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-549"></a>If a lambda-bound variable will be unboxed by worker/wrapper (so it must be
<a name="line-550"></a>demanded strictly), then give it a CPR signature. Here's a concrete example
<a name="line-551"></a>('f1' in test T10482a), assuming h is strict:
<a name="line-552"></a>
<a name="line-553"></a>  f1 :: Int -&gt; Int
<a name="line-554"></a>  f1 x = case h x of
<a name="line-555"></a>          A -&gt; x
<a name="line-556"></a>          B -&gt; f1 (x-1)
<a name="line-557"></a>          C -&gt; x+1
<a name="line-558"></a>
<a name="line-559"></a>If we notice that 'x' is used strictly, we can give it the CPR
<a name="line-560"></a>property; and hence f1 gets the CPR property too.  It's sound (doesn't
<a name="line-561"></a>change strictness) to give it the CPR property because by the time 'x'
<a name="line-562"></a>is returned (case A above), it'll have been evaluated (by the wrapper
<a name="line-563"></a>of 'h' in the example).
<a name="line-564"></a>
<a name="line-565"></a>Moreover, if f itself is strict in x, then we'll pass x unboxed to
<a name="line-566"></a>f1, and so the boxed version *won't* be available; in that case it's
<a name="line-567"></a>very helpful to give 'x' the CPR property.
<a name="line-568"></a>
<a name="line-569"></a>This is all done in 'extendSigEnvForArg'.
<a name="line-570"></a>
<a name="line-571"></a>Note that
<a name="line-572"></a>
<a name="line-573"></a>  * Whether or not something unboxes is decided by 'wantToUnbox', else we may
<a name="line-574"></a>    get over-optimistic CPR results (e.g., from \(x :: a) -&gt; x!).
<a name="line-575"></a>
<a name="line-576"></a>  * If the demand unboxes deeply, we can give the binder a /nested/ CPR
<a name="line-577"></a>    property, e.g.
<a name="line-578"></a>
<a name="line-579"></a>      g :: (Int, Int) -&gt; Int
<a name="line-580"></a>      g p = case p of
<a name="line-581"></a>        (x, y) | x &lt; 0     -&gt; 0
<a name="line-582"></a>               | otherwise -&gt; x
<a name="line-583"></a>
<a name="line-584"></a>    `x` should have the CPR property because it will be unboxed. We do so
<a name="line-585"></a>    by giving `p` the Nested CPR property `1(1,)`, indicating that we not only
<a name="line-586"></a>    have `p` available unboxed, but also its field `x`. Analysis of the Case
<a name="line-587"></a>    will then transfer the CPR property to `x`.
<a name="line-588"></a>
<a name="line-589"></a>    Before we were able to express Nested CPR, we used to guess which field
<a name="line-590"></a>    binders should get the CPR property.
<a name="line-591"></a>    See Historic Note [Optimistic field binder CPR].
<a name="line-592"></a>
<a name="line-593"></a>  * See Note [CPR examples]
<a name="line-594"></a>
<a name="line-595"></a>Historic Note [Optimistic field binder CPR]
<a name="line-596"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-597"></a>This Note describes how we used to guess whether fields have the CPR property
<a name="line-598"></a>before we were able to express Nested CPR for arguments.
<a name="line-599"></a>
<a name="line-600"></a>Consider
<a name="line-601"></a>
<a name="line-602"></a>  data T a = MkT a
<a name="line-603"></a>  f :: T Int -&gt; Int
<a name="line-604"></a>  f x = ... (case x of
<a name="line-605"></a>    MkT y -&gt; y) ...
<a name="line-606"></a>
<a name="line-607"></a>And assume we know from strictness analysis that `f` is strict in `x` and its
<a name="line-608"></a>field `y` and we unbox both. Then we give `x` the CPR property according
<a name="line-609"></a>to Note [CPR for binders that will be unboxed]. But `x`'s sole field `y`
<a name="line-610"></a>likewise will be unboxed and it should also get the CPR property. We'd
<a name="line-611"></a>need a *nested* CPR property here for `x` to express that and unwrap one level
<a name="line-612"></a>when we analyse the Case to give the CPR property to `y`.
<a name="line-613"></a>
<a name="line-614"></a>Lacking Nested CPR, we have to guess a bit, by looking for
<a name="line-615"></a>
<a name="line-616"></a>  (A) Flat CPR on the scrutinee
<a name="line-617"></a>  (B) A variable scrutinee. Otherwise surely it can't be a parameter.
<a name="line-618"></a>  (C) Strict demand on the field binder `y` (or it binds a strict field)
<a name="line-619"></a>
<a name="line-620"></a>While (A) is a necessary condition to give a field the CPR property, there are
<a name="line-621"></a>ways in which (B) and (C) are too lax, leading to unsound analysis results and
<a name="line-622"></a>thus reboxing in the wrapper:
<a name="line-623"></a>
<a name="line-624"></a>  (b) We could scrutinise some other variable than a parameter, like in
<a name="line-625"></a>
<a name="line-626"></a>        g :: T Int -&gt; Int
<a name="line-627"></a>        g x = let z = foo x in -- assume `z` has CPR property
<a name="line-628"></a>              case z of MkT y -&gt; y
<a name="line-629"></a>
<a name="line-630"></a>      Lacking Nested CPR and multiple levels of unboxing, only the outer box
<a name="line-631"></a>      of `z` will be available and a case on `y` won't actually cancel away.
<a name="line-632"></a>      But it's simple, and nothing terrible happens if we get it wrong. e.g.
<a name="line-633"></a>      #10694.
<a name="line-634"></a>
<a name="line-635"></a>  (c) A strictly used field binder doesn't mean the function is strict in it.
<a name="line-636"></a>
<a name="line-637"></a>        h :: T Int -&gt; Int -&gt; Int
<a name="line-638"></a>        h !x 0 = 0
<a name="line-639"></a>        h  x 0 = case x of MkT y -&gt; y
<a name="line-640"></a>
<a name="line-641"></a>      Here, `y` is used strictly, but the field of `x` certainly is not and
<a name="line-642"></a>      consequently will not be available unboxed.
<a name="line-643"></a>      Why not look at the demand of `x` instead to determine whether `y` is
<a name="line-644"></a>      unboxed? Because the 'idDemandInfo' on `x` will not have been propagated
<a name="line-645"></a>      to its occurrence in the scrutinee when CprAnal runs directly after
<a name="line-646"></a>      DmdAnal.
<a name="line-647"></a>
<a name="line-648"></a>We used to give the case binder the CPR property unconditionally instead of
<a name="line-649"></a>deriving it from the case scrutinee.
<a name="line-650"></a>See Historical Note [Optimistic case binder CPR].
<a name="line-651"></a>
<a name="line-652"></a>Historical Note [Optimistic case binder CPR]
<a name="line-653"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-654"></a>We used to give the case binder the CPR property unconditionally, which is too
<a name="line-655"></a>optimistic (#19232). Here are the details:
<a name="line-656"></a>
<a name="line-657"></a>Inside the alternative, the case binder always has the CPR property, meaning
<a name="line-658"></a>that a case on it will successfully cancel.
<a name="line-659"></a>Example:
<a name="line-660"></a>  f True  x = case x of y { I# x' -&gt; if x' ==# 3
<a name="line-661"></a>                                     then y
<a name="line-662"></a>                                     else I# 8 }
<a name="line-663"></a>  f False x = I# 3
<a name="line-664"></a>By giving 'y' the CPR property, we ensure that 'f' does too, so we get
<a name="line-665"></a>  f b x = case fw b x of { r -&gt; I# r }
<a name="line-666"></a>  fw True  x = case x of y { I# x' -&gt; if x' ==# 3 then x' else 8 }
<a name="line-667"></a>  fw False x = 3
<a name="line-668"></a>Of course there is the usual risk of re-boxing: we have 'x' available boxed
<a name="line-669"></a>and unboxed, but we return the unboxed version for the wrapper to box. If the
<a name="line-670"></a>wrapper doesn't cancel with its caller, we'll end up re-boxing something that
<a name="line-671"></a>we did have available in boxed form.
<a name="line-672"></a>
<a name="line-673"></a>Note [CPR for sum types]
<a name="line-674"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-675"></a>At the moment we do not do CPR for let-bindings that
<a name="line-676"></a>   * non-top level
<a name="line-677"></a>   * bind a sum type
<a name="line-678"></a>Reason: I found that in some benchmarks we were losing let-no-escapes,
<a name="line-679"></a>which messed it all up.  Example
<a name="line-680"></a>   let j = \x. ....
<a name="line-681"></a>   in case y of
<a name="line-682"></a>        True  -&gt; j False
<a name="line-683"></a>        False -&gt; j True
<a name="line-684"></a>If we w/w this we get
<a name="line-685"></a>   let j' = \x. ....
<a name="line-686"></a>   in case y of
<a name="line-687"></a>        True  -&gt; case j' False of { (# a #) -&gt; Just a }
<a name="line-688"></a>        False -&gt; case j' True of { (# a #) -&gt; Just a }
<a name="line-689"></a>Notice that j' is not a let-no-escape any more.
<a name="line-690"></a>
<a name="line-691"></a>However this means in turn that the *enclosing* function
<a name="line-692"></a>may be CPR'd (via the returned Justs).  But in the case of
<a name="line-693"></a>sums, there may be Nothing alternatives; and that messes
<a name="line-694"></a>up the sum-type CPR.
<a name="line-695"></a>
<a name="line-696"></a>Conclusion: only do this for products.  It's still not
<a name="line-697"></a>guaranteed OK for products, but sums definitely lose sometimes.
<a name="line-698"></a>
<a name="line-699"></a>Note [CPR for thunks]
<a name="line-700"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-701"></a>If the rhs is a thunk, we usually forget the CPR info, because
<a name="line-702"></a>it is presumably shared (else it would have been inlined, and
<a name="line-703"></a>so we'd lose sharing if w/w'd it into a function).  E.g.
<a name="line-704"></a>
<a name="line-705"></a>        let r = case expensive of
<a name="line-706"></a>                  (a,b) -&gt; (b,a)
<a name="line-707"></a>        in ...
<a name="line-708"></a>
<a name="line-709"></a>If we marked r as having the CPR property, then we'd w/w into
<a name="line-710"></a>
<a name="line-711"></a>        let $wr = \() -&gt; case expensive of
<a name="line-712"></a>                            (a,b) -&gt; (# b, a #)
<a name="line-713"></a>            r = case $wr () of
<a name="line-714"></a>                  (# b,a #) -&gt; (b,a)
<a name="line-715"></a>        in ...
<a name="line-716"></a>
<a name="line-717"></a>But now r is a thunk, which won't be inlined, so we are no further ahead.
<a name="line-718"></a>But consider
<a name="line-719"></a>
<a name="line-720"></a>        f x = let r = case expensive of (a,b) -&gt; (b,a)
<a name="line-721"></a>              in if foo r then r else (x,x)
<a name="line-722"></a>
<a name="line-723"></a>Does f have the CPR property?  Well, no.
<a name="line-724"></a>
<a name="line-725"></a>However, if the strictness analyser has figured out (in a previous
<a name="line-726"></a>iteration) that it's strict, then we DON'T need to forget the CPR info.
<a name="line-727"></a>Instead we can retain the CPR info and do the thunk-splitting transform
<a name="line-728"></a>(see WorkWrap.splitThunk).
<a name="line-729"></a>
<a name="line-730"></a>This made a big difference to PrelBase.modInt, which had something like
<a name="line-731"></a>        modInt = \ x -&gt; let r = ... -&gt; I# v in
<a name="line-732"></a>                        ...body strict in r...
<a name="line-733"></a>r's RHS isn't a value yet; but modInt returns r in various branches, so
<a name="line-734"></a>if r doesn't have the CPR property then neither does modInt
<a name="line-735"></a>Another case I found in practice (in Complex.magnitude), looks like this:
<a name="line-736"></a>                let k = if ... then I# a else I# b
<a name="line-737"></a>                in ... body strict in k ....
<a name="line-738"></a>(For this example, it doesn't matter whether k is returned as part of
<a name="line-739"></a>the overall result; but it does matter that k's RHS has the CPR property.)
<a name="line-740"></a>Left to itself, the simplifier will make a join point thus:
<a name="line-741"></a>                let $j k = ...body strict in k...
<a name="line-742"></a>                if ... then $j (I# a) else $j (I# b)
<a name="line-743"></a>With thunk-splitting, we get instead
<a name="line-744"></a>                let $j x = let k = I#x in ...body strict in k...
<a name="line-745"></a>                in if ... then $j a else $j b
<a name="line-746"></a>This is much better; there's a good chance the I# won't get allocated.
<a name="line-747"></a>
<a name="line-748"></a>But what about botCpr? Consider
<a name="line-749"></a>    lvl = error "boom"
<a name="line-750"></a>    fac -1 = lvl
<a name="line-751"></a>    fac 0 = 1
<a name="line-752"></a>    fac n = n * fac (n-1)
<a name="line-753"></a>fac won't have the CPR property here when we trim every thunk! But the
<a name="line-754"></a>assumption is that error cases are rarely entered and we are diverging anyway,
<a name="line-755"></a>so WW doesn't hurt.
<a name="line-756"></a>
<a name="line-757"></a>Should we also trim CPR on DataCon application bindings?
<a name="line-758"></a>See Note [CPR for data structures]!
<a name="line-759"></a>
<a name="line-760"></a>Note [CPR for data structures]
<a name="line-761"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-762"></a>Long static data structures (whether top-level or not) like
<a name="line-763"></a>
<a name="line-764"></a>  xs = x1 : xs1
<a name="line-765"></a>  xs1 = x2 : xs2
<a name="line-766"></a>  xs2 = x3 : xs3
<a name="line-767"></a>
<a name="line-768"></a>should not get CPR signatures (#18154), because they
<a name="line-769"></a>
<a name="line-770"></a>  * Never get WW'd, so their CPR signature should be irrelevant after analysis
<a name="line-771"></a>    (in fact the signature might even be harmful for that reason)
<a name="line-772"></a>  * Would need to be inlined/expanded to see their constructed product
<a name="line-773"></a>  * Recording CPR on them blows up interface file sizes and is redundant with
<a name="line-774"></a>    their unfolding. In case of Nested CPR, this blow-up can be quadratic!
<a name="line-775"></a>    Reason: the CPR info for xs1 contains the CPR info for xs; the CPR info
<a name="line-776"></a>    for xs2 contains that for xs1. And so on.
<a name="line-777"></a>
<a name="line-778"></a>Hence we don't analyse or annotate data structures in 'cprAnalBind'. To
<a name="line-779"></a>implement this, the isDataStructure guard is triggered for bindings that satisfy
<a name="line-780"></a>
<a name="line-781"></a>  (1) idArity id == 0 (otherwise it's a function)
<a name="line-782"></a>  (2) exprIsHNF rhs   (otherwise it's a thunk, Note [CPR for thunks] applies)
<a name="line-783"></a>
<a name="line-784"></a>But we can't just stop giving DataCon application bindings the CPR *property*,
<a name="line-785"></a>for example
<a name="line-786"></a>
<a name="line-787"></a>  fac 0 = I# 1#
<a name="line-788"></a>  fac n = n * fac (n-1)
<a name="line-789"></a>
<a name="line-790"></a>fac certainly has the CPR property and should be WW'd! But FloatOut will
<a name="line-791"></a>transform the first clause to
<a name="line-792"></a>
<a name="line-793"></a>  lvl = I# 1#
<a name="line-794"></a>  fac 0 = lvl
<a name="line-795"></a>
<a name="line-796"></a>If lvl doesn't have the CPR property, fac won't either. But lvl is a data
<a name="line-797"></a>structure, and hence (see above) will not have a CPR signature. So instead, when
<a name="line-798"></a>'cprAnal' meets a variable lacking a CPR signature to extrapolate into a CPR
<a name="line-799"></a>transformer, 'cprTransform' instead tries to get its unfolding (via
<a name="line-800"></a>'cprDataStructureUnfolding_maybe'), and analyses that instead.
<a name="line-801"></a>
<a name="line-802"></a>In practice, GHC generates a lot of (nested) TyCon and KindRep bindings, one
<a name="line-803"></a>for each data declaration. They should not have CPR signatures (blow up!).
<a name="line-804"></a>
<a name="line-805"></a>There is a perhaps surprising special case: KindRep bindings satisfy
<a name="line-806"></a>'isDataStructure' (so no CPR signature), but are marked NOINLINE at the same
<a name="line-807"></a>time (see the noinline wrinkle in Note [Grand plan for Typeable]). So there is
<a name="line-808"></a>no unfolding for 'cprDataStructureUnfolding_maybe' to look through and we'll
<a name="line-809"></a>return topCprType. And that is fine! We should refrain to look through NOINLINE
<a name="line-810"></a>data structures in general, as a constructed product could never be exposed
<a name="line-811"></a>after WW.
<a name="line-812"></a>
<a name="line-813"></a>It's also worth pointing out how ad-hoc this is: If we instead had
<a name="line-814"></a>
<a name="line-815"></a>    f1 x = x:[]
<a name="line-816"></a>    f2 x = x : f1 x
<a name="line-817"></a>    f3 x = x : f2 x
<a name="line-818"></a>    ...
<a name="line-819"></a>
<a name="line-820"></a>we still give every function an every deepening CPR signature. But it's very
<a name="line-821"></a>uncommon to find code like this, whereas the long static data structures from
<a name="line-822"></a>the beginning of this Note are very common because of GHC's strategy of ANF'ing
<a name="line-823"></a>data structure RHSs.
<a name="line-824"></a>
<a name="line-825"></a>Note [CPR examples]
<a name="line-826"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-827"></a>Here are some examples (stranal/should_compile/T10482a) of the
<a name="line-828"></a>usefulness of Note [Optimistic field binder CPR].  The main
<a name="line-829"></a>point: all of these functions can have the CPR property.
<a name="line-830"></a>
<a name="line-831"></a>    ------- f1 -----------
<a name="line-832"></a>    -- x is used strictly by h, so it'll be available
<a name="line-833"></a>    -- unboxed before it is returned in the True branch
<a name="line-834"></a>
<a name="line-835"></a>    f1 :: Int -&gt; Int
<a name="line-836"></a>    f1 x = case h x x of
<a name="line-837"></a>            True  -&gt; x
<a name="line-838"></a>            False -&gt; f1 (x-1)
<a name="line-839"></a>
<a name="line-840"></a>    ------- f3 -----------
<a name="line-841"></a>    -- h is strict in x, so x will be unboxed before it
<a name="line-842"></a>    -- is rerturned in the otherwise case.
<a name="line-843"></a>
<a name="line-844"></a>    data T3 = MkT3 Int Int
<a name="line-845"></a>
<a name="line-846"></a>    f1 :: T3 -&gt; Int
<a name="line-847"></a>    f1 (MkT3 x y) | h x y     = f3 (MkT3 x (y-1))
<a name="line-848"></a>                  | otherwise = x
<a name="line-849"></a>-}</span>
</pre></body>
</html>
