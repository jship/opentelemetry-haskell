<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>GHC/Core/TyCo/Rep.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP                #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE DeriveDataTypeable #-}</span>
<a name="line-3"></a>
<a name="line-4"></a><span class='hs-comment'>{-# OPTIONS_HADDOCK not-home #-}</span>
<a name="line-5"></a>
<a name="line-6"></a><span class='hs-comment'>{-
<a name="line-7"></a>(c) The University of Glasgow 2006
<a name="line-8"></a>(c) The GRASP/AQUA Project, Glasgow University, 1998
<a name="line-9"></a>\section[GHC.Core.TyCo.Rep]{Type and Coercion - friends' interface}
<a name="line-10"></a>
<a name="line-11"></a>Note [The Type-related module hierarchy]
<a name="line-12"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-13"></a>  GHC.Core.Class
<a name="line-14"></a>  GHC.Core.Coercion.Axiom
<a name="line-15"></a>  GHC.Core.TyCon           imports GHC.Core.{Class, Coercion.Axiom}
<a name="line-16"></a>  GHC.Core.TyCo.Rep        imports GHC.Core.{Class, Coercion.Axiom, TyCon}
<a name="line-17"></a>  GHC.Core.TyCo.Ppr        imports GHC.Core.TyCo.Rep
<a name="line-18"></a>  GHC.Core.TyCo.FVs        imports GHC.Core.TyCo.Rep
<a name="line-19"></a>  GHC.Core.TyCo.Subst      imports GHC.Core.TyCo.{Rep, FVs, Ppr}
<a name="line-20"></a>  GHC.Core.TyCo.Tidy       imports GHC.Core.TyCo.{Rep, FVs}
<a name="line-21"></a>  GHC.Builtin.Types.Prim   imports GHC.Core.TyCo.Rep ( including mkTyConTy )
<a name="line-22"></a>  GHC.Core.Coercion        imports GHC.Core.Type
<a name="line-23"></a>-}</span>
<a name="line-24"></a>
<a name="line-25"></a><span class='hs-comment'>-- We expose the relevant stuff from this module via the Type module</span>
<a name="line-26"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>GHC.Core.TyCo.Rep</span> <span class='hs-layout'>(</span>
<a name="line-27"></a>
<a name="line-28"></a>        <span class='hs-comment'>-- * Types</span>
<a name="line-29"></a>        <span class='hs-conid'>Type</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-30"></a>
<a name="line-31"></a>        <span class='hs-conid'>TyLit</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-32"></a>        <span class='hs-conid'>KindOrType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Kind</span><span class='hs-layout'>,</span>
<a name="line-33"></a>        <span class='hs-conid'>KnotTied</span><span class='hs-layout'>,</span>
<a name="line-34"></a>        <span class='hs-conid'>PredType</span><span class='hs-layout'>,</span> <span class='hs-conid'>ThetaType</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- Synonyms</span>
<a name="line-35"></a>        <span class='hs-conid'>ArgFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>AnonArgFlag</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-36"></a>
<a name="line-37"></a>        <span class='hs-comment'>-- * Coercions</span>
<a name="line-38"></a>        <span class='hs-conid'>Coercion</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-39"></a>        <span class='hs-conid'>UnivCoProvenance</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-40"></a>        <span class='hs-conid'>CoercionHole</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>coHoleCoVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>setCoHoleCoVar</span><span class='hs-layout'>,</span>
<a name="line-41"></a>        <span class='hs-conid'>CoercionN</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionR</span><span class='hs-layout'>,</span> <span class='hs-conid'>CoercionP</span><span class='hs-layout'>,</span> <span class='hs-conid'>KindCoercion</span><span class='hs-layout'>,</span>
<a name="line-42"></a>        <span class='hs-conid'>MCoercion</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercionR</span><span class='hs-layout'>,</span> <span class='hs-conid'>MCoercionN</span><span class='hs-layout'>,</span>
<a name="line-43"></a>
<a name="line-44"></a>        <span class='hs-comment'>-- * Functions over types</span>
<a name="line-45"></a>        <span class='hs-varid'>mkTyConTy_</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyVarTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyVarTys</span><span class='hs-layout'>,</span>
<a name="line-46"></a>        <span class='hs-varid'>mkTyCoVarTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTyCoVarTys</span><span class='hs-layout'>,</span>
<a name="line-47"></a>        <span class='hs-varid'>mkFunTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkVisFunTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInvisFunTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkVisFunTys</span><span class='hs-layout'>,</span>
<a name="line-48"></a>        <span class='hs-varid'>mkForAllTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkForAllTys</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInvisForAllTys</span><span class='hs-layout'>,</span>
<a name="line-49"></a>        <span class='hs-varid'>mkPiTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkPiTys</span><span class='hs-layout'>,</span>
<a name="line-50"></a>        <span class='hs-varid'>mkFunTyMany</span><span class='hs-layout'>,</span>
<a name="line-51"></a>        <span class='hs-varid'>mkScaledFunTy</span><span class='hs-layout'>,</span>
<a name="line-52"></a>        <span class='hs-varid'>mkVisFunTyMany</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkVisFunTysMany</span><span class='hs-layout'>,</span>
<a name="line-53"></a>        <span class='hs-varid'>mkInvisFunTyMany</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInvisFunTysMany</span><span class='hs-layout'>,</span>
<a name="line-54"></a>        <span class='hs-varid'>nonDetCmpTyLit</span><span class='hs-layout'>,</span> <span class='hs-varid'>cmpTyLit</span><span class='hs-layout'>,</span>
<a name="line-55"></a>
<a name="line-56"></a>        <span class='hs-comment'>-- * Functions over binders</span>
<a name="line-57"></a>        <span class='hs-conid'>TyCoBinder</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>TyCoVarBinder</span><span class='hs-layout'>,</span> <span class='hs-conid'>TyBinder</span><span class='hs-layout'>,</span>
<a name="line-58"></a>        <span class='hs-varid'>binderVar</span><span class='hs-layout'>,</span> <span class='hs-varid'>binderVars</span><span class='hs-layout'>,</span> <span class='hs-varid'>binderType</span><span class='hs-layout'>,</span> <span class='hs-varid'>binderArgFlag</span><span class='hs-layout'>,</span>
<a name="line-59"></a>        <span class='hs-varid'>delBinderVar</span><span class='hs-layout'>,</span>
<a name="line-60"></a>        <span class='hs-varid'>isInvisibleArgFlag</span><span class='hs-layout'>,</span> <span class='hs-varid'>isVisibleArgFlag</span><span class='hs-layout'>,</span>
<a name="line-61"></a>        <span class='hs-varid'>isInvisibleBinder</span><span class='hs-layout'>,</span> <span class='hs-varid'>isVisibleBinder</span><span class='hs-layout'>,</span>
<a name="line-62"></a>        <span class='hs-varid'>isTyBinder</span><span class='hs-layout'>,</span> <span class='hs-varid'>isNamedBinder</span><span class='hs-layout'>,</span>
<a name="line-63"></a>
<a name="line-64"></a>        <span class='hs-comment'>-- * Functions over coercions</span>
<a name="line-65"></a>        <span class='hs-varid'>pickLR</span><span class='hs-layout'>,</span>
<a name="line-66"></a>
<a name="line-67"></a>        <span class='hs-comment'>-- ** Analyzing types</span>
<a name="line-68"></a>        <span class='hs-conid'>TyCoFolder</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldTyCo</span><span class='hs-layout'>,</span>
<a name="line-69"></a>
<a name="line-70"></a>        <span class='hs-comment'>-- * Sizes</span>
<a name="line-71"></a>        <span class='hs-varid'>typeSize</span><span class='hs-layout'>,</span> <span class='hs-varid'>coercionSize</span><span class='hs-layout'>,</span> <span class='hs-varid'>provSize</span><span class='hs-layout'>,</span>
<a name="line-72"></a>
<a name="line-73"></a>        <span class='hs-comment'>-- * Multiplicities</span>
<a name="line-74"></a>        <span class='hs-conid'>Scaled</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>scaledMult</span><span class='hs-layout'>,</span> <span class='hs-varid'>scaledThing</span><span class='hs-layout'>,</span> <span class='hs-varid'>mapScaledType</span><span class='hs-layout'>,</span> <span class='hs-conid'>Mult</span>
<a name="line-75"></a>    <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-76"></a>
<a name="line-77"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-78"></a>
<a name="line-79"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-80"></a>
<a name="line-81"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Core.TyCo.Ppr</span> <span class='hs-layout'>(</span> <span class='hs-varid'>pprType</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprCo</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprTyLit</span> <span class='hs-layout'>)</span>
<a name="line-82"></a>
<a name="line-83"></a>   <span class='hs-comment'>-- Transitively pulls in a LOT of stuff, better to break the loop</span>
<a name="line-84"></a>
<a name="line-85"></a><span class='hs-comment'>-- friends:</span>
<a name="line-86"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Iface.Type</span>
<a name="line-87"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var</span>
<a name="line-88"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Var.Set</span>
<a name="line-89"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.TyCon</span>
<a name="line-90"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Coercion.Axiom</span>
<a name="line-91"></a>
<a name="line-92"></a><span class='hs-comment'>-- others</span>
<a name="line-93"></a><span class='hs-keyword'>import</span> <span class='hs-comment'>{-# SOURCE #-}</span> <span class='hs-conid'>GHC.Builtin.Types</span> <span class='hs-layout'>(</span> <span class='hs-varid'>manyDataConTy</span> <span class='hs-layout'>)</span>
<a name="line-94"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span> <span class='hs-layout'>(</span> <span class='hs-conid'>LeftOrRight</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>pickLR</span> <span class='hs-layout'>)</span>
<a name="line-95"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Unique</span> <span class='hs-layout'>(</span> <span class='hs-conid'>Uniquable</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-96"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-97"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-98"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Misc</span>
<a name="line-99"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-100"></a>
<a name="line-101"></a><span class='hs-comment'>-- libraries</span>
<a name="line-102"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Data</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Data</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span> <span class='hs-conid'>TyCon</span> <span class='hs-layout'>)</span>
<a name="line-103"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.IORef</span> <span class='hs-layout'>(</span> <span class='hs-conid'>IORef</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- for CoercionHole</span>
<a name="line-104"></a>
<a name="line-105"></a><span class='hs-comment'>{- **********************************************************************
<a name="line-106"></a>*                                                                       *
<a name="line-107"></a>                        Type
<a name="line-108"></a>*                                                                       *
<a name="line-109"></a>********************************************************************** -}</span>
<a name="line-110"></a>
<a name="line-111"></a><span class='hs-comment'>-- | The key representation of types within the compiler</span>
<a name="line-112"></a>
<a name="line-113"></a><a name="KindOrType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>KindOrType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span> <span class='hs-comment'>-- See Note [Arguments to type constructors]</span>
<a name="line-114"></a>
<a name="line-115"></a><a name="Kind"></a><span class='hs-comment'>-- | The key type representing kinds in the compiler.</span>
<a name="line-116"></a><a name="Kind"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Kind</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-117"></a>
<a name="line-118"></a><a name="Type"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-119"></a><a name="Type"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-120"></a><a name="Type"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Type</span>
<a name="line-121"></a>  <span class='hs-comment'>-- See Note [Non-trivial definitional equality]</span>
<a name="line-122"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyVarTy</span> <span class='hs-conid'>Var</span> <span class='hs-comment'>-- ^ Vanilla type or kind variable (*never* a coercion variable)</span>
<a name="line-123"></a>
<a name="line-124"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AppTy</span>
<a name="line-125"></a>        <span class='hs-conid'>Type</span>
<a name="line-126"></a>        <span class='hs-conid'>Type</span>            <span class='hs-comment'>-- ^ Type application to something other than a 'TyCon'. Parameters:</span>
<a name="line-127"></a>                        <span class='hs-comment'>--</span>
<a name="line-128"></a>                        <span class='hs-comment'>--  1) Function: must /not/ be a 'TyConApp' or 'CastTy',</span>
<a name="line-129"></a>                        <span class='hs-comment'>--     must be another 'AppTy', or 'TyVarTy'</span>
<a name="line-130"></a>                        <span class='hs-comment'>--     See Note [Respecting definitional equality] \(EQ1) about the</span>
<a name="line-131"></a>                        <span class='hs-comment'>--     no 'CastTy' requirement</span>
<a name="line-132"></a>                        <span class='hs-comment'>--</span>
<a name="line-133"></a>                        <span class='hs-comment'>--  2) Argument type</span>
<a name="line-134"></a>
<a name="line-135"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyConApp</span>
<a name="line-136"></a>        <span class='hs-conid'>TyCon</span>
<a name="line-137"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>KindOrType</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- ^ Application of a 'TyCon', including newtypes /and/ synonyms.</span>
<a name="line-138"></a>                        <span class='hs-comment'>-- Invariant: saturated applications of 'FunTyCon' must</span>
<a name="line-139"></a>                        <span class='hs-comment'>-- use 'FunTy' and saturated synonyms must use their own</span>
<a name="line-140"></a>                        <span class='hs-comment'>-- constructors. However, /unsaturated/ 'FunTyCon's</span>
<a name="line-141"></a>                        <span class='hs-comment'>-- do appear as 'TyConApp's.</span>
<a name="line-142"></a>                        <span class='hs-comment'>-- Parameters:</span>
<a name="line-143"></a>                        <span class='hs-comment'>--</span>
<a name="line-144"></a>                        <span class='hs-comment'>-- 1) Type constructor being applied to.</span>
<a name="line-145"></a>                        <span class='hs-comment'>--</span>
<a name="line-146"></a>                        <span class='hs-comment'>-- 2) Type arguments. Might not have enough type arguments</span>
<a name="line-147"></a>                        <span class='hs-comment'>--    here to saturate the constructor.</span>
<a name="line-148"></a>                        <span class='hs-comment'>--    Even type synonyms are not necessarily saturated;</span>
<a name="line-149"></a>                        <span class='hs-comment'>--    for example unsaturated type synonyms</span>
<a name="line-150"></a>                        <span class='hs-comment'>--    can appear as the right hand side of a type synonym.</span>
<a name="line-151"></a>
<a name="line-152"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ForAllTy</span>
<a name="line-153"></a>        <span class='hs-comment'>{-# UNPACK #-}</span> <span class='hs-varop'>!</span><span class='hs-conid'>TyCoVarBinder</span>
<a name="line-154"></a>        <span class='hs-conid'>Type</span>            <span class='hs-comment'>-- ^ A Π type.</span>
<a name="line-155"></a>             <span class='hs-comment'>-- INVARIANT: If the binder is a coercion variable, it must</span>
<a name="line-156"></a>             <span class='hs-comment'>-- be mentioned in the Type. See</span>
<a name="line-157"></a>             <span class='hs-comment'>-- Note [Unused coercion variable in ForAllTy]</span>
<a name="line-158"></a>
<a name="line-159"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FunTy</span>      <span class='hs-comment'>-- ^ FUN m t1 t2   Very common, so an important special case</span>
<a name="line-160"></a>                <span class='hs-comment'>-- See Note [Function types]</span>
<a name="line-161"></a>     <span class='hs-layout'>{</span> <span class='hs-varid'>ft_af</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnonArgFlag</span>    <span class='hs-comment'>-- Is this (-&gt;) or (=&gt;)?</span>
<a name="line-162"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>ft_mult</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span>          <span class='hs-comment'>-- Multiplicity</span>
<a name="line-163"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>ft_arg</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span>           <span class='hs-comment'>-- Argument type</span>
<a name="line-164"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>ft_res</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-layout'>}</span>         <span class='hs-comment'>-- Result type</span>
<a name="line-165"></a>
<a name="line-166"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LitTy</span> <span class='hs-conid'>TyLit</span>     <span class='hs-comment'>-- ^ Type literals are similar to type constructors.</span>
<a name="line-167"></a>
<a name="line-168"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CastTy</span>
<a name="line-169"></a>        <span class='hs-conid'>Type</span>
<a name="line-170"></a>        <span class='hs-conid'>KindCoercion</span>  <span class='hs-comment'>-- ^ A kind cast. The coercion is always nominal.</span>
<a name="line-171"></a>                      <span class='hs-comment'>-- INVARIANT: The cast is never reflexive \(EQ2)</span>
<a name="line-172"></a>                      <span class='hs-comment'>-- INVARIANT: The Type is not a CastTy (use TransCo instead) \(EQ3)</span>
<a name="line-173"></a>                      <span class='hs-comment'>-- INVARIANT: The Type is not a ForAllTy over a tyvar \(EQ4)</span>
<a name="line-174"></a>                      <span class='hs-comment'>-- See Note [Respecting definitional equality]</span>
<a name="line-175"></a>
<a name="line-176"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CoercionTy</span>
<a name="line-177"></a>        <span class='hs-conid'>Coercion</span>    <span class='hs-comment'>-- ^ Injection of a Coercion into a type</span>
<a name="line-178"></a>                    <span class='hs-comment'>-- This should only ever be used in the RHS of an AppTy,</span>
<a name="line-179"></a>                    <span class='hs-comment'>-- in the list of a TyConApp, when applying a promoted</span>
<a name="line-180"></a>                    <span class='hs-comment'>-- GADT data constructor</span>
<a name="line-181"></a>
<a name="line-182"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data.Data</span>
<a name="line-183"></a>
<a name="line-184"></a><a name="instance%20Outputable%20Type"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Type</span> <span class='hs-keyword'>where</span>
<a name="line-185"></a>  <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprType</span>
<a name="line-186"></a>
<a name="line-187"></a><a name="TyLit"></a><span class='hs-comment'>-- NOTE:  Other parts of the code assume that type literals do not contain</span>
<a name="line-188"></a><a name="TyLit"></a><span class='hs-comment'>-- types or type variables.</span>
<a name="line-189"></a><a name="TyLit"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TyLit</span>
<a name="line-190"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>NumTyLit</span> <span class='hs-conid'>Integer</span>
<a name="line-191"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StrTyLit</span> <span class='hs-conid'>FastString</span>
<a name="line-192"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CharTyLit</span> <span class='hs-conid'>Char</span>
<a name="line-193"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Data.Data</span><span class='hs-layout'>)</span>
<a name="line-194"></a>
<a name="line-195"></a><a name="nonDetCmpTyLit"></a><span class='hs-comment'>-- Non-determinism arises due to uniqCompareFS</span>
<a name="line-196"></a><span class='hs-definition'>nonDetCmpTyLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-197"></a><span class='hs-definition'>nonDetCmpTyLit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cmpTyLitWith</span> <span class='hs-conid'>NonDetFastString</span>
<a name="line-198"></a>
<a name="line-199"></a><a name="cmpTyLit"></a><span class='hs-comment'>-- Slower than nonDetCmpTyLit but deterministic</span>
<a name="line-200"></a><span class='hs-definition'>cmpTyLit</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-201"></a><span class='hs-definition'>cmpTyLit</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cmpTyLitWith</span> <span class='hs-conid'>LexicalFastString</span>
<a name="line-202"></a>
<a name="line-203"></a><a name="cmpTyLitWith"></a><span class='hs-comment'>{-# INLINE cmpTyLitWith #-}</span>
<a name="line-204"></a><span class='hs-definition'>cmpTyLitWith</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ord</span> <span class='hs-varid'>r</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>FastString</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>r</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ordering</span>
<a name="line-205"></a><span class='hs-definition'>cmpTyLitWith</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>NumTyLit</span>  <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>NumTyLit</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-206"></a><span class='hs-definition'>cmpTyLitWith</span> <span class='hs-varid'>w</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrTyLit</span>  <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>StrTyLit</span>  <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>w</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span>
<a name="line-207"></a><span class='hs-definition'>cmpTyLitWith</span> <span class='hs-keyword'>_</span> <span class='hs-layout'>(</span><span class='hs-conid'>CharTyLit</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>CharTyLit</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-varid'>x</span> <span class='hs-varid'>y</span>
<a name="line-208"></a><span class='hs-definition'>cmpTyLitWith</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>compare</span> <span class='hs-layout'>(</span><span class='hs-varid'>tag</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>tag</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span>
<a name="line-209"></a>  <span class='hs-keyword'>where</span>
<a name="line-210"></a>    <span class='hs-varid'>tag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-211"></a>    <span class='hs-varid'>tag</span> <span class='hs-conid'>NumTyLit</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-212"></a>    <span class='hs-varid'>tag</span> <span class='hs-conid'>StrTyLit</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-213"></a>    <span class='hs-varid'>tag</span> <span class='hs-conid'>CharTyLit</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>2</span>
<a name="line-214"></a>
<a name="line-215"></a><a name="instance%20Outputable%20TyLit"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>TyLit</span> <span class='hs-keyword'>where</span>
<a name="line-216"></a>   <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprTyLit</span>
<a name="line-217"></a>
<a name="line-218"></a><span class='hs-comment'>{- Note [Function types]
<a name="line-219"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-220"></a>FFunTy is the constructor for a function type.  Lots of things to say
<a name="line-221"></a>about it!
<a name="line-222"></a>
<a name="line-223"></a>* FFunTy is the data constructor, meaning "full function type".
<a name="line-224"></a>
<a name="line-225"></a>* The function type constructor (-&gt;) has kind
<a name="line-226"></a>     (-&gt;) :: forall {r1} {r2}. TYPE r1 -&gt; TYPE r2 -&gt; Type LiftedRep
<a name="line-227"></a>  mkTyConApp ensure that we convert a saturated application
<a name="line-228"></a>    TyConApp (-&gt;) [r1,r2,t1,t2] into FunTy t1 t2
<a name="line-229"></a>  dropping the 'r1' and 'r2' arguments; they are easily recovered
<a name="line-230"></a>  from 't1' and 't2'.
<a name="line-231"></a>
<a name="line-232"></a>* For the time being its RuntimeRep quantifiers are left
<a name="line-233"></a>  inferred. This is to allow for it to evolve.
<a name="line-234"></a>
<a name="line-235"></a>* The ft_af field says whether or not this is an invisible argument
<a name="line-236"></a>     VisArg:   t1 -&gt; t2    Ordinary function type
<a name="line-237"></a>     InvisArg: t1 =&gt; t2    t1 is guaranteed to be a predicate type,
<a name="line-238"></a>                           i.e. t1 :: Constraint
<a name="line-239"></a>  See Note [Types for coercions, predicates, and evidence]
<a name="line-240"></a>
<a name="line-241"></a>  This visibility info makes no difference in Core; it matters
<a name="line-242"></a>  only when we regard the type as a Haskell source type.
<a name="line-243"></a>
<a name="line-244"></a>* FunTy is a (unidirectional) pattern synonym that allows
<a name="line-245"></a>  positional pattern matching (FunTy arg res), ignoring the
<a name="line-246"></a>  ArgFlag.
<a name="line-247"></a>-}</span>
<a name="line-248"></a>
<a name="line-249"></a><span class='hs-comment'>{- -----------------------
<a name="line-250"></a>      Commented out until the pattern match
<a name="line-251"></a>      checker can handle it; see #16185
<a name="line-252"></a>
<a name="line-253"></a>      For now we use the CPP macro #define FunTy FFunTy _
<a name="line-254"></a>      (see HsVersions.h) to allow pattern matching on a
<a name="line-255"></a>      (positional) FunTy constructor.
<a name="line-256"></a>
<a name="line-257"></a>{-# COMPLETE FunTy, TyVarTy, AppTy, TyConApp
<a name="line-258"></a>           , ForAllTy, LitTy, CastTy, CoercionTy :: Type #-}
<a name="line-259"></a>
<a name="line-260"></a>-- | 'FunTy' is a (uni-directional) pattern synonym for the common
<a name="line-261"></a>-- case where we want to match on the argument/result type, but
<a name="line-262"></a>-- ignoring the AnonArgFlag
<a name="line-263"></a>pattern FunTy :: Type -&gt; Type -&gt; Type
<a name="line-264"></a>pattern FunTy arg res &lt;- FFunTy { ft_arg = arg, ft_res = res }
<a name="line-265"></a>
<a name="line-266"></a>       End of commented out block
<a name="line-267"></a>---------------------------------- -}</span>
<a name="line-268"></a>
<a name="line-269"></a><span class='hs-comment'>{- Note [Types for coercions, predicates, and evidence]
<a name="line-270"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-271"></a>We treat differently:
<a name="line-272"></a>
<a name="line-273"></a>  (a) Predicate types
<a name="line-274"></a>        Test: isPredTy
<a name="line-275"></a>        Binders: DictIds
<a name="line-276"></a>        Kind: Constraint
<a name="line-277"></a>        Examples: (Eq a), and (a ~ b)
<a name="line-278"></a>
<a name="line-279"></a>  (b) Coercion types are primitive, unboxed equalities
<a name="line-280"></a>        Test: isCoVarTy
<a name="line-281"></a>        Binders: CoVars (can appear in coercions)
<a name="line-282"></a>        Kind: TYPE (TupleRep [])
<a name="line-283"></a>        Examples: (t1 ~# t2) or (t1 ~R# t2)
<a name="line-284"></a>
<a name="line-285"></a>  (c) Evidence types is the type of evidence manipulated by
<a name="line-286"></a>      the type constraint solver.
<a name="line-287"></a>        Test: isEvVarType
<a name="line-288"></a>        Binders: EvVars
<a name="line-289"></a>        Kind: Constraint or TYPE (TupleRep [])
<a name="line-290"></a>        Examples: all coercion types and predicate types
<a name="line-291"></a>
<a name="line-292"></a>Coercion types and predicate types are mutually exclusive,
<a name="line-293"></a>but evidence types are a superset of both.
<a name="line-294"></a>
<a name="line-295"></a>When treated as a user type,
<a name="line-296"></a>
<a name="line-297"></a>  - Predicates (of kind Constraint) are invisible and are
<a name="line-298"></a>    implicitly instantiated
<a name="line-299"></a>
<a name="line-300"></a>  - Coercion types, and non-pred evidence types (i.e. not
<a name="line-301"></a>    of kind Constrain), are just regular old types, are
<a name="line-302"></a>    visible, and are not implicitly instantiated.
<a name="line-303"></a>
<a name="line-304"></a>In a FunTy { ft_af = InvisArg }, the argument type is always
<a name="line-305"></a>a Predicate type.
<a name="line-306"></a>
<a name="line-307"></a>Note [Weird typing rule for ForAllTy]
<a name="line-308"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-309"></a>Here are the typing rules for ForAllTy:
<a name="line-310"></a>
<a name="line-311"></a>tyvar : Type
<a name="line-312"></a>inner : TYPE r
<a name="line-313"></a>tyvar does not occur in r
<a name="line-314"></a>------------------------------------
<a name="line-315"></a>ForAllTy (Bndr tyvar vis) inner : TYPE r
<a name="line-316"></a>
<a name="line-317"></a>inner : TYPE r
<a name="line-318"></a>------------------------------------
<a name="line-319"></a>ForAllTy (Bndr covar vis) inner : Type
<a name="line-320"></a>
<a name="line-321"></a>Note that the kind of the result depends on whether the binder is a
<a name="line-322"></a>tyvar or a covar. The kind of a forall-over-tyvar is the same as
<a name="line-323"></a>the kind of the inner type. This is because quantification over types
<a name="line-324"></a>is erased before runtime. By contrast, the kind of a forall-over-covar
<a name="line-325"></a>is always Type, because a forall-over-covar is compiled into a function
<a name="line-326"></a>taking a 0-bit-wide erased coercion argument.
<a name="line-327"></a>
<a name="line-328"></a>Because the tyvar form above includes r in its result, we must
<a name="line-329"></a>be careful not to let any variables escape -- thus the last premise
<a name="line-330"></a>of the rule above.
<a name="line-331"></a>
<a name="line-332"></a>Note [Constraints in kinds]
<a name="line-333"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-334"></a>Do we allow a type constructor to have a kind like
<a name="line-335"></a>   S :: Eq a =&gt; a -&gt; Type
<a name="line-336"></a>
<a name="line-337"></a>No, we do not.  Doing so would mean would need a TyConApp like
<a name="line-338"></a>   S @k @(d :: Eq k) (ty :: k)
<a name="line-339"></a> and we have no way to build, or decompose, evidence like
<a name="line-340"></a> (d :: Eq k) at the type level.
<a name="line-341"></a>
<a name="line-342"></a>But we admit one exception: equality.  We /do/ allow, say,
<a name="line-343"></a>   MkT :: (a ~ b) =&gt; a -&gt; b -&gt; Type a b
<a name="line-344"></a>
<a name="line-345"></a>Why?  Because we can, without much difficulty.  Moreover
<a name="line-346"></a>we can promote a GADT data constructor (see TyCon
<a name="line-347"></a>Note [Promoted data constructors]), like
<a name="line-348"></a>  data GT a b where
<a name="line-349"></a>    MkGT : a -&gt; a -&gt; GT a a
<a name="line-350"></a>so programmers might reasonably expect to be able to
<a name="line-351"></a>promote MkT as well.
<a name="line-352"></a>
<a name="line-353"></a>How does this work?
<a name="line-354"></a>
<a name="line-355"></a>* In GHC.Tc.Validity.checkConstraintsOK we reject kinds that
<a name="line-356"></a>  have constraints other than (a~b) and (a~~b).
<a name="line-357"></a>
<a name="line-358"></a>* In Inst.tcInstInvisibleTyBinder we instantiate a call
<a name="line-359"></a>  of MkT by emitting
<a name="line-360"></a>     [W] co :: alpha ~# beta
<a name="line-361"></a>  and producing the elaborated term
<a name="line-362"></a>     MkT @alpha @beta (Eq# alpha beta co)
<a name="line-363"></a>  We don't generate a boxed "Wanted"; we generate only a
<a name="line-364"></a>  regular old /unboxed/ primitive-equality Wanted, and build
<a name="line-365"></a>  the box on the spot.
<a name="line-366"></a>
<a name="line-367"></a>* How can we get such a MkT?  By promoting a GADT-style data
<a name="line-368"></a>  constructor
<a name="line-369"></a>     data T a b where
<a name="line-370"></a>       MkT :: (a~b) =&gt; a -&gt; b -&gt; T a b
<a name="line-371"></a>  See DataCon.mkPromotedDataCon
<a name="line-372"></a>  and Note [Promoted data constructors] in GHC.Core.TyCon
<a name="line-373"></a>
<a name="line-374"></a>* We support both homogeneous (~) and heterogeneous (~~)
<a name="line-375"></a>  equality.  (See Note [The equality types story]
<a name="line-376"></a>  in GHC.Builtin.Types.Prim for a primer on these equality types.)
<a name="line-377"></a>
<a name="line-378"></a>* How do we prevent a MkT having an illegal constraint like
<a name="line-379"></a>  Eq a?  We check for this at use-sites; see GHC.Tc.Gen.HsType.tcTyVar,
<a name="line-380"></a>  specifically dc_theta_illegal_constraint.
<a name="line-381"></a>
<a name="line-382"></a>* Notice that nothing special happens if
<a name="line-383"></a>    K :: (a ~# b) =&gt; blah
<a name="line-384"></a>  because (a ~# b) is not a predicate type, and is never
<a name="line-385"></a>  implicitly instantiated. (Mind you, it's not clear how you
<a name="line-386"></a>  could creates a type constructor with such a kind.) See
<a name="line-387"></a>  Note [Types for coercions, predicates, and evidence]
<a name="line-388"></a>
<a name="line-389"></a>* The existence of promoted MkT with an equality-constraint
<a name="line-390"></a>  argument is the (only) reason that the AnonTCB constructor
<a name="line-391"></a>  of TyConBndrVis carries an AnonArgFlag (VisArg/InvisArg).
<a name="line-392"></a>  For example, when we promote the data constructor
<a name="line-393"></a>     MkT :: forall a b. (a~b) =&gt; a -&gt; b -&gt; T a b
<a name="line-394"></a>  we get a PromotedDataCon with tyConBinders
<a name="line-395"></a>      Bndr (a :: Type)  (NamedTCB Inferred)
<a name="line-396"></a>      Bndr (b :: Type)  (NamedTCB Inferred)
<a name="line-397"></a>      Bndr (_ :: a ~ b) (AnonTCB InvisArg)
<a name="line-398"></a>      Bndr (_ :: a)     (AnonTCB VisArg))
<a name="line-399"></a>      Bndr (_ :: b)     (AnonTCB VisArg))
<a name="line-400"></a>
<a name="line-401"></a>* One might reasonably wonder who *unpacks* these boxes once they are
<a name="line-402"></a>  made. After all, there is no type-level `case` construct. The
<a name="line-403"></a>  surprising answer is that no one ever does. Instead, if a GADT
<a name="line-404"></a>  constructor is used on the left-hand side of a type family equation,
<a name="line-405"></a>  that occurrence forces GHC to unify the types in question. For
<a name="line-406"></a>  example:
<a name="line-407"></a>
<a name="line-408"></a>  data G a where
<a name="line-409"></a>    MkG :: G Bool
<a name="line-410"></a>
<a name="line-411"></a>  type family F (x :: G a) :: a where
<a name="line-412"></a>    F MkG = False
<a name="line-413"></a>
<a name="line-414"></a>  When checking the LHS `F MkG`, GHC sees the MkG constructor and then must
<a name="line-415"></a>  unify F's implicit parameter `a` with Bool. This succeeds, making the equation
<a name="line-416"></a>
<a name="line-417"></a>    F Bool (MkG @Bool &lt;Bool&gt;) = False
<a name="line-418"></a>
<a name="line-419"></a>  Note that we never need unpack the coercion. This is because type
<a name="line-420"></a>  family equations are *not* parametric in their kind variables. That
<a name="line-421"></a>  is, we could have just said
<a name="line-422"></a>
<a name="line-423"></a>  type family H (x :: G a) :: a where
<a name="line-424"></a>    H _ = False
<a name="line-425"></a>
<a name="line-426"></a>  The presence of False on the RHS also forces `a` to become Bool,
<a name="line-427"></a>  giving us
<a name="line-428"></a>
<a name="line-429"></a>    H Bool _ = False
<a name="line-430"></a>
<a name="line-431"></a>  The fact that any of this works stems from the lack of phase
<a name="line-432"></a>  separation between types and kinds (unlike the very present phase
<a name="line-433"></a>  separation between terms and types).
<a name="line-434"></a>
<a name="line-435"></a>  Once we have the ability to pattern-match on types below top-level,
<a name="line-436"></a>  this will no longer cut it, but it seems fine for now.
<a name="line-437"></a>
<a name="line-438"></a>
<a name="line-439"></a>Note [Arguments to type constructors]
<a name="line-440"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-441"></a>Because of kind polymorphism, in addition to type application we now
<a name="line-442"></a>have kind instantiation. We reuse the same notations to do so.
<a name="line-443"></a>
<a name="line-444"></a>For example:
<a name="line-445"></a>
<a name="line-446"></a>  Just (* -&gt; *) Maybe
<a name="line-447"></a>  Right * Nat Zero
<a name="line-448"></a>
<a name="line-449"></a>are represented by:
<a name="line-450"></a>
<a name="line-451"></a>  TyConApp (PromotedDataCon Just) [* -&gt; *, Maybe]
<a name="line-452"></a>  TyConApp (PromotedDataCon Right) [*, Nat, (PromotedDataCon Zero)]
<a name="line-453"></a>
<a name="line-454"></a>Important note: Nat is used as a *kind* and not as a type. This can be
<a name="line-455"></a>confusing, since type-level Nat and kind-level Nat are identical. We
<a name="line-456"></a>use the kind of (PromotedDataCon Right) to know if its arguments are
<a name="line-457"></a>kinds or types.
<a name="line-458"></a>
<a name="line-459"></a>This kind instantiation only happens in TyConApp currently.
<a name="line-460"></a>
<a name="line-461"></a>Note [Non-trivial definitional equality]
<a name="line-462"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-463"></a>Is Int |&gt; &lt;*&gt; the same as Int? YES! In order to reduce headaches,
<a name="line-464"></a>we decide that any reflexive casts in types are just ignored.
<a name="line-465"></a>(Indeed they must be. See Note [Respecting definitional equality].)
<a name="line-466"></a>More generally, the `eqType` function, which defines Core's type equality
<a name="line-467"></a>relation, ignores casts and coercion arguments, as long as the
<a name="line-468"></a>two types have the same kind. This allows us to be a little sloppier
<a name="line-469"></a>in keeping track of coercions, which is a good thing. It also means
<a name="line-470"></a>that eqType does not depend on eqCoercion, which is also a good thing.
<a name="line-471"></a>
<a name="line-472"></a>Why is this sensible? That is, why is something different than α-equivalence
<a name="line-473"></a>appropriate for the implementation of eqType?
<a name="line-474"></a>
<a name="line-475"></a>Anything smaller than ~ and homogeneous is an appropriate definition for
<a name="line-476"></a>equality. The type safety of FC depends only on ~. Let's say η : τ ~ σ. Any
<a name="line-477"></a>expression of type τ can be transmuted to one of type σ at any point by
<a name="line-478"></a>casting. The same is true of expressions of type σ. So in some sense, τ and σ
<a name="line-479"></a>are interchangeable.
<a name="line-480"></a>
<a name="line-481"></a>But let's be more precise. If we examine the typing rules of FC (say, those in
<a name="line-482"></a>https://richarde.dev/papers/2015/equalities/equalities.pdf)
<a name="line-483"></a>there are several places where the same metavariable is used in two different
<a name="line-484"></a>premises to a rule. (For example, see Ty_App.) There is an implicit equality
<a name="line-485"></a>check here. What definition of equality should we use? By convention, we use
<a name="line-486"></a>α-equivalence. Take any rule with one (or more) of these implicit equality
<a name="line-487"></a>checks. Then there is an admissible rule that uses ~ instead of the implicit
<a name="line-488"></a>check, adding in casts as appropriate.
<a name="line-489"></a>
<a name="line-490"></a>The only problem here is that ~ is heterogeneous. To make the kinds work out
<a name="line-491"></a>in the admissible rule that uses ~, it is necessary to homogenize the
<a name="line-492"></a>coercions. That is, if we have η : (τ : κ1) ~ (σ : κ2), then we don't use η;
<a name="line-493"></a>we use η |&gt; kind η, which is homogeneous.
<a name="line-494"></a>
<a name="line-495"></a>The effect of this all is that eqType, the implementation of the implicit
<a name="line-496"></a>equality check, can use any homogeneous relation that is smaller than ~, as
<a name="line-497"></a>those rules must also be admissible.
<a name="line-498"></a>
<a name="line-499"></a>A more drawn out argument around all of this is presented in Section 7.2 of
<a name="line-500"></a>Richard E's thesis (<a href="http://richarde.dev/papers/2016/thesis/eisenberg-thesis.pdf).">http://richarde.dev/papers/2016/thesis/eisenberg-thesis.pdf).</a>
<a name="line-501"></a>
<a name="line-502"></a>What would go wrong if we insisted on the casts matching? See the beginning of
<a name="line-503"></a>Section 8 in the unpublished paper above. Theoretically, nothing at all goes
<a name="line-504"></a>wrong. But in practical terms, getting the coercions right proved to be
<a name="line-505"></a>nightmarish. And types would explode: during kind-checking, we often produce
<a name="line-506"></a>reflexive kind coercions. When we try to cast by these, mkCastTy just discards
<a name="line-507"></a>them. But if we used an eqType that distinguished between Int and Int |&gt; &lt;*&gt;,
<a name="line-508"></a>then we couldn't discard -- the output of kind-checking would be enormous,
<a name="line-509"></a>and we would need enormous casts with lots of CoherenceCo's to straighten
<a name="line-510"></a>them out.
<a name="line-511"></a>
<a name="line-512"></a>Would anything go wrong if eqType looked through type families? No, not at
<a name="line-513"></a>all. But that makes eqType rather hard to implement.
<a name="line-514"></a>
<a name="line-515"></a>Thus, the guideline for eqType is that it should be the largest
<a name="line-516"></a>easy-to-implement relation that is still smaller than ~ and homogeneous. The
<a name="line-517"></a>precise choice of relation is somewhat incidental, as long as the smart
<a name="line-518"></a>constructors and destructors in Type respect whatever relation is chosen.
<a name="line-519"></a>
<a name="line-520"></a>Another helpful principle with eqType is this:
<a name="line-521"></a>
<a name="line-522"></a> (EQ) If (t1 `eqType` t2) then I can replace t1 by t2 anywhere.
<a name="line-523"></a>
<a name="line-524"></a>This principle also tells us that eqType must relate only types with the
<a name="line-525"></a>same kinds.
<a name="line-526"></a>
<a name="line-527"></a>Interestingly, it must be the case that the free variables of t1 and t2
<a name="line-528"></a>might be different, even if t1 `eqType` t2. A simple example of this is
<a name="line-529"></a>if we have both cv1 :: k1 ~ k2 and cv2 :: k1 ~ k2 in the environment.
<a name="line-530"></a>Then t1 = t |&gt; cv1 and t2 = t |&gt; cv2 are eqType; yet cv1 is in the free
<a name="line-531"></a>vars of t1 and cv2 is in the free vars of t2. Unless we choose to implement
<a name="line-532"></a>eqType to be just α-equivalence, this wrinkle around free variables
<a name="line-533"></a>remains.
<a name="line-534"></a>
<a name="line-535"></a>Yet not all is lost: we can say that any two equal types share the same
<a name="line-536"></a>*relevant* free variables. Here, a relevant variable is a shallow
<a name="line-537"></a>free variable (see Note [Shallow and deep free variables] in GHC.Core.TyCo.FVs)
<a name="line-538"></a>that does not appear within a coercion. Note that type variables can
<a name="line-539"></a>appear within coercions (in, say, a Refl node), but that coercion variables
<a name="line-540"></a>cannot appear outside a coercion. We do not (yet) have a function to
<a name="line-541"></a>extract relevant free variables, but it would not be hard to write if
<a name="line-542"></a>the need arises.
<a name="line-543"></a>
<a name="line-544"></a>Besides eqType, another equality relation that upholds the (EQ) property above
<a name="line-545"></a>is /typechecker equality/, which is implemented as
<a name="line-546"></a>GHC.Tc.Utils.TcType.tcEqType. See
<a name="line-547"></a>Note [Typechecker equality vs definitional equality] in GHC.Tc.Utils.TcType for
<a name="line-548"></a>what the difference between eqType and tcEqType is.
<a name="line-549"></a>
<a name="line-550"></a>Note [Respecting definitional equality]
<a name="line-551"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-552"></a>Note [Non-trivial definitional equality] introduces the property (EQ).
<a name="line-553"></a>How is this upheld?
<a name="line-554"></a>
<a name="line-555"></a>Any function that pattern matches on all the constructors will have to
<a name="line-556"></a>consider the possibility of CastTy. Presumably, those functions will handle
<a name="line-557"></a>CastTy appropriately and we'll be OK.
<a name="line-558"></a>
<a name="line-559"></a>More dangerous are the splitXXX functions. Let's focus on splitTyConApp.
<a name="line-560"></a>We don't want it to fail on (T a b c |&gt; co). Happily, if we have
<a name="line-561"></a>  (T a b c |&gt; co) `eqType` (T d e f)
<a name="line-562"></a>then co must be reflexive. Why? eqType checks that the kinds are equal, as
<a name="line-563"></a>well as checking that (a `eqType` d), (b `eqType` e), and (c `eqType` f).
<a name="line-564"></a>By the kind check, we know that (T a b c |&gt; co) and (T d e f) have the same
<a name="line-565"></a>kind. So the only way that co could be non-reflexive is for (T a b c) to have
<a name="line-566"></a>a different kind than (T d e f). But because T's kind is closed (all tycon kinds
<a name="line-567"></a>are closed), the only way for this to happen is that one of the arguments has
<a name="line-568"></a>to differ, leading to a contradiction. Thus, co is reflexive.
<a name="line-569"></a>
<a name="line-570"></a>Accordingly, by eliminating reflexive casts, splitTyConApp need not worry
<a name="line-571"></a>about outermost casts to uphold (EQ). Eliminating reflexive casts is done
<a name="line-572"></a>in mkCastTy. This is (EQ1) below.
<a name="line-573"></a>
<a name="line-574"></a>Unforunately, that's not the end of the story. Consider comparing
<a name="line-575"></a>  (T a b c)      =?       (T a b |&gt; (co -&gt; &lt;Type&gt;)) (c |&gt; co)
<a name="line-576"></a>These two types have the same kind (Type), but the left type is a TyConApp
<a name="line-577"></a>while the right type is not. To handle this case, we say that the right-hand
<a name="line-578"></a>type is ill-formed, requiring an AppTy never to have a casted TyConApp
<a name="line-579"></a>on its left. It is easy enough to pull around the coercions to maintain
<a name="line-580"></a>this invariant, as done in Type.mkAppTy. In the example above, trying to
<a name="line-581"></a>form the right-hand type will instead yield (T a b (c |&gt; co |&gt; sym co) |&gt; &lt;Type&gt;).
<a name="line-582"></a>Both the casts there are reflexive and will be dropped. Huzzah.
<a name="line-583"></a>
<a name="line-584"></a>This idea of pulling coercions to the right works for splitAppTy as well.
<a name="line-585"></a>
<a name="line-586"></a>However, there is one hiccup: it's possible that a coercion doesn't relate two
<a name="line-587"></a>Pi-types. For example, if we have @type family Fun a b where Fun a b = a -&gt; b@,
<a name="line-588"></a>then we might have (T :: Fun Type Type) and (T |&gt; axFun) Int. That axFun can't
<a name="line-589"></a>be pulled to the right. But we don't need to pull it: (T |&gt; axFun) Int is not
<a name="line-590"></a>`eqType` to any proper TyConApp -- thus, leaving it where it is doesn't violate
<a name="line-591"></a>our (EQ) property.
<a name="line-592"></a>
<a name="line-593"></a>In order to detect reflexive casts reliably, we must make sure not
<a name="line-594"></a>to have nested casts: we update (t |&gt; co1 |&gt; co2) to (t |&gt; (co1 `TransCo` co2)).
<a name="line-595"></a>This is (EQ2) below.
<a name="line-596"></a>
<a name="line-597"></a>One other troublesome case is ForAllTy. See Note [Weird typing rule for ForAllTy].
<a name="line-598"></a>The kind of the body is the same as the kind of the ForAllTy. Accordingly,
<a name="line-599"></a>
<a name="line-600"></a>  ForAllTy tv (ty |&gt; co)     and     (ForAllTy tv ty) |&gt; co
<a name="line-601"></a>
<a name="line-602"></a>are `eqType`. But only the first can be split by splitForAllTy. So we forbid
<a name="line-603"></a>the second form, instead pushing the coercion inside to get the first form.
<a name="line-604"></a>This is done in mkCastTy.
<a name="line-605"></a>
<a name="line-606"></a>In sum, in order to uphold (EQ), we need the following invariants:
<a name="line-607"></a>
<a name="line-608"></a>  (EQ1) No decomposable CastTy to the left of an AppTy, where a decomposable
<a name="line-609"></a>        cast is one that relates either a FunTy to a FunTy or a
<a name="line-610"></a>        ForAllTy to a ForAllTy.
<a name="line-611"></a>  (EQ2) No reflexive casts in CastTy.
<a name="line-612"></a>  (EQ3) No nested CastTys.
<a name="line-613"></a>  (EQ4) No CastTy over (ForAllTy (Bndr tyvar vis) body).
<a name="line-614"></a>        See Note [Weird typing rule for ForAllTy]
<a name="line-615"></a>
<a name="line-616"></a>These invariants are all documented above, in the declaration for Type.
<a name="line-617"></a>
<a name="line-618"></a>Note [Equality on FunTys]
<a name="line-619"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-620"></a>A (FunTy vis mult arg res) is just an abbreviation for a
<a name="line-621"></a>  TyConApp funTyCon [mult, arg_rep, res_rep, arg, res]
<a name="line-622"></a>where
<a name="line-623"></a>  arg :: TYPE arg_rep
<a name="line-624"></a>  res :: TYPE res_rep
<a name="line-625"></a>Note that the vis field of a FunTy appears nowhere in the
<a name="line-626"></a>equivalent TyConApp. In Core, this is OK, because we no longer
<a name="line-627"></a>care about the visibility of the argument in a FunTy
<a name="line-628"></a>(the vis distinguishes between arg -&gt; res and arg =&gt; res).
<a name="line-629"></a>In the type-checker, we are careful not to decompose FunTys
<a name="line-630"></a>with an invisible argument. See also Note [Decomposing fat arrow c=&gt;t]
<a name="line-631"></a>in GHC.Core.Type.
<a name="line-632"></a>
<a name="line-633"></a>In order to compare FunTys while respecting how they could
<a name="line-634"></a>expand into TyConApps, we must check
<a name="line-635"></a>the kinds of the arg and the res.
<a name="line-636"></a>
<a name="line-637"></a>Note [Unused coercion variable in ForAllTy]
<a name="line-638"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-639"></a>Suppose we have
<a name="line-640"></a>  \(co:t1 ~ t2). e
<a name="line-641"></a>
<a name="line-642"></a>What type should we give to this expression?
<a name="line-643"></a>  (1) forall (co:t1 ~ t2) -&gt; t
<a name="line-644"></a>  (2) (t1 ~ t2) -&gt; t
<a name="line-645"></a>
<a name="line-646"></a>If co is used in t, (1) should be the right choice.
<a name="line-647"></a>if co is not used in t, we would like to have (1) and (2) equivalent.
<a name="line-648"></a>
<a name="line-649"></a>However, we want to keep eqType simple and don't want eqType (1) (2) to return
<a name="line-650"></a>True in any case.
<a name="line-651"></a>
<a name="line-652"></a>We decide to always construct (2) if co is not used in t.
<a name="line-653"></a>
<a name="line-654"></a>Thus in mkLamType, we check whether the variable is a coercion
<a name="line-655"></a>variable (of type (t1 ~# t2), and whether it is un-used in the
<a name="line-656"></a>body. If so, it returns a FunTy instead of a ForAllTy.
<a name="line-657"></a>
<a name="line-658"></a>There are cases we want to skip the check. For example, the check is
<a name="line-659"></a>unnecessary when it is known from the context that the input variable
<a name="line-660"></a>is a type variable.  In those cases, we use mkForAllTy.
<a name="line-661"></a>
<a name="line-662"></a>Note [Weird typing rule for ForAllTy]
<a name="line-663"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-664"></a>Here is the (truncated) typing rule for the dependent ForAllTy:
<a name="line-665"></a>
<a name="line-666"></a>  inner : TYPE r
<a name="line-667"></a>  tyvar is not free in r
<a name="line-668"></a>  ----------------------------------------
<a name="line-669"></a>  ForAllTy (Bndr tyvar vis) inner : TYPE r
<a name="line-670"></a>
<a name="line-671"></a>Note that the kind of `inner` is the kind of the overall ForAllTy. This is
<a name="line-672"></a>necessary because every ForAllTy over a type variable is erased at runtime.
<a name="line-673"></a>Thus the runtime representation of a ForAllTy (as encoded, via TYPE rep, in
<a name="line-674"></a>the kind) must be the same as the representation of the body. We must check
<a name="line-675"></a>for skolem-escape, though. The skolem-escape would prevent a definition like
<a name="line-676"></a>
<a name="line-677"></a>  undefined :: forall (r :: RuntimeRep) (a :: TYPE r). a
<a name="line-678"></a>
<a name="line-679"></a>because the type's kind (TYPE r) mentions the out-of-scope r. Luckily, the real
<a name="line-680"></a>type of undefined is
<a name="line-681"></a>
<a name="line-682"></a>  undefined :: forall (r :: RuntimeRep) (a :: TYPE r). HasCallStack =&gt; a
<a name="line-683"></a>
<a name="line-684"></a>and that HasCallStack constraint neatly sidesteps the potential skolem-escape
<a name="line-685"></a>problem.
<a name="line-686"></a>
<a name="line-687"></a>If the bound variable is a coercion variable:
<a name="line-688"></a>
<a name="line-689"></a>  inner : TYPE r
<a name="line-690"></a>  covar is free in inner
<a name="line-691"></a>  ------------------------------------
<a name="line-692"></a>  ForAllTy (Bndr covar vis) inner : Type
<a name="line-693"></a>
<a name="line-694"></a>Here, the kind of the ForAllTy is just Type, because coercion abstractions
<a name="line-695"></a>are *not* erased. The "covar is free in inner" premise is solely to maintain
<a name="line-696"></a>the representation invariant documented in
<a name="line-697"></a>Note [Unused coercion variable in ForAllTy]. Though there is surface similarity
<a name="line-698"></a>between this free-var check and the one in the tyvar rule, these two restrictions
<a name="line-699"></a>are truly unrelated.
<a name="line-700"></a>
<a name="line-701"></a>-}</span>
<a name="line-702"></a>
<a name="line-703"></a><a name="KnotTied"></a><span class='hs-comment'>-- | A type labeled 'KnotTied' might have knot-tied tycons in it. See</span>
<a name="line-704"></a><a name="KnotTied"></a><span class='hs-comment'>-- Note [Type checking recursive type and class declarations] in</span>
<a name="line-705"></a><a name="KnotTied"></a><span class='hs-comment'>-- "GHC.Tc.TyCl"</span>
<a name="line-706"></a><a name="KnotTied"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>KnotTied</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty</span>
<a name="line-707"></a>
<a name="line-708"></a><span class='hs-comment'>{- **********************************************************************
<a name="line-709"></a>*                                                                       *
<a name="line-710"></a>                  TyCoBinder and ArgFlag
<a name="line-711"></a>*                                                                       *
<a name="line-712"></a>********************************************************************** -}</span>
<a name="line-713"></a>
<a name="line-714"></a><a name="TyCoBinder"></a><span class='hs-comment'>-- | A 'TyCoBinder' represents an argument to a function. TyCoBinders can be</span>
<a name="line-715"></a><a name="TyCoBinder"></a><span class='hs-comment'>-- dependent ('Named') or nondependent ('Anon'). They may also be visible or</span>
<a name="line-716"></a><a name="TyCoBinder"></a><span class='hs-comment'>-- not. See Note [TyCoBinders]</span>
<a name="line-717"></a><a name="TyCoBinder"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TyCoBinder</span>
<a name="line-718"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Named</span> <span class='hs-conid'>TyCoVarBinder</span>    <span class='hs-comment'>-- A type-lambda binder</span>
<a name="line-719"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Anon</span> <span class='hs-conid'>AnonArgFlag</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- A term-lambda binder. Type here can be CoercionTy.</span>
<a name="line-720"></a>                                    <span class='hs-comment'>-- Visibility is determined by the AnonArgFlag</span>
<a name="line-721"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data.Data</span>
<a name="line-722"></a>
<a name="line-723"></a><a name="instance%20Outputable%20TyCoBinder"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>TyCoBinder</span> <span class='hs-keyword'>where</span>
<a name="line-724"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-varid'>af</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>af</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span>
<a name="line-725"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>v</span> <span class='hs-conid'>Required</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span>
<a name="line-726"></a>  <span class='hs-comment'>-- See Note [Explicit Case Statement for Specificity]</span>
<a name="line-727"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>v</span> <span class='hs-layout'>(</span><span class='hs-conid'>Invisible</span> <span class='hs-varid'>spec</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>spec</span> <span class='hs-keyword'>of</span>
<a name="line-728"></a>    <span class='hs-conid'>SpecifiedSpec</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>char</span> <span class='hs-chr'>'@'</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span>
<a name="line-729"></a>    <span class='hs-conid'>InferredSpec</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-730"></a>
<a name="line-731"></a>
<a name="line-732"></a><a name="TyBinder"></a><span class='hs-comment'>-- | 'TyBinder' is like 'TyCoBinder', but there can only be 'TyVarBinder'</span>
<a name="line-733"></a><a name="TyBinder"></a><span class='hs-comment'>-- in the 'Named' field.</span>
<a name="line-734"></a><a name="TyBinder"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>TyBinder</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyCoBinder</span>
<a name="line-735"></a>
<a name="line-736"></a><a name="delBinderVar"></a><span class='hs-comment'>-- | Remove the binder's variable from the set, if the binder has</span>
<a name="line-737"></a><span class='hs-comment'>-- a variable.</span>
<a name="line-738"></a><span class='hs-definition'>delBinderVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>VarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCoVarBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>VarSet</span>
<a name="line-739"></a><span class='hs-definition'>delBinderVar</span> <span class='hs-varid'>vars</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>vars</span> <span class='hs-varop'>`delVarSet`</span> <span class='hs-varid'>tv</span>
<a name="line-740"></a>
<a name="line-741"></a><a name="isInvisibleBinder"></a><span class='hs-comment'>-- | Does this binder bind an invisible argument?</span>
<a name="line-742"></a><span class='hs-definition'>isInvisibleBinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-743"></a><span class='hs-definition'>isInvisibleBinder</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isInvisibleArgFlag</span> <span class='hs-varid'>vis</span>
<a name="line-744"></a><span class='hs-definition'>isInvisibleBinder</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-conid'>InvisArg</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-745"></a><span class='hs-definition'>isInvisibleBinder</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-conid'>VisArg</span>   <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-746"></a>
<a name="line-747"></a><a name="isVisibleBinder"></a><span class='hs-comment'>-- | Does this binder bind a visible argument?</span>
<a name="line-748"></a><span class='hs-definition'>isVisibleBinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-749"></a><span class='hs-definition'>isVisibleBinder</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isInvisibleBinder</span>
<a name="line-750"></a>
<a name="line-751"></a><a name="isNamedBinder"></a><span class='hs-definition'>isNamedBinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-752"></a><span class='hs-definition'>isNamedBinder</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-753"></a><span class='hs-definition'>isNamedBinder</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-754"></a>
<a name="line-755"></a><a name="isTyBinder"></a><span class='hs-comment'>-- | If its a named binder, is the binder a tyvar?</span>
<a name="line-756"></a><span class='hs-comment'>-- Returns True for nondependent binder.</span>
<a name="line-757"></a><span class='hs-comment'>-- This check that we're really returning a *Ty*Binder (as opposed to a</span>
<a name="line-758"></a><span class='hs-comment'>-- coercion binder). That way, if/when we allow coercion quantification</span>
<a name="line-759"></a><span class='hs-comment'>-- in more places, we'll know we missed updating some function.</span>
<a name="line-760"></a><span class='hs-definition'>isTyBinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-761"></a><span class='hs-definition'>isTyBinder</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-varid'>bnd</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyVarBinder</span> <span class='hs-varid'>bnd</span>
<a name="line-762"></a><span class='hs-definition'>isTyBinder</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-763"></a>
<a name="line-764"></a><span class='hs-comment'>{- Note [TyCoBinders]
<a name="line-765"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-766"></a>A ForAllTy contains a TyCoVarBinder.  But a type can be decomposed
<a name="line-767"></a>to a telescope consisting of a [TyCoBinder]
<a name="line-768"></a>
<a name="line-769"></a>A TyCoBinder represents the type of binders -- that is, the type of an
<a name="line-770"></a>argument to a Pi-type. GHC Core currently supports two different
<a name="line-771"></a>Pi-types:
<a name="line-772"></a>
<a name="line-773"></a> * A non-dependent function type,
<a name="line-774"></a>   written with -&gt;, e.g. ty1 -&gt; ty2
<a name="line-775"></a>   represented as FunTy ty1 ty2. These are
<a name="line-776"></a>   lifted to Coercions with the corresponding FunCo.
<a name="line-777"></a>
<a name="line-778"></a> * A dependent compile-time-only polytype,
<a name="line-779"></a>   written with forall, e.g.  forall (a:*). ty
<a name="line-780"></a>   represented as ForAllTy (Bndr a v) ty
<a name="line-781"></a>
<a name="line-782"></a>Both Pi-types classify terms/types that take an argument. In other
<a name="line-783"></a>words, if `x` is either a function or a polytype, `x arg` makes sense
<a name="line-784"></a>(for an appropriate `arg`).
<a name="line-785"></a>
<a name="line-786"></a>
<a name="line-787"></a>Note [VarBndrs, TyCoVarBinders, TyConBinders, and visibility]
<a name="line-788"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-789"></a>* A ForAllTy (used for both types and kinds) contains a TyCoVarBinder.
<a name="line-790"></a>  Each TyCoVarBinder
<a name="line-791"></a>      Bndr a tvis
<a name="line-792"></a>  is equipped with tvis::ArgFlag, which says whether or not arguments
<a name="line-793"></a>  for this binder should be visible (explicit) in source Haskell.
<a name="line-794"></a>
<a name="line-795"></a>* A TyCon contains a list of TyConBinders.  Each TyConBinder
<a name="line-796"></a>      Bndr a cvis
<a name="line-797"></a>  is equipped with cvis::TyConBndrVis, which says whether or not type
<a name="line-798"></a>  and kind arguments for this TyCon should be visible (explicit) in
<a name="line-799"></a>  source Haskell.
<a name="line-800"></a>
<a name="line-801"></a>This table summarises the visibility rules:
<a name="line-802"></a>---------------------------------------------------------------------------------------
<a name="line-803"></a>|                                                      Occurrences look like this
<a name="line-804"></a>|                             GHC displays type as     in Haskell source code
<a name="line-805"></a>|--------------------------------------------------------------------------------------
<a name="line-806"></a>| Bndr a tvis :: TyCoVarBinder, in the binder of ForAllTy for a term
<a name="line-807"></a>|  tvis :: ArgFlag
<a name="line-808"></a>|  tvis = Inferred:            f :: forall {a}. type    Arg not allowed:  f
<a name="line-809"></a>                               f :: forall {co}. type   Arg not allowed:  f
<a name="line-810"></a>|  tvis = Specified:           f :: forall a. type      Arg optional:     f  or  f @Int
<a name="line-811"></a>|  tvis = Required:            T :: forall k -&gt; type    Arg required:     T *
<a name="line-812"></a>|    This last form is illegal in terms: See Note [No Required TyCoBinder in terms]
<a name="line-813"></a>|
<a name="line-814"></a>| Bndr k cvis :: TyConBinder, in the TyConBinders of a TyCon
<a name="line-815"></a>|  cvis :: TyConBndrVis
<a name="line-816"></a>|  cvis = AnonTCB:             T :: kind -&gt; kind        Required:            T *
<a name="line-817"></a>|  cvis = NamedTCB Inferred:   T :: forall {k}. kind    Arg not allowed:     T
<a name="line-818"></a>|                              T :: forall {co}. kind   Arg not allowed:     T
<a name="line-819"></a>|  cvis = NamedTCB Specified:  T :: forall k. kind      Arg not allowed[1]:  T
<a name="line-820"></a>|  cvis = NamedTCB Required:   T :: forall k -&gt; kind    Required:            T *
<a name="line-821"></a>---------------------------------------------------------------------------------------
<a name="line-822"></a>
<a name="line-823"></a>[1] In types, in the Specified case, it would make sense to allow
<a name="line-824"></a>    optional kind applications, thus (T @*), but we have not
<a name="line-825"></a>    yet implemented that
<a name="line-826"></a>
<a name="line-827"></a>---- In term declarations ----
<a name="line-828"></a>
<a name="line-829"></a>* Inferred.  Function defn, with no signature:  f1 x = x
<a name="line-830"></a>  We infer f1 :: forall {a}. a -&gt; a, with 'a' Inferred
<a name="line-831"></a>  It's Inferred because it doesn't appear in any
<a name="line-832"></a>  user-written signature for f1
<a name="line-833"></a>
<a name="line-834"></a>* Specified.  Function defn, with signature (implicit forall):
<a name="line-835"></a>     f2 :: a -&gt; a; f2 x = x
<a name="line-836"></a>  So f2 gets the type f2 :: forall a. a -&gt; a, with 'a' Specified
<a name="line-837"></a>  even though 'a' is not bound in the source code by an explicit forall
<a name="line-838"></a>
<a name="line-839"></a>* Specified.  Function defn, with signature (explicit forall):
<a name="line-840"></a>     f3 :: forall a. a -&gt; a; f3 x = x
<a name="line-841"></a>  So f3 gets the type f3 :: forall a. a -&gt; a, with 'a' Specified
<a name="line-842"></a>
<a name="line-843"></a>* Inferred.  Function defn, with signature (explicit forall), marked as inferred:
<a name="line-844"></a>     f4 :: forall {a}. a -&gt; a; f4 x = x
<a name="line-845"></a>  So f4 gets the type f4 :: forall {a}. a -&gt; a, with 'a' Inferred
<a name="line-846"></a>  It's Inferred because the user marked it as such, even though it does appear
<a name="line-847"></a>  in the user-written signature for f4
<a name="line-848"></a>
<a name="line-849"></a>* Inferred/Specified.  Function signature with inferred kind polymorphism.
<a name="line-850"></a>     f5 :: a b -&gt; Int
<a name="line-851"></a>  So 'f5' gets the type f5 :: forall {k} (a:k-&gt;*) (b:k). a b -&gt; Int
<a name="line-852"></a>  Here 'k' is Inferred (it's not mentioned in the type),
<a name="line-853"></a>  but 'a' and 'b' are Specified.
<a name="line-854"></a>
<a name="line-855"></a>* Specified.  Function signature with explicit kind polymorphism
<a name="line-856"></a>     f6 :: a (b :: k) -&gt; Int
<a name="line-857"></a>  This time 'k' is Specified, because it is mentioned explicitly,
<a name="line-858"></a>  so we get f6 :: forall (k:*) (a:k-&gt;*) (b:k). a b -&gt; Int
<a name="line-859"></a>
<a name="line-860"></a>* Similarly pattern synonyms:
<a name="line-861"></a>  Inferred - from inferred types (e.g. no pattern type signature)
<a name="line-862"></a>           - or from inferred kind polymorphism
<a name="line-863"></a>
<a name="line-864"></a>---- In type declarations ----
<a name="line-865"></a>
<a name="line-866"></a>* Inferred (k)
<a name="line-867"></a>     data T1 a b = MkT1 (a b)
<a name="line-868"></a>  Here T1's kind is  T1 :: forall {k:*}. (k-&gt;*) -&gt; k -&gt; *
<a name="line-869"></a>  The kind variable 'k' is Inferred, since it is not mentioned
<a name="line-870"></a>
<a name="line-871"></a>  Note that 'a' and 'b' correspond to /Anon/ TyCoBinders in T1's kind,
<a name="line-872"></a>  and Anon binders don't have a visibility flag. (Or you could think
<a name="line-873"></a>  of Anon having an implicit Required flag.)
<a name="line-874"></a>
<a name="line-875"></a>* Specified (k)
<a name="line-876"></a>     data T2 (a::k-&gt;*) b = MkT (a b)
<a name="line-877"></a>  Here T's kind is  T :: forall (k:*). (k-&gt;*) -&gt; k -&gt; *
<a name="line-878"></a>  The kind variable 'k' is Specified, since it is mentioned in
<a name="line-879"></a>  the signature.
<a name="line-880"></a>
<a name="line-881"></a>* Required (k)
<a name="line-882"></a>     data T k (a::k-&gt;*) b = MkT (a b)
<a name="line-883"></a>  Here T's kind is  T :: forall k:* -&gt; (k-&gt;*) -&gt; k -&gt; *
<a name="line-884"></a>  The kind is Required, since it bound in a positional way in T's declaration
<a name="line-885"></a>  Every use of T must be explicitly applied to a kind
<a name="line-886"></a>
<a name="line-887"></a>* Inferred (k1), Specified (k)
<a name="line-888"></a>     data T a b (c :: k) = MkT (a b) (Proxy c)
<a name="line-889"></a>  Here T's kind is  T :: forall {k1:*} (k:*). (k1-&gt;*) -&gt; k1 -&gt; k -&gt; *
<a name="line-890"></a>  So 'k' is Specified, because it appears explicitly,
<a name="line-891"></a>  but 'k1' is Inferred, because it does not
<a name="line-892"></a>
<a name="line-893"></a>Generally, in the list of TyConBinders for a TyCon,
<a name="line-894"></a>
<a name="line-895"></a>* Inferred arguments always come first
<a name="line-896"></a>* Specified, Anon and Required can be mixed
<a name="line-897"></a>
<a name="line-898"></a>e.g.
<a name="line-899"></a>  data Foo (a :: Type) :: forall b. (a -&gt; b -&gt; Type) -&gt; Type where ...
<a name="line-900"></a>
<a name="line-901"></a>Here Foo's TyConBinders are
<a name="line-902"></a>   [Required 'a', Specified 'b', Anon]
<a name="line-903"></a>and its kind prints as
<a name="line-904"></a>   Foo :: forall a -&gt; forall b. (a -&gt; b -&gt; Type) -&gt; Type
<a name="line-905"></a>
<a name="line-906"></a>See also Note [Required, Specified, and Inferred for types] in GHC.Tc.TyCl
<a name="line-907"></a>
<a name="line-908"></a>---- Printing -----
<a name="line-909"></a>
<a name="line-910"></a> We print forall types with enough syntax to tell you their visibility
<a name="line-911"></a> flag.  But this is not source Haskell, and these types may not all
<a name="line-912"></a> be parsable.
<a name="line-913"></a>
<a name="line-914"></a> Specified: a list of Specified binders is written between `forall` and `.`:
<a name="line-915"></a>               const :: forall a b. a -&gt; b -&gt; a
<a name="line-916"></a>
<a name="line-917"></a> Inferred: like Specified, but every binder is written in braces:
<a name="line-918"></a>               f :: forall {k} (a:k). S k a -&gt; Int
<a name="line-919"></a>
<a name="line-920"></a> Required: binders are put between `forall` and `-&gt;`:
<a name="line-921"></a>              T :: forall k -&gt; *
<a name="line-922"></a>
<a name="line-923"></a>---- Other points -----
<a name="line-924"></a>
<a name="line-925"></a>* In classic Haskell, all named binders (that is, the type variables in
<a name="line-926"></a>  a polymorphic function type f :: forall a. a -&gt; a) have been Inferred.
<a name="line-927"></a>
<a name="line-928"></a>* Inferred variables correspond to "generalized" variables from the
<a name="line-929"></a>  Visible Type Applications paper (ESOP'16).
<a name="line-930"></a>
<a name="line-931"></a>Note [No Required TyCoBinder in terms]
<a name="line-932"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-933"></a>We don't allow Required foralls for term variables, including pattern
<a name="line-934"></a>synonyms and data constructors.  Why?  Because then an application
<a name="line-935"></a>would need a /compulsory/ type argument (possibly without an "@"?),
<a name="line-936"></a>thus (f Int); and we don't have concrete syntax for that.
<a name="line-937"></a>
<a name="line-938"></a>We could change this decision, but Required, Named TyCoBinders are rare
<a name="line-939"></a>anyway.  (Most are Anons.)
<a name="line-940"></a>
<a name="line-941"></a>However the type of a term can (just about) have a required quantifier;
<a name="line-942"></a>see Note [Required quantifiers in the type of a term] in GHC.Tc.Gen.Expr.
<a name="line-943"></a>-}</span>
<a name="line-944"></a>
<a name="line-945"></a>
<a name="line-946"></a><span class='hs-comment'>{- **********************************************************************
<a name="line-947"></a>*                                                                       *
<a name="line-948"></a>                        PredType
<a name="line-949"></a>*                                                                       *
<a name="line-950"></a>********************************************************************** -}</span>
<a name="line-951"></a>
<a name="line-952"></a>
<a name="line-953"></a><a name="PredType"></a><span class='hs-comment'>-- | A type of the form @p@ of constraint kind represents a value whose type is</span>
<a name="line-954"></a><a name="PredType"></a><span class='hs-comment'>-- the Haskell predicate @p@, where a predicate is what occurs before</span>
<a name="line-955"></a><a name="PredType"></a><span class='hs-comment'>-- the @=&gt;@ in a Haskell type.</span>
<a name="line-956"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-957"></a><a name="PredType"></a><span class='hs-comment'>-- We use 'PredType' as documentation to mark those types that we guarantee to</span>
<a name="line-958"></a><a name="PredType"></a><span class='hs-comment'>-- have this kind.</span>
<a name="line-959"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-960"></a><a name="PredType"></a><span class='hs-comment'>-- It can be expanded into its representation, but:</span>
<a name="line-961"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-962"></a><a name="PredType"></a><span class='hs-comment'>-- * The type checker must treat it as opaque</span>
<a name="line-963"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-964"></a><a name="PredType"></a><span class='hs-comment'>-- * The rest of the compiler treats it as transparent</span>
<a name="line-965"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-966"></a><a name="PredType"></a><span class='hs-comment'>-- Consider these examples:</span>
<a name="line-967"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-968"></a><a name="PredType"></a><span class='hs-comment'>-- &gt; f :: (Eq a) =&gt; a -&gt; Int</span>
<a name="line-969"></a><a name="PredType"></a><span class='hs-comment'>-- &gt; g :: (?x :: Int -&gt; Int) =&gt; a -&gt; Int</span>
<a name="line-970"></a><a name="PredType"></a><span class='hs-comment'>-- &gt; h :: (r\l) =&gt; {r} =&gt; {l::Int | r}</span>
<a name="line-971"></a><a name="PredType"></a><span class='hs-comment'>--</span>
<a name="line-972"></a><a name="PredType"></a><span class='hs-comment'>-- Here the @Eq a@ and @?x :: Int -&gt; Int@ and @r\l@ are all called \"predicates\"</span>
<a name="line-973"></a><a name="PredType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
<a name="line-974"></a>
<a name="line-975"></a><a name="ThetaType"></a><span class='hs-comment'>-- | A collection of 'PredType's</span>
<a name="line-976"></a><a name="ThetaType"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>
<a name="line-977"></a>
<a name="line-978"></a><span class='hs-comment'>{-
<a name="line-979"></a>(We don't support TREX records yet, but the setup is designed
<a name="line-980"></a>to expand to allow them.)
<a name="line-981"></a>
<a name="line-982"></a>A Haskell qualified type, such as that for f,g,h above, is
<a name="line-983"></a>represented using
<a name="line-984"></a>        * a FunTy for the double arrow
<a name="line-985"></a>        * with a type of kind Constraint as the function argument
<a name="line-986"></a>
<a name="line-987"></a>The predicate really does turn into a real extra argument to the
<a name="line-988"></a>function.  If the argument has type (p :: Constraint) then the predicate p is
<a name="line-989"></a>represented by evidence of type p.
<a name="line-990"></a>
<a name="line-991"></a>
<a name="line-992"></a>%************************************************************************
<a name="line-993"></a>%*                                                                      *
<a name="line-994"></a>            Simple constructors
<a name="line-995"></a>%*                                                                      *
<a name="line-996"></a>%************************************************************************
<a name="line-997"></a>
<a name="line-998"></a>These functions are here so that they can be used by GHC.Builtin.Types.Prim,
<a name="line-999"></a>which in turn is imported by Type
<a name="line-1000"></a>-}</span>
<a name="line-1001"></a>
<a name="line-1002"></a><a name="mkTyVarTy"></a><span class='hs-definition'>mkTyVarTy</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVar</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1003"></a><span class='hs-definition'>mkTyVarTy</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-1004"></a>              <span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>v</span>
<a name="line-1005"></a>
<a name="line-1006"></a><a name="mkTyVarTys"></a><span class='hs-definition'>mkTyVarTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1007"></a><span class='hs-definition'>mkTyVarTys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-comment'>-- a common use of mkTyVarTy</span>
<a name="line-1008"></a>
<a name="line-1009"></a><a name="mkTyCoVarTy"></a><span class='hs-definition'>mkTyCoVarTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1010"></a><span class='hs-definition'>mkTyCoVarTy</span> <span class='hs-varid'>v</span>
<a name="line-1011"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTyVar</span> <span class='hs-varid'>v</span>
<a name="line-1012"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>v</span>
<a name="line-1013"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1014"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoercionTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoVarCo</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-1015"></a>
<a name="line-1016"></a><a name="mkTyCoVarTys"></a><span class='hs-definition'>mkTyCoVarTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCoVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1017"></a><span class='hs-definition'>mkTyCoVarTys</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-varid'>mkTyCoVarTy</span>
<a name="line-1018"></a>
<a name="line-1019"></a><span class='hs-keyword'>infixr</span> <span class='hs-num'>3</span> <span class='hs-varop'>`mkFunTy`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkVisFunTy`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkInvisFunTy`</span><span class='hs-layout'>,</span> <span class='hs-varop'>`mkVisFunTyMany`</span><span class='hs-layout'>,</span>
<a name="line-1020"></a>         <span class='hs-varop'>`mkInvisFunTyMany`</span>      <span class='hs-comment'>-- Associates to the right</span>
<a name="line-1021"></a>
<a name="line-1022"></a><a name="mkFunTy"></a><span class='hs-definition'>mkFunTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnonArgFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1023"></a><span class='hs-definition'>mkFunTy</span> <span class='hs-varid'>af</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FunTy</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ft_af</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>af</span>
<a name="line-1024"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ft_mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mult</span>
<a name="line-1025"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ft_arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>arg</span>
<a name="line-1026"></a>                                <span class='hs-layout'>,</span> <span class='hs-varid'>ft_res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>res</span> <span class='hs-layout'>}</span>
<a name="line-1027"></a>
<a name="line-1028"></a><a name="mkScaledFunTy"></a><span class='hs-definition'>mkScaledFunTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnonArgFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1029"></a><span class='hs-definition'>mkScaledFunTy</span> <span class='hs-varid'>af</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span> <span class='hs-varid'>res</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunTy</span> <span class='hs-varid'>af</span> <span class='hs-varid'>mult</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span>
<a name="line-1030"></a>
<a name="line-1031"></a><a name="mkVisFunTy"></a><span class='hs-definition'>mkVisFunTy</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkInvisFunTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1032"></a><span class='hs-definition'>mkVisFunTy</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunTy</span> <span class='hs-conid'>VisArg</span>
<a name="line-1033"></a><a name="mkInvisFunTy"></a><span class='hs-definition'>mkInvisFunTy</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunTy</span> <span class='hs-conid'>InvisArg</span>
<a name="line-1034"></a>
<a name="line-1035"></a><a name="mkFunTyMany"></a><span class='hs-definition'>mkFunTyMany</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>AnonArgFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1036"></a><span class='hs-definition'>mkFunTyMany</span> <span class='hs-varid'>af</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFunTy</span> <span class='hs-varid'>af</span> <span class='hs-varid'>manyDataConTy</span>
<a name="line-1037"></a>
<a name="line-1038"></a><a name="mkVisFunTyMany"></a><span class='hs-comment'>-- | Special, common, case: Arrow type with mult Many</span>
<a name="line-1039"></a><span class='hs-definition'>mkVisFunTyMany</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1040"></a><span class='hs-definition'>mkVisFunTyMany</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVisFunTy</span> <span class='hs-varid'>manyDataConTy</span>
<a name="line-1041"></a>
<a name="line-1042"></a><a name="mkInvisFunTyMany"></a><span class='hs-definition'>mkInvisFunTyMany</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1043"></a><span class='hs-definition'>mkInvisFunTyMany</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkInvisFunTy</span> <span class='hs-varid'>manyDataConTy</span>
<a name="line-1044"></a>
<a name="line-1045"></a><a name="mkVisFunTys"></a><span class='hs-comment'>-- | Make nested arrow types</span>
<a name="line-1046"></a><span class='hs-definition'>mkVisFunTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1047"></a><span class='hs-definition'>mkVisFunTys</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkScaledFunTy</span> <span class='hs-conid'>VisArg</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span>
<a name="line-1048"></a>
<a name="line-1049"></a><a name="mkVisFunTysMany"></a><span class='hs-definition'>mkVisFunTysMany</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1050"></a><span class='hs-definition'>mkVisFunTysMany</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkVisFunTyMany</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span>
<a name="line-1051"></a>
<a name="line-1052"></a><a name="mkInvisFunTysMany"></a><span class='hs-definition'>mkInvisFunTysMany</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1053"></a><span class='hs-definition'>mkInvisFunTysMany</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkInvisFunTyMany</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tys</span>
<a name="line-1054"></a>
<a name="line-1055"></a><a name="mkForAllTy"></a><span class='hs-comment'>-- | Like 'mkTyCoForAllTy', but does not check the occurrence of the binder</span>
<a name="line-1056"></a><span class='hs-comment'>-- See Note [Unused coercion variable in ForAllTy]</span>
<a name="line-1057"></a><span class='hs-definition'>mkForAllTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1058"></a><span class='hs-definition'>mkForAllTy</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-1059"></a>
<a name="line-1060"></a><a name="mkForAllTys"></a><span class='hs-comment'>-- | Wraps foralls over the type using the provided 'TyCoVar's from left to right</span>
<a name="line-1061"></a><span class='hs-definition'>mkForAllTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCoVarBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1062"></a><span class='hs-definition'>mkForAllTys</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tyvars</span>
<a name="line-1063"></a>
<a name="line-1064"></a><a name="mkInvisForAllTys"></a><span class='hs-comment'>-- | Wraps foralls over the type using the provided 'InvisTVBinder's from left to right</span>
<a name="line-1065"></a><span class='hs-definition'>mkInvisForAllTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>InvisTVBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1066"></a><span class='hs-definition'>mkInvisForAllTys</span> <span class='hs-varid'>tyvars</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-conid'>ForAllTy</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>$</span> <span class='hs-varid'>tyVarSpecToBinders</span> <span class='hs-varid'>tyvars</span>
<a name="line-1067"></a>
<a name="line-1068"></a><a name="mkPiTy"></a><span class='hs-definition'>mkPiTy</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCoBinder</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1069"></a><span class='hs-definition'>mkPiTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Anon</span> <span class='hs-varid'>af</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkScaledFunTy</span> <span class='hs-varid'>af</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1070"></a><span class='hs-definition'>mkPiTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Named</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkForAllTy</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span> <span class='hs-varid'>ty</span>
<a name="line-1071"></a>
<a name="line-1072"></a><a name="mkPiTys"></a><span class='hs-definition'>mkPiTys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TyCoBinder</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1073"></a><span class='hs-definition'>mkPiTys</span> <span class='hs-varid'>tbs</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkPiTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>tbs</span>
<a name="line-1074"></a>
<a name="line-1075"></a><a name="mkTyConTy_"></a><span class='hs-comment'>-- | Create a nullary 'TyConApp'. In general you should rather use</span>
<a name="line-1076"></a><span class='hs-comment'>-- 'GHC.Core.Type.mkTyConTy'. This merely exists to break the import cycle</span>
<a name="line-1077"></a><span class='hs-comment'>-- between 'GHC.Core.TyCon' and this module.</span>
<a name="line-1078"></a><span class='hs-definition'>mkTyConTy_</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span>
<a name="line-1079"></a><span class='hs-definition'>mkTyConTy_</span> <span class='hs-varid'>tycon</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tycon</span> <span class='hs-conid'>[]</span>
<a name="line-1080"></a>
<a name="line-1081"></a><span class='hs-comment'>{-
<a name="line-1082"></a>%************************************************************************
<a name="line-1083"></a>%*                                                                      *
<a name="line-1084"></a>            Coercions
<a name="line-1085"></a>%*                                                                      *
<a name="line-1086"></a>%************************************************************************
<a name="line-1087"></a>-}</span>
<a name="line-1088"></a>
<a name="line-1089"></a><span class='hs-comment'>-- | A 'Coercion' is concrete evidence of the equality/convertibility</span>
<a name="line-1090"></a><span class='hs-comment'>-- of two types.</span>
<a name="line-1091"></a>
<a name="line-1092"></a><a name="Coercion"></a><span class='hs-comment'>-- If you edit this type, you may need to update the GHC formalism</span>
<a name="line-1093"></a><a name="Coercion"></a><span class='hs-comment'>-- See Note [GHC Formalism] in GHC.Core.Lint</span>
<a name="line-1094"></a><a name="Coercion"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Coercion</span>
<a name="line-1095"></a>  <span class='hs-comment'>-- Each constructor has a "role signature", indicating the way roles are</span>
<a name="line-1096"></a>  <span class='hs-comment'>-- propagated through coercions.</span>
<a name="line-1097"></a>  <span class='hs-comment'>--    -  P, N, and R stand for coercions of the given role</span>
<a name="line-1098"></a>  <span class='hs-comment'>--    -  e stands for a coercion of a specific unknown role</span>
<a name="line-1099"></a>  <span class='hs-comment'>--           (think "role polymorphism")</span>
<a name="line-1100"></a>  <span class='hs-comment'>--    -  "e" stands for an explicit role parameter indicating role e.</span>
<a name="line-1101"></a>  <span class='hs-comment'>--    -   _ stands for a parameter that is not a Role or Coercion.</span>
<a name="line-1102"></a>
<a name="line-1103"></a>  <span class='hs-comment'>-- These ones mirror the shape of types</span>
<a name="line-1104"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Refl :: _ -&gt; N</span>
<a name="line-1105"></a>    <span class='hs-comment'>-- A special case reflexivity for a very common case: Nominal reflexivity</span>
<a name="line-1106"></a>    <span class='hs-comment'>-- If you need Representational, use (GRefl Representational ty MRefl)</span>
<a name="line-1107"></a>    <span class='hs-comment'>--                               not (SubCo (Refl ty))</span>
<a name="line-1108"></a>    <span class='hs-conid'>Refl</span> <span class='hs-conid'>Type</span>  <span class='hs-comment'>-- See Note [Refl invariant]</span>
<a name="line-1109"></a>
<a name="line-1110"></a>  <span class='hs-comment'>-- GRefl :: "e" -&gt; _ -&gt; Maybe N -&gt; e</span>
<a name="line-1111"></a>  <span class='hs-comment'>-- See Note [Generalized reflexive coercion]</span>
<a name="line-1112"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GRefl</span> <span class='hs-conid'>Role</span> <span class='hs-conid'>Type</span> <span class='hs-conid'>MCoercionN</span>  <span class='hs-comment'>-- See Note [Refl invariant]</span>
<a name="line-1113"></a>          <span class='hs-comment'>-- Use (Refl ty), not (GRefl Nominal ty MRefl)</span>
<a name="line-1114"></a>          <span class='hs-comment'>-- Use (GRefl Representational _ _), not (SubCo (GRefl Nominal _ _))</span>
<a name="line-1115"></a>
<a name="line-1116"></a>  <span class='hs-comment'>-- These ones simply lift the correspondingly-named</span>
<a name="line-1117"></a>  <span class='hs-comment'>-- Type constructors into Coercions</span>
<a name="line-1118"></a>
<a name="line-1119"></a>  <span class='hs-comment'>-- TyConAppCo :: "e" -&gt; _ -&gt; ?? -&gt; e</span>
<a name="line-1120"></a>  <span class='hs-comment'>-- See Note [TyConAppCo roles]</span>
<a name="line-1121"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TyConAppCo</span> <span class='hs-conid'>Role</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span>    <span class='hs-comment'>-- lift TyConApp</span>
<a name="line-1122"></a>               <span class='hs-comment'>-- The TyCon is never a synonym;</span>
<a name="line-1123"></a>               <span class='hs-comment'>-- we expand synonyms eagerly</span>
<a name="line-1124"></a>               <span class='hs-comment'>-- But it can be a type function</span>
<a name="line-1125"></a>               <span class='hs-comment'>-- TyCon is never a saturated (-&gt;); use FunCo instead</span>
<a name="line-1126"></a>
<a name="line-1127"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AppCo</span> <span class='hs-conid'>Coercion</span> <span class='hs-conid'>CoercionN</span>             <span class='hs-comment'>-- lift AppTy</span>
<a name="line-1128"></a>          <span class='hs-comment'>-- AppCo :: e -&gt; N -&gt; e</span>
<a name="line-1129"></a>
<a name="line-1130"></a>  <span class='hs-comment'>-- See Note [Forall coercions]</span>
<a name="line-1131"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ForAllCo</span> <span class='hs-conid'>TyCoVar</span> <span class='hs-conid'>KindCoercion</span> <span class='hs-conid'>Coercion</span>
<a name="line-1132"></a>         <span class='hs-comment'>-- ForAllCo :: _ -&gt; N -&gt; e -&gt; e</span>
<a name="line-1133"></a>
<a name="line-1134"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FunCo</span> <span class='hs-conid'>Role</span> <span class='hs-conid'>CoercionN</span> <span class='hs-conid'>Coercion</span> <span class='hs-conid'>Coercion</span>         <span class='hs-comment'>-- lift FunTy</span>
<a name="line-1135"></a>         <span class='hs-comment'>-- FunCo :: "e" -&gt; N -&gt; e -&gt; e -&gt; e</span>
<a name="line-1136"></a>         <span class='hs-comment'>-- Note: why doesn't FunCo have a AnonArgFlag, like FunTy?</span>
<a name="line-1137"></a>         <span class='hs-comment'>-- Because the AnonArgFlag has no impact on Core; it is only</span>
<a name="line-1138"></a>         <span class='hs-comment'>-- there to guide implicit instantiation of Haskell source</span>
<a name="line-1139"></a>         <span class='hs-comment'>-- types, and that is irrelevant for coercions, which are</span>
<a name="line-1140"></a>         <span class='hs-comment'>-- Core-only.</span>
<a name="line-1141"></a>
<a name="line-1142"></a>  <span class='hs-comment'>-- These are special</span>
<a name="line-1143"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CoVarCo</span> <span class='hs-conid'>CoVar</span>      <span class='hs-comment'>-- :: _ -&gt; (N or R)</span>
<a name="line-1144"></a>                       <span class='hs-comment'>-- result role depends on the tycon of the variable's type</span>
<a name="line-1145"></a>
<a name="line-1146"></a>    <span class='hs-comment'>-- AxiomInstCo :: e -&gt; _ -&gt; ?? -&gt; e</span>
<a name="line-1147"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AxiomInstCo</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoAxiom</span> <span class='hs-conid'>Branched</span><span class='hs-layout'>)</span> <span class='hs-conid'>BranchIndex</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span>
<a name="line-1148"></a>     <span class='hs-comment'>-- See also [CoAxiom index]</span>
<a name="line-1149"></a>     <span class='hs-comment'>-- The coercion arguments always *precisely* saturate</span>
<a name="line-1150"></a>     <span class='hs-comment'>-- arity of (that branch of) the CoAxiom. If there are</span>
<a name="line-1151"></a>     <span class='hs-comment'>-- any left over, we use AppCo.</span>
<a name="line-1152"></a>     <span class='hs-comment'>-- See [Coercion axioms applied to coercions]</span>
<a name="line-1153"></a>     <span class='hs-comment'>-- The roles of the argument coercions are determined</span>
<a name="line-1154"></a>     <span class='hs-comment'>-- by the cab_roles field of the relevant branch of the CoAxiom</span>
<a name="line-1155"></a>
<a name="line-1156"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>AxiomRuleCo</span> <span class='hs-conid'>CoAxiomRule</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span>
<a name="line-1157"></a>    <span class='hs-comment'>-- AxiomRuleCo is very like AxiomInstCo, but for a CoAxiomRule</span>
<a name="line-1158"></a>    <span class='hs-comment'>-- The number coercions should match exactly the expectations</span>
<a name="line-1159"></a>    <span class='hs-comment'>-- of the CoAxiomRule (i.e., the rule is fully saturated).</span>
<a name="line-1160"></a>
<a name="line-1161"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UnivCo</span> <span class='hs-conid'>UnivCoProvenance</span> <span class='hs-conid'>Role</span> <span class='hs-conid'>Type</span> <span class='hs-conid'>Type</span>
<a name="line-1162"></a>      <span class='hs-comment'>-- :: _ -&gt; "e" -&gt; _ -&gt; _ -&gt; e</span>
<a name="line-1163"></a>
<a name="line-1164"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SymCo</span> <span class='hs-conid'>Coercion</span>             <span class='hs-comment'>-- :: e -&gt; e</span>
<a name="line-1165"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TransCo</span> <span class='hs-conid'>Coercion</span> <span class='hs-conid'>Coercion</span>  <span class='hs-comment'>-- :: e -&gt; e -&gt; e</span>
<a name="line-1166"></a>
<a name="line-1167"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NthCo</span>  <span class='hs-conid'>Role</span> <span class='hs-conid'>Int</span> <span class='hs-conid'>Coercion</span>     <span class='hs-comment'>-- Zero-indexed; decomposes (T t0 ... tn)</span>
<a name="line-1168"></a>    <span class='hs-comment'>-- :: "e" -&gt; _ -&gt; e0 -&gt; e (inverse of TyConAppCo, see Note [TyConAppCo roles])</span>
<a name="line-1169"></a>    <span class='hs-comment'>-- Using NthCo on a ForAllCo gives an N coercion always</span>
<a name="line-1170"></a>    <span class='hs-comment'>-- See Note [NthCo and newtypes]</span>
<a name="line-1171"></a>    <span class='hs-comment'>--</span>
<a name="line-1172"></a>    <span class='hs-comment'>-- Invariant:  (NthCo r i co), it is always the case that r = role of (Nth i co)</span>
<a name="line-1173"></a>    <span class='hs-comment'>-- That is: the role of the entire coercion is redundantly cached here.</span>
<a name="line-1174"></a>    <span class='hs-comment'>-- See Note [NthCo Cached Roles]</span>
<a name="line-1175"></a>
<a name="line-1176"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LRCo</span>   <span class='hs-conid'>LeftOrRight</span> <span class='hs-conid'>CoercionN</span>     <span class='hs-comment'>-- Decomposes (t_left t_right)</span>
<a name="line-1177"></a>    <span class='hs-comment'>-- :: _ -&gt; N -&gt; N</span>
<a name="line-1178"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>InstCo</span> <span class='hs-conid'>Coercion</span> <span class='hs-conid'>CoercionN</span>
<a name="line-1179"></a>    <span class='hs-comment'>-- :: e -&gt; N -&gt; e</span>
<a name="line-1180"></a>    <span class='hs-comment'>-- See Note [InstCo roles]</span>
<a name="line-1181"></a>
<a name="line-1182"></a>  <span class='hs-comment'>-- Extract a kind coercion from a (heterogeneous) type coercion</span>
<a name="line-1183"></a>  <span class='hs-comment'>-- NB: all kind coercions are Nominal</span>
<a name="line-1184"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>KindCo</span> <span class='hs-conid'>Coercion</span>
<a name="line-1185"></a>     <span class='hs-comment'>-- :: e -&gt; N</span>
<a name="line-1186"></a>
<a name="line-1187"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SubCo</span> <span class='hs-conid'>CoercionN</span>                  <span class='hs-comment'>-- Turns a ~N into a ~R</span>
<a name="line-1188"></a>    <span class='hs-comment'>-- :: N -&gt; R</span>
<a name="line-1189"></a>
<a name="line-1190"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HoleCo</span> <span class='hs-conid'>CoercionHole</span>              <span class='hs-comment'>-- ^ See Note [Coercion holes]</span>
<a name="line-1191"></a>                                     <span class='hs-comment'>-- Only present during typechecking</span>
<a name="line-1192"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data.Data</span>
<a name="line-1193"></a>
<a name="line-1194"></a><a name="CoercionN"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoercionN</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>       <span class='hs-comment'>-- always nominal</span>
<a name="line-1195"></a><a name="CoercionR"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoercionR</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>       <span class='hs-comment'>-- always representational</span>
<a name="line-1196"></a><a name="CoercionP"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CoercionP</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Coercion</span>       <span class='hs-comment'>-- always phantom</span>
<a name="line-1197"></a><a name="KindCoercion"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>KindCoercion</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoercionN</span>   <span class='hs-comment'>-- always nominal</span>
<a name="line-1198"></a>
<a name="line-1199"></a><a name="instance%20Outputable%20Coercion"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyword'>where</span>
<a name="line-1200"></a>  <span class='hs-varid'>ppr</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprCo</span>
<a name="line-1201"></a>
<a name="line-1202"></a><a name="MCoercion"></a><span class='hs-comment'>-- | A semantically more meaningful type to represent what may or may not be a</span>
<a name="line-1203"></a><a name="MCoercion"></a><span class='hs-comment'>-- useful 'Coercion'.</span>
<a name="line-1204"></a><a name="MCoercion"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>MCoercion</span>
<a name="line-1205"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MRefl</span>
<a name="line-1206"></a>    <span class='hs-comment'>-- A trivial Reflexivity coercion</span>
<a name="line-1207"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MCo</span> <span class='hs-conid'>Coercion</span>
<a name="line-1208"></a>    <span class='hs-comment'>-- Other coercions</span>
<a name="line-1209"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data.Data</span>
<a name="line-1210"></a><a name="MCoercionR"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>MCoercionR</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MCoercion</span>
<a name="line-1211"></a><a name="MCoercionN"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>MCoercionN</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MCoercion</span>
<a name="line-1212"></a>
<a name="line-1213"></a><a name="instance%20Outputable%20MCoercion"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>MCoercion</span> <span class='hs-keyword'>where</span>
<a name="line-1214"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>MRefl</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"MRefl"</span>
<a name="line-1215"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"MCo"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span>
<a name="line-1216"></a>
<a name="line-1217"></a><span class='hs-comment'>{- Note [Refl invariant]
<a name="line-1218"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1219"></a>Invariant 1: Refl lifting
<a name="line-1220"></a>        Refl (similar for GRefl r ty MRefl) is always lifted as far as possible.
<a name="line-1221"></a>    For example
<a name="line-1222"></a>        (Refl T) (Refl a) (Refl b) is normalised (by mkAPpCo) to  (Refl (T a b)).
<a name="line-1223"></a>
<a name="line-1224"></a>    You might think that a consequences is:
<a name="line-1225"></a>         Every identity coercion has Refl at the root
<a name="line-1226"></a>
<a name="line-1227"></a>    But that's not quite true because of coercion variables.  Consider
<a name="line-1228"></a>         g         where g :: Int~Int
<a name="line-1229"></a>         Left h    where h :: Maybe Int ~ Maybe Int
<a name="line-1230"></a>    etc.  So the consequence is only true of coercions that
<a name="line-1231"></a>    have no coercion variables.
<a name="line-1232"></a>
<a name="line-1233"></a>Invariant 2: TyConAppCo
<a name="line-1234"></a>   An application of (Refl T) to some coercions, at least one of which is
<a name="line-1235"></a>   NOT the identity, is normalised to TyConAppCo.  (They may not be
<a name="line-1236"></a>   fully saturated however.)  TyConAppCo coercions (like all coercions
<a name="line-1237"></a>   other than Refl) are NEVER the identity.
<a name="line-1238"></a>
<a name="line-1239"></a>Note [Generalized reflexive coercion]
<a name="line-1240"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1241"></a>GRefl is a generalized reflexive coercion (see #15192). It wraps a kind
<a name="line-1242"></a>coercion, which might be reflexive (MRefl) or any coercion (MCo co). The typing
<a name="line-1243"></a>rules for GRefl:
<a name="line-1244"></a>
<a name="line-1245"></a>  ty : k1
<a name="line-1246"></a>  ------------------------------------
<a name="line-1247"></a>  GRefl r ty MRefl: ty ~r ty
<a name="line-1248"></a>
<a name="line-1249"></a>  ty : k1       co :: k1 ~ k2
<a name="line-1250"></a>  ------------------------------------
<a name="line-1251"></a>  GRefl r ty (MCo co) : ty ~r ty |&gt; co
<a name="line-1252"></a>
<a name="line-1253"></a>Consider we have
<a name="line-1254"></a>
<a name="line-1255"></a>   g1 :: s ~r t
<a name="line-1256"></a>   s  :: k1
<a name="line-1257"></a>   g2 :: k1 ~ k2
<a name="line-1258"></a>
<a name="line-1259"></a>and we want to construct a coercions co which has type
<a name="line-1260"></a>
<a name="line-1261"></a>   (s |&gt; g2) ~r t
<a name="line-1262"></a>
<a name="line-1263"></a>We can define
<a name="line-1264"></a>
<a name="line-1265"></a>   co = Sym (GRefl r s g2) ; g1
<a name="line-1266"></a>
<a name="line-1267"></a>It is easy to see that
<a name="line-1268"></a>
<a name="line-1269"></a>   Refl == GRefl Nominal ty MRefl :: ty ~n ty
<a name="line-1270"></a>
<a name="line-1271"></a>A nominal reflexive coercion is quite common, so we keep the special form Refl to
<a name="line-1272"></a>save allocation.
<a name="line-1273"></a>
<a name="line-1274"></a>Note [Coercion axioms applied to coercions]
<a name="line-1275"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1276"></a>The reason coercion axioms can be applied to coercions and not just
<a name="line-1277"></a>types is to allow for better optimization.  There are some cases where
<a name="line-1278"></a>we need to be able to "push transitivity inside" an axiom in order to
<a name="line-1279"></a>expose further opportunities for optimization.
<a name="line-1280"></a>
<a name="line-1281"></a>For example, suppose we have
<a name="line-1282"></a>
<a name="line-1283"></a>  C a : t[a] ~ F a
<a name="line-1284"></a>  g   : b ~ c
<a name="line-1285"></a>
<a name="line-1286"></a>and we want to optimize
<a name="line-1287"></a>
<a name="line-1288"></a>  sym (C b) ; t[g] ; C c
<a name="line-1289"></a>
<a name="line-1290"></a>which has the kind
<a name="line-1291"></a>
<a name="line-1292"></a>  F b ~ F c
<a name="line-1293"></a>
<a name="line-1294"></a>(stopping through t[b] and t[c] along the way).
<a name="line-1295"></a>
<a name="line-1296"></a>We'd like to optimize this to just F g -- but how?  The key is
<a name="line-1297"></a>that we need to allow axioms to be instantiated by *coercions*,
<a name="line-1298"></a>not just by types.  Then we can (in certain cases) push
<a name="line-1299"></a>transitivity inside the axiom instantiations, and then react
<a name="line-1300"></a>opposite-polarity instantiations of the same axiom.  In this
<a name="line-1301"></a>case, e.g., we match t[g] against the LHS of (C c)'s kind, to
<a name="line-1302"></a>obtain the substitution  a |-&gt; g  (note this operation is sort
<a name="line-1303"></a>of the dual of lifting!) and hence end up with
<a name="line-1304"></a>
<a name="line-1305"></a>  C g : t[b] ~ F c
<a name="line-1306"></a>
<a name="line-1307"></a>which indeed has the same kind as  t[g] ; C c.
<a name="line-1308"></a>
<a name="line-1309"></a>Now we have
<a name="line-1310"></a>
<a name="line-1311"></a>  sym (C b) ; C g
<a name="line-1312"></a>
<a name="line-1313"></a>which can be optimized to F g.
<a name="line-1314"></a>
<a name="line-1315"></a>Note [CoAxiom index]
<a name="line-1316"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-1317"></a>A CoAxiom has 1 or more branches. Each branch has contains a list
<a name="line-1318"></a>of the free type variables in that branch, the LHS type patterns,
<a name="line-1319"></a>and the RHS type for that branch. When we apply an axiom to a list
<a name="line-1320"></a>of coercions, we must choose which branch of the axiom we wish to
<a name="line-1321"></a>use, as the different branches may have different numbers of free
<a name="line-1322"></a>type variables. (The number of type patterns is always the same
<a name="line-1323"></a>among branches, but that doesn't quite concern us here.)
<a name="line-1324"></a>
<a name="line-1325"></a>The Int in the AxiomInstCo constructor is the 0-indexed number
<a name="line-1326"></a>of the chosen branch.
<a name="line-1327"></a>
<a name="line-1328"></a>Note [Forall coercions]
<a name="line-1329"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1330"></a>Constructing coercions between forall-types can be a bit tricky,
<a name="line-1331"></a>because the kinds of the bound tyvars can be different.
<a name="line-1332"></a>
<a name="line-1333"></a>The typing rule is:
<a name="line-1334"></a>
<a name="line-1335"></a>
<a name="line-1336"></a>  kind_co : k1 ~ k2
<a name="line-1337"></a>  tv1:k1 |- co : t1 ~ t2
<a name="line-1338"></a>  -------------------------------------------------------------------
<a name="line-1339"></a>  ForAllCo tv1 kind_co co : all tv1:k1. t1  ~
<a name="line-1340"></a>                            all tv1:k2. (t2[tv1 |-&gt; tv1 |&gt; sym kind_co])
<a name="line-1341"></a>
<a name="line-1342"></a>First, the TyCoVar stored in a ForAllCo is really an optimisation: this field
<a name="line-1343"></a>should be a Name, as its kind is redundant. Thinking of the field as a Name
<a name="line-1344"></a>is helpful in understanding what a ForAllCo means.
<a name="line-1345"></a>The kind of TyCoVar always matches the left-hand kind of the coercion.
<a name="line-1346"></a>
<a name="line-1347"></a>The idea is that kind_co gives the two kinds of the tyvar. See how, in the
<a name="line-1348"></a>conclusion, tv1 is assigned kind k1 on the left but kind k2 on the right.
<a name="line-1349"></a>
<a name="line-1350"></a>Of course, a type variable can't have different kinds at the same time. So,
<a name="line-1351"></a>we arbitrarily prefer the first kind when using tv1 in the inner coercion
<a name="line-1352"></a>co, which shows that t1 equals t2.
<a name="line-1353"></a>
<a name="line-1354"></a>The last wrinkle is that we need to fix the kinds in the conclusion. In
<a name="line-1355"></a>t2, tv1 is assumed to have kind k1, but it has kind k2 in the conclusion of
<a name="line-1356"></a>the rule. So we do a kind-fixing substitution, replacing (tv1:k1) with
<a name="line-1357"></a>(tv1:k2) |&gt; sym kind_co. This substitution is slightly bizarre, because it
<a name="line-1358"></a>mentions the same name with different kinds, but it *is* well-kinded, noting
<a name="line-1359"></a>that `(tv1:k2) |&gt; sym kind_co` has kind k1.
<a name="line-1360"></a>
<a name="line-1361"></a>This all really would work storing just a Name in the ForAllCo. But we can't
<a name="line-1362"></a>add Names to, e.g., VarSets, and there generally is just an impedance mismatch
<a name="line-1363"></a>in a bunch of places. So we use tv1. When we need tv2, we can use
<a name="line-1364"></a>setTyVarKind.
<a name="line-1365"></a>
<a name="line-1366"></a>Note [Predicate coercions]
<a name="line-1367"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1368"></a>Suppose we have
<a name="line-1369"></a>   g :: a~b
<a name="line-1370"></a>How can we coerce between types
<a name="line-1371"></a>   ([c]~a) =&gt; [a] -&gt; c
<a name="line-1372"></a>and
<a name="line-1373"></a>   ([c]~b) =&gt; [b] -&gt; c
<a name="line-1374"></a>where the equality predicate *itself* differs?
<a name="line-1375"></a>
<a name="line-1376"></a>Answer: we simply treat (~) as an ordinary type constructor, so these
<a name="line-1377"></a>types really look like
<a name="line-1378"></a>
<a name="line-1379"></a>   ((~) [c] a) -&gt; [a] -&gt; c
<a name="line-1380"></a>   ((~) [c] b) -&gt; [b] -&gt; c
<a name="line-1381"></a>
<a name="line-1382"></a>So the coercion between the two is obviously
<a name="line-1383"></a>
<a name="line-1384"></a>   ((~) [c] g) -&gt; [g] -&gt; c
<a name="line-1385"></a>
<a name="line-1386"></a>Another way to see this to say that we simply collapse predicates to
<a name="line-1387"></a>their representation type (see Type.coreView and Type.predTypeRep).
<a name="line-1388"></a>
<a name="line-1389"></a>This collapse is done by mkPredCo; there is no PredCo constructor
<a name="line-1390"></a>in Coercion.  This is important because we need Nth to work on
<a name="line-1391"></a>predicates too:
<a name="line-1392"></a>    Nth 1 ((~) [c] g) = g
<a name="line-1393"></a>See Simplify.simplCoercionF, which generates such selections.
<a name="line-1394"></a>
<a name="line-1395"></a>Note [Roles]
<a name="line-1396"></a>~~~~~~~~~~~~
<a name="line-1397"></a>Roles are a solution to the GeneralizedNewtypeDeriving problem, articulated
<a name="line-1398"></a>in #1496. The full story is in docs/core-spec/core-spec.pdf. Also, see
<a name="line-1399"></a>https://gitlab.haskell.org/ghc/ghc/wikis/roles-implementation
<a name="line-1400"></a>
<a name="line-1401"></a>Here is one way to phrase the problem:
<a name="line-1402"></a>
<a name="line-1403"></a>Given:
<a name="line-1404"></a>newtype Age = MkAge Int
<a name="line-1405"></a>type family F x
<a name="line-1406"></a>type instance F Age = Bool
<a name="line-1407"></a>type instance F Int = Char
<a name="line-1408"></a>
<a name="line-1409"></a>This compiles down to:
<a name="line-1410"></a>axAge :: Age ~ Int
<a name="line-1411"></a>axF1 :: F Age ~ Bool
<a name="line-1412"></a>axF2 :: F Int ~ Char
<a name="line-1413"></a>
<a name="line-1414"></a>Then, we can make:
<a name="line-1415"></a>(sym (axF1) ; F axAge ; axF2) :: Bool ~ Char
<a name="line-1416"></a>
<a name="line-1417"></a>Yikes!
<a name="line-1418"></a>
<a name="line-1419"></a>The solution is _roles_, as articulated in "Generative Type Abstraction and
<a name="line-1420"></a>Type-level Computation" (POPL 2010), available at
<a name="line-1421"></a><a href="http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf">http://www.seas.upenn.edu/~sweirich/papers/popl163af-weirich.pdf</a>
<a name="line-1422"></a>
<a name="line-1423"></a>The specification for roles has evolved somewhat since that paper. For the
<a name="line-1424"></a>current full details, see the documentation in docs/core-spec. Here are some
<a name="line-1425"></a>highlights.
<a name="line-1426"></a>
<a name="line-1427"></a>We label every equality with a notion of type equivalence, of which there are
<a name="line-1428"></a>three options: Nominal, Representational, and Phantom. A ground type is
<a name="line-1429"></a>nominally equivalent only with itself. A newtype (which is considered a ground
<a name="line-1430"></a>type in Haskell) is representationally equivalent to its representation.
<a name="line-1431"></a>Anything is "phantomly" equivalent to anything else. We use "N", "R", and "P"
<a name="line-1432"></a>to denote the equivalences.
<a name="line-1433"></a>
<a name="line-1434"></a>The axioms above would be:
<a name="line-1435"></a>axAge :: Age ~R Int
<a name="line-1436"></a>axF1 :: F Age ~N Bool
<a name="line-1437"></a>axF2 :: F Age ~N Char
<a name="line-1438"></a>
<a name="line-1439"></a>Then, because transitivity applies only to coercions proving the same notion
<a name="line-1440"></a>of equivalence, the above construction is impossible.
<a name="line-1441"></a>
<a name="line-1442"></a>However, there is still an escape hatch: we know that any two types that are
<a name="line-1443"></a>nominally equivalent are representationally equivalent as well. This is what
<a name="line-1444"></a>the form SubCo proves -- it "demotes" a nominal equivalence into a
<a name="line-1445"></a>representational equivalence. So, it would seem the following is possible:
<a name="line-1446"></a>
<a name="line-1447"></a>sub (sym axF1) ; F axAge ; sub axF2 :: Bool ~R Char   -- WRONG
<a name="line-1448"></a>
<a name="line-1449"></a>What saves us here is that the arguments to a type function F, lifted into a
<a name="line-1450"></a>coercion, *must* prove nominal equivalence. So, (F axAge) is ill-formed, and
<a name="line-1451"></a>we are safe.
<a name="line-1452"></a>
<a name="line-1453"></a>Roles are attached to parameters to TyCons. When lifting a TyCon into a
<a name="line-1454"></a>coercion (through TyConAppCo), we need to ensure that the arguments to the
<a name="line-1455"></a>TyCon respect their roles. For example:
<a name="line-1456"></a>
<a name="line-1457"></a>data T a b = MkT a (F b)
<a name="line-1458"></a>
<a name="line-1459"></a>If we know that a1 ~R a2, then we know (T a1 b) ~R (T a2 b). But, if we know
<a name="line-1460"></a>that b1 ~R b2, we know nothing about (T a b1) and (T a b2)! This is because
<a name="line-1461"></a>the type function F branches on b's *name*, not representation. So, we say
<a name="line-1462"></a>that 'a' has role Representational and 'b' has role Nominal. The third role,
<a name="line-1463"></a>Phantom, is for parameters not used in the type's definition. Given the
<a name="line-1464"></a>following definition
<a name="line-1465"></a>
<a name="line-1466"></a>data Q a = MkQ Int
<a name="line-1467"></a>
<a name="line-1468"></a>the Phantom role allows us to say that (Q Bool) ~R (Q Char), because we
<a name="line-1469"></a>can construct the coercion Bool ~P Char (using UnivCo).
<a name="line-1470"></a>
<a name="line-1471"></a>See the paper cited above for more examples and information.
<a name="line-1472"></a>
<a name="line-1473"></a>Note [TyConAppCo roles]
<a name="line-1474"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1475"></a>The TyConAppCo constructor has a role parameter, indicating the role at
<a name="line-1476"></a>which the coercion proves equality. The choice of this parameter affects
<a name="line-1477"></a>the required roles of the arguments of the TyConAppCo. To help explain
<a name="line-1478"></a>it, assume the following definition:
<a name="line-1479"></a>
<a name="line-1480"></a>  type instance F Int = Bool   -- Axiom axF : F Int ~N Bool
<a name="line-1481"></a>  newtype Age = MkAge Int      -- Axiom axAge : Age ~R Int
<a name="line-1482"></a>  data Foo a = MkFoo a         -- Role on Foo's parameter is Representational
<a name="line-1483"></a>
<a name="line-1484"></a>TyConAppCo Nominal Foo axF : Foo (F Int) ~N Foo Bool
<a name="line-1485"></a>  For (TyConAppCo Nominal) all arguments must have role Nominal. Why?
<a name="line-1486"></a>  So that Foo Age ~N Foo Int does *not* hold.
<a name="line-1487"></a>
<a name="line-1488"></a>TyConAppCo Representational Foo (SubCo axF) : Foo (F Int) ~R Foo Bool
<a name="line-1489"></a>TyConAppCo Representational Foo axAge       : Foo Age     ~R Foo Int
<a name="line-1490"></a>  For (TyConAppCo Representational), all arguments must have the roles
<a name="line-1491"></a>  corresponding to the result of tyConRoles on the TyCon. This is the
<a name="line-1492"></a>  whole point of having roles on the TyCon to begin with. So, we can
<a name="line-1493"></a>  have Foo Age ~R Foo Int, if Foo's parameter has role R.
<a name="line-1494"></a>
<a name="line-1495"></a>  If a Representational TyConAppCo is over-saturated (which is otherwise fine),
<a name="line-1496"></a>  the spill-over arguments must all be at Nominal. This corresponds to the
<a name="line-1497"></a>  behavior for AppCo.
<a name="line-1498"></a>
<a name="line-1499"></a>TyConAppCo Phantom Foo (UnivCo Phantom Int Bool) : Foo Int ~P Foo Bool
<a name="line-1500"></a>  All arguments must have role Phantom. This one isn't strictly
<a name="line-1501"></a>  necessary for soundness, but this choice removes ambiguity.
<a name="line-1502"></a>
<a name="line-1503"></a>The rules here dictate the roles of the parameters to mkTyConAppCo
<a name="line-1504"></a>(should be checked by Lint).
<a name="line-1505"></a>
<a name="line-1506"></a>Note [NthCo and newtypes]
<a name="line-1507"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1508"></a>Suppose we have
<a name="line-1509"></a>
<a name="line-1510"></a>  newtype N a = MkN Int
<a name="line-1511"></a>  type role N representational
<a name="line-1512"></a>
<a name="line-1513"></a>This yields axiom
<a name="line-1514"></a>
<a name="line-1515"></a>  NTCo:N :: forall a. N a ~R Int
<a name="line-1516"></a>
<a name="line-1517"></a>We can then build
<a name="line-1518"></a>
<a name="line-1519"></a>  co :: forall a b. N a ~R N b
<a name="line-1520"></a>  co = NTCo:N a ; sym (NTCo:N b)
<a name="line-1521"></a>
<a name="line-1522"></a>for any `a` and `b`. Because of the role annotation on N, if we use
<a name="line-1523"></a>NthCo, we'll get out a representational coercion. That is:
<a name="line-1524"></a>
<a name="line-1525"></a>  NthCo r 0 co :: forall a b. a ~R b
<a name="line-1526"></a>
<a name="line-1527"></a>Yikes! Clearly, this is terrible. The solution is simple: forbid
<a name="line-1528"></a>NthCo to be used on newtypes if the internal coercion is representational.
<a name="line-1529"></a>
<a name="line-1530"></a>This is not just some corner case discovered by a segfault somewhere;
<a name="line-1531"></a>it was discovered in the proof of soundness of roles and described
<a name="line-1532"></a>in the "Safe Coercions" paper (ICFP '14).
<a name="line-1533"></a>
<a name="line-1534"></a>Note [NthCo Cached Roles]
<a name="line-1535"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1536"></a>Why do we cache the role of NthCo in the NthCo constructor?
<a name="line-1537"></a>Because computing role(Nth i co) involves figuring out that
<a name="line-1538"></a>
<a name="line-1539"></a>  co :: T tys1 ~ T tys2
<a name="line-1540"></a>
<a name="line-1541"></a>using coercionKind, and finding (coercionRole co), and then looking
<a name="line-1542"></a>at the tyConRoles of T. Avoiding bad asymptotic behaviour here means
<a name="line-1543"></a>we have to compute the kind and role of a coercion simultaneously,
<a name="line-1544"></a>which makes the code complicated and inefficient.
<a name="line-1545"></a>
<a name="line-1546"></a>This only happens for NthCo. Caching the role solves the problem, and
<a name="line-1547"></a>allows coercionKind and coercionRole to be simple.
<a name="line-1548"></a>
<a name="line-1549"></a>See #11735
<a name="line-1550"></a>
<a name="line-1551"></a>Note [InstCo roles]
<a name="line-1552"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-1553"></a>Here is (essentially) the typing rule for InstCo:
<a name="line-1554"></a>
<a name="line-1555"></a>g :: (forall a. t1) ~r (forall a. t2)
<a name="line-1556"></a>w :: s1 ~N s2
<a name="line-1557"></a>------------------------------- InstCo
<a name="line-1558"></a>InstCo g w :: (t1 [a |-&gt; s1]) ~r (t2 [a |-&gt; s2])
<a name="line-1559"></a>
<a name="line-1560"></a>Note that the Coercion w *must* be nominal. This is necessary
<a name="line-1561"></a>because the variable a might be used in a "nominal position"
<a name="line-1562"></a>(that is, a place where role inference would require a nominal
<a name="line-1563"></a>role) in t1 or t2. If we allowed w to be representational, we
<a name="line-1564"></a>could get bogus equalities.
<a name="line-1565"></a>
<a name="line-1566"></a>A more nuanced treatment might be able to relax this condition
<a name="line-1567"></a>somewhat, by checking if t1 and/or t2 use their bound variables
<a name="line-1568"></a>in nominal ways. If not, having w be representational is OK.
<a name="line-1569"></a>
<a name="line-1570"></a>
<a name="line-1571"></a>%************************************************************************
<a name="line-1572"></a>%*                                                                      *
<a name="line-1573"></a>                UnivCoProvenance
<a name="line-1574"></a>%*                                                                      *
<a name="line-1575"></a>%************************************************************************
<a name="line-1576"></a>
<a name="line-1577"></a>A UnivCo is a coercion whose proof does not directly express its role
<a name="line-1578"></a>and kind (indeed for some UnivCos, like PluginProv, there /is/ no proof).
<a name="line-1579"></a>
<a name="line-1580"></a>The different kinds of UnivCo are described by UnivCoProvenance.  Really
<a name="line-1581"></a>each is entirely separate, but they all share the need to represent their
<a name="line-1582"></a>role and kind, which is done in the UnivCo constructor.
<a name="line-1583"></a>
<a name="line-1584"></a>-}</span>
<a name="line-1585"></a>
<a name="line-1586"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- | For simplicity, we have just one UnivCo that represents a coercion from</span>
<a name="line-1587"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- some type to some other type, with (in general) no restrictions on the</span>
<a name="line-1588"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- type. The UnivCoProvenance specifies more exactly what the coercion really</span>
<a name="line-1589"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- is and why a program should (or shouldn't!) trust the coercion.</span>
<a name="line-1590"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- It is reasonable to consider each constructor of 'UnivCoProvenance'</span>
<a name="line-1591"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- as a totally independent coercion form; their only commonality is</span>
<a name="line-1592"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- that they don't tell you what types they coercion between. (That info</span>
<a name="line-1593"></a><a name="UnivCoProvenance"></a><span class='hs-comment'>-- is in the 'UnivCo' constructor of 'Coercion'.</span>
<a name="line-1594"></a><a name="UnivCoProvenance"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UnivCoProvenance</span>
<a name="line-1595"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>PhantomProv</span> <span class='hs-conid'>KindCoercion</span> <span class='hs-comment'>-- ^ See Note [Phantom coercions]. Only in Phantom</span>
<a name="line-1596"></a>                             <span class='hs-comment'>-- roled coercions</span>
<a name="line-1597"></a>
<a name="line-1598"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ProofIrrelProv</span> <span class='hs-conid'>KindCoercion</span>  <span class='hs-comment'>-- ^ From the fact that any two coercions are</span>
<a name="line-1599"></a>                                 <span class='hs-comment'>--   considered equivalent. See Note [ProofIrrelProv].</span>
<a name="line-1600"></a>                                 <span class='hs-comment'>-- Can be used in Nominal or Representational coercions</span>
<a name="line-1601"></a>
<a name="line-1602"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PluginProv</span> <span class='hs-conid'>String</span>  <span class='hs-comment'>-- ^ From a plugin, which asserts that this coercion</span>
<a name="line-1603"></a>                       <span class='hs-comment'>--   is sound. The string is for the use of the plugin.</span>
<a name="line-1604"></a>
<a name="line-1605"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CorePrepProv</span>       <span class='hs-comment'>-- See Note [Unsafe coercions] in GHC.Core.CoreToStg.Prep</span>
<a name="line-1606"></a>      <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- True  &lt;=&gt; the UnivCo must be homogeneously kinded</span>
<a name="line-1607"></a>             <span class='hs-comment'>-- False &lt;=&gt; allow hetero-kinded, e.g. Int ~ Int#</span>
<a name="line-1608"></a>
<a name="line-1609"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data.Data</span>
<a name="line-1610"></a>
<a name="line-1611"></a><a name="instance%20Outputable%20UnivCoProvenance"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>UnivCoProvenance</span> <span class='hs-keyword'>where</span>
<a name="line-1612"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhantomProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"(phantom)"</span>
<a name="line-1613"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>ProofIrrelProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"(proof irrel.)"</span>
<a name="line-1614"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>PluginProv</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>parens</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"plugin"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>brackets</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-varid'>str</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1615"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CorePrepProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"(CorePrep)"</span>
<a name="line-1616"></a>
<a name="line-1617"></a><a name="CoercionHole"></a><span class='hs-comment'>-- | A coercion to be filled in by the type-checker. See Note [Coercion holes]</span>
<a name="line-1618"></a><a name="CoercionHole"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>CoercionHole</span>
<a name="line-1619"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ch_co_var</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoVar</span>
<a name="line-1620"></a>                       <span class='hs-comment'>-- See Note [CoercionHoles and coercion free variables]</span>
<a name="line-1621"></a>
<a name="line-1622"></a>                 <span class='hs-layout'>,</span> <span class='hs-varid'>ch_ref</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>IORef</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Coercion</span><span class='hs-layout'>)</span>
<a name="line-1623"></a>                 <span class='hs-layout'>}</span>
<a name="line-1624"></a>
<a name="line-1625"></a><a name="coHoleCoVar"></a><span class='hs-definition'>coHoleCoVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoVar</span>
<a name="line-1626"></a><span class='hs-definition'>coHoleCoVar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ch_co_var</span>
<a name="line-1627"></a>
<a name="line-1628"></a><a name="setCoHoleCoVar"></a><span class='hs-definition'>setCoHoleCoVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionHole</span>
<a name="line-1629"></a><span class='hs-definition'>setCoHoleCoVar</span> <span class='hs-varid'>h</span> <span class='hs-varid'>cv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>h</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ch_co_var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>}</span>
<a name="line-1630"></a>
<a name="line-1631"></a><a name="instance%20Data.Data%20CoercionHole"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Data.Data</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-keyword'>where</span>
<a name="line-1632"></a>  <span class='hs-comment'>-- don't traverse?</span>
<a name="line-1633"></a>  <span class='hs-varid'>toConstr</span> <span class='hs-keyword'>_</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>abstractConstr</span> <span class='hs-str'>"CoercionHole"</span>
<a name="line-1634"></a>  <span class='hs-varid'>gunfold</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>error</span> <span class='hs-str'>"gunfold"</span>
<a name="line-1635"></a>  <span class='hs-varid'>dataTypeOf</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkNoRepType</span> <span class='hs-str'>"CoercionHole"</span>
<a name="line-1636"></a>
<a name="line-1637"></a><a name="instance%20Outputable%20CoercionHole"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-keyword'>where</span>
<a name="line-1638"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionHole</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ch_co_var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>cv</span><span class='hs-layout'>)</span>
<a name="line-1639"></a>
<a name="line-1640"></a><a name="instance%20Uniquable%20CoercionHole"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Uniquable</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-keyword'>where</span>
<a name="line-1641"></a>  <span class='hs-varid'>getUnique</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionHole</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ch_co_var</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cv</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getUnique</span> <span class='hs-varid'>cv</span>
<a name="line-1642"></a>
<a name="line-1643"></a><span class='hs-comment'>{- Note [Phantom coercions]
<a name="line-1644"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1645"></a>Consider
<a name="line-1646"></a>     data T a = T1 | T2
<a name="line-1647"></a>Then we have
<a name="line-1648"></a>     T s ~R T t
<a name="line-1649"></a>for any old s,t. The witness for this is (TyConAppCo T Rep co),
<a name="line-1650"></a>where (co :: s ~P t) is a phantom coercion built with PhantomProv.
<a name="line-1651"></a>The role of the UnivCo is always Phantom.  The Coercion stored is the
<a name="line-1652"></a>(nominal) kind coercion between the types
<a name="line-1653"></a>   kind(s) ~N kind (t)
<a name="line-1654"></a>
<a name="line-1655"></a>Note [Coercion holes]
<a name="line-1656"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1657"></a>During typechecking, constraint solving for type classes works by
<a name="line-1658"></a>  - Generate an evidence Id,  d7 :: Num a
<a name="line-1659"></a>  - Wrap it in a Wanted constraint, [W] d7 :: Num a
<a name="line-1660"></a>  - Use the evidence Id where the evidence is needed
<a name="line-1661"></a>  - Solve the constraint later
<a name="line-1662"></a>  - When solved, add an enclosing let-binding  let d7 = .... in ....
<a name="line-1663"></a>    which actually binds d7 to the (Num a) evidence
<a name="line-1664"></a>
<a name="line-1665"></a>For equality constraints we use a different strategy.  See Note [The
<a name="line-1666"></a>equality types story] in GHC.Builtin.Types.Prim for background on equality constraints.
<a name="line-1667"></a>  - For /boxed/ equality constraints, (t1 ~N t2) and (t1 ~R t2), it's just
<a name="line-1668"></a>    like type classes above. (Indeed, boxed equality constraints *are* classes.)
<a name="line-1669"></a>  - But for /unboxed/ equality constraints (t1 ~R# t2) and (t1 ~N# t2)
<a name="line-1670"></a>    we use a different plan
<a name="line-1671"></a>
<a name="line-1672"></a>For unboxed equalities:
<a name="line-1673"></a>  - Generate a CoercionHole, a mutable variable just like a unification
<a name="line-1674"></a>    variable
<a name="line-1675"></a>  - Wrap the CoercionHole in a Wanted constraint; see GHC.Tc.Utils.TcEvDest
<a name="line-1676"></a>  - Use the CoercionHole in a Coercion, via HoleCo
<a name="line-1677"></a>  - Solve the constraint later
<a name="line-1678"></a>  - When solved, fill in the CoercionHole by side effect, instead of
<a name="line-1679"></a>    doing the let-binding thing
<a name="line-1680"></a>
<a name="line-1681"></a>The main reason for all this is that there may be no good place to let-bind
<a name="line-1682"></a>the evidence for unboxed equalities:
<a name="line-1683"></a>
<a name="line-1684"></a>  - We emit constraints for kind coercions, to be used to cast a
<a name="line-1685"></a>    type's kind. These coercions then must be used in types. Because
<a name="line-1686"></a>    they might appear in a top-level type, there is no place to bind
<a name="line-1687"></a>    these (unlifted) coercions in the usual way.
<a name="line-1688"></a>
<a name="line-1689"></a>  - A coercion for (forall a. t1) ~ (forall a. t2) will look like
<a name="line-1690"></a>       forall a. (coercion for t1~t2)
<a name="line-1691"></a>    But the coercion for (t1~t2) may mention 'a', and we don't have
<a name="line-1692"></a>    let-bindings within coercions.  We could add them, but coercion
<a name="line-1693"></a>    holes are easier.
<a name="line-1694"></a>
<a name="line-1695"></a>  - Moreover, nothing is lost from the lack of let-bindings. For
<a name="line-1696"></a>    dictionaries want to achieve sharing to avoid recomoputing the
<a name="line-1697"></a>    dictionary.  But coercions are entirely erased, so there's little
<a name="line-1698"></a>    benefit to sharing. Indeed, even if we had a let-binding, we
<a name="line-1699"></a>    always inline types and coercions at every use site and drop the
<a name="line-1700"></a>    binding.
<a name="line-1701"></a>
<a name="line-1702"></a>Other notes about HoleCo:
<a name="line-1703"></a>
<a name="line-1704"></a> * INVARIANT: CoercionHole and HoleCo are used only during type checking,
<a name="line-1705"></a>   and should never appear in Core. Just like unification variables; a Type
<a name="line-1706"></a>   can contain a TcTyVar, but only during type checking. If, one day, we
<a name="line-1707"></a>   use type-level information to separate out forms that can appear during
<a name="line-1708"></a>   type-checking vs forms that can appear in core proper, holes in Core will
<a name="line-1709"></a>   be ruled out.
<a name="line-1710"></a>
<a name="line-1711"></a> * See Note [CoercionHoles and coercion free variables]
<a name="line-1712"></a>
<a name="line-1713"></a> * Coercion holes can be compared for equality like other coercions:
<a name="line-1714"></a>   by looking at the types coerced.
<a name="line-1715"></a>
<a name="line-1716"></a>
<a name="line-1717"></a>Note [CoercionHoles and coercion free variables]
<a name="line-1718"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1719"></a>Why does a CoercionHole contain a CoVar, as well as reference to
<a name="line-1720"></a>fill in?  Because we want to treat that CoVar as a free variable of
<a name="line-1721"></a>the coercion.  See #14584, and Note [What prevents a
<a name="line-1722"></a>constraint from floating] in GHC.Tc.Solver, item (4):
<a name="line-1723"></a>
<a name="line-1724"></a>        forall k. [W] co1 :: t1 ~# t2 |&gt; co2
<a name="line-1725"></a>                  [W] co2 :: k ~# *
<a name="line-1726"></a>
<a name="line-1727"></a>Here co2 is a CoercionHole. But we /must/ know that it is free in
<a name="line-1728"></a>co1, because that's all that stops it floating outside the
<a name="line-1729"></a>implication.
<a name="line-1730"></a>
<a name="line-1731"></a>
<a name="line-1732"></a>Note [ProofIrrelProv]
<a name="line-1733"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-1734"></a>A ProofIrrelProv is a coercion between coercions. For example:
<a name="line-1735"></a>
<a name="line-1736"></a>  data G a where
<a name="line-1737"></a>    MkG :: G Bool
<a name="line-1738"></a>
<a name="line-1739"></a>In core, we get
<a name="line-1740"></a>
<a name="line-1741"></a>  G :: * -&gt; *
<a name="line-1742"></a>  MkG :: forall (a :: *). (a ~ Bool) -&gt; G a
<a name="line-1743"></a>
<a name="line-1744"></a>Now, consider 'MkG -- that is, MkG used in a type -- and suppose we want
<a name="line-1745"></a>a proof that ('MkG a1 co1) ~ ('MkG a2 co2). This will have to be
<a name="line-1746"></a>
<a name="line-1747"></a>  TyConAppCo Nominal MkG [co3, co4]
<a name="line-1748"></a>  where
<a name="line-1749"></a>    co3 :: co1 ~ co2
<a name="line-1750"></a>    co4 :: a1 ~ a2
<a name="line-1751"></a>
<a name="line-1752"></a>Note that
<a name="line-1753"></a>  co1 :: a1 ~ Bool
<a name="line-1754"></a>  co2 :: a2 ~ Bool
<a name="line-1755"></a>
<a name="line-1756"></a>Here,
<a name="line-1757"></a>  co3 = UnivCo (ProofIrrelProv co5) Nominal (CoercionTy co1) (CoercionTy co2)
<a name="line-1758"></a>  where
<a name="line-1759"></a>    co5 :: (a1 ~ Bool) ~ (a2 ~ Bool)
<a name="line-1760"></a>    co5 = TyConAppCo Nominal (~#) [&lt;*&gt;, &lt;*&gt;, co4, &lt;Bool&gt;]
<a name="line-1761"></a>-}</span>
<a name="line-1762"></a>
<a name="line-1763"></a>
<a name="line-1764"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1765"></a>*                                                                      *
<a name="line-1766"></a>                foldType  and   foldCoercion
<a name="line-1767"></a>*                                                                      *
<a name="line-1768"></a>********************************************************************* -}</span>
<a name="line-1769"></a>
<a name="line-1770"></a><span class='hs-comment'>{- Note [foldType]
<a name="line-1771"></a>~~~~~~~~~~~~~~~~~~
<a name="line-1772"></a>foldType is a bit more powerful than perhaps it looks:
<a name="line-1773"></a>
<a name="line-1774"></a>* You can fold with an accumulating parameter, via
<a name="line-1775"></a>     TyCoFolder env (Endo a)
<a name="line-1776"></a>  Recall newtype Endo a = Endo (a-&gt;a)
<a name="line-1777"></a>
<a name="line-1778"></a>* You can fold monadically with a monad M, via
<a name="line-1779"></a>     TyCoFolder env (M a)
<a name="line-1780"></a>  provided you have
<a name="line-1781"></a>     instance ..  =&gt; Monoid (M a)
<a name="line-1782"></a>
<a name="line-1783"></a>Note [mapType vs foldType]
<a name="line-1784"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1785"></a>We define foldType here, but mapType in module Type. Why?
<a name="line-1786"></a>
<a name="line-1787"></a>* foldType is used in GHC.Core.TyCo.FVs for finding free variables.
<a name="line-1788"></a>  It's a very simple function that analyses a type,
<a name="line-1789"></a>  but does not construct one.
<a name="line-1790"></a>
<a name="line-1791"></a>* mapType constructs new types, and so it needs to call
<a name="line-1792"></a>  the "smart constructors", mkAppTy, mkCastTy, and so on.
<a name="line-1793"></a>  These are sophisticated functions, and can't be defined
<a name="line-1794"></a>  here in GHC.Core.TyCo.Rep.
<a name="line-1795"></a>
<a name="line-1796"></a>Note [Specialising foldType]
<a name="line-1797"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1798"></a>We inline foldType at every call site (there are not many), so that it
<a name="line-1799"></a>becomes specialised for the particular monoid *and* TyCoFolder at
<a name="line-1800"></a>that site.  This is just for efficiency, but walking over types is
<a name="line-1801"></a>done a *lot* in GHC, so worth optimising.
<a name="line-1802"></a>
<a name="line-1803"></a>We were worried that
<a name="line-1804"></a>    TyCoFolder env (Endo a)
<a name="line-1805"></a>might not eta-expand.  Recall newtype Endo a = Endo (a-&gt;a).
<a name="line-1806"></a>
<a name="line-1807"></a>In particular, given
<a name="line-1808"></a>   fvs :: Type -&gt; TyCoVarSet
<a name="line-1809"></a>   fvs ty = appEndo (foldType tcf emptyVarSet ty) emptyVarSet
<a name="line-1810"></a>
<a name="line-1811"></a>   tcf :: TyCoFolder enf (Endo a)
<a name="line-1812"></a>   tcf = TyCoFolder { tcf_tyvar = do_tv, ... }
<a name="line-1813"></a>      where
<a name="line-1814"></a>        do_tvs is tv = Endo do_it
<a name="line-1815"></a>           where
<a name="line-1816"></a>             do_it acc | tv `elemVarSet` is  = acc
<a name="line-1817"></a>                       | tv `elemVarSet` acc = acc
<a name="line-1818"></a>                       | otherwise = acc `extendVarSet` tv
<a name="line-1819"></a>
<a name="line-1820"></a>
<a name="line-1821"></a>we want to end up with
<a name="line-1822"></a>   fvs ty = go emptyVarSet ty emptyVarSet
<a name="line-1823"></a>     where
<a name="line-1824"></a>       go env (TyVarTy tv) acc = acc `extendVarSet` tv
<a name="line-1825"></a>       ..etc..
<a name="line-1826"></a>
<a name="line-1827"></a>And indeed this happens.
<a name="line-1828"></a>  - Selections from 'tcf' are done at compile time
<a name="line-1829"></a>  - 'go' is nicely eta-expanded.
<a name="line-1830"></a>
<a name="line-1831"></a>We were also worried about
<a name="line-1832"></a>   deep_fvs :: Type -&gt; TyCoVarSet
<a name="line-1833"></a>   deep_fvs ty = appEndo (foldType deep_tcf emptyVarSet ty) emptyVarSet
<a name="line-1834"></a>
<a name="line-1835"></a>   deep_tcf :: TyCoFolder enf (Endo a)
<a name="line-1836"></a>   deep_tcf = TyCoFolder { tcf_tyvar = do_tv, ... }
<a name="line-1837"></a>      where
<a name="line-1838"></a>        do_tvs is tv = Endo do_it
<a name="line-1839"></a>           where
<a name="line-1840"></a>             do_it acc | tv `elemVarSet` is  = acc
<a name="line-1841"></a>                       | tv `elemVarSet` acc = acc
<a name="line-1842"></a>                       | otherwise = deep_fvs (varType tv)
<a name="line-1843"></a>                                     `unionVarSet` acc
<a name="line-1844"></a>                                     `extendVarSet` tv
<a name="line-1845"></a>
<a name="line-1846"></a>Here deep_fvs and deep_tcf are mutually recursive, unlike fvs and tcf.
<a name="line-1847"></a>But, amazingly, we get good code here too. GHC is careful not to makr
<a name="line-1848"></a>TyCoFolder data constructor for deep_tcf as a loop breaker, so the
<a name="line-1849"></a>record selections still cancel.  And eta expansion still happens too.
<a name="line-1850"></a>-}</span>
<a name="line-1851"></a>
<a name="line-1852"></a><a name="TyCoFolder"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TyCoFolder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>a</span>
<a name="line-1853"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>TyCoFolder</span>
<a name="line-1854"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>tcf_view</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Type</span>   <span class='hs-comment'>-- Optional "view" function</span>
<a name="line-1855"></a>                                          <span class='hs-comment'>-- E.g. expand synonyms</span>
<a name="line-1856"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_tyvar</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1857"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_covar</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1858"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_hole</span>  <span class='hs-keyglyph'>::</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CoercionHole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-1859"></a>          <span class='hs-comment'>-- ^ What to do with coercion holes.</span>
<a name="line-1860"></a>          <span class='hs-comment'>-- See Note [Coercion holes] in "GHC.Core.TyCo.Rep".</span>
<a name="line-1861"></a>
<a name="line-1862"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_tycobinder</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>env</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCoVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ArgFlag</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>env</span>
<a name="line-1863"></a>          <span class='hs-comment'>-- ^ The returned env is used in the extended scope</span>
<a name="line-1864"></a>      <span class='hs-layout'>}</span>
<a name="line-1865"></a>
<a name="line-1866"></a><span class='hs-comment'>{-# INLINE foldTyCo  #-}</span>  <span class='hs-comment'>-- See Note [Specialising foldType]</span>
<a name="line-1867"></a><a name="foldTyCo"></a><span class='hs-definition'>foldTyCo</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Monoid</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>TyCoFolder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>env</span>
<a name="line-1868"></a>         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Coercion</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>
<a name="line-1869"></a><span class='hs-definition'>foldTyCo</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyCoFolder</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tcf_view</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>view</span>
<a name="line-1870"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_tyvar</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvar</span>
<a name="line-1871"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_tycobinder</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tycobinder</span>
<a name="line-1872"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_covar</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>covar</span>
<a name="line-1873"></a>                     <span class='hs-layout'>,</span> <span class='hs-varid'>tcf_hole</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cohole</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>env</span>
<a name="line-1874"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>go_tys</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span><span class='hs-layout'>,</span> <span class='hs-varid'>go_cos</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span>
<a name="line-1875"></a>  <span class='hs-keyword'>where</span>
<a name="line-1876"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>view</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty'</span>
<a name="line-1877"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyvar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tv</span>
<a name="line-1878"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t2</span>
<a name="line-1879"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-keyword'>_</span>   <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-1880"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1881"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1882"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w</span> <span class='hs-varid'>arg</span> <span class='hs-varid'>res</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>w</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>res</span>
<a name="line-1883"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_tys</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tys</span>
<a name="line-1884"></a>    <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span><span class='hs-layout'>)</span> <span class='hs-varid'>inner</span><span class='hs-layout'>)</span>
<a name="line-1885"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varop'>!</span><span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tycobinder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>vis</span>  <span class='hs-comment'>-- Avoid building a thunk here</span>
<a name="line-1886"></a>        <span class='hs-keyword'>in</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>inner</span>
<a name="line-1887"></a>
<a name="line-1888"></a>    <span class='hs-comment'>-- Explicit recursion because using foldr builds a local</span>
<a name="line-1889"></a>    <span class='hs-comment'>-- loop (with env free) and I'm not confident it'll be</span>
<a name="line-1890"></a>    <span class='hs-comment'>-- lambda lifted in the end</span>
<a name="line-1891"></a>    <span class='hs-varid'>go_tys</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-1892"></a>    <span class='hs-varid'>go_tys</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>t</span><span class='hs-conop'>:</span><span class='hs-varid'>ts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_tys</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ts</span>
<a name="line-1893"></a>
<a name="line-1894"></a>    <span class='hs-varid'>go_cos</span> <span class='hs-keyword'>_</span>   <span class='hs-conid'>[]</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-1895"></a>    <span class='hs-varid'>go_cos</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>c</span><span class='hs-conop'>:</span><span class='hs-varid'>cs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_cos</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cs</span>
<a name="line-1896"></a>
<a name="line-1897"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>Refl</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1898"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>GRefl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span>
<a name="line-1899"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>GRefl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1900"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConAppCo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_cos</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span>
<a name="line-1901"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppCo</span> <span class='hs-varid'>c1</span> <span class='hs-varid'>c2</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c2</span>
<a name="line-1902"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunCo</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cw</span> <span class='hs-varid'>c1</span> <span class='hs-varid'>c2</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cw</span> <span class='hs-varop'>`mappend`</span>
<a name="line-1903"></a>                                        <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>`mappend`</span>
<a name="line-1904"></a>                                        <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c2</span>
<a name="line-1905"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoVarCo</span> <span class='hs-varid'>cv</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>covar</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cv</span>
<a name="line-1906"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AxiomInstCo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_cos</span> <span class='hs-varid'>env</span> <span class='hs-varid'>args</span>
<a name="line-1907"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>HoleCo</span> <span class='hs-varid'>hole</span><span class='hs-layout'>)</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>cohole</span> <span class='hs-varid'>env</span> <span class='hs-varid'>hole</span>
<a name="line-1908"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnivCo</span> <span class='hs-varid'>p</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_prov</span> <span class='hs-varid'>env</span> <span class='hs-varid'>p</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t1</span>
<a name="line-1909"></a>                                                      <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-varid'>t2</span>
<a name="line-1910"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>SymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1911"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>TransCo</span> <span class='hs-varid'>c1</span> <span class='hs-varid'>c2</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c1</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>c2</span>
<a name="line-1912"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>AxiomRuleCo</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_cos</span> <span class='hs-varid'>env</span> <span class='hs-varid'>cos</span>
<a name="line-1913"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>NthCo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1914"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>LRCo</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1915"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>arg</span>
<a name="line-1916"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>KindCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1917"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>SubCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1918"></a>    <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllCo</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>kind_co</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-1919"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>kind_co</span> <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_ty</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1920"></a>                          <span class='hs-varop'>`mappend`</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env'</span> <span class='hs-varid'>co</span>
<a name="line-1921"></a>      <span class='hs-keyword'>where</span>
<a name="line-1922"></a>        <span class='hs-varid'>env'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tycobinder</span> <span class='hs-varid'>env</span> <span class='hs-varid'>tv</span> <span class='hs-conid'>Inferred</span>
<a name="line-1923"></a>
<a name="line-1924"></a>    <span class='hs-varid'>go_prov</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhantomProv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1925"></a>    <span class='hs-varid'>go_prov</span> <span class='hs-varid'>env</span> <span class='hs-layout'>(</span><span class='hs-conid'>ProofIrrelProv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>go_co</span> <span class='hs-varid'>env</span> <span class='hs-varid'>co</span>
<a name="line-1926"></a>    <span class='hs-varid'>go_prov</span> <span class='hs-keyword'>_</span>   <span class='hs-layout'>(</span><span class='hs-conid'>PluginProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-1927"></a>    <span class='hs-varid'>go_prov</span> <span class='hs-keyword'>_</span>   <span class='hs-layout'>(</span><span class='hs-conid'>CorePrepProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mempty</span>
<a name="line-1928"></a>
<a name="line-1929"></a><span class='hs-comment'>{- *********************************************************************
<a name="line-1930"></a>*                                                                      *
<a name="line-1931"></a>                   typeSize, coercionSize
<a name="line-1932"></a>*                                                                      *
<a name="line-1933"></a>********************************************************************* -}</span>
<a name="line-1934"></a>
<a name="line-1935"></a><span class='hs-comment'>-- NB: We put typeSize/coercionSize here because they are mutually</span>
<a name="line-1936"></a><span class='hs-comment'>--     recursive, and have the CPR property.  If we have mutual</span>
<a name="line-1937"></a><span class='hs-comment'>--     recursion across a hi-boot file, we don't get the CPR property</span>
<a name="line-1938"></a><span class='hs-comment'>--     and these functions allocate a tremendous amount of rubbish.</span>
<a name="line-1939"></a><span class='hs-comment'>--     It's not critical (because typeSize is really only used in</span>
<a name="line-1940"></a><span class='hs-comment'>--     debug mode, but I tripped over an example (T5642) in which</span>
<a name="line-1941"></a><span class='hs-comment'>--     typeSize was one of the biggest single allocators in all of GHC.</span>
<a name="line-1942"></a><span class='hs-comment'>--     And it's easy to fix, so I did.</span>
<a name="line-1943"></a>
<a name="line-1944"></a><span class='hs-comment'>-- NB: typeSize does not respect `eqType`, in that two types that</span>
<a name="line-1945"></a><span class='hs-comment'>--     are `eqType` may return different sizes. This is OK, because this</span>
<a name="line-1946"></a><span class='hs-comment'>--     function is used only in reporting, not decision-making.</span>
<a name="line-1947"></a>
<a name="line-1948"></a><a name="typeSize"></a><span class='hs-definition'>typeSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1949"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1950"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>               <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1951"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t2</span>
<a name="line-1952"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t2</span>
<a name="line-1953"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bndr</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-varid'>varType</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span> <span class='hs-varop'>+</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t</span>
<a name="line-1954"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>ts</span><span class='hs-layout'>)</span>
<a name="line-1955"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CastTy</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1956"></a><span class='hs-definition'>typeSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoercionTy</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1957"></a>
<a name="line-1958"></a><a name="coercionSize"></a><span class='hs-definition'>coercionSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Coercion</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1959"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>Refl</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>ty</span>
<a name="line-1960"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>GRefl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-conid'>MRefl</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>ty</span>
<a name="line-1961"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>GRefl</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ty</span> <span class='hs-layout'>(</span><span class='hs-conid'>MCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1962"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConAppCo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-1963"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>arg</span>
<a name="line-1964"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>ForAllCo</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>h</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>h</span>
<a name="line-1965"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunCo</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>w</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co2</span>
<a name="line-1966"></a>                                                        <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>w</span>
<a name="line-1967"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CoVarCo</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1968"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>HoleCo</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1969"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>AxiomInstCo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>args</span><span class='hs-layout'>)</span>
<a name="line-1970"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>UnivCo</span> <span class='hs-varid'>p</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>provSize</span> <span class='hs-varid'>p</span> <span class='hs-varop'>+</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>typeSize</span> <span class='hs-varid'>t2</span>
<a name="line-1971"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>SymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1972"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>TransCo</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co2</span>
<a name="line-1973"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>NthCo</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1974"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>LRCo</span>  <span class='hs-keyword'>_</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>        <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1975"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>InstCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>arg</span>
<a name="line-1976"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>KindCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>         <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1977"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>SubCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1978"></a><span class='hs-definition'>coercionSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>AxiomRuleCo</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>sum</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>cs</span><span class='hs-layout'>)</span>
<a name="line-1979"></a>
<a name="line-1980"></a><a name="provSize"></a><span class='hs-definition'>provSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>UnivCoProvenance</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-1981"></a><span class='hs-definition'>provSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>PhantomProv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1982"></a><span class='hs-definition'>provSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>ProofIrrelProv</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span> <span class='hs-varop'>+</span> <span class='hs-varid'>coercionSize</span> <span class='hs-varid'>co</span>
<a name="line-1983"></a><span class='hs-definition'>provSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>PluginProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1984"></a><span class='hs-definition'>provSize</span> <span class='hs-layout'>(</span><span class='hs-conid'>CorePrepProv</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>    <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-1985"></a>
<a name="line-1986"></a><span class='hs-comment'>{-
<a name="line-1987"></a>************************************************************************
<a name="line-1988"></a>*                                                                      *
<a name="line-1989"></a>                    Multiplicities
<a name="line-1990"></a>*                                                                      *
<a name="line-1991"></a>************************************************************************
<a name="line-1992"></a>
<a name="line-1993"></a>These definitions are here to avoid module loops, and to keep
<a name="line-1994"></a>GHC.Core.Multiplicity above this module.
<a name="line-1995"></a>
<a name="line-1996"></a>-}</span>
<a name="line-1997"></a>
<a name="line-1998"></a><a name="Scaled"></a><span class='hs-comment'>-- | A shorthand for data with an attached 'Mult' element (the multiplicity).</span>
<a name="line-1999"></a><a name="Scaled"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Scaled</span> <span class='hs-varop'>!</span><span class='hs-conid'>Mult</span> <span class='hs-varid'>a</span>
<a name="line-2000"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Data.Data</span><span class='hs-layout'>)</span>
<a name="line-2001"></a>  <span class='hs-comment'>-- You might think that this would be a natural candidate for</span>
<a name="line-2002"></a>  <span class='hs-comment'>-- Functor, Traversable but Krzysztof says (!3674) "it was too easy</span>
<a name="line-2003"></a>  <span class='hs-comment'>-- to accidentally lift functions (substitutions, zonking etc.) from</span>
<a name="line-2004"></a>  <span class='hs-comment'>-- Type -&gt; Type to Scaled Type -&gt; Scaled Type, ignoring</span>
<a name="line-2005"></a>  <span class='hs-comment'>-- multiplicities and causing bugs".  So we don't.</span>
<a name="line-2006"></a>  <span class='hs-comment'>--</span>
<a name="line-2007"></a>  <span class='hs-comment'>-- Being strict in a is worse for performance, so we are only strict on the</span>
<a name="line-2008"></a>  <span class='hs-comment'>-- Mult part of scaled.</span>
<a name="line-2009"></a>
<a name="line-2010"></a>
<a name="line-2011"></a><a name="instance%20Outputable%20(Scaled%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-2012"></a>   <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-sel'>_cnt</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>t</span>
<a name="line-2013"></a>     <span class='hs-comment'>-- Do not print the multiplicity here because it tends to be too verbose</span>
<a name="line-2014"></a>
<a name="line-2015"></a><a name="scaledMult"></a><span class='hs-definition'>scaledMult</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Mult</span>
<a name="line-2016"></a><span class='hs-definition'>scaledMult</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>m</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>m</span>
<a name="line-2017"></a>
<a name="line-2018"></a><a name="scaledThing"></a><span class='hs-definition'>scaledThing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Scaled</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span>
<a name="line-2019"></a><span class='hs-definition'>scaledThing</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span>
<a name="line-2020"></a>
<a name="line-2021"></a><a name="mapScaledType"></a><span class='hs-comment'>-- | Apply a function to both the Mult and the Type in a 'Scaled Type'</span>
<a name="line-2022"></a><span class='hs-definition'>mapScaledType</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Type</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span>
<a name="line-2023"></a><span class='hs-definition'>mapScaledType</span> <span class='hs-varid'>f</span> <span class='hs-layout'>(</span><span class='hs-conid'>Scaled</span> <span class='hs-varid'>m</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Scaled</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>f</span> <span class='hs-varid'>t</span><span class='hs-layout'>)</span>
<a name="line-2024"></a>
<a name="line-2025"></a><a name="Mult"></a><span class='hs-comment'>{- |
<a name="line-2026"></a>Mult is a type alias for Type.
<a name="line-2027"></a>
<a name="line-2028"></a>Mult must contain Type because multiplicity variables are mere type variables
<a name="line-2029"></a>(of kind Multiplicity) in Haskell. So the simplest implementation is to make
<a name="line-2030"></a>Mult be Type.
<a name="line-2031"></a>
<a name="line-2032"></a>Multiplicities can be formed with:
<a name="line-2033"></a>- One: GHC.Types.One (= oneDataCon)
<a name="line-2034"></a>- Many: GHC.Types.Many (= manyDataCon)
<a name="line-2035"></a>- Multiplication: GHC.Types.MultMul (= multMulTyCon)
<a name="line-2036"></a>
<a name="line-2037"></a>So that Mult feels a bit more structured, we provide pattern synonyms and smart
<a name="line-2038"></a>constructors for these.
<a name="line-2039"></a>-}</span>
<a name="line-2040"></a><a name="Mult"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Mult</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Type</span>
</pre></body>
</html>
