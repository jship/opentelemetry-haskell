<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Language/Haskell/Syntax/Expr.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE ConstraintKinds #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE DataKinds #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE DeriveDataTypeable #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE ExistentialQuantification #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts #-}</span>
<a name="line-7"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-8"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-9"></a><span class='hs-comment'>{-# LANGUAGE TypeApplications #-}</span>
<a name="line-10"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilyDependencies #-}</span>
<a name="line-11"></a><span class='hs-comment'>{-# LANGUAGE UndecidableInstances #-}</span> <span class='hs-comment'>-- Wrinkle in Note [Trees That Grow]</span>
<a name="line-12"></a>                                      <span class='hs-comment'>-- in module Language.Haskell.Syntax.Extension</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-comment'>{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}</span>
<a name="line-15"></a>
<a name="line-16"></a><span class='hs-comment'>{-
<a name="line-17"></a>(c) The University of Glasgow 2006
<a name="line-18"></a>(c) The GRASP/AQUA Project, Glasgow University, 1992-1998
<a name="line-19"></a>-}</span>
<a name="line-20"></a>
<a name="line-21"></a><span class='hs-comment'>-- See Note [Language.Haskell.Syntax.* Hierarchy] for why not GHC.Hs.*</span>
<a name="line-22"></a>
<a name="line-23"></a><span class='hs-comment'>-- | Abstract Haskell syntax for expressions.</span>
<a name="line-24"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Language.Haskell.Syntax.Expr</span> <span class='hs-keyword'>where</span>
<a name="line-25"></a>
<a name="line-26"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-27"></a>
<a name="line-28"></a><span class='hs-comment'>-- friends:</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Prelude</span>
<a name="line-30"></a>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Decls</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Pat</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Lit</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Extension</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Type</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Language.Haskell.Syntax.Binds</span>
<a name="line-37"></a>
<a name="line-38"></a><span class='hs-comment'>-- others:</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Tc.Types.Evidence</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.DataCon</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldLabelString</span><span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Name</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Basic</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Fixity</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SourceText</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.SrcLoc</span>
<a name="line-46"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Types.Tickish</span>
<a name="line-47"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.ConLike</span>
<a name="line-48"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Unit.Module</span> <span class='hs-layout'>(</span><span class='hs-conid'>ModuleName</span><span class='hs-layout'>)</span>
<a name="line-49"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Outputable</span>
<a name="line-50"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Utils.Panic</span>
<a name="line-51"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Data.FastString</span>
<a name="line-52"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC.Core.Type</span>
<a name="line-53"></a>
<a name="line-54"></a><span class='hs-comment'>-- libraries:</span>
<a name="line-55"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.Data</span> <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>Fixity</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Data.Data</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>Data</span> <span class='hs-layout'>(</span><span class='hs-conid'>Fixity</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-57"></a>
<a name="line-58"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data.List.NonEmpty</span> <span class='hs-layout'>(</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-layout'>)</span>
<a name="line-59"></a>
<a name="line-60"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHCi.RemoteTypes</span> <span class='hs-layout'>(</span> <span class='hs-conid'>ForeignRef</span> <span class='hs-layout'>)</span>
<a name="line-61"></a><span class='hs-keyword'>import</span> <span class='hs-keyword'>qualified</span> <span class='hs-conid'>Language.Haskell.TH</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TH</span> <span class='hs-layout'>(</span><span class='hs-conid'>Q</span><span class='hs-layout'>)</span>
<a name="line-62"></a>
<a name="line-63"></a><span class='hs-comment'>{- Note [RecordDotSyntax field updates]
<a name="line-64"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-65"></a>The extensions @OverloadedRecordDot@ @OverloadedRecordUpdate@ together
<a name="line-66"></a>enable record updates like @a{foo.bar.baz = 1}@. Introducing this
<a name="line-67"></a>syntax slightly complicates parsing. This note explains how it's done.
<a name="line-68"></a>
<a name="line-69"></a>In the event a record is being constructed or updated, it's this
<a name="line-70"></a>production that's in play:
<a name="line-71"></a>@
<a name="line-72"></a>aexp1 -&gt; aexp1 '{' fbinds '}' {
<a name="line-73"></a>  ...
<a name="line-74"></a>  mkHsRecordPV ... $1 (snd $3)
<a name="line-75"></a>}
<a name="line-76"></a>@
<a name="line-77"></a>@fbinds@ is a list of field bindings. @mkHsRecordPV@ is a function of
<a name="line-78"></a>the @DisambECP b@ typeclass, see Note [Ambiguous syntactic
<a name="line-79"></a>categories].
<a name="line-80"></a>
<a name="line-81"></a>The "normal" rules for an @fbind@ are:
<a name="line-82"></a>@
<a name="line-83"></a>fbind
<a name="line-84"></a>        : qvar '=' texp
<a name="line-85"></a>        | qvar
<a name="line-86"></a>@
<a name="line-87"></a>These rules compute values of @LHsRecField GhcPs (Located b)@. They
<a name="line-88"></a>apply in the context of record construction, record updates, record
<a name="line-89"></a>patterns and record expressions. That is, @b@ ranges over @HsExpr
<a name="line-90"></a>GhcPs@, @HsPat GhcPs@ and @HsCmd GhcPs@.
<a name="line-91"></a>
<a name="line-92"></a>When @OverloadedRecordDot@ and @OverloadedRecordUpdate@ are both
<a name="line-93"></a>enabled, two additional @fbind@ rules are admitted:
<a name="line-94"></a>@
<a name="line-95"></a>        | field TIGHT_INFIX_PROJ fieldToUpdate '=' texp
<a name="line-96"></a>        | field TIGHT_INFIX_PROJ fieldToUpdate
<a name="line-97"></a>@
<a name="line-98"></a>
<a name="line-99"></a>These rules only make sense when parsing record update expressions
<a name="line-100"></a>(that is, patterns and commands cannot be parsed by these rules and
<a name="line-101"></a>neither record constructions).
<a name="line-102"></a>
<a name="line-103"></a>The results of these new rules cannot be represented by @LHsRecField
<a name="line-104"></a>GhcPs (LHsExpr GhcPs)@ values as the type is defined today. We
<a name="line-105"></a>minimize modifying existing code by having these new rules calculate
<a name="line-106"></a>@LHsRecProj GhcPs (Located b)@ ("record projection") values instead:
<a name="line-107"></a>@
<a name="line-108"></a>newtype FieldLabelStrings = FieldLabelStrings [Located FieldLabelString]
<a name="line-109"></a>type RecProj arg = HsRecField' FieldLabelStrings arg
<a name="line-110"></a>type LHsRecProj p arg = Located (RecProj arg)
<a name="line-111"></a>@
<a name="line-112"></a>
<a name="line-113"></a>The @fbind@ rule is then given the type @fbind :: { forall b.
<a name="line-114"></a>DisambECP b =&gt; PV (Fbind b) }@ accomodating both alternatives:
<a name="line-115"></a>@
<a name="line-116"></a>type Fbind b = Either
<a name="line-117"></a>                  (LHsRecField GhcPs (Located b))
<a name="line-118"></a>                  ( LHsRecProj GhcPs (Located b))
<a name="line-119"></a>@
<a name="line-120"></a>
<a name="line-121"></a>In @data HsExpr p@, the @RecordUpd@ constuctor indicates regular
<a name="line-122"></a>updates vs. projection updates by means of the @rupd_flds@ member
<a name="line-123"></a>type, an @Either@ instance:
<a name="line-124"></a>@
<a name="line-125"></a>  | RecordUpd
<a name="line-126"></a>      { rupd_ext  :: XRecordUpd p
<a name="line-127"></a>      , rupd_expr :: LHsExpr p
<a name="line-128"></a>      , rupd_flds :: Either [LHsRecUpdField p] [LHsRecUpdProj p]
<a name="line-129"></a>      }
<a name="line-130"></a>@
<a name="line-131"></a>Here,
<a name="line-132"></a>@
<a name="line-133"></a>type RecUpdProj p = RecProj (LHsExpr p)
<a name="line-134"></a>type LHsRecUpdProj p = Located (RecUpdProj p)
<a name="line-135"></a>@
<a name="line-136"></a>and @Left@ values indicating regular record update, @Right@ values
<a name="line-137"></a>updates desugared to @setField@s.
<a name="line-138"></a>
<a name="line-139"></a>If @OverloadedRecordUpdate@ is enabled, any updates parsed as
<a name="line-140"></a>@LHsRecField GhcPs@ values are converted to @LHsRecUpdProj GhcPs@
<a name="line-141"></a>values (see function @mkRdrRecordUpd@ in 'GHC.Parser.PostProcess').
<a name="line-142"></a>-}</span>
<a name="line-143"></a>
<a name="line-144"></a><span class='hs-comment'>-- | RecordDotSyntax field updates</span>
<a name="line-145"></a>
<a name="line-146"></a><a name="FieldLabelStrings"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span>
<a name="line-147"></a>  <span class='hs-conid'>FieldLabelStrings</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Located</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsFieldLabel</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-148"></a>
<a name="line-149"></a><a name="instance%20Outputable%20(FieldLabelStrings%20p)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-150"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-151"></a>    <span class='hs-varid'>hcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>punctuate</span> <span class='hs-varid'>dot</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span><span class='hs-layout'>)</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-152"></a>
<a name="line-153"></a><a name="instance%20OutputableBndr%20(FieldLabelStrings%20p)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>OutputableBndr</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-154"></a>  <span class='hs-varid'>pprInfixOcc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprFieldLabelStrings</span>
<a name="line-155"></a>  <span class='hs-varid'>pprPrefixOcc</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprFieldLabelStrings</span>
<a name="line-156"></a>
<a name="line-157"></a><a name="pprFieldLabelStrings"></a><span class='hs-definition'>pprFieldLabelStrings</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-158"></a><span class='hs-definition'>pprFieldLabelStrings</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-159"></a>    <span class='hs-varid'>hcat</span> <span class='hs-layout'>(</span><span class='hs-varid'>punctuate</span> <span class='hs-varid'>dot</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varop'>.</span> <span class='hs-varid'>unLoc</span><span class='hs-layout'>)</span> <span class='hs-varid'>flds</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-160"></a>
<a name="line-161"></a><a name="instance%20Outputable%20(HsFieldLabel%20p)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsFieldLabel</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-162"></a>  <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsFieldLabel</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>s</span>
<a name="line-163"></a>  <span class='hs-varid'>ppr</span> <span class='hs-conid'>XHsFieldLabel</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"XHsFieldLabel"</span>
<a name="line-164"></a>
<a name="line-165"></a><a name="RecProj"></a><span class='hs-comment'>-- Field projection updates (e.g. @foo.bar.baz = 1@). See Note</span>
<a name="line-166"></a><a name="RecProj"></a><span class='hs-comment'>-- [RecordDotSyntax field updates].</span>
<a name="line-167"></a><a name="RecProj"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RecProj</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsRecField'</span> <span class='hs-layout'>(</span><span class='hs-conid'>FieldLabelStrings</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-varid'>arg</span>
<a name="line-168"></a>
<a name="line-169"></a><a name="LHsRecProj"></a><span class='hs-comment'>-- The phantom type parameter @p@ is for symmetry with @LHsRecField p</span>
<a name="line-170"></a><a name="LHsRecProj"></a><span class='hs-comment'>-- arg@ in the definition of @data Fbind@ (see GHC.Parser.Process).</span>
<a name="line-171"></a><a name="LHsRecProj"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsRecProj</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>RecProj</span> <span class='hs-varid'>p</span> <span class='hs-varid'>arg</span><span class='hs-layout'>)</span>
<a name="line-172"></a>
<a name="line-173"></a><a name="RecUpdProj"></a><span class='hs-comment'>-- These two synonyms are used in the definition of syntax @RecordUpd@</span>
<a name="line-174"></a><a name="RecUpdProj"></a><span class='hs-comment'>-- below.</span>
<a name="line-175"></a><a name="RecUpdProj"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>RecUpdProj</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>RecProj</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-176"></a><a name="LHsRecUpdProj"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsRecUpdProj</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>RecUpdProj</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-177"></a>
<a name="line-178"></a><span class='hs-comment'>{-
<a name="line-179"></a>************************************************************************
<a name="line-180"></a>*                                                                      *
<a name="line-181"></a>\subsection{Expressions proper}
<a name="line-182"></a>*                                                                      *
<a name="line-183"></a>************************************************************************
<a name="line-184"></a>-}</span>
<a name="line-185"></a>
<a name="line-186"></a><span class='hs-comment'>-- * Expressions proper</span>
<a name="line-187"></a>
<a name="line-188"></a><a name="LHsExpr"></a><span class='hs-comment'>-- | Located Haskell Expression</span>
<a name="line-189"></a><a name="LHsExpr"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-190"></a>  <span class='hs-comment'>-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma' when</span>
<a name="line-191"></a>  <span class='hs-comment'>--   in a list</span>
<a name="line-192"></a>
<a name="line-193"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-194"></a>
<a name="line-195"></a><span class='hs-comment'>-------------------------</span>
<a name="line-196"></a><span class='hs-comment'>{- Note [NoSyntaxExpr]
<a name="line-197"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-198"></a>Syntax expressions can be missing (NoSyntaxExprRn or NoSyntaxExprTc)
<a name="line-199"></a>for several reasons:
<a name="line-200"></a>
<a name="line-201"></a> 1. As described in Note [Rebindable if]
<a name="line-202"></a>
<a name="line-203"></a> 2. In order to suppress "not in scope: xyz" messages when a bit of
<a name="line-204"></a>    rebindable syntax does not apply. For example, when using an irrefutable
<a name="line-205"></a>    pattern in a BindStmt, we don't need a `fail` operator.
<a name="line-206"></a>
<a name="line-207"></a> 3. Rebindable syntax might just not make sense. For example, a BodyStmt
<a name="line-208"></a>    contains the syntax for `guard`, but that's used only in monad comprehensions.
<a name="line-209"></a>    If we had more of a whiz-bang type system, we might be able to rule this
<a name="line-210"></a>    case out statically.
<a name="line-211"></a>-}</span>
<a name="line-212"></a>
<a name="line-213"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- | Syntax Expression</span>
<a name="line-214"></a><a name="SyntaxExpr"></a><span class='hs-comment'>--</span>
<a name="line-215"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- SyntaxExpr is represents the function used in interpreting rebindable</span>
<a name="line-216"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- syntax. In the parser, we have no information to supply; in the renamer,</span>
<a name="line-217"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- we have the name of the function (but see</span>
<a name="line-218"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- Note [Monad fail : Rebindable syntax, overloaded strings] for a wrinkle)</span>
<a name="line-219"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- and in the type-checker we have a more elaborate structure 'SyntaxExprTc'.</span>
<a name="line-220"></a><a name="SyntaxExpr"></a><span class='hs-comment'>--</span>
<a name="line-221"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- In some contexts, rebindable syntax is not implemented, and so we have</span>
<a name="line-222"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- constructors to represent that possibility in both the renamer and</span>
<a name="line-223"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- typechecker instantiations.</span>
<a name="line-224"></a><a name="SyntaxExpr"></a><span class='hs-comment'>--</span>
<a name="line-225"></a><a name="SyntaxExpr"></a><span class='hs-comment'>-- E.g. @(&gt;&gt;=)@ is filled in before the renamer by the appropriate 'Name' for</span>
<a name="line-226"></a><a name="SyntaxExpr"></a><span class='hs-comment'>--      @(&gt;&gt;=)@, and then instantiated by the type checker with its type args</span>
<a name="line-227"></a><a name="SyntaxExpr"></a><span class='hs-comment'>--      etc</span>
<a name="line-228"></a><a name="SyntaxExpr"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span>
<a name="line-229"></a>
<a name="line-230"></a><a name="CmdSyntaxTable"></a><span class='hs-comment'>-- | Command Syntax Table (for Arrow syntax)</span>
<a name="line-231"></a><a name="CmdSyntaxTable"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CmdSyntaxTable</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>HsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-232"></a><span class='hs-comment'>-- See Note [CmdSyntaxTable]</span>
<a name="line-233"></a>
<a name="line-234"></a><span class='hs-comment'>{-
<a name="line-235"></a>Note [CmdSyntaxTable]
<a name="line-236"></a>~~~~~~~~~~~~~~~~~~~~~
<a name="line-237"></a>Used only for arrow-syntax stuff (HsCmdTop), the CmdSyntaxTable keeps
<a name="line-238"></a>track of the methods needed for a Cmd.
<a name="line-239"></a>
<a name="line-240"></a>* Before the renamer, this list is an empty list
<a name="line-241"></a>
<a name="line-242"></a>* After the renamer, it takes the form @[(std_name, HsVar actual_name)]@
<a name="line-243"></a>  For example, for the 'arr' method
<a name="line-244"></a>   * normal case:            (GHC.Control.Arrow.arr, HsVar GHC.Control.Arrow.arr)
<a name="line-245"></a>   * with rebindable syntax: (GHC.Control.Arrow.arr, arr_22)
<a name="line-246"></a>             where @arr_22@ is whatever 'arr' is in scope
<a name="line-247"></a>
<a name="line-248"></a>* After the type checker, it takes the form [(std_name, &lt;expression&gt;)]
<a name="line-249"></a>  where &lt;expression&gt; is the evidence for the method.  This evidence is
<a name="line-250"></a>  instantiated with the class, but is still polymorphic in everything
<a name="line-251"></a>  else.  For example, in the case of 'arr', the evidence has type
<a name="line-252"></a>         forall b c. (b-&gt;c) -&gt; a b c
<a name="line-253"></a>  where 'a' is the ambient type of the arrow.  This polymorphism is
<a name="line-254"></a>  important because the desugarer uses the same evidence at multiple
<a name="line-255"></a>  different types.
<a name="line-256"></a>
<a name="line-257"></a>This is Less Cool than what we normally do for rebindable syntax, which is to
<a name="line-258"></a>make fully-instantiated piece of evidence at every use site.  The Cmd way
<a name="line-259"></a>is Less Cool because
<a name="line-260"></a>  * The renamer has to predict which methods are needed.
<a name="line-261"></a>    See the tedious GHC.Rename.Expr.methodNamesCmd.
<a name="line-262"></a>
<a name="line-263"></a>  * The desugarer has to know the polymorphic type of the instantiated
<a name="line-264"></a>    method. This is checked by Inst.tcSyntaxName, but is less flexible
<a name="line-265"></a>    than the rest of rebindable syntax, where the type is less
<a name="line-266"></a>    pre-ordained.  (And this flexibility is useful; for example we can
<a name="line-267"></a>    typecheck do-notation with (&gt;&gt;=) :: m1 a -&gt; (a -&gt; m2 b) -&gt; m2 b.)
<a name="line-268"></a>-}</span>
<a name="line-269"></a>
<a name="line-270"></a><a name="HsExpr"></a><span class='hs-comment'>-- | A Haskell expression.</span>
<a name="line-271"></a><a name="HsExpr"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsExpr</span> <span class='hs-varid'>p</span>
<a name="line-272"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsVar</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XVar</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-273"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ Variable</span>
<a name="line-274"></a>                       <span class='hs-comment'>-- See Note [Located RdrNames]</span>
<a name="line-275"></a>
<a name="line-276"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsUnboundVar</span> <span class='hs-layout'>(</span><span class='hs-conid'>XUnboundVar</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-277"></a>                 <span class='hs-conid'>OccName</span>     <span class='hs-comment'>-- ^ Unbound variable; also used for "holes"</span>
<a name="line-278"></a>                             <span class='hs-comment'>--   (_ or _x).</span>
<a name="line-279"></a>                             <span class='hs-comment'>-- Turned from HsVar to HsUnboundVar by the</span>
<a name="line-280"></a>                             <span class='hs-comment'>--   renamer, when it finds an out-of-scope</span>
<a name="line-281"></a>                             <span class='hs-comment'>--   variable or hole.</span>
<a name="line-282"></a>                             <span class='hs-comment'>-- The (XUnboundVar p) field becomes an HoleExprRef</span>
<a name="line-283"></a>                             <span class='hs-comment'>--   after typechecking; this is where the</span>
<a name="line-284"></a>                             <span class='hs-comment'>--   erroring expression will be written after</span>
<a name="line-285"></a>                             <span class='hs-comment'>--   solving. See Note [Holes] in GHC.Tc.Types.Constraint.</span>
<a name="line-286"></a>
<a name="line-287"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsConLikeOut</span> <span class='hs-layout'>(</span><span class='hs-conid'>XConLikeOut</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-288"></a>                 <span class='hs-conid'>ConLike</span>     <span class='hs-comment'>-- ^ After typechecker only; must be different</span>
<a name="line-289"></a>                             <span class='hs-comment'>-- HsVar for pretty printing</span>
<a name="line-290"></a>
<a name="line-291"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsRecFld</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XRecFld</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-292"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>AmbiguousFieldOcc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ Variable pointing to record selector</span>
<a name="line-293"></a>              <span class='hs-comment'>-- The parser produces HsVars</span>
<a name="line-294"></a>              <span class='hs-comment'>-- The renamer renames record-field selectors to HsRecFld</span>
<a name="line-295"></a>              <span class='hs-comment'>-- The typechecker preserves HsRecFld</span>
<a name="line-296"></a>
<a name="line-297"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsOverLabel</span> <span class='hs-layout'>(</span><span class='hs-conid'>XOverLabel</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-conid'>FastString</span>
<a name="line-298"></a>     <span class='hs-comment'>-- ^ Overloaded label (Note [Overloaded labels] in GHC.OverloadedLabels)</span>
<a name="line-299"></a>
<a name="line-300"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsIPVar</span>   <span class='hs-layout'>(</span><span class='hs-conid'>XIPVar</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-301"></a>              <span class='hs-conid'>HsIPName</span>   <span class='hs-comment'>-- ^ Implicit parameter (not in use after typechecking)</span>
<a name="line-302"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsOverLit</span> <span class='hs-layout'>(</span><span class='hs-conid'>XOverLitE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-303"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>HsOverLit</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ Overloaded literals</span>
<a name="line-304"></a>
<a name="line-305"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsLit</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XLitE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-306"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>HsLit</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- ^ Simple (non-overloaded) literals</span>
<a name="line-307"></a>
<a name="line-308"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsLam</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XLam</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-309"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-310"></a>                       <span class='hs-comment'>-- ^ Lambda abstraction. Currently always a single match</span>
<a name="line-311"></a>       <span class='hs-comment'>--</span>
<a name="line-312"></a>       <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span>
<a name="line-313"></a>       <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnRarrow',</span>
<a name="line-314"></a>
<a name="line-315"></a>       <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-316"></a>
<a name="line-317"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsLamCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>XLamCase</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ Lambda-case</span>
<a name="line-318"></a>       <span class='hs-comment'>--</span>
<a name="line-319"></a>       <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span>
<a name="line-320"></a>       <span class='hs-comment'>--           'GHC.Parser.Annotation.AnnCase','GHC.Parser.Annotation.AnnOpen',</span>
<a name="line-321"></a>       <span class='hs-comment'>--           'GHC.Parser.Annotation.AnnClose'</span>
<a name="line-322"></a>
<a name="line-323"></a>       <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-324"></a>
<a name="line-325"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsApp</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XApp</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ Application</span>
<a name="line-326"></a>
<a name="line-327"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsAppType</span> <span class='hs-layout'>(</span><span class='hs-conid'>XAppTypeE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- After typechecking: the type argument</span>
<a name="line-328"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-329"></a>              <span class='hs-layout'>(</span><span class='hs-conid'>LHsWcType</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoGhcTc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ Visible type application</span>
<a name="line-330"></a>       <span class='hs-comment'>--</span>
<a name="line-331"></a>       <span class='hs-comment'>-- Explicit type argument; e.g  f @Int x y</span>
<a name="line-332"></a>       <span class='hs-comment'>-- NB: Has wildcards, but no implicit quantification</span>
<a name="line-333"></a>       <span class='hs-comment'>--</span>
<a name="line-334"></a>       <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnAt',</span>
<a name="line-335"></a>
<a name="line-336"></a>  <span class='hs-comment'>-- | Operator applications:</span>
<a name="line-337"></a>  <span class='hs-comment'>-- NB Bracketed ops such as (+) come out as Vars.</span>
<a name="line-338"></a>
<a name="line-339"></a>  <span class='hs-comment'>-- NB Sadly, we need an expr for the operator in an OpApp/Section since</span>
<a name="line-340"></a>  <span class='hs-comment'>-- the renamer may turn a HsVar into HsRecFld or HsUnboundVar</span>
<a name="line-341"></a>
<a name="line-342"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>OpApp</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XOpApp</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-343"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- left operand</span>
<a name="line-344"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- operator</span>
<a name="line-345"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- right operand</span>
<a name="line-346"></a>
<a name="line-347"></a>  <span class='hs-comment'>-- | Negation operator. Contains the negated expression and the name</span>
<a name="line-348"></a>  <span class='hs-comment'>-- of 'negate'</span>
<a name="line-349"></a>  <span class='hs-comment'>--</span>
<a name="line-350"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnMinus'</span>
<a name="line-351"></a>
<a name="line-352"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-353"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>NegApp</span>      <span class='hs-layout'>(</span><span class='hs-conid'>XNegApp</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-354"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-355"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-356"></a>
<a name="line-357"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span>
<a name="line-358"></a>  <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-359"></a>
<a name="line-360"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-361"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsPar</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XPar</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-362"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ Parenthesised expr; see Note [Parens in HsSyn]</span>
<a name="line-363"></a>
<a name="line-364"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SectionL</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XSectionL</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-365"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- operand; see Note [Sections in HsSyn]</span>
<a name="line-366"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- operator</span>
<a name="line-367"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>SectionR</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XSectionR</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-368"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- operator; see Note [Sections in HsSyn]</span>
<a name="line-369"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- operand</span>
<a name="line-370"></a>
<a name="line-371"></a>  <span class='hs-comment'>-- | Used for explicit tuples and sections thereof</span>
<a name="line-372"></a>  <span class='hs-comment'>--</span>
<a name="line-373"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span>
<a name="line-374"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose'</span>
<a name="line-375"></a>
<a name="line-376"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-377"></a>  <span class='hs-comment'>-- Note [ExplicitTuple]</span>
<a name="line-378"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ExplicitTuple</span>
<a name="line-379"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XExplicitTuple</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-380"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>HsTupArg</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-381"></a>        <span class='hs-conid'>Boxity</span>
<a name="line-382"></a>
<a name="line-383"></a>  <span class='hs-comment'>-- | Used for unboxed sum types</span>
<a name="line-384"></a>  <span class='hs-comment'>--</span>
<a name="line-385"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'(#'@,</span>
<a name="line-386"></a>  <span class='hs-comment'>--          'GHC.Parser.Annotation.AnnVbar', 'GHC.Parser.Annotation.AnnClose' @'#)'@,</span>
<a name="line-387"></a>  <span class='hs-comment'>--</span>
<a name="line-388"></a>  <span class='hs-comment'>--  There will be multiple 'GHC.Parser.Annotation.AnnVbar', (1 - alternative) before</span>
<a name="line-389"></a>  <span class='hs-comment'>--  the expression, (arity - alternative) after it</span>
<a name="line-390"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ExplicitSum</span>
<a name="line-391"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>XExplicitSum</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-392"></a>          <span class='hs-conid'>ConTag</span> <span class='hs-comment'>--  Alternative (one-based)</span>
<a name="line-393"></a>          <span class='hs-conid'>Arity</span>  <span class='hs-comment'>--  Sum arity</span>
<a name="line-394"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-395"></a>
<a name="line-396"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnCase',</span>
<a name="line-397"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnOf','GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-398"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-399"></a>
<a name="line-400"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-401"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCase</span>      <span class='hs-layout'>(</span><span class='hs-conid'>XCase</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-402"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-403"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-404"></a>
<a name="line-405"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf',</span>
<a name="line-406"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnSemi',</span>
<a name="line-407"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnThen','GHC.Parser.Annotation.AnnSemi',</span>
<a name="line-408"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnElse',</span>
<a name="line-409"></a>
<a name="line-410"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-411"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsIf</span>        <span class='hs-layout'>(</span><span class='hs-conid'>XIf</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- GhcPs: this is a Bool; False &lt;=&gt; do not use</span>
<a name="line-412"></a>                               <span class='hs-comment'>--  rebindable syntax</span>
<a name="line-413"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>--  predicate</span>
<a name="line-414"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>--  then part</span>
<a name="line-415"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>--  else part</span>
<a name="line-416"></a>
<a name="line-417"></a>  <span class='hs-comment'>-- | Multi-way if</span>
<a name="line-418"></a>  <span class='hs-comment'>--</span>
<a name="line-419"></a>  <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf'</span>
<a name="line-420"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose',</span>
<a name="line-421"></a>
<a name="line-422"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-423"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsMultiIf</span>   <span class='hs-layout'>(</span><span class='hs-conid'>XMultiIf</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LGRHS</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-424"></a>
<a name="line-425"></a>  <span class='hs-comment'>-- | let(rec)</span>
<a name="line-426"></a>  <span class='hs-comment'>--</span>
<a name="line-427"></a>  <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet',</span>
<a name="line-428"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-429"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnClose' @'}'@,'GHC.Parser.Annotation.AnnIn'</span>
<a name="line-430"></a>
<a name="line-431"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-432"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsLet</span>       <span class='hs-layout'>(</span><span class='hs-conid'>XLet</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-433"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>HsLocalBinds</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-434"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span>  <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-435"></a>
<a name="line-436"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDo',</span>
<a name="line-437"></a>  <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnOpen', 'GHC.Parser.Annotation.AnnSemi',</span>
<a name="line-438"></a>  <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnVbar',</span>
<a name="line-439"></a>  <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnClose'</span>
<a name="line-440"></a>
<a name="line-441"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-442"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsDo</span>        <span class='hs-layout'>(</span><span class='hs-conid'>XDo</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                  <span class='hs-comment'>-- Type of the whole expression</span>
<a name="line-443"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>HsStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsDoRn</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-444"></a>                <span class='hs-comment'>-- The parameterisation of the above is unimportant</span>
<a name="line-445"></a>                <span class='hs-comment'>-- because in this context we never use</span>
<a name="line-446"></a>                <span class='hs-comment'>-- the PatGuard or ParStmt variant</span>
<a name="line-447"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ExprLStmt</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- "do":one or more stmts</span>
<a name="line-448"></a>
<a name="line-449"></a>  <span class='hs-comment'>-- | Syntactic list: [a,b,c,...]</span>
<a name="line-450"></a>  <span class='hs-comment'>--</span>
<a name="line-451"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span>
<a name="line-452"></a>  <span class='hs-comment'>--              'GHC.Parser.Annotation.AnnClose' @']'@</span>
<a name="line-453"></a>
<a name="line-454"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-455"></a>  <span class='hs-comment'>-- See Note [Empty lists]</span>
<a name="line-456"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ExplicitList</span>
<a name="line-457"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>XExplicitList</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Gives type of components of list</span>
<a name="line-458"></a>                <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-459"></a>
<a name="line-460"></a>  <span class='hs-comment'>-- | Record construction</span>
<a name="line-461"></a>  <span class='hs-comment'>--</span>
<a name="line-462"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-463"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-464"></a>
<a name="line-465"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-466"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecordCon</span>
<a name="line-467"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>rcon_ext</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRecordCon</span> <span class='hs-varid'>p</span>
<a name="line-468"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>rcon_con</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>ConLikeP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- The constructor</span>
<a name="line-469"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>rcon_flds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsRecordBinds</span> <span class='hs-varid'>p</span> <span class='hs-layout'>}</span>    <span class='hs-comment'>-- The fields</span>
<a name="line-470"></a>
<a name="line-471"></a>  <span class='hs-comment'>-- | Record update</span>
<a name="line-472"></a>  <span class='hs-comment'>--</span>
<a name="line-473"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-474"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnDotdot','GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-475"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnComma, 'GHC.Parser.Annotation.AnnDot',</span>
<a name="line-476"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-477"></a>
<a name="line-478"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-479"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecordUpd</span>
<a name="line-480"></a>      <span class='hs-layout'>{</span> <span class='hs-varid'>rupd_ext</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRecordUpd</span> <span class='hs-varid'>p</span>
<a name="line-481"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>rupd_expr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span>
<a name="line-482"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>rupd_flds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Either</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsRecUpdField</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsRecUpdProj</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>
<a name="line-483"></a>      <span class='hs-layout'>}</span>
<a name="line-484"></a>  <span class='hs-comment'>-- For a type family, the arg types are of the *instance* tycon,</span>
<a name="line-485"></a>  <span class='hs-comment'>-- not the family tycon</span>
<a name="line-486"></a>
<a name="line-487"></a>  <span class='hs-comment'>-- | Record field selection e.g @z.x@.</span>
<a name="line-488"></a>  <span class='hs-comment'>--</span>
<a name="line-489"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDot'</span>
<a name="line-490"></a>  <span class='hs-comment'>--</span>
<a name="line-491"></a>  <span class='hs-comment'>-- This case only arises when the OverloadedRecordDot langauge</span>
<a name="line-492"></a>  <span class='hs-comment'>-- extension is enabled.</span>
<a name="line-493"></a>
<a name="line-494"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsGetField</span> <span class='hs-layout'>{</span>
<a name="line-495"></a>        <span class='hs-varid'>gf_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XGetField</span> <span class='hs-varid'>p</span>
<a name="line-496"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>gf_expr</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span>
<a name="line-497"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>gf_field</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Located</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsFieldLabel</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-498"></a>      <span class='hs-layout'>}</span>
<a name="line-499"></a>
<a name="line-500"></a>  <span class='hs-comment'>-- | Record field selector. e.g. @(.x)@ or @(.x.y)@</span>
<a name="line-501"></a>  <span class='hs-comment'>--</span>
<a name="line-502"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpenP'</span>
<a name="line-503"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnDot', 'GHC.Parser.Annotation.AnnCloseP'</span>
<a name="line-504"></a>  <span class='hs-comment'>--</span>
<a name="line-505"></a>  <span class='hs-comment'>-- This case only arises when the OverloadedRecordDot langauge</span>
<a name="line-506"></a>  <span class='hs-comment'>-- extensions is enabled.</span>
<a name="line-507"></a>
<a name="line-508"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsProjection</span> <span class='hs-layout'>{</span>
<a name="line-509"></a>        <span class='hs-varid'>proj_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XProjection</span> <span class='hs-varid'>p</span>
<a name="line-510"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>proj_flds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>NonEmpty</span> <span class='hs-layout'>(</span><span class='hs-conid'>Located</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsFieldLabel</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-511"></a>      <span class='hs-layout'>}</span>
<a name="line-512"></a>
<a name="line-513"></a>  <span class='hs-comment'>-- | Expression with an explicit type signature. @e :: type@</span>
<a name="line-514"></a>  <span class='hs-comment'>--</span>
<a name="line-515"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDcolon'</span>
<a name="line-516"></a>
<a name="line-517"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-518"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ExprWithTySig</span>
<a name="line-519"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>XExprWithTySig</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-520"></a>
<a name="line-521"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-522"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsSigWcType</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoGhcTc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-523"></a>
<a name="line-524"></a>  <span class='hs-comment'>-- | Arithmetic sequence</span>
<a name="line-525"></a>  <span class='hs-comment'>--</span>
<a name="line-526"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'['@,</span>
<a name="line-527"></a>  <span class='hs-comment'>--              'GHC.Parser.Annotation.AnnComma','GHC.Parser.Annotation.AnnDotdot',</span>
<a name="line-528"></a>  <span class='hs-comment'>--              'GHC.Parser.Annotation.AnnClose' @']'@</span>
<a name="line-529"></a>
<a name="line-530"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-531"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ArithSeq</span>
<a name="line-532"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>XArithSeq</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-533"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-534"></a>                                  <span class='hs-comment'>-- For OverloadedLists, the fromList witness</span>
<a name="line-535"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>ArithSeqInfo</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-536"></a>
<a name="line-537"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-538"></a>
<a name="line-539"></a>  <span class='hs-comment'>-----------------------------------------------------------</span>
<a name="line-540"></a>  <span class='hs-comment'>-- MetaHaskell Extensions</span>
<a name="line-541"></a>
<a name="line-542"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span>
<a name="line-543"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnOpenE','GHC.Parser.Annotation.AnnOpenEQ',</span>
<a name="line-544"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose','GHC.Parser.Annotation.AnnCloseQ'</span>
<a name="line-545"></a>
<a name="line-546"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-547"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsBracket</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XBracket</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsBracket</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-548"></a>
<a name="line-549"></a>    <span class='hs-comment'>-- See Note [Pending Splices]</span>
<a name="line-550"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsRnBracketOut</span>
<a name="line-551"></a>      <span class='hs-layout'>(</span><span class='hs-conid'>XRnBracketOut</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-552"></a>      <span class='hs-layout'>(</span><span class='hs-conid'>HsBracket</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsBracketRn</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Output of the renamer is the *original* renamed</span>
<a name="line-553"></a>                                  <span class='hs-comment'>-- expression, plus</span>
<a name="line-554"></a>      <span class='hs-keyglyph'>[</span><span class='hs-conid'>PendingRnSplice'</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- _renamed_ splices to be type checked</span>
<a name="line-555"></a>
<a name="line-556"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsTcBracketOut</span>
<a name="line-557"></a>      <span class='hs-layout'>(</span><span class='hs-conid'>XTcBracketOut</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-558"></a>      <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>QuoteWrapper</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- The wrapper to apply type and dictionary argument</span>
<a name="line-559"></a>                           <span class='hs-comment'>-- to the quote.</span>
<a name="line-560"></a>      <span class='hs-layout'>(</span><span class='hs-conid'>HsBracket</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsBracketRn</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Output of the type checker is the *original*</span>
<a name="line-561"></a>                                 <span class='hs-comment'>-- renamed expression, plus</span>
<a name="line-562"></a>      <span class='hs-keyglyph'>[</span><span class='hs-conid'>PendingTcSplice'</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- _typechecked_ splices to be</span>
<a name="line-563"></a>                           <span class='hs-comment'>-- pasted back in by the desugarer</span>
<a name="line-564"></a>
<a name="line-565"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span>
<a name="line-566"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnClose'</span>
<a name="line-567"></a>
<a name="line-568"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-569"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsSpliceE</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XSpliceE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsSplice</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-570"></a>
<a name="line-571"></a>  <span class='hs-comment'>-----------------------------------------------------------</span>
<a name="line-572"></a>  <span class='hs-comment'>-- Arrow notation extension</span>
<a name="line-573"></a>
<a name="line-574"></a>  <span class='hs-comment'>-- | @proc@ notation for Arrows</span>
<a name="line-575"></a>  <span class='hs-comment'>--</span>
<a name="line-576"></a>  <span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnProc',</span>
<a name="line-577"></a>  <span class='hs-comment'>--          'GHC.Parser.Annotation.AnnRarrow'</span>
<a name="line-578"></a>
<a name="line-579"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-580"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsProc</span>      <span class='hs-layout'>(</span><span class='hs-conid'>XProc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-581"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>               <span class='hs-comment'>-- arrow abstraction, proc</span>
<a name="line-582"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmdTop</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>          <span class='hs-comment'>-- body of the abstraction</span>
<a name="line-583"></a>                                       <span class='hs-comment'>-- always has an empty stack</span>
<a name="line-584"></a>
<a name="line-585"></a>  <span class='hs-comment'>---------------------------------------</span>
<a name="line-586"></a>  <span class='hs-comment'>-- static pointers extension</span>
<a name="line-587"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnStatic',</span>
<a name="line-588"></a>
<a name="line-589"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-590"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsStatic</span> <span class='hs-layout'>(</span><span class='hs-conid'>XStatic</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Free variables of the body</span>
<a name="line-591"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Body</span>
<a name="line-592"></a>
<a name="line-593"></a>  <span class='hs-comment'>---------------------------------------</span>
<a name="line-594"></a>  <span class='hs-comment'>-- Haskell program coverage (Hpc) Support</span>
<a name="line-595"></a>
<a name="line-596"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsTick</span>
<a name="line-597"></a>     <span class='hs-layout'>(</span><span class='hs-conid'>XTick</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-598"></a>     <span class='hs-conid'>CoreTickish</span>
<a name="line-599"></a>     <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                       <span class='hs-comment'>-- sub-expression</span>
<a name="line-600"></a>
<a name="line-601"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsBinTick</span>
<a name="line-602"></a>     <span class='hs-layout'>(</span><span class='hs-conid'>XBinTick</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-603"></a>     <span class='hs-conid'>Int</span>                                <span class='hs-comment'>-- module-local tick number for True</span>
<a name="line-604"></a>     <span class='hs-conid'>Int</span>                                <span class='hs-comment'>-- module-local tick number for False</span>
<a name="line-605"></a>     <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>                        <span class='hs-comment'>-- sub-expression</span>
<a name="line-606"></a>
<a name="line-607"></a>  <span class='hs-comment'>---------------------------------------</span>
<a name="line-608"></a>  <span class='hs-comment'>-- Expressions annotated with pragmas, written as {-# ... #-}</span>
<a name="line-609"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsPragE</span> <span class='hs-layout'>(</span><span class='hs-conid'>XPragE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsPragE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-610"></a>
<a name="line-611"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XExpr</span>       <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-612"></a>  <span class='hs-comment'>-- Note [Trees that Grow] extension constructor for the</span>
<a name="line-613"></a>  <span class='hs-comment'>-- general idea, and Note [Rebindable syntax and HsExpansion] in GHC.Hs.Expr</span>
<a name="line-614"></a>  <span class='hs-comment'>-- for an example of how we use it.</span>
<a name="line-615"></a>
<a name="line-616"></a><a name="HsDoRn"></a><span class='hs-comment'>-- | The AST used to hard-refer to GhcPass, which was a layer violation. For now,</span>
<a name="line-617"></a><a name="HsDoRn"></a><span class='hs-comment'>-- we paper it over with this new extension point.</span>
<a name="line-618"></a><a name="HsDoRn"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>HsDoRn</span> <span class='hs-varid'>p</span>
<a name="line-619"></a><a name="HsBracketRn"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>HsBracketRn</span> <span class='hs-varid'>p</span>
<a name="line-620"></a><a name="PendingRnSplice'"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>PendingRnSplice'</span> <span class='hs-varid'>p</span>
<a name="line-621"></a><a name="PendingTcSplice'"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>PendingTcSplice'</span> <span class='hs-varid'>p</span>
<a name="line-622"></a>
<a name="line-623"></a><span class='hs-comment'>-- ---------------------------------------------------------------------</span>
<a name="line-624"></a>
<a name="line-625"></a><a name="HsFieldLabel"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsFieldLabel</span> <span class='hs-varid'>p</span>
<a name="line-626"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsFieldLabel</span>
<a name="line-627"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>hflExt</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XCHsFieldLabel</span> <span class='hs-varid'>p</span>
<a name="line-628"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>hflLabel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Located</span> <span class='hs-conid'>FieldLabelString</span>
<a name="line-629"></a>    <span class='hs-layout'>}</span>
<a name="line-630"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsFieldLabel</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXHsFieldLabel</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-631"></a>
<a name="line-632"></a><span class='hs-comment'>-- ---------------------------------------------------------------------</span>
<a name="line-633"></a>
<a name="line-634"></a><a name="HsPragE"></a><span class='hs-comment'>-- | A pragma, written as {-# ... #-}, that may appear within an expression.</span>
<a name="line-635"></a><a name="HsPragE"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsPragE</span> <span class='hs-varid'>p</span>
<a name="line-636"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsPragSCC</span>   <span class='hs-layout'>(</span><span class='hs-conid'>XSCC</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-637"></a>                <span class='hs-conid'>SourceText</span>            <span class='hs-comment'>-- Note [Pragma source text] in GHC.Types.SourceText</span>
<a name="line-638"></a>                <span class='hs-conid'>StringLiteral</span>         <span class='hs-comment'>-- "set cost centre" SCC pragma</span>
<a name="line-639"></a>
<a name="line-640"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen',</span>
<a name="line-641"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnOpen' @'{-\# GENERATED'@,</span>
<a name="line-642"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnVal',</span>
<a name="line-643"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnColon','GHC.Parser.Annotation.AnnVal',</span>
<a name="line-644"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnMinus',</span>
<a name="line-645"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnVal','GHC.Parser.Annotation.AnnColon',</span>
<a name="line-646"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnVal',</span>
<a name="line-647"></a>  <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnClose' @'\#-}'@</span>
<a name="line-648"></a>
<a name="line-649"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XHsPragE</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXPragE</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-650"></a>
<a name="line-651"></a><a name="LHsTupArg"></a><span class='hs-comment'>-- | Located Haskell Tuple Argument</span>
<a name="line-652"></a><a name="LHsTupArg"></a><span class='hs-comment'>--</span>
<a name="line-653"></a><a name="LHsTupArg"></a><span class='hs-comment'>-- 'HsTupArg' is used for tuple sections</span>
<a name="line-654"></a><a name="LHsTupArg"></a><span class='hs-comment'>-- @(,a,)@ is represented by</span>
<a name="line-655"></a><a name="LHsTupArg"></a><span class='hs-comment'>-- @ExplicitTuple [Missing ty1, Present a, Missing ty3]@</span>
<a name="line-656"></a><a name="LHsTupArg"></a><span class='hs-comment'>-- Which in turn stands for @(\x:ty1 \y:ty2. (x,a,y))@</span>
<a name="line-657"></a><a name="LHsTupArg"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsTupArg</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsTupArg</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-658"></a><span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnComma'</span>
<a name="line-659"></a>
<a name="line-660"></a><span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-661"></a>
<a name="line-662"></a><a name="HsTupArg"></a><span class='hs-comment'>-- | Haskell Tuple Argument</span>
<a name="line-663"></a><a name="HsTupArg"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsTupArg</span> <span class='hs-varid'>id</span>
<a name="line-664"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Present</span> <span class='hs-layout'>(</span><span class='hs-conid'>XPresent</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- ^ The argument</span>
<a name="line-665"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Missing</span> <span class='hs-layout'>(</span><span class='hs-conid'>XMissing</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ^ The argument is missing, but this is its type</span>
<a name="line-666"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XTupArg</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXTupArg</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- ^ Note [Trees that Grow] extension point</span>
<a name="line-667"></a>
<a name="line-668"></a><span class='hs-comment'>{-
<a name="line-669"></a>Note [Parens in HsSyn]
<a name="line-670"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-671"></a>HsPar (and ParPat in patterns, HsParTy in types) is used as follows
<a name="line-672"></a>
<a name="line-673"></a>  * HsPar is required; the pretty printer does not add parens.
<a name="line-674"></a>
<a name="line-675"></a>  * HsPars are respected when rearranging operator fixities.
<a name="line-676"></a>    So   a * (b + c)  means what it says (where the parens are an HsPar)
<a name="line-677"></a>
<a name="line-678"></a>  * For ParPat and HsParTy the pretty printer does add parens but this should be
<a name="line-679"></a>    a no-op for ParsedSource, based on the pretty printer round trip feature
<a name="line-680"></a>    introduced in
<a name="line-681"></a>    https://phabricator.haskell.org/rGHC499e43824bda967546ebf95ee33ec1f84a114a7c
<a name="line-682"></a>
<a name="line-683"></a>  * ParPat and HsParTy are pretty printed as '( .. )' regardless of whether or
<a name="line-684"></a>    not they are strictly necessary. This should be addressed when #13238 is
<a name="line-685"></a>    completed, to be treated the same as HsPar.
<a name="line-686"></a>
<a name="line-687"></a>
<a name="line-688"></a>Note [Sections in HsSyn]
<a name="line-689"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-690"></a>Sections should always appear wrapped in an HsPar, thus
<a name="line-691"></a>         HsPar (SectionR ...)
<a name="line-692"></a>The parser parses sections in a wider variety of situations
<a name="line-693"></a>(See Note [Parsing sections]), but the renamer checks for those
<a name="line-694"></a>parens.  This invariant makes pretty-printing easier; we don't need
<a name="line-695"></a>a special case for adding the parens round sections.
<a name="line-696"></a>
<a name="line-697"></a>Note [Rebindable if]
<a name="line-698"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-699"></a>The rebindable syntax for 'if' is a bit special, because when
<a name="line-700"></a>rebindable syntax is *off* we do not want to treat
<a name="line-701"></a>   (if c then t else e)
<a name="line-702"></a>as if it was an application (ifThenElse c t e).  Why not?
<a name="line-703"></a>Because we allow an 'if' to return *unboxed* results, thus
<a name="line-704"></a>  if blah then 3# else 4#
<a name="line-705"></a>whereas that would not be possible using a all to a polymorphic function
<a name="line-706"></a>(because you can't call a polymorphic function at an unboxed type).
<a name="line-707"></a>
<a name="line-708"></a>So we use NoSyntaxExpr to mean "use the old built-in typing rule".
<a name="line-709"></a>
<a name="line-710"></a>A further complication is that, in the `deriving` code, we never want
<a name="line-711"></a>to use rebindable syntax. So, even in GhcPs, we want to denote whether
<a name="line-712"></a>to use rebindable syntax or not. This is done via the type instance
<a name="line-713"></a>for XIf GhcPs.
<a name="line-714"></a>
<a name="line-715"></a>Note [Record Update HsWrapper]
<a name="line-716"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-717"></a>There is a wrapper in RecordUpd which is used for the *required*
<a name="line-718"></a>constraints for pattern synonyms. This wrapper is created in the
<a name="line-719"></a>typechecking and is then directly used in the desugaring without
<a name="line-720"></a>modification.
<a name="line-721"></a>
<a name="line-722"></a>For example, if we have the record pattern synonym P,
<a name="line-723"></a>  pattern P :: (Show a) =&gt; a -&gt; Maybe a
<a name="line-724"></a>  pattern P{x} = Just x
<a name="line-725"></a>
<a name="line-726"></a>  foo = (Just True) { x = False }
<a name="line-727"></a>then `foo` desugars to something like
<a name="line-728"></a>  foo = case Just True of
<a name="line-729"></a>          P x -&gt; P False
<a name="line-730"></a>hence we need to provide the correct dictionaries to P's matcher on
<a name="line-731"></a>the RHS so that we can build the expression.
<a name="line-732"></a>
<a name="line-733"></a>Note [Located RdrNames]
<a name="line-734"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-735"></a>A number of syntax elements have seemingly redundant locations
<a name="line-736"></a>attached to them.  This is deliberate, to allow transformations making
<a name="line-737"></a>use of the exact print annotations to easily correlate a Located Name
<a name="line-738"></a>in the RenamedSource with a Located RdrName in the ParsedSource.
<a name="line-739"></a>
<a name="line-740"></a>There are unfortunately enough differences between the ParsedSource
<a name="line-741"></a>and the RenamedSource that the exact print annotations cannot be used
<a name="line-742"></a>directly with RenamedSource, so this allows a simple mapping to be
<a name="line-743"></a>used based on the location.
<a name="line-744"></a>
<a name="line-745"></a>Note [ExplicitTuple]
<a name="line-746"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-747"></a>An ExplicitTuple is never just a data constructor like (,,,).
<a name="line-748"></a>That is, the `[LHsTupArg p]` argument of `ExplicitTuple` has at least
<a name="line-749"></a>one `Present` member (and is thus never empty).
<a name="line-750"></a>
<a name="line-751"></a>A tuple data constructor like () or (,,,) is parsed as an `HsVar`, not an
<a name="line-752"></a>`ExplicitTuple`, and stays that way. This is important for two reasons:
<a name="line-753"></a>
<a name="line-754"></a>  1. We don't need -XTupleSections for (,,,)
<a name="line-755"></a>  2. The type variables in (,,,) can be instantiated with visible type application.
<a name="line-756"></a>     That is,
<a name="line-757"></a>
<a name="line-758"></a>       (,,)     :: forall a b c. a -&gt; b -&gt; c -&gt; (a,b,c)
<a name="line-759"></a>       (True,,) :: forall {b} {c}. b -&gt; c -&gt; (Bool,b,c)
<a name="line-760"></a>
<a name="line-761"></a>     Note that the tuple section has *inferred* arguments, while the data
<a name="line-762"></a>     constructor has *specified* ones.
<a name="line-763"></a>     (See Note [Required, Specified, and Inferred for types] in GHC.Tc.TyCl
<a name="line-764"></a>     for background.)
<a name="line-765"></a>
<a name="line-766"></a>Sadly, the grammar for this is actually ambiguous, and it's only thanks to the
<a name="line-767"></a>preference of a shift in a shift/reduce conflict that the parser works as this
<a name="line-768"></a>Note details. Search for a reference to this Note in GHC.Parser for further
<a name="line-769"></a>explanation.
<a name="line-770"></a>
<a name="line-771"></a>Note [Empty lists]
<a name="line-772"></a>~~~~~~~~~~~~~~~~~~
<a name="line-773"></a>An empty list could be considered either a data constructor (stored with
<a name="line-774"></a>HsVar) or an ExplicitList. This Note describes how empty lists flow through the
<a name="line-775"></a>various phases and why.
<a name="line-776"></a>
<a name="line-777"></a>Parsing
<a name="line-778"></a>-------
<a name="line-779"></a>An empty list is parsed by the sysdcon nonterminal. It thus comes to life via
<a name="line-780"></a>HsVar nilDataCon (defined in GHC.Builtin.Types). A freshly-parsed (HsExpr GhcPs) empty list
<a name="line-781"></a>is never a ExplicitList.
<a name="line-782"></a>
<a name="line-783"></a>Renaming
<a name="line-784"></a>--------
<a name="line-785"></a>If -XOverloadedLists is enabled, we must type-check the empty list as if it
<a name="line-786"></a>were a call to fromListN. (This is true regardless of the setting of
<a name="line-787"></a>-XRebindableSyntax.) This is very easy if the empty list is an ExplicitList,
<a name="line-788"></a>but an annoying special case if it's an HsVar. So the renamer changes a
<a name="line-789"></a>HsVar nilDataCon to an ExplicitList [], but only if -XOverloadedLists is on.
<a name="line-790"></a>(Why not always? Read on, dear friend.) This happens in the HsVar case of rnExpr.
<a name="line-791"></a>
<a name="line-792"></a>Type-checking
<a name="line-793"></a>-------------
<a name="line-794"></a>We want to accept an expression like [] @Int. To do this, we must infer that
<a name="line-795"></a>[] :: forall a. [a]. This is easy if [] is a HsVar with the right DataCon inside.
<a name="line-796"></a>However, the type-checking for explicit lists works differently: [x,y,z] is never
<a name="line-797"></a>polymorphic. Instead, we unify the types of x, y, and z together, and use the
<a name="line-798"></a>unified type as the argument to the cons and nil constructors. Thus, treating
<a name="line-799"></a>[] as an empty ExplicitList in the type-checker would prevent [] @Int from working.
<a name="line-800"></a>
<a name="line-801"></a>However, if -XOverloadedLists is on, then [] @Int really shouldn't be allowed:
<a name="line-802"></a>it's just like fromListN 0 [] @Int. Since
<a name="line-803"></a>  fromListN :: forall list. IsList list =&gt; Int -&gt; [Item list] -&gt; list
<a name="line-804"></a>that expression really should be rejected. Thus, the renamer's behaviour is
<a name="line-805"></a>exactly what we want: treat [] as a datacon when -XNoOverloadedLists, and as
<a name="line-806"></a>an empty ExplicitList when -XOverloadedLists.
<a name="line-807"></a>
<a name="line-808"></a>See also #13680, which requested [] @Int to work.
<a name="line-809"></a>-}</span>
<a name="line-810"></a>
<a name="line-811"></a>
<a name="line-812"></a><a name="pprExternalSrcLoc"></a><span class='hs-comment'>-----------------------</span>
<a name="line-813"></a><span class='hs-definition'>pprExternalSrcLoc</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>StringLiteral</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span><span class='hs-conid'>Int</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-conid'>Int</span><span class='hs-layout'>,</span><span class='hs-conid'>Int</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-814"></a><span class='hs-definition'>pprExternalSrcLoc</span> <span class='hs-layout'>(</span><span class='hs-conid'>StringLiteral</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>src</span> <span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-varid'>n1</span><span class='hs-layout'>,</span><span class='hs-varid'>n2</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-varid'>n3</span><span class='hs-layout'>,</span><span class='hs-varid'>n4</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-815"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>src</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-varid'>n1</span><span class='hs-layout'>,</span><span class='hs-varid'>n2</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-varid'>n3</span><span class='hs-layout'>,</span><span class='hs-varid'>n4</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-816"></a>
<a name="line-817"></a><span class='hs-comment'>{-
<a name="line-818"></a>HsSyn records exactly where the user put parens, with HsPar.
<a name="line-819"></a>So generally speaking we print without adding any parens.
<a name="line-820"></a>However, some code is internally generated, and in some places
<a name="line-821"></a>parens are absolutely required; so for these places we use
<a name="line-822"></a>pprParendLExpr (but don't print double parens of course).
<a name="line-823"></a>
<a name="line-824"></a>For operator applications we don't add parens, because the operator
<a name="line-825"></a>fixities should do the job, except in debug mode (-dppr-debug) so we
<a name="line-826"></a>can see the structure of the parse tree.
<a name="line-827"></a>-}</span>
<a name="line-828"></a>
<a name="line-829"></a><span class='hs-comment'>{-
<a name="line-830"></a>************************************************************************
<a name="line-831"></a>*                                                                      *
<a name="line-832"></a>\subsection{Commands (in arrow abstractions)}
<a name="line-833"></a>*                                                                      *
<a name="line-834"></a>************************************************************************
<a name="line-835"></a>
<a name="line-836"></a>We re-use HsExpr to represent these.
<a name="line-837"></a>-}</span>
<a name="line-838"></a>
<a name="line-839"></a><a name="LHsCmd"></a><span class='hs-comment'>-- | Located Haskell Command (for arrow syntax)</span>
<a name="line-840"></a><a name="LHsCmd"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-841"></a>
<a name="line-842"></a><a name="HsCmd"></a><span class='hs-comment'>-- | Haskell Command (e.g. a "statement" in an Arrow proc block)</span>
<a name="line-843"></a><a name="HsCmd"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsCmd</span> <span class='hs-varid'>id</span>
<a name="line-844"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.Annlarrowtail',</span>
<a name="line-845"></a>  <span class='hs-comment'>--          'GHC.Parser.Annotation.Annrarrowtail','GHC.Parser.Annotation.AnnLarrowtail',</span>
<a name="line-846"></a>  <span class='hs-comment'>--          'GHC.Parser.Annotation.AnnRarrowtail'</span>
<a name="line-847"></a>
<a name="line-848"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-849"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsCmdArrApp</span>          <span class='hs-comment'>-- Arrow tail, or arrow application (f -&lt; arg)</span>
<a name="line-850"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XCmdArrApp</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- type of the arrow expressions f,</span>
<a name="line-851"></a>                         <span class='hs-comment'>-- of the form a t t', where arg :: t</span>
<a name="line-852"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- arrow expression, f</span>
<a name="line-853"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- input expression, arg</span>
<a name="line-854"></a>        <span class='hs-conid'>HsArrAppType</span>     <span class='hs-comment'>-- higher-order (-&lt;&lt;) or first-order (-&lt;)</span>
<a name="line-855"></a>        <span class='hs-conid'>Bool</span>             <span class='hs-comment'>-- True =&gt; right-to-left (f -&lt; arg)</span>
<a name="line-856"></a>                         <span class='hs-comment'>-- False =&gt; left-to-right (arg &gt;- f)</span>
<a name="line-857"></a>
<a name="line-858"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpenB' @'(|'@,</span>
<a name="line-859"></a>  <span class='hs-comment'>--         'GHC.Parser.Annotation.AnnCloseB' @'|)'@</span>
<a name="line-860"></a>
<a name="line-861"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-862"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdArrForm</span>         <span class='hs-comment'>-- Command formation,  (| e cmd1 .. cmdn |)</span>
<a name="line-863"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XCmdArrForm</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-864"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- The operator.</span>
<a name="line-865"></a>                         <span class='hs-comment'>-- After type-checking, a type abstraction to be</span>
<a name="line-866"></a>                         <span class='hs-comment'>-- applied to the type of the local environment tuple</span>
<a name="line-867"></a>        <span class='hs-conid'>LexicalFixity</span>    <span class='hs-comment'>-- Whether the operator appeared prefix or infix when</span>
<a name="line-868"></a>                         <span class='hs-comment'>-- parsed.</span>
<a name="line-869"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Fixity</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- fixity (filled in by the renamer), for forms that</span>
<a name="line-870"></a>                         <span class='hs-comment'>-- were converted from OpApp's by the renamer</span>
<a name="line-871"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsCmdTop</span> <span class='hs-varid'>id</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- argument commands</span>
<a name="line-872"></a>
<a name="line-873"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdApp</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XCmdApp</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-874"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-875"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-876"></a>
<a name="line-877"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdLam</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XCmdLam</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-878"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- kappa</span>
<a name="line-879"></a>       <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span>
<a name="line-880"></a>       <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnRarrow',</span>
<a name="line-881"></a>
<a name="line-882"></a>       <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-883"></a>
<a name="line-884"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdPar</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XCmdPar</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-885"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>                     <span class='hs-comment'>-- parenthesised command</span>
<a name="line-886"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnOpen' @'('@,</span>
<a name="line-887"></a>    <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnClose' @')'@</span>
<a name="line-888"></a>
<a name="line-889"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-890"></a>
<a name="line-891"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdCase</span>   <span class='hs-layout'>(</span><span class='hs-conid'>XCmdCase</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-892"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-893"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- bodies are HsCmd's</span>
<a name="line-894"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnCase',</span>
<a name="line-895"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnOf','GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-896"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-897"></a>
<a name="line-898"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-899"></a>
<a name="line-900"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdLamCase</span> <span class='hs-layout'>(</span><span class='hs-conid'>XCmdLamCase</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-901"></a>                 <span class='hs-layout'>(</span><span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- bodies are HsCmd's</span>
<a name="line-902"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLam',</span>
<a name="line-903"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnCase','GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-904"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnClose' @'}'@</span>
<a name="line-905"></a>
<a name="line-906"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-907"></a>
<a name="line-908"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdIf</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XCmdIf</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-909"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- cond function</span>
<a name="line-910"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>            <span class='hs-comment'>-- predicate</span>
<a name="line-911"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- then part</span>
<a name="line-912"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- else part</span>
<a name="line-913"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnIf',</span>
<a name="line-914"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnSemi',</span>
<a name="line-915"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnThen','GHC.Parser.Annotation.AnnSemi',</span>
<a name="line-916"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnElse',</span>
<a name="line-917"></a>
<a name="line-918"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-919"></a>
<a name="line-920"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdLet</span>    <span class='hs-layout'>(</span><span class='hs-conid'>XCmdLet</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-921"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>HsLocalBinds</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- let(rec)</span>
<a name="line-922"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span>  <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-923"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet',</span>
<a name="line-924"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnOpen' @'{'@,</span>
<a name="line-925"></a>    <span class='hs-comment'>--       'GHC.Parser.Annotation.AnnClose' @'}'@,'GHC.Parser.Annotation.AnnIn'</span>
<a name="line-926"></a>
<a name="line-927"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-928"></a>
<a name="line-929"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsCmdDo</span>     <span class='hs-layout'>(</span><span class='hs-conid'>XCmdDo</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>                     <span class='hs-comment'>-- Type of the whole expression</span>
<a name="line-930"></a>                <span class='hs-layout'>(</span><span class='hs-conid'>XRec</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>CmdLStmt</span> <span class='hs-varid'>id</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-931"></a>    <span class='hs-comment'>-- ^ - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnDo',</span>
<a name="line-932"></a>    <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnOpen', 'GHC.Parser.Annotation.AnnSemi',</span>
<a name="line-933"></a>    <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnVbar',</span>
<a name="line-934"></a>    <span class='hs-comment'>--             'GHC.Parser.Annotation.AnnClose'</span>
<a name="line-935"></a>
<a name="line-936"></a>    <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-937"></a>
<a name="line-938"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XCmd</span>        <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXCmd</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- Note [Trees that Grow] extension point</span>
<a name="line-939"></a>
<a name="line-940"></a>
<a name="line-941"></a><a name="HsArrAppType"></a><span class='hs-comment'>-- | Haskell Array Application Type</span>
<a name="line-942"></a><a name="HsArrAppType"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsArrAppType</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsHigherOrderApp</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsFirstOrderApp</span>
<a name="line-943"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-944"></a>
<a name="line-945"></a>
<a name="line-946"></a><span class='hs-comment'>{- | Top-level command, introducing a new arrow.
<a name="line-947"></a>This may occur inside a proc (where the stack is empty) or as an
<a name="line-948"></a>argument of a command-forming operator.
<a name="line-949"></a>-}</span>
<a name="line-950"></a>
<a name="line-951"></a><a name="LHsCmdTop"></a><span class='hs-comment'>-- | Located Haskell Top-level Command</span>
<a name="line-952"></a><a name="LHsCmdTop"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LHsCmdTop</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsCmdTop</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-953"></a>
<a name="line-954"></a><a name="HsCmdTop"></a><span class='hs-comment'>-- | Haskell Top-level Command</span>
<a name="line-955"></a><a name="HsCmdTop"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsCmdTop</span> <span class='hs-varid'>p</span>
<a name="line-956"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsCmdTop</span> <span class='hs-layout'>(</span><span class='hs-conid'>XCmdTop</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-957"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-958"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XCmdTop</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXCmdTop</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- Note [Trees that Grow] extension point</span>
<a name="line-959"></a>
<a name="line-960"></a><span class='hs-comment'>-----------------------</span>
<a name="line-961"></a>
<a name="line-962"></a><span class='hs-comment'>{-
<a name="line-963"></a>************************************************************************
<a name="line-964"></a>*                                                                      *
<a name="line-965"></a>\subsection{Record binds}
<a name="line-966"></a>*                                                                      *
<a name="line-967"></a>************************************************************************
<a name="line-968"></a>-}</span>
<a name="line-969"></a>
<a name="line-970"></a><a name="HsRecordBinds"></a><span class='hs-comment'>-- | Haskell Record Bindings</span>
<a name="line-971"></a><a name="HsRecordBinds"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>HsRecordBinds</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsRecFields</span> <span class='hs-varid'>p</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-972"></a>
<a name="line-973"></a><span class='hs-comment'>{-
<a name="line-974"></a>************************************************************************
<a name="line-975"></a>*                                                                      *
<a name="line-976"></a>\subsection{@Match@, @GRHSs@, and @GRHS@ datatypes}
<a name="line-977"></a>*                                                                      *
<a name="line-978"></a>************************************************************************
<a name="line-979"></a>
<a name="line-980"></a>@Match@es are sets of pattern bindings and right hand sides for
<a name="line-981"></a>functions, patterns or case branches. For example, if a function @g@
<a name="line-982"></a>is defined as:
<a name="line-983"></a>\begin{verbatim}
<a name="line-984"></a>g (x,y) = y
<a name="line-985"></a>g ((x:ys),y) = y+1,
<a name="line-986"></a>\end{verbatim}
<a name="line-987"></a>then \tr{g} has two @Match@es: @(x,y) = y@ and @((x:ys),y) = y+1@.
<a name="line-988"></a>
<a name="line-989"></a>It is always the case that each element of an @[Match]@ list has the
<a name="line-990"></a>same number of @pats@s inside it.  This corresponds to saying that
<a name="line-991"></a>a function defined by pattern matching must have the same number of
<a name="line-992"></a>patterns in each equation.
<a name="line-993"></a>-}</span>
<a name="line-994"></a>
<a name="line-995"></a><a name="MatchGroup"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>MatchGroup</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span>
<a name="line-996"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MG</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mg_ext</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XMG</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span> <span class='hs-comment'>-- Post-typechecker, types of args and result</span>
<a name="line-997"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>mg_alts</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LMatch</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- The alternatives</span>
<a name="line-998"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>mg_origin</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Origin</span> <span class='hs-layout'>}</span>
<a name="line-999"></a>     <span class='hs-comment'>-- The type is the type of the entire group</span>
<a name="line-1000"></a>     <span class='hs-comment'>--      t1 -&gt; ... -&gt; tn -&gt; tr</span>
<a name="line-1001"></a>     <span class='hs-comment'>-- where there are n patterns</span>
<a name="line-1002"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XMatchGroup</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXMatchGroup</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1003"></a>
<a name="line-1004"></a><a name="MatchGroupTc"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>MatchGroupTc</span>
<a name="line-1005"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>MatchGroupTc</span>
<a name="line-1006"></a>       <span class='hs-layout'>{</span> <span class='hs-varid'>mg_arg_tys</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Scaled</span> <span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- Types of the arguments, t1..tn</span>
<a name="line-1007"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>mg_res_ty</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span>    <span class='hs-comment'>-- Type of the result, tr</span>
<a name="line-1008"></a>       <span class='hs-layout'>}</span> <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-1009"></a>
<a name="line-1010"></a><a name="LMatch"></a><span class='hs-comment'>-- | Located Match</span>
<a name="line-1011"></a><a name="LMatch"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LMatch</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>Match</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1012"></a><span class='hs-comment'>-- ^ May have 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnSemi' when in a</span>
<a name="line-1013"></a><span class='hs-comment'>--   list</span>
<a name="line-1014"></a>
<a name="line-1015"></a><a name="Match"></a><span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1016"></a><a name="Match"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Match</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span>
<a name="line-1017"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Match</span> <span class='hs-layout'>{</span>
<a name="line-1018"></a>        <span class='hs-varid'>m_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XCMatch</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span>
<a name="line-1019"></a>        <span class='hs-varid'>m_ctxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsMatchContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>NoGhcTc</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-1020"></a>          <span class='hs-comment'>-- See note [m_ctxt in Match]</span>
<a name="line-1021"></a>        <span class='hs-varid'>m_pats</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- The patterns</span>
<a name="line-1022"></a>        <span class='hs-varid'>m_grhss</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>GRHSs</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1023"></a>  <span class='hs-layout'>}</span>
<a name="line-1024"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XMatch</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXMatch</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1025"></a>
<a name="line-1026"></a><span class='hs-comment'>{-
<a name="line-1027"></a>Note [m_ctxt in Match]
<a name="line-1028"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1029"></a>
<a name="line-1030"></a>A Match can occur in a number of contexts, such as a FunBind, HsCase, HsLam and
<a name="line-1031"></a>so on.
<a name="line-1032"></a>
<a name="line-1033"></a>In order to simplify tooling processing and pretty print output, the provenance
<a name="line-1034"></a>is captured in an HsMatchContext.
<a name="line-1035"></a>
<a name="line-1036"></a>This is particularly important for the exact print annotations for a
<a name="line-1037"></a>multi-equation FunBind.
<a name="line-1038"></a>
<a name="line-1039"></a>The parser initially creates a FunBind with a single Match in it for
<a name="line-1040"></a>every function definition it sees.
<a name="line-1041"></a>
<a name="line-1042"></a>These are then grouped together by getMonoBind into a single FunBind,
<a name="line-1043"></a>where all the Matches are combined.
<a name="line-1044"></a>
<a name="line-1045"></a>In the process, all the original FunBind fun_id's bar one are
<a name="line-1046"></a>discarded, including the locations.
<a name="line-1047"></a>
<a name="line-1048"></a>This causes a problem for source to source conversions via exact print
<a name="line-1049"></a>annotations, so the original fun_ids and infix flags are preserved in
<a name="line-1050"></a>the Match, when it originates from a FunBind.
<a name="line-1051"></a>
<a name="line-1052"></a>Example infix function definition requiring individual exact print
<a name="line-1053"></a>annotations
<a name="line-1054"></a>
<a name="line-1055"></a>    (&amp;&amp;&amp;  ) [] [] =  []
<a name="line-1056"></a>    xs    &amp;&amp;&amp;   [] =  xs
<a name="line-1057"></a>    (  &amp;&amp;&amp;  ) [] ys =  ys
<a name="line-1058"></a>
<a name="line-1059"></a>
<a name="line-1060"></a>
<a name="line-1061"></a>-}</span>
<a name="line-1062"></a>
<a name="line-1063"></a>
<a name="line-1064"></a><a name="isInfixMatch"></a><span class='hs-definition'>isInfixMatch</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Match</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1065"></a><span class='hs-definition'>isInfixMatch</span> <span class='hs-varid'>match</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>m_ctxt</span> <span class='hs-varid'>match</span> <span class='hs-keyword'>of</span>
<a name="line-1066"></a>  <span class='hs-conid'>FunRhs</span> <span class='hs-layout'>{</span><span class='hs-varid'>mc_fixity</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Infix</span><span class='hs-layout'>}</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1067"></a>  <span class='hs-keyword'>_</span>                          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1068"></a>
<a name="line-1069"></a><span class='hs-comment'>-- | Guarded Right-Hand Sides</span>
<a name="line-1070"></a><span class='hs-comment'>--</span>
<a name="line-1071"></a><span class='hs-comment'>-- GRHSs are used both for pattern bindings and for Matches</span>
<a name="line-1072"></a><span class='hs-comment'>--</span>
<a name="line-1073"></a><span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVbar',</span>
<a name="line-1074"></a><span class='hs-comment'>--        'GHC.Parser.Annotation.AnnEqual','GHC.Parser.Annotation.AnnWhere',</span>
<a name="line-1075"></a><span class='hs-comment'>--        'GHC.Parser.Annotation.AnnOpen','GHC.Parser.Annotation.AnnClose'</span>
<a name="line-1076"></a><span class='hs-comment'>--        'GHC.Parser.Annotation.AnnRarrow','GHC.Parser.Annotation.AnnSemi'</span>
<a name="line-1077"></a>
<a name="line-1078"></a><a name="GRHSs"></a><span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1079"></a><a name="GRHSs"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>GRHSs</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span>
<a name="line-1080"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GRHSs</span> <span class='hs-layout'>{</span>
<a name="line-1081"></a>      <span class='hs-varid'>grhssExt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XCGRHSs</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span>
<a name="line-1082"></a>      <span class='hs-varid'>grhssGRHSs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LGRHS</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- ^ Guarded RHSs</span>
<a name="line-1083"></a>      <span class='hs-varid'>grhssLocalBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsLocalBinds</span> <span class='hs-varid'>p</span> <span class='hs-comment'>-- ^ The where clause</span>
<a name="line-1084"></a>    <span class='hs-layout'>}</span>
<a name="line-1085"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XGRHSs</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXGRHSs</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1086"></a>
<a name="line-1087"></a><a name="LGRHS"></a><span class='hs-comment'>-- | Located Guarded Right-Hand Side</span>
<a name="line-1088"></a><a name="LGRHS"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LGRHS</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>GRHS</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1089"></a>
<a name="line-1090"></a><a name="GRHS"></a><span class='hs-comment'>-- | Guarded Right Hand Side.</span>
<a name="line-1091"></a><a name="GRHS"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>GRHS</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GRHS</span> <span class='hs-layout'>(</span><span class='hs-conid'>XCGRHS</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1092"></a>                        <span class='hs-keyglyph'>[</span><span class='hs-conid'>GuardLStmt</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- Guards</span>
<a name="line-1093"></a>                        <span class='hs-varid'>body</span>           <span class='hs-comment'>-- Right hand side</span>
<a name="line-1094"></a>                  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XGRHS</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXGRHS</span> <span class='hs-varid'>p</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1095"></a>
<a name="line-1096"></a><span class='hs-comment'>-- We know the list must have at least one @Match@ in it.</span>
<a name="line-1097"></a>
<a name="line-1098"></a><span class='hs-comment'>{-
<a name="line-1099"></a>************************************************************************
<a name="line-1100"></a>*                                                                      *
<a name="line-1101"></a>\subsection{Do stmts and list comprehensions}
<a name="line-1102"></a>*                                                                      *
<a name="line-1103"></a>************************************************************************
<a name="line-1104"></a>-}</span>
<a name="line-1105"></a>
<a name="line-1106"></a><a name="LStmt"></a><span class='hs-comment'>-- | Located @do@ block Statement</span>
<a name="line-1107"></a><a name="LStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LStmt</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>StmtLR</span> <span class='hs-varid'>id</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1108"></a>
<a name="line-1109"></a><a name="LStmtLR"></a><span class='hs-comment'>-- | Located Statement with separate Left and Right id's</span>
<a name="line-1110"></a><a name="LStmtLR"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>LStmtLR</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>idL</span> <span class='hs-layout'>(</span><span class='hs-conid'>StmtLR</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1111"></a>
<a name="line-1112"></a><a name="Stmt"></a><span class='hs-comment'>-- | @do@ block Statement</span>
<a name="line-1113"></a><a name="Stmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>Stmt</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>StmtLR</span> <span class='hs-varid'>id</span> <span class='hs-varid'>id</span> <span class='hs-varid'>body</span>
<a name="line-1114"></a>
<a name="line-1115"></a><a name="CmdLStmt"></a><span class='hs-comment'>-- | Command Located Statement</span>
<a name="line-1116"></a><a name="CmdLStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CmdLStmt</span>   <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LStmt</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span>  <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1117"></a>
<a name="line-1118"></a><a name="CmdStmt"></a><span class='hs-comment'>-- | Command Statement</span>
<a name="line-1119"></a><a name="CmdStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CmdStmt</span>    <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stmt</span>  <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsCmd</span>  <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1120"></a>
<a name="line-1121"></a><a name="ExprLStmt"></a><span class='hs-comment'>-- | Expression Located Statement</span>
<a name="line-1122"></a><a name="ExprLStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ExprLStmt</span>  <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LStmt</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1123"></a>
<a name="line-1124"></a><a name="ExprStmt"></a><span class='hs-comment'>-- | Expression Statement</span>
<a name="line-1125"></a><a name="ExprStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ExprStmt</span>   <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stmt</span>  <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1126"></a>
<a name="line-1127"></a><a name="GuardLStmt"></a><span class='hs-comment'>-- | Guard Located Statement</span>
<a name="line-1128"></a><a name="GuardLStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>GuardLStmt</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LStmt</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1129"></a>
<a name="line-1130"></a><a name="GuardStmt"></a><span class='hs-comment'>-- | Guard Statement</span>
<a name="line-1131"></a><a name="GuardStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>GuardStmt</span>  <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stmt</span>  <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1132"></a>
<a name="line-1133"></a><a name="GhciLStmt"></a><span class='hs-comment'>-- | Ghci Located Statement</span>
<a name="line-1134"></a><a name="GhciLStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>GhciLStmt</span>  <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LStmt</span> <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1135"></a>
<a name="line-1136"></a><a name="GhciStmt"></a><span class='hs-comment'>-- | Ghci Statement</span>
<a name="line-1137"></a><a name="GhciStmt"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>GhciStmt</span>   <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Stmt</span>  <span class='hs-varid'>id</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1138"></a>
<a name="line-1139"></a><span class='hs-comment'>-- The SyntaxExprs in here are used *only* for do-notation and monad</span>
<a name="line-1140"></a><span class='hs-comment'>-- comprehensions, which have rebindable syntax. Otherwise they are unused.</span>
<a name="line-1141"></a><span class='hs-comment'>-- | Exact print annotations when in qualifier lists or guards</span>
<a name="line-1142"></a><span class='hs-comment'>--  - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnVbar',</span>
<a name="line-1143"></a><span class='hs-comment'>--         'GHC.Parser.Annotation.AnnComma','GHC.Parser.Annotation.AnnThen',</span>
<a name="line-1144"></a><span class='hs-comment'>--         'GHC.Parser.Annotation.AnnBy','GHC.Parser.Annotation.AnnBy',</span>
<a name="line-1145"></a><span class='hs-comment'>--         'GHC.Parser.Annotation.AnnGroup','GHC.Parser.Annotation.AnnUsing'</span>
<a name="line-1146"></a>
<a name="line-1147"></a><a name="StmtLR"></a><span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1148"></a><a name="StmtLR"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>StmtLR</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span> <span class='hs-comment'>-- body should always be (LHs**** idR)</span>
<a name="line-1149"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LastStmt</span>  <span class='hs-comment'>-- Always the last Stmt in ListComp, MonadComp,</span>
<a name="line-1150"></a>              <span class='hs-comment'>-- and (after the renamer, see GHC.Rename.Expr.checkLastStmt) DoExpr, MDoExpr</span>
<a name="line-1151"></a>              <span class='hs-comment'>-- Not used for GhciStmtCtxt, PatGuard, which scope over other stuff</span>
<a name="line-1152"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>XLastStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1153"></a>          <span class='hs-varid'>body</span>
<a name="line-1154"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>Bool</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Whether return was stripped</span>
<a name="line-1155"></a>            <span class='hs-comment'>-- Just True &lt;=&gt; return with a dollar was stripped by ApplicativeDo</span>
<a name="line-1156"></a>            <span class='hs-comment'>-- Just False &lt;=&gt; return without a dollar was stripped by ApplicativeDo</span>
<a name="line-1157"></a>            <span class='hs-comment'>-- Nothing &lt;=&gt; Nothing was stripped</span>
<a name="line-1158"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- The return operator</span>
<a name="line-1159"></a>            <span class='hs-comment'>-- The return operator is used only for MonadComp</span>
<a name="line-1160"></a>            <span class='hs-comment'>-- For ListComp we use the baked-in 'return'</span>
<a name="line-1161"></a>            <span class='hs-comment'>-- For DoExpr, MDoExpr, we don't apply a 'return' at all</span>
<a name="line-1162"></a>            <span class='hs-comment'>-- See Note [Monad Comprehensions]</span>
<a name="line-1163"></a>            <span class='hs-comment'>-- - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLarrow'</span>
<a name="line-1164"></a>
<a name="line-1165"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1166"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BindStmt</span> <span class='hs-layout'>(</span><span class='hs-conid'>XBindStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1167"></a>             <span class='hs-comment'>-- ^ Post renaming has optional fail and bind / (&gt;&gt;=) operator.</span>
<a name="line-1168"></a>             <span class='hs-comment'>-- Post typechecking, also has multiplicity of the argument</span>
<a name="line-1169"></a>             <span class='hs-comment'>-- and the result type of the function passed to bind;</span>
<a name="line-1170"></a>             <span class='hs-comment'>-- that is, (P, S) in (&gt;&gt;=) :: Q -&gt; (R # P -&gt; S) -&gt; T</span>
<a name="line-1171"></a>             <span class='hs-comment'>-- See Note [The type of bind in Stmts]</span>
<a name="line-1172"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>idL</span><span class='hs-layout'>)</span>
<a name="line-1173"></a>             <span class='hs-varid'>body</span>
<a name="line-1174"></a>
<a name="line-1175"></a>  <span class='hs-comment'>-- | 'ApplicativeStmt' represents an applicative expression built with</span>
<a name="line-1176"></a>  <span class='hs-comment'>-- '&lt;$&gt;' and '&lt;*&gt;'.  It is generated by the renamer, and is desugared into the</span>
<a name="line-1177"></a>  <span class='hs-comment'>-- appropriate applicative expression by the desugarer, but it is intended</span>
<a name="line-1178"></a>  <span class='hs-comment'>-- to be invisible in error messages.</span>
<a name="line-1179"></a>  <span class='hs-comment'>--</span>
<a name="line-1180"></a>  <span class='hs-comment'>-- For full details, see Note [ApplicativeDo] in "GHC.Rename.Expr"</span>
<a name="line-1181"></a>  <span class='hs-comment'>--</span>
<a name="line-1182"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ApplicativeStmt</span>
<a name="line-1183"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>XApplicativeStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Post typecheck, Type of the body</span>
<a name="line-1184"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span>
<a name="line-1185"></a>               <span class='hs-layout'>,</span> <span class='hs-conid'>ApplicativeArg</span> <span class='hs-varid'>idL</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-1186"></a>                      <span class='hs-comment'>-- [(&lt;$&gt;, e1), (&lt;*&gt;, e2), ..., (&lt;*&gt;, en)]</span>
<a name="line-1187"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- 'join', if necessary</span>
<a name="line-1188"></a>
<a name="line-1189"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BodyStmt</span> <span class='hs-layout'>(</span><span class='hs-conid'>XBodyStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Post typecheck, element type</span>
<a name="line-1190"></a>                                      <span class='hs-comment'>-- of the RHS (used for arrows)</span>
<a name="line-1191"></a>             <span class='hs-varid'>body</span>              <span class='hs-comment'>-- See Note [BodyStmt]</span>
<a name="line-1192"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- The (&gt;&gt;) operator</span>
<a name="line-1193"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- The `guard` operator; used only in MonadComp</span>
<a name="line-1194"></a>                               <span class='hs-comment'>-- See notes [Monad Comprehensions]</span>
<a name="line-1195"></a>
<a name="line-1196"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnLet'</span>
<a name="line-1197"></a>  <span class='hs-comment'>--          'GHC.Parser.Annotation.AnnOpen' @'{'@,'GHC.Parser.Annotation.AnnClose' @'}'@,</span>
<a name="line-1198"></a>
<a name="line-1199"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1200"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LetStmt</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XLetStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsLocalBindsLR</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>
<a name="line-1201"></a>
<a name="line-1202"></a>  <span class='hs-comment'>-- ParStmts only occur in a list/monad comprehension</span>
<a name="line-1203"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ParStmt</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XParStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- Post typecheck,</span>
<a name="line-1204"></a>                                        <span class='hs-comment'>-- S in (&gt;&gt;=) :: Q -&gt; (R -&gt; S) -&gt; T</span>
<a name="line-1205"></a>             <span class='hs-keyglyph'>[</span><span class='hs-conid'>ParStmtBlock</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span><span class='hs-keyglyph'>]</span>
<a name="line-1206"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>HsExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>               <span class='hs-comment'>-- Polymorphic `mzip` for monad comprehensions</span>
<a name="line-1207"></a>             <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- The `&gt;&gt;=` operator</span>
<a name="line-1208"></a>                                        <span class='hs-comment'>-- See notes [Monad Comprehensions]</span>
<a name="line-1209"></a>            <span class='hs-comment'>-- After renaming, the ids are the binders</span>
<a name="line-1210"></a>            <span class='hs-comment'>-- bound by the stmts and used after themp</span>
<a name="line-1211"></a>
<a name="line-1212"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TransStmt</span> <span class='hs-layout'>{</span>
<a name="line-1213"></a>      <span class='hs-varid'>trS_ext</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XTransStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- Post typecheck,</span>
<a name="line-1214"></a>                                            <span class='hs-comment'>-- R in (&gt;&gt;=) :: Q -&gt; (R -&gt; S) -&gt; T</span>
<a name="line-1215"></a>      <span class='hs-varid'>trS_form</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TransForm</span><span class='hs-layout'>,</span>
<a name="line-1216"></a>      <span class='hs-varid'>trS_stmts</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ExprLStmt</span> <span class='hs-varid'>idL</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>   <span class='hs-comment'>-- Stmts to the *left* of the 'group'</span>
<a name="line-1217"></a>                                      <span class='hs-comment'>-- which generates the tuples to be grouped</span>
<a name="line-1218"></a>
<a name="line-1219"></a>      <span class='hs-varid'>trS_bndrs</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>idR</span><span class='hs-layout'>,</span> <span class='hs-conid'>IdP</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-comment'>-- See Note [TransStmt binder map]</span>
<a name="line-1220"></a>
<a name="line-1221"></a>      <span class='hs-varid'>trS_using</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>,</span>
<a name="line-1222"></a>      <span class='hs-varid'>trS_by</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>  <span class='hs-comment'>-- "by e" (optional)</span>
<a name="line-1223"></a>        <span class='hs-comment'>-- Invariant: if trS_form = GroupBy, then grp_by = Just e</span>
<a name="line-1224"></a>
<a name="line-1225"></a>      <span class='hs-varid'>trS_ret</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- The monomorphic 'return' function for</span>
<a name="line-1226"></a>                                      <span class='hs-comment'>-- the inner monad comprehensions</span>
<a name="line-1227"></a>      <span class='hs-varid'>trS_bind</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>,</span>     <span class='hs-comment'>-- The '(&gt;&gt;=)' operator</span>
<a name="line-1228"></a>      <span class='hs-varid'>trS_fmap</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsExpr</span> <span class='hs-varid'>idR</span>          <span class='hs-comment'>-- The polymorphic 'fmap' function for desugaring</span>
<a name="line-1229"></a>                                      <span class='hs-comment'>-- Only for 'group' forms</span>
<a name="line-1230"></a>                                      <span class='hs-comment'>-- Just a simple HsExpr, because it's</span>
<a name="line-1231"></a>                                      <span class='hs-comment'>-- too polymorphic for tcSyntaxOp</span>
<a name="line-1232"></a>    <span class='hs-layout'>}</span>                                 <span class='hs-comment'>-- See Note [Monad Comprehensions]</span>
<a name="line-1233"></a>
<a name="line-1234"></a>  <span class='hs-comment'>-- Recursive statement (see Note [How RecStmt works] below)</span>
<a name="line-1235"></a>  <span class='hs-comment'>-- | - 'GHC.Parser.Annotation.AnnKeywordId' : 'GHC.Parser.Annotation.AnnRec'</span>
<a name="line-1236"></a>
<a name="line-1237"></a>  <span class='hs-comment'>-- For details on above see note [exact print annotations] in GHC.Parser.Annotation</span>
<a name="line-1238"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecStmt</span>
<a name="line-1239"></a>     <span class='hs-layout'>{</span> <span class='hs-varid'>recS_ext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRecStmt</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span>
<a name="line-1240"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>recS_stmts</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XRec</span> <span class='hs-varid'>idR</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>LStmtLR</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-keyglyph'>]</span>
<a name="line-1241"></a>     <span class='hs-comment'>-- Assume XRec is the same for idL and idR, pick one arbitrarily</span>
<a name="line-1242"></a>
<a name="line-1243"></a>        <span class='hs-comment'>-- The next two fields are only valid after renaming</span>
<a name="line-1244"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>recS_later_ids</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>idR</span><span class='hs-keyglyph'>]</span>
<a name="line-1245"></a>                         <span class='hs-comment'>-- The ids are a subset of the variables bound by the</span>
<a name="line-1246"></a>                         <span class='hs-comment'>-- stmts that are used in stmts that follow the RecStmt</span>
<a name="line-1247"></a>
<a name="line-1248"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>recS_rec_ids</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>idR</span><span class='hs-keyglyph'>]</span>
<a name="line-1249"></a>                         <span class='hs-comment'>-- Ditto, but these variables are the "recursive" ones,</span>
<a name="line-1250"></a>                         <span class='hs-comment'>-- that are used before they are bound in the stmts of</span>
<a name="line-1251"></a>                         <span class='hs-comment'>-- the RecStmt.</span>
<a name="line-1252"></a>        <span class='hs-comment'>-- An Id can be in both groups</span>
<a name="line-1253"></a>        <span class='hs-comment'>-- Both sets of Ids are (now) treated monomorphically</span>
<a name="line-1254"></a>        <span class='hs-comment'>-- See Note [How RecStmt works] for why they are separate</span>
<a name="line-1255"></a>
<a name="line-1256"></a>        <span class='hs-comment'>-- Rebindable syntax</span>
<a name="line-1257"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>recS_bind_fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span> <span class='hs-comment'>-- The bind function</span>
<a name="line-1258"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>recS_ret_fn</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span> <span class='hs-comment'>-- The return function</span>
<a name="line-1259"></a>     <span class='hs-layout'>,</span> <span class='hs-varid'>recS_mfix_fn</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span> <span class='hs-comment'>-- The mfix function</span>
<a name="line-1260"></a>      <span class='hs-layout'>}</span>
<a name="line-1261"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XStmtLR</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXStmtLR</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span> <span class='hs-varid'>body</span><span class='hs-layout'>)</span>
<a name="line-1262"></a>
<a name="line-1263"></a><a name="TransForm"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>TransForm</span>   <span class='hs-comment'>-- The 'f' below is the 'using' function, 'e' is the by function</span>
<a name="line-1264"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ThenForm</span>     <span class='hs-comment'>-- then f               or    then f by e             (depending on trS_by)</span>
<a name="line-1265"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GroupForm</span>    <span class='hs-comment'>-- then group using f   or    then group by e using f (depending on trS_by)</span>
<a name="line-1266"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-1267"></a>
<a name="line-1268"></a><a name="ParStmtBlock"></a><span class='hs-comment'>-- | Parenthesised Statement Block</span>
<a name="line-1269"></a><a name="ParStmtBlock"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ParStmtBlock</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span>
<a name="line-1270"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ParStmtBlock</span>
<a name="line-1271"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XParStmtBlock</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>
<a name="line-1272"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>ExprLStmt</span> <span class='hs-varid'>idL</span><span class='hs-keyglyph'>]</span>
<a name="line-1273"></a>        <span class='hs-keyglyph'>[</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>idR</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- The variables to be returned</span>
<a name="line-1274"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- The return operator</span>
<a name="line-1275"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XParStmtBlock</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXParStmtBlock</span> <span class='hs-varid'>idL</span> <span class='hs-varid'>idR</span><span class='hs-layout'>)</span>
<a name="line-1276"></a>
<a name="line-1277"></a><a name="FailOperator"></a><span class='hs-comment'>-- | The fail operator</span>
<a name="line-1278"></a><a name="FailOperator"></a><span class='hs-comment'>--</span>
<a name="line-1279"></a><a name="FailOperator"></a><span class='hs-comment'>-- This is used for `.. &lt;-` "bind statements" in do notation, including</span>
<a name="line-1280"></a><a name="FailOperator"></a><span class='hs-comment'>-- non-monadic "binds" in applicative.</span>
<a name="line-1281"></a><a name="FailOperator"></a><span class='hs-comment'>--</span>
<a name="line-1282"></a><a name="FailOperator"></a><span class='hs-comment'>-- The fail operator is 'Just expr' if it potentially fail monadically. if the</span>
<a name="line-1283"></a><a name="FailOperator"></a><span class='hs-comment'>-- pattern match cannot fail, or shouldn't fail monadically (regular incomplete</span>
<a name="line-1284"></a><a name="FailOperator"></a><span class='hs-comment'>-- pattern exception), it is 'Nothing'.</span>
<a name="line-1285"></a><a name="FailOperator"></a><span class='hs-comment'>--</span>
<a name="line-1286"></a><a name="FailOperator"></a><span class='hs-comment'>-- See Note [Monad fail : Rebindable syntax, overloaded strings] for the type of</span>
<a name="line-1287"></a><a name="FailOperator"></a><span class='hs-comment'>-- expression in the 'Just' case, and why it is so.</span>
<a name="line-1288"></a><a name="FailOperator"></a><span class='hs-comment'>--</span>
<a name="line-1289"></a><a name="FailOperator"></a><span class='hs-comment'>-- See Note [Failing pattern matches in Stmts] for which contexts for</span>
<a name="line-1290"></a><a name="FailOperator"></a><span class='hs-comment'>-- '@BindStmt@'s should use the monadic fail and which shouldn't.</span>
<a name="line-1291"></a><a name="FailOperator"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>FailOperator</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>SyntaxExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1292"></a>
<a name="line-1293"></a><a name="ApplicativeArg"></a><span class='hs-comment'>-- | Applicative Argument</span>
<a name="line-1294"></a><a name="ApplicativeArg"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ApplicativeArg</span> <span class='hs-varid'>idL</span>
<a name="line-1295"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ApplicativeArgOne</span>      <span class='hs-comment'>-- A single statement (BindStmt or BodyStmt)</span>
<a name="line-1296"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>xarg_app_arg_one</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XApplicativeArgOne</span> <span class='hs-varid'>idL</span>
<a name="line-1297"></a>      <span class='hs-comment'>-- ^ The fail operator, after renaming</span>
<a name="line-1298"></a>      <span class='hs-comment'>--</span>
<a name="line-1299"></a>      <span class='hs-comment'>-- The fail operator is needed if this is a BindStmt</span>
<a name="line-1300"></a>      <span class='hs-comment'>-- where the pattern can fail. E.g.:</span>
<a name="line-1301"></a>      <span class='hs-comment'>-- (Just a) &lt;- stmt</span>
<a name="line-1302"></a>      <span class='hs-comment'>-- The fail operator will be invoked if the pattern</span>
<a name="line-1303"></a>      <span class='hs-comment'>-- match fails.</span>
<a name="line-1304"></a>      <span class='hs-comment'>-- It is also used for guards in MonadComprehensions.</span>
<a name="line-1305"></a>      <span class='hs-comment'>-- The fail operator is Nothing</span>
<a name="line-1306"></a>      <span class='hs-comment'>-- if the pattern match can't fail</span>
<a name="line-1307"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>app_arg_pattern</span>   <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LPat</span> <span class='hs-varid'>idL</span> <span class='hs-comment'>-- WildPat if it was a BodyStmt (see below)</span>
<a name="line-1308"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>arg_expr</span>          <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>idL</span>
<a name="line-1309"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>is_body_stmt</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span>
<a name="line-1310"></a>      <span class='hs-comment'>-- ^ True &lt;=&gt; was a BodyStmt,</span>
<a name="line-1311"></a>      <span class='hs-comment'>-- False &lt;=&gt; was a BindStmt.</span>
<a name="line-1312"></a>      <span class='hs-comment'>-- See Note [Applicative BodyStmt]</span>
<a name="line-1313"></a>    <span class='hs-layout'>}</span>
<a name="line-1314"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ApplicativeArgMany</span>     <span class='hs-comment'>-- do { stmts; return vars }</span>
<a name="line-1315"></a>    <span class='hs-layout'>{</span> <span class='hs-varid'>xarg_app_arg_many</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>XApplicativeArgMany</span> <span class='hs-varid'>idL</span>
<a name="line-1316"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>app_stmts</span>         <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ExprLStmt</span> <span class='hs-varid'>idL</span><span class='hs-keyglyph'>]</span> <span class='hs-comment'>-- stmts</span>
<a name="line-1317"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>final_expr</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsExpr</span> <span class='hs-varid'>idL</span>    <span class='hs-comment'>-- return (v1,..,vn), or just (v1,..,vn)</span>
<a name="line-1318"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>bv_pattern</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LPat</span> <span class='hs-varid'>idL</span>      <span class='hs-comment'>-- (v1,...,vn)</span>
<a name="line-1319"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>stmt_context</span>      <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>ApplicativeArgStmCtxPass</span> <span class='hs-varid'>idL</span><span class='hs-layout'>)</span>
<a name="line-1320"></a>      <span class='hs-comment'>-- ^ context of the do expression, used in pprArg</span>
<a name="line-1321"></a>    <span class='hs-layout'>}</span>
<a name="line-1322"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XApplicativeArg</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXApplicativeArg</span> <span class='hs-varid'>idL</span><span class='hs-layout'>)</span>
<a name="line-1323"></a>
<a name="line-1324"></a><a name="ApplicativeArgStmCtxPass"></a><span class='hs-keyword'>type</span> <span class='hs-keyword'>family</span> <span class='hs-conid'>ApplicativeArgStmCtxPass</span> <span class='hs-varid'>idL</span>
<a name="line-1325"></a>
<a name="line-1326"></a><span class='hs-comment'>{-
<a name="line-1327"></a>Note [The type of bind in Stmts]
<a name="line-1328"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1329"></a>Some Stmts, notably BindStmt, keep the (&gt;&gt;=) bind operator.
<a name="line-1330"></a>We do NOT assume that it has type
<a name="line-1331"></a>    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
<a name="line-1332"></a>In some cases (see #303, #1537) it might have a more
<a name="line-1333"></a>exotic type, such as
<a name="line-1334"></a>    (&gt;&gt;=) :: m i j a -&gt; (a -&gt; m j k b) -&gt; m i k b
<a name="line-1335"></a>So we must be careful not to make assumptions about the type.
<a name="line-1336"></a>In particular, the monad may not be uniform throughout.
<a name="line-1337"></a>
<a name="line-1338"></a>Note [TransStmt binder map]
<a name="line-1339"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1340"></a>The [(idR,idR)] in a TransStmt behaves as follows:
<a name="line-1341"></a>
<a name="line-1342"></a>  * Before renaming: []
<a name="line-1343"></a>
<a name="line-1344"></a>  * After renaming:
<a name="line-1345"></a>          [ (x27,x27), ..., (z35,z35) ]
<a name="line-1346"></a>    These are the variables
<a name="line-1347"></a>       bound by the stmts to the left of the 'group'
<a name="line-1348"></a>       and used either in the 'by' clause,
<a name="line-1349"></a>                or     in the stmts following the 'group'
<a name="line-1350"></a>    Each item is a pair of identical variables.
<a name="line-1351"></a>
<a name="line-1352"></a>  * After typechecking:
<a name="line-1353"></a>          [ (x27:Int, x27:[Int]), ..., (z35:Bool, z35:[Bool]) ]
<a name="line-1354"></a>    Each pair has the same unique, but different *types*.
<a name="line-1355"></a>
<a name="line-1356"></a>Note [BodyStmt]
<a name="line-1357"></a>~~~~~~~~~~~~~~~
<a name="line-1358"></a>BodyStmts are a bit tricky, because what they mean
<a name="line-1359"></a>depends on the context.  Consider the following contexts:
<a name="line-1360"></a>
<a name="line-1361"></a>        A do expression of type (m res_ty)
<a name="line-1362"></a>        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1363"></a>        * BodyStmt E any_ty:   do { ....; E; ... }
<a name="line-1364"></a>                E :: m any_ty
<a name="line-1365"></a>          Translation: E &gt;&gt; ...
<a name="line-1366"></a>
<a name="line-1367"></a>        A list comprehensions of type [elt_ty]
<a name="line-1368"></a>        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1369"></a>        * BodyStmt E Bool:   [ .. | .... E ]
<a name="line-1370"></a>                        [ .. | ..., E, ... ]
<a name="line-1371"></a>                        [ .. | .... | ..., E | ... ]
<a name="line-1372"></a>                E :: Bool
<a name="line-1373"></a>          Translation: if E then fail else ...
<a name="line-1374"></a>
<a name="line-1375"></a>        A guard list, guarding a RHS of type rhs_ty
<a name="line-1376"></a>        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1377"></a>        * BodyStmt E BooParStmtBlockl:   f x | ..., E, ... = ...rhs...
<a name="line-1378"></a>                E :: Bool
<a name="line-1379"></a>          Translation: if E then fail else ...
<a name="line-1380"></a>
<a name="line-1381"></a>        A monad comprehension of type (m res_ty)
<a name="line-1382"></a>        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1383"></a>        * BodyStmt E Bool:   [ .. | .... E ]
<a name="line-1384"></a>                E :: Bool
<a name="line-1385"></a>          Translation: guard E &gt;&gt; ...
<a name="line-1386"></a>
<a name="line-1387"></a>Array comprehensions are handled like list comprehensions.
<a name="line-1388"></a>
<a name="line-1389"></a>Note [How RecStmt works]
<a name="line-1390"></a>~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1391"></a>Example:
<a name="line-1392"></a>   HsDo [ BindStmt x ex
<a name="line-1393"></a>
<a name="line-1394"></a>        , RecStmt { recS_rec_ids   = [a, c]
<a name="line-1395"></a>                  , recS_stmts     = [ BindStmt b (return (a,c))
<a name="line-1396"></a>                                     , LetStmt a = ...b...
<a name="line-1397"></a>                                     , BindStmt c ec ]
<a name="line-1398"></a>                  , recS_later_ids = [a, b]
<a name="line-1399"></a>
<a name="line-1400"></a>        , return (a b) ]
<a name="line-1401"></a>
<a name="line-1402"></a>Here, the RecStmt binds a,b,c; but
<a name="line-1403"></a>  - Only a,b are used in the stmts *following* the RecStmt,
<a name="line-1404"></a>  - Only a,c are used in the stmts *inside* the RecStmt
<a name="line-1405"></a>        *before* their bindings
<a name="line-1406"></a>
<a name="line-1407"></a>Why do we need *both* rec_ids and later_ids?  For monads they could be
<a name="line-1408"></a>combined into a single set of variables, but not for arrows.  That
<a name="line-1409"></a>follows from the types of the respective feedback operators:
<a name="line-1410"></a>
<a name="line-1411"></a>        mfix :: MonadFix m =&gt; (a -&gt; m a) -&gt; m a
<a name="line-1412"></a>        loop :: ArrowLoop a =&gt; a (b,d) (c,d) -&gt; a b c
<a name="line-1413"></a>
<a name="line-1414"></a>* For mfix, the 'a' covers the union of the later_ids and the rec_ids
<a name="line-1415"></a>* For 'loop', 'c' is the later_ids and 'd' is the rec_ids
<a name="line-1416"></a>
<a name="line-1417"></a>Note [Typing a RecStmt]
<a name="line-1418"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1419"></a>A (RecStmt stmts) types as if you had written
<a name="line-1420"></a>
<a name="line-1421"></a>  (v1,..,vn, _, ..., _) &lt;- mfix (\~(_, ..., _, r1, ..., rm) -&gt;
<a name="line-1422"></a>                                 do { stmts
<a name="line-1423"></a>                                    ; return (v1,..vn, r1, ..., rm) })
<a name="line-1424"></a>
<a name="line-1425"></a>where v1..vn are the later_ids
<a name="line-1426"></a>      r1..rm are the rec_ids
<a name="line-1427"></a>
<a name="line-1428"></a>Note [Monad Comprehensions]
<a name="line-1429"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1430"></a>Monad comprehensions require separate functions like 'return' and
<a name="line-1431"></a>'&gt;&gt;=' for desugaring. These functions are stored in the statements
<a name="line-1432"></a>used in monad comprehensions. For example, the 'return' of the 'LastStmt'
<a name="line-1433"></a>expression is used to lift the body of the monad comprehension:
<a name="line-1434"></a>
<a name="line-1435"></a>  [ body | stmts ]
<a name="line-1436"></a>   =&gt;
<a name="line-1437"></a>  stmts &gt;&gt;= \bndrs -&gt; return body
<a name="line-1438"></a>
<a name="line-1439"></a>In transform and grouping statements ('then ..' and 'then group ..') the
<a name="line-1440"></a>'return' function is required for nested monad comprehensions, for example:
<a name="line-1441"></a>
<a name="line-1442"></a>  [ body | stmts, then f, rest ]
<a name="line-1443"></a>   =&gt;
<a name="line-1444"></a>  f [ env | stmts ] &gt;&gt;= \bndrs -&gt; [ body | rest ]
<a name="line-1445"></a>
<a name="line-1446"></a>BodyStmts require the 'Control.Monad.guard' function for boolean
<a name="line-1447"></a>expressions:
<a name="line-1448"></a>
<a name="line-1449"></a>  [ body | exp, stmts ]
<a name="line-1450"></a>   =&gt;
<a name="line-1451"></a>  guard exp &gt;&gt; [ body | stmts ]
<a name="line-1452"></a>
<a name="line-1453"></a>Parallel statements require the 'Control.Monad.Zip.mzip' function:
<a name="line-1454"></a>
<a name="line-1455"></a>  [ body | stmts1 | stmts2 | .. ]
<a name="line-1456"></a>   =&gt;
<a name="line-1457"></a>  mzip stmts1 (mzip stmts2 (..)) &gt;&gt;= \(bndrs1, (bndrs2, ..)) -&gt; return body
<a name="line-1458"></a>
<a name="line-1459"></a>In any other context than 'MonadComp', the fields for most of these
<a name="line-1460"></a>'SyntaxExpr's stay bottom.
<a name="line-1461"></a>
<a name="line-1462"></a>
<a name="line-1463"></a>Note [Applicative BodyStmt]
<a name="line-1464"></a>
<a name="line-1465"></a>(#12143) For the purposes of ApplicativeDo, we treat any BodyStmt
<a name="line-1466"></a>as if it was a BindStmt with a wildcard pattern.  For example,
<a name="line-1467"></a>
<a name="line-1468"></a>  do
<a name="line-1469"></a>    x &lt;- A
<a name="line-1470"></a>    B
<a name="line-1471"></a>    return x
<a name="line-1472"></a>
<a name="line-1473"></a>is transformed as if it were
<a name="line-1474"></a>
<a name="line-1475"></a>  do
<a name="line-1476"></a>    x &lt;- A
<a name="line-1477"></a>    _ &lt;- B
<a name="line-1478"></a>    return x
<a name="line-1479"></a>
<a name="line-1480"></a>so it transforms to
<a name="line-1481"></a>
<a name="line-1482"></a>  (\(x,_) -&gt; x) &lt;$&gt; A &lt;*&gt; B
<a name="line-1483"></a>
<a name="line-1484"></a>But we have to remember when we treat a BodyStmt like a BindStmt,
<a name="line-1485"></a>because in error messages we want to emit the original syntax the user
<a name="line-1486"></a>wrote, not our internal representation.  So ApplicativeArgOne has a
<a name="line-1487"></a>Bool flag that is True when the original statement was a BodyStmt, so
<a name="line-1488"></a>that we can pretty-print it correctly.
<a name="line-1489"></a>-}</span>
<a name="line-1490"></a>
<a name="line-1491"></a>
<a name="line-1492"></a><span class='hs-comment'>{-
<a name="line-1493"></a>************************************************************************
<a name="line-1494"></a>*                                                                      *
<a name="line-1495"></a>                Template Haskell quotation brackets
<a name="line-1496"></a>*                                                                      *
<a name="line-1497"></a>************************************************************************
<a name="line-1498"></a>-}</span>
<a name="line-1499"></a>
<a name="line-1500"></a><a name="HsSplice"></a><span class='hs-comment'>-- | Haskell Splice</span>
<a name="line-1501"></a><a name="HsSplice"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsSplice</span> <span class='hs-varid'>id</span>
<a name="line-1502"></a>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsTypedSplice</span>       <span class='hs-comment'>--  $$z  or $$(f 4)</span>
<a name="line-1503"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XTypedSplice</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1504"></a>        <span class='hs-conid'>SpliceDecoration</span> <span class='hs-comment'>-- Whether $$( ) variant found, for pretty printing</span>
<a name="line-1505"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- A unique name to identify this splice point</span>
<a name="line-1506"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- See Note [Pending Splices]</span>
<a name="line-1507"></a>
<a name="line-1508"></a>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsUntypedSplice</span>     <span class='hs-comment'>--  $z  or $(f 4)</span>
<a name="line-1509"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XUntypedSplice</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1510"></a>        <span class='hs-conid'>SpliceDecoration</span> <span class='hs-comment'>-- Whether $( ) variant found, for pretty printing</span>
<a name="line-1511"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- A unique name to identify this splice point</span>
<a name="line-1512"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>     <span class='hs-comment'>-- See Note [Pending Splices]</span>
<a name="line-1513"></a>
<a name="line-1514"></a>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsQuasiQuote</span>        <span class='hs-comment'>-- See Note [Quasi-quote overview] in GHC.Tc.Gen.Splice</span>
<a name="line-1515"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XQuasiQuote</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1516"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- Splice point</span>
<a name="line-1517"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>         <span class='hs-comment'>-- Quoter</span>
<a name="line-1518"></a>        <span class='hs-conid'>SrcSpan</span>          <span class='hs-comment'>-- The span of the enclosed string</span>
<a name="line-1519"></a>        <span class='hs-conid'>FastString</span>       <span class='hs-comment'>-- The enclosed string</span>
<a name="line-1520"></a>
<a name="line-1521"></a>   <span class='hs-comment'>-- AZ:TODO: use XSplice instead of HsSpliced</span>
<a name="line-1522"></a>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsSpliced</span>  <span class='hs-comment'>-- See Note [Delaying modFinalizers in untyped splices] in</span>
<a name="line-1523"></a>                <span class='hs-comment'>-- GHC.Rename.Splice.</span>
<a name="line-1524"></a>                <span class='hs-comment'>-- This is the result of splicing a splice. It is produced by</span>
<a name="line-1525"></a>                <span class='hs-comment'>-- the renamer and consumed by the typechecker. It lives only</span>
<a name="line-1526"></a>                <span class='hs-comment'>-- between the two.</span>
<a name="line-1527"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>XSpliced</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1528"></a>        <span class='hs-conid'>ThModFinalizers</span>     <span class='hs-comment'>-- TH finalizers produced by the splice.</span>
<a name="line-1529"></a>        <span class='hs-layout'>(</span><span class='hs-conid'>HsSplicedThing</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- The result of splicing</span>
<a name="line-1530"></a>   <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XSplice</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXSplice</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Note [Trees that Grow] extension point</span>
<a name="line-1531"></a>
<a name="line-1532"></a><a name="SpliceDecoration"></a><span class='hs-comment'>-- | A splice can appear with various decorations wrapped around it. This data</span>
<a name="line-1533"></a><a name="SpliceDecoration"></a><span class='hs-comment'>-- type captures explicitly how it was originally written, for use in the pretty</span>
<a name="line-1534"></a><a name="SpliceDecoration"></a><span class='hs-comment'>-- printer.</span>
<a name="line-1535"></a><a name="SpliceDecoration"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>SpliceDecoration</span>
<a name="line-1536"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>DollarSplice</span>  <span class='hs-comment'>-- ^ $splice or $$splice</span>
<a name="line-1537"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>BareSplice</span>    <span class='hs-comment'>-- ^ bare splice</span>
<a name="line-1538"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Data</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
<a name="line-1539"></a>
<a name="line-1540"></a><a name="instance%20Outputable%20SpliceDecoration"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Outputable</span> <span class='hs-conid'>SpliceDecoration</span> <span class='hs-keyword'>where</span>
<a name="line-1541"></a>  <span class='hs-varid'>ppr</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-varop'>$</span> <span class='hs-varid'>show</span> <span class='hs-varid'>x</span>
<a name="line-1542"></a>
<a name="line-1543"></a>
<a name="line-1544"></a><a name="isTypedSplice"></a><span class='hs-definition'>isTypedSplice</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsSplice</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1545"></a><span class='hs-definition'>isTypedSplice</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsTypedSplice</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1546"></a><span class='hs-definition'>isTypedSplice</span> <span class='hs-keyword'>_</span>                  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>   <span class='hs-comment'>-- Quasi-quotes are untyped splices</span>
<a name="line-1547"></a>
<a name="line-1548"></a><a name="ThModFinalizers"></a><span class='hs-comment'>-- | Finalizers produced by a splice with</span>
<a name="line-1549"></a><a name="ThModFinalizers"></a><span class='hs-comment'>-- 'Language.Haskell.TH.Syntax.addModFinalizer'</span>
<a name="line-1550"></a><a name="ThModFinalizers"></a><span class='hs-comment'>--</span>
<a name="line-1551"></a><a name="ThModFinalizers"></a><span class='hs-comment'>-- See Note [Delaying modFinalizers in untyped splices] in GHC.Rename.Splice. For how</span>
<a name="line-1552"></a><a name="ThModFinalizers"></a><span class='hs-comment'>-- this is used.</span>
<a name="line-1553"></a><a name="ThModFinalizers"></a><span class='hs-comment'>--</span>
<a name="line-1554"></a><a name="ThModFinalizers"></a><span class='hs-keyword'>newtype</span> <span class='hs-conid'>ThModFinalizers</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ThModFinalizers</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>ForeignRef</span> <span class='hs-layout'>(</span><span class='hs-conid'>TH.Q</span> <span class='hs-conid'>()</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-1555"></a>
<a name="line-1556"></a><a name="instance%20Data%20ThModFinalizers"></a><span class='hs-comment'>-- A Data instance which ignores the argument of 'ThModFinalizers'.</span>
<a name="line-1557"></a><a name="instance%20Data%20ThModFinalizers"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Data</span> <span class='hs-conid'>ThModFinalizers</span> <span class='hs-keyword'>where</span>
<a name="line-1558"></a>  <span class='hs-varid'>gunfold</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>z</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>z</span> <span class='hs-varop'>$</span> <span class='hs-conid'>ThModFinalizers</span> <span class='hs-conid'>[]</span>
<a name="line-1559"></a>  <span class='hs-varid'>toConstr</span>  <span class='hs-varid'>a</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkConstr</span> <span class='hs-layout'>(</span><span class='hs-varid'>dataTypeOf</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-str'>"ThModFinalizers"</span> <span class='hs-conid'>[]</span> <span class='hs-conid'>Data.Prefix</span>
<a name="line-1560"></a>  <span class='hs-varid'>dataTypeOf</span> <span class='hs-varid'>a</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkDataType</span> <span class='hs-str'>"HsExpr.ThModFinalizers"</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>toConstr</span> <span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-1561"></a>
<a name="line-1562"></a><a name="HsSplicedThing"></a><span class='hs-comment'>-- | Haskell Spliced Thing</span>
<a name="line-1563"></a><a name="HsSplicedThing"></a><span class='hs-comment'>--</span>
<a name="line-1564"></a><a name="HsSplicedThing"></a><span class='hs-comment'>-- Values that can result from running a splice.</span>
<a name="line-1565"></a><a name="HsSplicedThing"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsSplicedThing</span> <span class='hs-varid'>id</span>
<a name="line-1566"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>HsSplicedExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ Haskell Spliced Expression</span>
<a name="line-1567"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsSplicedTy</span>   <span class='hs-layout'>(</span><span class='hs-conid'>HsType</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- ^ Haskell Spliced Type</span>
<a name="line-1568"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-conid'>HsSplicedPat</span>  <span class='hs-layout'>(</span><span class='hs-conid'>Pat</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ^ Haskell Spliced Pattern</span>
<a name="line-1569"></a>
<a name="line-1570"></a>
<a name="line-1571"></a><a name="SplicePointName"></a><span class='hs-comment'>-- See Note [Pending Splices]</span>
<a name="line-1572"></a><a name="SplicePointName"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>SplicePointName</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Name</span>
<a name="line-1573"></a>
<a name="line-1574"></a><a name="UntypedSpliceFlavour"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>UntypedSpliceFlavour</span>
<a name="line-1575"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>UntypedExpSplice</span>
<a name="line-1576"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UntypedPatSplice</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UntypedTypeSplice</span>
<a name="line-1578"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>UntypedDeclSplice</span>
<a name="line-1579"></a>  <span class='hs-keyword'>deriving</span> <span class='hs-conid'>Data</span>
<a name="line-1580"></a>
<a name="line-1581"></a><a name="HsBracket"></a><span class='hs-comment'>-- | Haskell Bracket</span>
<a name="line-1582"></a><a name="HsBracket"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsBracket</span> <span class='hs-varid'>p</span>
<a name="line-1583"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ExpBr</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XExpBr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- [|  expr  |]</span>
<a name="line-1584"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PatBr</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XPatBr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>LPat</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- [p| pat   |]</span>
<a name="line-1585"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DecBrL</span> <span class='hs-layout'>(</span><span class='hs-conid'>XDecBrL</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>[</span><span class='hs-conid'>LHsDecl</span> <span class='hs-varid'>p</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- [d| decls |]; result of parser</span>
<a name="line-1586"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DecBrG</span> <span class='hs-layout'>(</span><span class='hs-conid'>XDecBrG</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-layout'>(</span><span class='hs-conid'>HsGroup</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- [d| decls |]; result of renamer</span>
<a name="line-1587"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TypBr</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XTypBr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-layout'>(</span><span class='hs-conid'>LHsType</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- [t| type  |]</span>
<a name="line-1588"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>VarBr</span>  <span class='hs-layout'>(</span><span class='hs-conid'>XVarBr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>   <span class='hs-conid'>Bool</span> <span class='hs-layout'>(</span><span class='hs-conid'>LIdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1589"></a>                                <span class='hs-comment'>-- True: 'x, False: ''T</span>
<a name="line-1590"></a>                                <span class='hs-comment'>-- (The Bool flag is used only in pprHsBracket)</span>
<a name="line-1591"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TExpBr</span> <span class='hs-layout'>(</span><span class='hs-conid'>XTExpBr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- [||  expr  ||]</span>
<a name="line-1592"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>XBracket</span> <span class='hs-varop'>!</span><span class='hs-layout'>(</span><span class='hs-conid'>XXBracket</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>           <span class='hs-comment'>-- Note [Trees that Grow] extension point</span>
<a name="line-1593"></a>
<a name="line-1594"></a><a name="isTypedBracket"></a><span class='hs-definition'>isTypedBracket</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsBracket</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1595"></a><span class='hs-definition'>isTypedBracket</span> <span class='hs-layout'>(</span><span class='hs-conid'>TExpBr</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1596"></a><span class='hs-definition'>isTypedBracket</span> <span class='hs-keyword'>_</span>           <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1597"></a>
<a name="line-1598"></a><span class='hs-comment'>{-
<a name="line-1599"></a>************************************************************************
<a name="line-1600"></a>*                                                                      *
<a name="line-1601"></a>\subsection{Enumerations and list comprehensions}
<a name="line-1602"></a>*                                                                      *
<a name="line-1603"></a>************************************************************************
<a name="line-1604"></a>-}</span>
<a name="line-1605"></a>
<a name="line-1606"></a><a name="ArithSeqInfo"></a><span class='hs-comment'>-- | Arithmetic Sequence Information</span>
<a name="line-1607"></a><a name="ArithSeqInfo"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ArithSeqInfo</span> <span class='hs-varid'>id</span>
<a name="line-1608"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>From</span>            <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1609"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FromThen</span>        <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1610"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1611"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FromTo</span>          <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1612"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1613"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FromThenTo</span>      <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1614"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1615"></a>                    <span class='hs-layout'>(</span><span class='hs-conid'>LHsExpr</span> <span class='hs-varid'>id</span><span class='hs-layout'>)</span>
<a name="line-1616"></a><span class='hs-comment'>-- AZ: Should ArithSeqInfo have a TTG extension?</span>
<a name="line-1617"></a>
<a name="line-1618"></a><span class='hs-comment'>{-
<a name="line-1619"></a>************************************************************************
<a name="line-1620"></a>*                                                                      *
<a name="line-1621"></a>\subsection{HsMatchCtxt}
<a name="line-1622"></a>*                                                                      *
<a name="line-1623"></a>************************************************************************
<a name="line-1624"></a>-}</span>
<a name="line-1625"></a>
<a name="line-1626"></a><a name="HsMatchContext"></a><span class='hs-comment'>-- | Haskell Match Context</span>
<a name="line-1627"></a><a name="HsMatchContext"></a><span class='hs-comment'>--</span>
<a name="line-1628"></a><a name="HsMatchContext"></a><span class='hs-comment'>-- Context of a pattern match. This is more subtle than it would seem. See Note</span>
<a name="line-1629"></a><a name="HsMatchContext"></a><span class='hs-comment'>-- [Varieties of pattern matches].</span>
<a name="line-1630"></a><a name="HsMatchContext"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsMatchContext</span> <span class='hs-varid'>p</span>
<a name="line-1631"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FunRhs</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mc_fun</span>        <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LIdP</span> <span class='hs-varid'>p</span>    <span class='hs-comment'>-- ^ function binder of @f@</span>
<a name="line-1632"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>mc_fixity</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>LexicalFixity</span> <span class='hs-comment'>-- ^ fixing of @f@</span>
<a name="line-1633"></a>           <span class='hs-layout'>,</span> <span class='hs-varid'>mc_strictness</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>SrcStrictness</span> <span class='hs-comment'>-- ^ was @f@ banged?</span>
<a name="line-1634"></a>                                            <span class='hs-comment'>-- See Note [FunBind vs PatBind]</span>
<a name="line-1635"></a>           <span class='hs-layout'>}</span>
<a name="line-1636"></a>                                <span class='hs-comment'>-- ^A pattern matching on an argument of a</span>
<a name="line-1637"></a>                                <span class='hs-comment'>-- function binding</span>
<a name="line-1638"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LambdaExpr</span>                  <span class='hs-comment'>-- ^Patterns of a lambda</span>
<a name="line-1639"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CaseAlt</span>                     <span class='hs-comment'>-- ^Patterns and guards on a case alternative</span>
<a name="line-1640"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>IfAlt</span>                       <span class='hs-comment'>-- ^Guards of a multi-way if alternative</span>
<a name="line-1641"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ArrowMatchCtxt</span>              <span class='hs-comment'>-- ^A pattern match inside arrow notation</span>
<a name="line-1642"></a>      <span class='hs-conid'>HsArrowMatchContext</span>
<a name="line-1643"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PatBindRhs</span>                  <span class='hs-comment'>-- ^A pattern binding  eg [y] &lt;- e = e</span>
<a name="line-1644"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PatBindGuards</span>               <span class='hs-comment'>-- ^Guards of pattern bindings, e.g.,</span>
<a name="line-1645"></a>                                <span class='hs-comment'>--    (Just b) | Just _ &lt;- x = e</span>
<a name="line-1646"></a>                                <span class='hs-comment'>--             | otherwise   = e'</span>
<a name="line-1647"></a>
<a name="line-1648"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>RecUpd</span>                      <span class='hs-comment'>-- ^Record update [used only in GHC.HsToCore.Expr to</span>
<a name="line-1649"></a>                                <span class='hs-comment'>--    tell matchWrapper what sort of</span>
<a name="line-1650"></a>                                <span class='hs-comment'>--    runtime error message to generate]</span>
<a name="line-1651"></a>
<a name="line-1652"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>StmtCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^Pattern of a do-stmt, list comprehension,</span>
<a name="line-1653"></a>                                <span class='hs-comment'>-- pattern guard, etc</span>
<a name="line-1654"></a>
<a name="line-1655"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ThPatSplice</span>            <span class='hs-comment'>-- ^A Template Haskell pattern splice</span>
<a name="line-1656"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ThPatQuote</span>             <span class='hs-comment'>-- ^A Template Haskell pattern quotation [p| (a,b) |]</span>
<a name="line-1657"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PatSyn</span>                 <span class='hs-comment'>-- ^A pattern synonym declaration</span>
<a name="line-1658"></a>
<a name="line-1659"></a><a name="isPatSynCtxt"></a><span class='hs-definition'>isPatSynCtxt</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsMatchContext</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1660"></a><span class='hs-definition'>isPatSynCtxt</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span>
<a name="line-1661"></a>  <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1662"></a>    <span class='hs-conid'>PatSyn</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1663"></a>    <span class='hs-keyword'>_</span>      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1664"></a>
<a name="line-1665"></a><a name="HsStmtContext"></a><span class='hs-comment'>-- | Haskell Statement Context.</span>
<a name="line-1666"></a><a name="HsStmtContext"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>p</span>
<a name="line-1667"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ListComp</span>
<a name="line-1668"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MonadComp</span>
<a name="line-1669"></a>
<a name="line-1670"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>DoExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>ModuleName</span><span class='hs-layout'>)</span>        <span class='hs-comment'>-- ^[ModuleName.]do { ... }</span>
<a name="line-1671"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>MDoExpr</span> <span class='hs-layout'>(</span><span class='hs-conid'>Maybe</span> <span class='hs-conid'>ModuleName</span><span class='hs-layout'>)</span>       <span class='hs-comment'>-- ^[ModuleName.]mdo { ... }  ie recursive do-expression</span>
<a name="line-1672"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ArrowExpr</span>                        <span class='hs-comment'>-- ^do-notation in an arrow-command context</span>
<a name="line-1673"></a>
<a name="line-1674"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>GhciStmtCtxt</span>                     <span class='hs-comment'>-- ^A command-line Stmt in GHCi pat &lt;- rhs</span>
<a name="line-1675"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>PatGuard</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsMatchContext</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>      <span class='hs-comment'>-- ^Pattern guard for specified thing</span>
<a name="line-1676"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ParStmtCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ^A branch of a parallel stmt</span>
<a name="line-1677"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>TransStmtCtxt</span> <span class='hs-layout'>(</span><span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^A branch of a transform stmt</span>
<a name="line-1678"></a>
<a name="line-1679"></a><a name="HsArrowMatchContext"></a><span class='hs-comment'>-- | Haskell arrow match context.</span>
<a name="line-1680"></a><a name="HsArrowMatchContext"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>HsArrowMatchContext</span>
<a name="line-1681"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProcExpr</span>     <span class='hs-comment'>-- ^ A proc expression</span>
<a name="line-1682"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>ArrowCaseAlt</span> <span class='hs-comment'>-- ^ A case alternative inside arrow notation</span>
<a name="line-1683"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>KappaExpr</span>    <span class='hs-comment'>-- ^ An arrow kappa abstraction</span>
<a name="line-1684"></a>
<a name="line-1685"></a><a name="qualifiedDoModuleName_maybe"></a><span class='hs-definition'>qualifiedDoModuleName_maybe</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>ModuleName</span>
<a name="line-1686"></a><span class='hs-definition'>qualifiedDoModuleName_maybe</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1687"></a>  <span class='hs-conid'>DoExpr</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span>
<a name="line-1688"></a>  <span class='hs-conid'>MDoExpr</span> <span class='hs-varid'>m</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>m</span>
<a name="line-1689"></a>  <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Nothing</span>
<a name="line-1690"></a>
<a name="line-1691"></a><a name="isComprehensionContext"></a><span class='hs-definition'>isComprehensionContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1692"></a><span class='hs-comment'>-- Uses comprehension syntax [ e | quals ]</span>
<a name="line-1693"></a><span class='hs-definition'>isComprehensionContext</span> <span class='hs-conid'>ListComp</span>          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1694"></a><span class='hs-definition'>isComprehensionContext</span> <span class='hs-conid'>MonadComp</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1695"></a><span class='hs-definition'>isComprehensionContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>ParStmtCtxt</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isComprehensionContext</span> <span class='hs-varid'>c</span>
<a name="line-1696"></a><span class='hs-definition'>isComprehensionContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>TransStmtCtxt</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isComprehensionContext</span> <span class='hs-varid'>c</span>
<a name="line-1697"></a><span class='hs-definition'>isComprehensionContext</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1698"></a>
<a name="line-1699"></a><a name="isMonadStmtContext"></a><span class='hs-comment'>-- | Is this a monadic context?</span>
<a name="line-1700"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1701"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-conid'>MonadComp</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1702"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-conid'>DoExpr</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>             <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1703"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-conid'>MDoExpr</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span>            <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1704"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-conid'>GhciStmtCtxt</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1705"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>ParStmtCtxt</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isMonadStmtContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-1706"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>TransStmtCtxt</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isMonadStmtContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-1707"></a><span class='hs-definition'>isMonadStmtContext</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span> <span class='hs-comment'>-- ListComp, PatGuard, ArrowExpr</span>
<a name="line-1708"></a>
<a name="line-1709"></a><a name="isMonadCompContext"></a><span class='hs-definition'>isMonadCompContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>id</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1710"></a><span class='hs-definition'>isMonadCompContext</span> <span class='hs-conid'>MonadComp</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1711"></a><span class='hs-definition'>isMonadCompContext</span> <span class='hs-keyword'>_</span>         <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1712"></a>
<a name="line-1713"></a><a name="matchSeparator"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsMatchContext</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1714"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunRhs</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"="</span>
<a name="line-1715"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>CaseAlt</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"-&gt;"</span>
<a name="line-1716"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>IfAlt</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"-&gt;"</span>
<a name="line-1717"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>LambdaExpr</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"-&gt;"</span>
<a name="line-1718"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArrowMatchCtxt</span><span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"-&gt;"</span>
<a name="line-1719"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>PatBindRhs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"="</span>
<a name="line-1720"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>PatBindGuards</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"="</span>
<a name="line-1721"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-layout'>(</span><span class='hs-conid'>StmtCtxt</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"&lt;-"</span>
<a name="line-1722"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>RecUpd</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"="</span> <span class='hs-comment'>-- This can be printed by the pattern</span>
<a name="line-1723"></a>                                       <span class='hs-comment'>-- match checker trace</span>
<a name="line-1724"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>ThPatSplice</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"unused"</span>
<a name="line-1725"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>ThPatQuote</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"unused"</span>
<a name="line-1726"></a><span class='hs-definition'>matchSeparator</span> <span class='hs-conid'>PatSyn</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"unused"</span>
<a name="line-1727"></a>
<a name="line-1728"></a><a name="pprMatchContext"></a><span class='hs-definition'>pprMatchContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnXRec</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1729"></a>                <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HsMatchContext</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1730"></a><span class='hs-definition'>pprMatchContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-1731"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>want_an</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"an"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprMatchContextNoun</span> <span class='hs-varid'>ctxt</span>
<a name="line-1732"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"a"</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprMatchContextNoun</span> <span class='hs-varid'>ctxt</span>
<a name="line-1733"></a>  <span class='hs-keyword'>where</span>
<a name="line-1734"></a>    <span class='hs-varid'>want_an</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunRhs</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>  <span class='hs-comment'>-- Use "an" in front</span>
<a name="line-1735"></a>    <span class='hs-varid'>want_an</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArrowMatchCtxt</span> <span class='hs-conid'>ProcExpr</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1736"></a>    <span class='hs-varid'>want_an</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArrowMatchCtxt</span> <span class='hs-conid'>KappaExpr</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1737"></a>    <span class='hs-varid'>want_an</span> <span class='hs-keyword'>_</span>                          <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1738"></a>
<a name="line-1739"></a><a name="pprMatchContextNoun"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyword'>forall</span> <span class='hs-varid'>p</span><span class='hs-varop'>.</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnXRec</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1740"></a>                    <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HsMatchContext</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1741"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunRhs</span> <span class='hs-layout'>{</span><span class='hs-varid'>mc_fun</span><span class='hs-keyglyph'>=</span><span class='hs-varid'>fun</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1742"></a>                                    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"equation for"</span>
<a name="line-1743"></a>                                      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>quotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>unXRec</span> <span class='hs-keyglyph'>@</span><span class='hs-varid'>p</span> <span class='hs-varid'>fun</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1744"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>CaseAlt</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"case alternative"</span>
<a name="line-1745"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>IfAlt</span>           <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"multi-way if alternative"</span>
<a name="line-1746"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>RecUpd</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"record-update construct"</span>
<a name="line-1747"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>ThPatSplice</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Template Haskell pattern splice"</span>
<a name="line-1748"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>ThPatQuote</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Template Haskell pattern quotation"</span>
<a name="line-1749"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>PatBindRhs</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pattern binding"</span>
<a name="line-1750"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>PatBindGuards</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pattern binding guards"</span>
<a name="line-1751"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>LambdaExpr</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"lambda abstraction"</span>
<a name="line-1752"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-layout'>(</span><span class='hs-conid'>ArrowMatchCtxt</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprArrowMatchContextNoun</span> <span class='hs-varid'>c</span>
<a name="line-1753"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-layout'>(</span><span class='hs-conid'>StmtCtxt</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pattern binding in"</span>
<a name="line-1754"></a>                                      <span class='hs-varop'>$$</span> <span class='hs-varid'>pprAStmtContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-1755"></a><span class='hs-definition'>pprMatchContextNoun</span> <span class='hs-conid'>PatSyn</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pattern synonym declaration"</span>
<a name="line-1756"></a>
<a name="line-1757"></a><a name="pprArrowMatchContextNoun"></a><span class='hs-definition'>pprArrowMatchContextNoun</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>HsArrowMatchContext</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1758"></a><span class='hs-definition'>pprArrowMatchContextNoun</span> <span class='hs-conid'>ProcExpr</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"arrow proc pattern"</span>
<a name="line-1759"></a><span class='hs-definition'>pprArrowMatchContextNoun</span> <span class='hs-conid'>ArrowCaseAlt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"case alternative within arrow notation"</span>
<a name="line-1760"></a><span class='hs-definition'>pprArrowMatchContextNoun</span> <span class='hs-conid'>KappaExpr</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"arrow kappa abstraction"</span>
<a name="line-1761"></a>
<a name="line-1762"></a><a name="pprAStmtContext"></a><span class='hs-comment'>-----------------</span>
<a name="line-1763"></a><span class='hs-definition'>pprAStmtContext</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprStmtContext</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Outputable</span> <span class='hs-layout'>(</span><span class='hs-conid'>IdP</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>UnXRec</span> <span class='hs-varid'>p</span><span class='hs-layout'>)</span>
<a name="line-1764"></a>                                <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>HsStmtContext</span> <span class='hs-varid'>p</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1765"></a><span class='hs-definition'>pprAStmtContext</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>article</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprStmtContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-1766"></a>  <span class='hs-keyword'>where</span>
<a name="line-1767"></a>    <span class='hs-varid'>pp_an</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"an"</span>
<a name="line-1768"></a>    <span class='hs-varid'>pp_a</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"a"</span>
<a name="line-1769"></a>    <span class='hs-varid'>article</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>ctxt</span> <span class='hs-keyword'>of</span>
<a name="line-1770"></a>                  <span class='hs-conid'>MDoExpr</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pp_an</span>
<a name="line-1771"></a>                  <span class='hs-conid'>GhciStmtCtxt</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pp_an</span>
<a name="line-1772"></a>                  <span class='hs-keyword'>_</span>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>pp_a</span>
<a name="line-1773"></a>
<a name="line-1774"></a>
<a name="line-1775"></a><a name="pprStmtContext"></a><span class='hs-comment'>-----------------</span>
<a name="line-1776"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-conid'>GhciStmtCtxt</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"interactive GHCi command"</span>
<a name="line-1777"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>DoExpr</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prependQualified</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"'do' block"</span><span class='hs-layout'>)</span>
<a name="line-1778"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>MDoExpr</span> <span class='hs-varid'>m</span><span class='hs-layout'>)</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>prependQualified</span> <span class='hs-varid'>m</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"'mdo' block"</span><span class='hs-layout'>)</span>
<a name="line-1779"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-conid'>ArrowExpr</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"'do' block in an arrow command"</span>
<a name="line-1780"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-conid'>ListComp</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"list comprehension"</span>
<a name="line-1781"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-conid'>MonadComp</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"monad comprehension"</span>
<a name="line-1782"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>PatGuard</span> <span class='hs-varid'>ctxt</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"pattern guard for"</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>pprMatchContext</span> <span class='hs-varid'>ctxt</span>
<a name="line-1783"></a>
<a name="line-1784"></a><span class='hs-comment'>-- Drop the inner contexts when reporting errors, else we get</span>
<a name="line-1785"></a><span class='hs-comment'>--     Unexpected transform statement</span>
<a name="line-1786"></a><span class='hs-comment'>--     in a transformed branch of</span>
<a name="line-1787"></a><span class='hs-comment'>--          transformed branch of</span>
<a name="line-1788"></a><span class='hs-comment'>--          transformed branch of monad comprehension</span>
<a name="line-1789"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>ParStmtCtxt</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1790"></a>  <span class='hs-varid'>ifPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"parallel branch of"</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprAStmtContext</span> <span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1791"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>pprStmtContext</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-1792"></a><span class='hs-definition'>pprStmtContext</span> <span class='hs-layout'>(</span><span class='hs-conid'>TransStmtCtxt</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span>
<a name="line-1793"></a>  <span class='hs-varid'>ifPprDebug</span> <span class='hs-layout'>(</span><span class='hs-varid'>sep</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>text</span> <span class='hs-str'>"transformed branch of"</span><span class='hs-layout'>,</span> <span class='hs-varid'>pprAStmtContext</span> <span class='hs-varid'>c</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1794"></a>             <span class='hs-layout'>(</span><span class='hs-varid'>pprStmtContext</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-1795"></a>
<a name="line-1796"></a><a name="prependQualified"></a><span class='hs-definition'>prependQualified</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>ModuleName</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>SDoc</span>
<a name="line-1797"></a><span class='hs-definition'>prependQualified</span> <span class='hs-conid'>Nothing</span>  <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>t</span>
<a name="line-1798"></a><span class='hs-definition'>prependQualified</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-varid'>t</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>text</span> <span class='hs-str'>"qualified"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>t</span>
</pre></body>
</html>
