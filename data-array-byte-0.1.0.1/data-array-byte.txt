-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compatibility layer for Data.Array.Byte
--   
--   Compatibility layer for <a>Data.Array.Byte</a>, providing boxed
--   wrappers for <tt>ByteArray#</tt> and <tt>MutableByteArray#</tt> and
--   relevant instances for GHC &lt; 9.4. Include it into your Cabal file:
--   
--   <pre>
--   build-depends: base
--   if impl(ghc &lt; 9.4)
--     build-depends: data-array-byte
--   </pre>
--   
--   and then <tt>import Data.Array.Byte</tt> unconditionally.
@package data-array-byte
@version 0.1.0.1


-- | Compatibility layer for <a>Data.Array.Byte</a>, providing boxed
--   wrappers for <a>ByteArray#</a> and <a>MutableByteArray#</a> and
--   relevant instances for GHC &lt; 9.4. Include it into your Cabal file:
--   
--   <pre>
--   build-depends: base
--   if impl(ghc &lt; 9.4)
--     build-depends: data-array-byte
--   </pre>
--   
--   and then import <a>Data.Array.Byte</a> unconditionally.
--   
--   Originally derived from <tt>primitive</tt> package.
module Data.Array.Byte

-- | Boxed wrapper for <a>ByteArray#</a>.
--   
--   Since <a>ByteArray#</a> is an unlifted type and not a member of kind
--   <a>Type</a>, things like <tt>[ByteArray#]</tt> or <tt>IO
--   ByteArray#</tt> are ill-typed. To work around this inconvenience this
--   module provides a standard boxed wrapper, inhabiting <a>Type</a>.
--   Clients are expected to use <a>ByteArray</a> in higher-level APIs, but
--   wrap and unwrap <a>ByteArray</a> internally as they please and use
--   functions from <a>GHC.Exts</a>.
data ByteArray
ByteArray :: ByteArray# -> ByteArray

-- | Boxed wrapper for <a>MutableByteArray#</a>.
--   
--   Since <a>MutableByteArray#</a> is an unlifted type and not a member of
--   kind <a>Type</a>, things like <tt>[MutableByteArray#]</tt> or <tt>IO
--   MutableByteArray#</tt> are ill-typed. To work around this
--   inconvenience this module provides a standard boxed wrapper,
--   inhabiting <a>Type</a>. Clients are expected to use
--   <a>MutableByteArray</a> in higher-level APIs, but wrap and unwrap
--   <a>MutableByteArray</a> internally as they please and use functions
--   from <a>GHC.Exts</a>.
data MutableByteArray s
MutableByteArray :: MutableByteArray# s -> MutableByteArray s
instance Data.Typeable.Internal.Typeable s => Data.Data.Data (Data.Array.Byte.MutableByteArray s)
instance GHC.Classes.Eq (Data.Array.Byte.MutableByteArray s)
instance Control.DeepSeq.NFData (Data.Array.Byte.MutableByteArray s)
instance Data.Data.Data Data.Array.Byte.ByteArray
instance GHC.Show.Show Data.Array.Byte.ByteArray
instance GHC.Classes.Eq Data.Array.Byte.ByteArray
instance GHC.Classes.Ord Data.Array.Byte.ByteArray
instance GHC.Base.Semigroup Data.Array.Byte.ByteArray
instance GHC.Base.Monoid Data.Array.Byte.ByteArray
instance GHC.Exts.IsList Data.Array.Byte.ByteArray
instance Control.DeepSeq.NFData Data.Array.Byte.ByteArray
instance Language.Haskell.TH.Syntax.Lift Data.Array.Byte.ByteArray
