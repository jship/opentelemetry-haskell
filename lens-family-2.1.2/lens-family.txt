-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lens Families
--   
--   This package provides first class functional references in Van
--   Laarhoven style supporting the following optics:
--   
--   <ul>
--   <li>Lenses (view, over)</li>
--   <li>Traversals (toListOf, matching, over)</li>
--   <li>Setters (over)</li>
--   <li>Grates (zipWithOf, under, review)</li>
--   <li>Resetters (under)</li>
--   <li>Adapters (view, review)</li>
--   <li>Grids (toListOf, over / under, review)</li>
--   <li>Prisms (matching, over / under, review)</li>
--   <li>Getters (view)</li>
--   <li>Folders (toListOf)</li>
--   <li>Reviewers (review)</li>
--   </ul>
@package lens-family
@version 2.1.2


-- | <i>Caution</i>: Improper use of this module can lead to unexpected
--   behaviour if the preconditions of the functions are not met.
module Lens.Family2.Unchecked

-- | Build an adapter from an isomorphism family.
--   
--   <i>Caution</i>: In order for the generated adapter family to be
--   well-defined, you must ensure that the two isomorphism laws hold:
--   
--   <ul>
--   <li><pre>yin . yang === id</pre></li>
--   <li><pre>yang . yin === id</pre></li>
--   </ul>
adapter :: (s -> a) -> (b -> t) -> Adapter s t a b

-- | Build a lens from a <tt>getter</tt> and <tt>setter</tt> family.
--   
--   <i>Caution</i>: In order for the generated lens family to be
--   well-defined, you must ensure that the three lens laws hold:
--   
--   <ul>
--   <li><pre>getter (setter s a) === a</pre></li>
--   <li><pre>setter s (getter s) === s</pre></li>
--   <li><pre>setter (setter s a1) a2 === setter s a2</pre></li>
--   </ul>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Build a prism from a <tt>matcher</tt> and <tt>reviewer</tt> family.
--   
--   <i>Caution</i>: In order for the generated prism family to be
--   well-defined, you must ensure that the three prism laws hold:
--   
--   <ul>
--   <li><pre>matcher (reviewer b) === Right b</pre></li>
--   <li><pre>(id ||| reviewer) (matcher s) === s</pre></li>
--   <li><pre>left matcher (matcher s) === left Left (matcher s)</pre></li>
--   </ul>
prism :: (s -> Either t a) -> (b -> t) -> Prism s t a b

-- | Build a grate from a <tt>grater</tt> family.
--   
--   <i>Caution</i>: In order for the generated grate family to be
--   well-defined, you must ensure that the two grater laws hold:
--   
--   <ul>
--   <li><pre>grater ($ s) === s</pre></li>
--   <li><pre>grater (k -&gt; h (k . grater)) === grater (k -&gt; h ($
--   k))</pre></li>
--   </ul>
--   
--   Note: The grater laws are that of an algebra for the parameterised
--   continuation monad, <a>PCont</a>.
grate :: (((s -> a) -> b) -> t) -> Grate s t a b

-- | <a>setting</a> promotes a "semantic editor combinator" to a
--   modify-only lens. To demote a lens to a semantic edit combinator, use
--   the section <tt>(l %~)</tt> or <tt>over l</tt> from
--   <a>Lens.Family2</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [("The",0),("quick",1),("brown",1),("fox",2)] &amp; setting map . fstL %~ length
--   [(3,0),(5,1),(5,1),(3,2)]
--   </pre>
--   
--   <i>Caution</i>: In order for the generated family to be well-defined,
--   you must ensure that the two functors laws hold:
--   
--   <ul>
--   <li><pre>sec id === id</pre></li>
--   <li><pre>sec f . sec g === sec (f . g)</pre></li>
--   </ul>
setting :: ((a -> b) -> s -> t) -> Setter s t a b

-- | <a>resetting</a> promotes a "semantic editor combinator" to a form of
--   grate that can only lift unary functions. To demote a grate to a
--   semantic edit combinator, use <tt>under l</tt> from
--   <a>Lens.Family2</a>.
--   
--   <i>Caution</i>: In order for the generated family to be well-defined,
--   you must ensure that the two functors laws hold:
--   
--   <ul>
--   <li><pre>sec id === id</pre></li>
--   <li><pre>sec f . sec g === sec (f . g)</pre></li>
--   </ul>
resetting :: ((a -> b) -> s -> t) -> Resetter s t a b
type Adapter s t a b = forall f g. (Functor f, Functor g) => AdapterLike f g s t a b
type Adapter' s a = forall f g. (Functor f, Functor g) => AdapterLike' f g s a
type Prism s t a b = forall f g. (Applicative f, Traversable g) => AdapterLike f g s t a b
type Prism' s a = forall f g. (Applicative f, Traversable g) => AdapterLike' f g s a
type Lens s t a b = forall f. Functor f => LensLike f s t a b
type Lens' s a = forall f. Functor f => LensLike' f s a
type Traversal s t a b = forall f. Applicative f => LensLike f s t a b
type Traversal' s a = forall f. Applicative f => LensLike' f s a
type Setter s t a b = forall f. Identical f => LensLike f s t a b
type Setter' s a = forall f. Identical f => LensLike' f s a
type Grate s t a b = forall g. Functor g => GrateLike g s t a b
type Grate' s a = forall g. Functor g => GrateLike' g s a
type Resetter s t a b = forall g. Identical g => GrateLike g s t a b
type Resetter' s a = forall g. Identical g => GrateLike' g s a
type AdapterLike (f :: Type -> Type) (g :: Type -> Type) s t a b = g a -> f b -> g s -> f t
type AdapterLike' (f :: Type -> Type) (g :: Type -> Type) s a = g a -> f a -> g s -> f s
type LensLike (f :: Type -> Type) s t a b = a -> f b -> s -> f t
type LensLike' (f :: Type -> Type) s a = a -> f a -> s -> f s
type GrateLike (g :: Type -> Type) s t a b = g a -> b -> g s -> t
type GrateLike' (g :: Type -> Type) s a = g a -> a -> g s -> s
class (Traversable f, Applicative f) => Identical (f :: Type -> Type)


-- | This is the main module for end-users of lens-families. If you are not
--   building your own optics such as lenses, traversals, grates, etc., but
--   just using optics made by others, this is the only module you need.
module Lens.Family2

-- | <a>to</a> promotes a projection function to a read-only lens called a
--   getter. To demote a lens to a projection function, use the section
--   <tt>(^.l)</tt> or <tt>view l</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; (3 :+ 4, "example")^._1.to(abs)
--   5.0 :+ 0.0
--   </pre>
to :: (s -> a) -> Getter s t a b

-- | <pre>
--   view :: Getter s t a b -&gt; s -&gt; a
--   </pre>
--   
--   Demote a lens or getter to a projection function.
--   
--   <pre>
--   view :: Monoid a =&gt; Fold s t a b -&gt; s -&gt; a
--   </pre>
--   
--   Returns the monoidal summary of a traversal or a fold.
view :: FoldLike a s t a b -> s -> a

-- | <pre>
--   (^.) :: s -&gt; Getter s t a b -&gt; a
--   </pre>
--   
--   Access the value referenced by a getter or lens.
--   
--   <pre>
--   (^.) :: Monoid a =&gt; s -&gt; Fold s t a b -&gt; a
--   </pre>
--   
--   Access the monoidal summary referenced by a traversal or a fold.
(^.) :: s -> FoldLike a s t a b -> a
infixl 8 ^.

-- | <a>folding</a> promotes a "toList" function to a read-only traversal
--   called a fold.
--   
--   To demote a traversal or fold to a "toList" function use the section
--   <tt>(^..l)</tt> or <tt>toListOf l</tt>.
folding :: Foldable f => (s -> f a) -> Fold s t a b

-- | <pre>
--   views :: Monoid r =&gt; Fold s t a b -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   Given a fold or traversal, return the <a>foldMap</a> of all the values
--   using the given function.
--   
--   <pre>
--   views :: Getter s t a b -&gt; (a -&gt; r) -&gt; s -&gt; r
--   </pre>
--   
--   <a>views</a> is not particularly useful for getters or lenses, but
--   given a getter or lens, it returns the referenced value passed through
--   the given function.
--   
--   <pre>
--   views l f s = f (view l s)
--   </pre>
views :: FoldLike r s t a b -> (a -> r) -> s -> r

-- | Returns a list of all of the referenced values in order.
(^..) :: s -> Fold s t a b -> [a]
infixl 8 ^..

-- | Returns <a>Just</a> the first referenced value. Returns <a>Nothing</a>
--   if there are no referenced values.
(^?) :: s -> Fold s t a b -> Maybe a
infixl 8 ^?

-- | Returns a list of all of the referenced values in order.
toListOf :: Fold s t a b -> s -> [a]

-- | Returns true if all of the referenced values satisfy the given
--   predicate.
allOf :: Fold s t a b -> (a -> Bool) -> s -> Bool

-- | Returns true if any of the referenced values satisfy the given
--   predicate.
anyOf :: Fold s t a b -> (a -> Bool) -> s -> Bool

-- | Returns <a>Just</a> the first referenced value. Returns <a>Nothing</a>
--   if there are no referenced values. See <a>^?</a> for an infix version
--   of <a>firstOf</a>
firstOf :: Fold s t a b -> s -> Maybe a

-- | Returns <a>Just</a> the last referenced value. Returns <a>Nothing</a>
--   if there are no referenced values.
lastOf :: Fold s t a b -> s -> Maybe a

-- | Returns the sum of all the referenced values.
sumOf :: Num a => Fold s t a b -> s -> a

-- | Returns the product of all the referenced values.
productOf :: Num a => Fold s t a b -> s -> a

-- | Counts the number of references in a traversal or fold for the input.
lengthOf :: Num r => Fold s t a b -> s -> r

-- | Returns true if the number of references in the input is zero.
nullOf :: Fold s t a b -> s -> Bool

-- | Returns <a>Right</a> of the first referenced value. Returns
--   <a>Left</a> the original value when there are no referenced values. In
--   case there are no referenced values, the result might have a fresh
--   type parameter, thereby proving the original value had no referenced
--   values.
matching :: Traversal s t a b -> s -> Either t a

-- | Demote a setter to a semantic editor combinator.
--   
--   <pre>
--   over :: Prism s t a b -&gt; Reviwer s t a b
--   over :: Grid s t a b -&gt; Grate s t a b
--   over :: Adapter s t a b -&gt; Grate s t a b
--   </pre>
--   
--   Covert an <a>AdapterLike</a> optic into a <a>GrateLike</a> optic.
over :: Setter s t a b -> (a -> b) -> s -> t

-- | Modify all referenced fields.
(%~) :: Setter s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Set all referenced fields to the given value.
set :: Setter s t a b -> b -> s -> t

-- | Set all referenced fields to the given value.
(.~) :: Setter s t a b -> b -> s -> t
infixr 4 .~

-- | <pre>
--   review :: Grate s t a b -&gt; b -&gt; t
--   review :: Reviewer s t a b -&gt; b -&gt; t
--   </pre>
review :: GrateLike (Constant () :: Type -> Type) s t a b -> b -> t

-- | Returns a binary instance of a grate.
--   
--   <pre>
--   zipWithOf l f x y = degrating l (k -&gt; f (k x) (k y))
--   </pre>
zipWithOf :: Grate s t a b -> (a -> a -> b) -> s -> s -> t

-- | Demote a grate to its normal, higher-order function, form.
--   
--   <pre>
--   degrating . grate = id
--   grate . degrating = id
--   </pre>
degrating :: Grate s t a b -> ((s -> a) -> b) -> t

-- | Demote a resetter to a semantic editor combinator.
--   
--   <pre>
--   under :: Prism s t a b -&gt; Traversal s t a b
--   under :: Grid s t a b -&gt; Traversal s t a b
--   under :: Adapter s t a b -&gt; Lens s t a b
--   </pre>
--   
--   Covert an <a>AdapterLike</a> optic into a <a>LensLike</a> optic.
--   
--   Note: this function is unrelated to the lens package's <tt>under</tt>
--   function.
under :: Resetter s t a b -> (a -> b) -> s -> t

-- | Set all referenced fields to the given value.
reset :: Resetter s t a b -> b -> s -> t

-- | A flipped version of <tt>($)</tt>.
(&) :: s -> (s -> t) -> t
infixl 1 &
(+~) :: Num a => Setter s t a a -> a -> s -> t
infixr 4 +~
(*~) :: Num a => Setter s t a a -> a -> s -> t
infixr 4 *~
(-~) :: Num a => Setter s t a a -> a -> s -> t
infixr 4 -~
(//~) :: Fractional a => Setter s t a a -> a -> s -> t
infixr 4 //~
(&&~) :: Setter s t Bool Bool -> Bool -> s -> t
infixr 4 &&~
(||~) :: Setter s t Bool Bool -> Bool -> s -> t
infixr 4 ||~

-- | Monoidally append a value to all referenced fields.
(<>~) :: Monoid a => Setter s t a a -> a -> s -> t
infixr 4 <>~
type Adapter s t a b = forall f g. (Functor f, Functor g) => AdapterLike f g s t a b
type Adapter' s a = forall f g. (Functor f, Functor g) => AdapterLike' f g s a
type Prism s t a b = forall f g. (Applicative f, Traversable g) => AdapterLike f g s t a b
type Prism' s a = forall f g. (Applicative f, Traversable g) => AdapterLike' f g s a
type Lens s t a b = forall f. Functor f => LensLike f s t a b
type Lens' s a = forall f. Functor f => LensLike' f s a
type Traversal s t a b = forall f. Applicative f => LensLike f s t a b
type Traversal' s a = forall f. Applicative f => LensLike' f s a
type Setter s t a b = forall f. Identical f => LensLike f s t a b
type Setter' s a = forall f. Identical f => LensLike' f s a
type Getter s t a b = forall f. Phantom f => LensLike f s t a b
type Getter' s a = forall f. Phantom f => LensLike' f s a
type Fold s t a b = forall f. (Phantom f, Applicative f) => LensLike f s t a b
type Fold' s a = forall f. (Phantom f, Applicative f) => LensLike' f s a
type Grate s t a b = forall g. Functor g => GrateLike g s t a b
type Grate' s a = forall g. Functor g => GrateLike' g s a
type Grid s t a b = forall f g. (Applicative f, Functor g) => AdapterLike f g s t a b
type Grid' s a = forall f g. (Applicative f, Functor g) => AdapterLike' f g s a
type Reviewer s t a b = forall f. Phantom f => GrateLike f s t a b
type Reviewer' s a = forall f. Phantom f => GrateLike' f s a
type AdapterLike (f :: Type -> Type) (g :: Type -> Type) s t a b = g a -> f b -> g s -> f t
type AdapterLike' (f :: Type -> Type) (g :: Type -> Type) s a = g a -> f a -> g s -> f s
type LensLike (f :: Type -> Type) s t a b = a -> f b -> s -> f t
type LensLike' (f :: Type -> Type) s a = a -> f a -> s -> f s
type GrateLike (g :: Type -> Type) s t a b = g a -> b -> g s -> t
type GrateLike' (g :: Type -> Type) s a = g a -> a -> g s -> s
type FoldLike r s t a b = LensLike Constant r :: Type -> Type s t a b
type FoldLike' r s a = LensLike' Constant r :: Type -> Type s a

-- | Constant functor.
data () => Constant a (b :: k)
class Functor f => Phantom (f :: Type -> Type)
class (Traversable f, Applicative f) => Identical (f :: Type -> Type)


-- | This module contains lenses, prisms, grids, grates and traversals for
--   common structures in Haskell. It also contains the combinators for
--   various kinds of optics.
--   
--   A Function name with <tt>'</tt> is a grate variant of a grid, and a
--   function name with <tt>_</tt> is a traversal variants of a grid or
--   prism. For example, <a>both'</a> is the grate variant of <a>both</a>
--   while <a>both_</a> is the traversal variant.
module Lens.Family2.Stock

-- | Lens on the first element of a pair.
_1 :: Lens (a, r) (b, r) a b

-- | Lens on the second element of a pair.
_2 :: Lens (r, a) (r, b) a b

-- | Lens on the Left or Right element of an (<a>Either</a> a a).
chosen :: Lens (Either a a) (Either b b) a b

-- | Lens on a given point of a function.
ix :: Eq k => k -> Lens' (k -> v) v

-- | Lens on a given point of a <a>Map</a>.
at :: Ord k => k -> Lens' (Map k v) (Maybe v)

-- | Lens on a given point of a <a>IntMap</a>.
intAt :: Int -> Lens' (IntMap v) (Maybe v)

-- | Lens providing strict access to a given point of a <a>Map</a>.
at' :: Ord k => k -> Lens' (Map k v) (Maybe v)

-- | Lens providing strict access to a given point of a <a>IntMap</a>.
intAt' :: Int -> Lens' (IntMap v) (Maybe v)

-- | Lens on a given point of a <a>Set</a>.
contains :: Ord k => k -> Lens' (Set k) Bool

-- | Lens on a given point of a <a>IntSet</a>.
intContains :: Int -> Lens' IntSet Bool

-- | A prism on the <a>Left</a> element of an <a>Either</a>.
left :: Prism (Either a r) (Either b r) a b

-- | A prism on the <a>Right</a> element of an <a>Either</a>.
right :: Prism (Either r a) (Either r b) a b

-- | A prism on the <a>Just</a> element of a <a>Maybe</a>.
just :: Prism (Maybe a) (Maybe b) a b

-- | A prism on the <a>Nothing</a> element of a <a>Maybe</a>.
nothing :: Prism' (Maybe a) ()

-- | A grid on both elements of a pair <tt>(a,a)</tt>.
both :: Grid (a, a) (b, b) a b

-- | A grid from the most significant bit to the least significant bit of a
--   <tt>FiniteBits</tt> type.
--   
--   Big endian order.
bend :: FiniteBits b => Grid' b Bool

-- | A grid from the least significant bit to the most significant bit of a
--   <tt>FiniteBits</tt> type.
--   
--   Little endian order.
lend :: FiniteBits b => Grid' b Bool

-- | A grate accessing the codomain of a function.
cod :: Grate (r -> a) (r -> b) a b

-- | A grate on both elements of a pair <tt>(a,a)</tt>.
both' :: Grate (a, a) (b, b) a b

-- | A grate from the most significant bit to the least significant bit of
--   a <tt>FiniteBits</tt> type.
--   
--   Big endian order.
bend' :: FiniteBits b => Grate' b Bool

-- | A grate from the least significant bit to the most significant bit of
--   a <tt>FiniteBits</tt> type.
--   
--   Little endian order.
lend' :: FiniteBits b => Grate' b Bool

-- | Traversals on both elements of a pair <tt>(a,a)</tt>.
both_ :: Traversal (a, a) (b, b) a b

-- | A traversal from the most significant bit to the least significant bit
--   of a <tt>FiniteBits</tt> type.
--   
--   Big endian order.
bend_ :: FiniteBits b => Traversal' b Bool

-- | A traversal from the least significant bit to the most significant bit
--   of a <tt>FiniteBits</tt> type.
--   
--   Little endian order.
lend_ :: FiniteBits b => Traversal' b Bool

-- | Traversal on the <a>Left</a> element of an <a>Either</a>.
left_ :: Traversal (Either a r) (Either b r) a b

-- | Traversal on the <a>Right</a> element of an <a>Either</a>.
right_ :: Traversal (Either r a) (Either r b) a b

-- | Traversal on the <a>Just</a> element of a <a>Maybe</a>.
just_ :: Traversal (Maybe a) (Maybe b) a b

-- | Traversal on the <a>Nothing</a> element of a <a>Maybe</a>.
nothing_ :: Traversal' (Maybe a) ()

-- | The empty traveral on any type.
ignored :: Traversal a a b b'

-- | An SEC referencing the parameter of a functor.
mapped :: Functor f => Setter (f a) (f a') a a'

-- | <pre>
--   alongside :: Lens s0 t0 a0 b0 -&gt; Lens s1 t1 a1 b1 -&gt; Lens (s0, s1) (t0, t1) (a0, a1) (b0, b1)
--   </pre>
--   
--   <pre>
--   alongside :: Getter s0 t0 a0 b0 -&gt; Getter s1 t1 a1 b1 -&gt; Getter (s0, s1) (t0, t1) (a0, a1) (b0, b1)
--   </pre>
--   
--   Given two lens/getter families, make a new lens/getter on their
--   product.
alongside :: Functor f => LensLike (AlongsideLeft f b1) s0 t0 a0 b0 -> LensLike (AlongsideRight f t0) s1 t1 a1 b1 -> LensLike f (s0, s1) (t0, t1) (a0, a1) (b0, b1)

-- | <pre>
--   backwards :: Traversal s t a b -&gt; Traversal s t a b
--   backwards :: Fold s t a b -&gt; Fold s t a b
--   </pre>
--   
--   Given a traversal or fold, reverse the order that elements are
--   traversed.
--   
--   <pre>
--   backwards :: Lens s t a b -&gt; Lens s t a b
--   backwards :: Getter s t a b -&gt; Getter s t a b
--   backwards :: Setter s t a b -&gt; Setter s t a b
--   </pre>
--   
--   No effect on lenses, getters or setters.
backwards :: LensLike (Backwards f) s t a b -> LensLike f s t a b

-- | <pre>
--   beside :: Grid s1 t1 a b -&gt; Grid s2 t2 a b -&gt; Grid (s1, s2) (t1, t2) a b
--   </pre>
--   
--   Given two grids referencing a type <tt>c</tt>, create a grid on the
--   pair referencing <tt>c</tt>.
beside :: (Applicative f, Functor g) => AdapterLike f g s0 t0 a b -> AdapterLike f g s1 t1 a b -> AdapterLike f g (s0, s1) (t0, t1) a b

-- | <pre>
--   beside' :: Grate s0 t0 a b -&gt; Grate s1 t1 a b -&gt; Grate (s0, s1) (t0, t1) a b
--   </pre>
--   
--   <pre>
--   beside' :: Resetter s0 t0 a b -&gt; Resetter s1 t1 a b -&gt; Resetter (s0, s1) (t0, t1) a b
--   </pre>
--   
--   Given two grates/resetters referencing a type <tt>c</tt>, create a
--   grate/resetter on the pair referencing <tt>c</tt>.
beside' :: Functor g => GrateLike g s0 t0 a b -> GrateLike g s1 t1 a b -> GrateLike g (s0, s1) (t0, t1) a b

-- | <pre>
--   beside_ :: Traversal s0 t0 a b -&gt; Traversal s1 t1 a b -&gt; Traversal (s0, s1) (t0, t1) a b
--   </pre>
--   
--   <pre>
--   beside_ :: Fold s0 t0 a b -&gt; Fold s1 t1 a b -&gt; Fold (s0, s1) (t0, t1) a b
--   </pre>
--   
--   <pre>
--   beside_ :: Setter s0 t0 a b -&gt; Setter s1 t1 a b -&gt; Setter (s0, s1) (t0, t1) a b
--   </pre>
--   
--   Given two traversals/folds/setters referencing a type <tt>c</tt>,
--   create a traversal/fold/setter on the pair referencing <tt>c</tt>.
beside_ :: Applicative f => LensLike f s0 t0 a b -> LensLike f s1 t1 a b -> LensLike f (s0, s1) (t0, t1) a b

-- | <pre>
--   choosing :: Lens s0 t0 a b -&gt; Lens s1 t1 a b -&gt; Lens (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Traversal s0 t0 a b -&gt; Traversal s1 t1 a b -&gt; Traversal (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Getter s0 t0 a b -&gt; Getter s1 t1 a b -&gt; Getter (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Fold s0 t0 a b -&gt; Fold s1 t1 a b -&gt; Fold (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   <pre>
--   choosing :: Setter s0 t0 a b -&gt; Setter s1 t1 a b -&gt; Setter (Either s0 s1) (Either t0 t1) a b
--   </pre>
--   
--   Given two lens/traversal/getter/fold/setter families with the same
--   substructure, make a new lens/traversal/getter/fold/setter on
--   <a>Either</a>.
choosing :: Functor f => LensLike f s0 t0 a b -> LensLike f s1 t1 a b -> LensLike f (Either s0 s1) (Either t0 t1) a b

-- | <pre>
--   from :: Adapter b a t s -&gt; Adapter s t a b
--   </pre>
--   
--   Reverses the direction of an adapter.
--   
--   <pre>
--   from :: Getter b a t s -&gt; Reviewer s t a b
--   from :: Reviewer b a t s -&gt; Getter s t a b
--   </pre>
--   
--   Changes a Getter into a Reviewer and vice versa.
from :: (Functor f, Functor g) => AdapterLike (FromF (g s -> f t) (f b) g) (FromG (f b) f) b a t s -> AdapterLike f g s t a b
data () => AlongsideLeft (f :: Type -> Type) b a
data () => AlongsideRight (f :: Type -> Type) a b
data () => FromF i j (g :: Type -> Type) x
data () => FromG e (f :: Type -> Type) x
type Lens s t a b = forall f. Functor f => LensLike f s t a b
type Lens' s a = forall f. Functor f => LensLike' f s a
type Grate s t a b = forall g. Functor g => GrateLike g s t a b
type Grate' s a = forall g. Functor g => GrateLike' g s a
type Traversal s t a b = forall f. Applicative f => LensLike f s t a b
type Traversal' s a = forall f. Applicative f => LensLike' f s a
type Setter s t a b = forall f. Identical f => LensLike f s t a b
type AdapterLike (f :: Type -> Type) (g :: Type -> Type) s t a b = g a -> f b -> g s -> f t
type AdapterLike' (f :: Type -> Type) (g :: Type -> Type) s a = g a -> f a -> g s -> f s
type LensLike (f :: Type -> Type) s t a b = a -> f b -> s -> f t
type LensLike' (f :: Type -> Type) s a = a -> f a -> s -> f s
class (Traversable f, Applicative f) => Identical (f :: Type -> Type)

-- | The same functor, but with an <a>Applicative</a> instance that
--   performs actions in the reverse order.
data () => Backwards (f :: k -> Type) (a :: k)

-- | The <a>FiniteBits</a> class denotes types with a finite, fixed number
--   of bits.
class Bits b => FiniteBits b

-- | <i>Deprecated: Renamed as <a>left</a>.</i>
lft :: Prism (Either a r) (Either b r) a b

-- | <i>Deprecated: Renamed as <a>right</a>.</i>
rgt :: Prism (Either r a) (Either r b) a b

-- | <i>Deprecated: Renamed as <a>just</a>.</i>
some :: Prism (Maybe a) (Maybe b) a b

-- | <i>Deprecated: Renamed as <a>nothing</a>.</i>
none :: Prism' (Maybe a) ()

-- | <i>Deprecated: Renamed as <a>left_</a>.</i>
lft_ :: Traversal (Either a r) (Either b r) a b

-- | <i>Deprecated: Renamed as <a>right_</a>.</i>
rgt_ :: Traversal (Either r a) (Either r b) a b

-- | <i>Deprecated: Renamed as <a>just_</a>.</i>
some_ :: Traversal (Maybe a) (Maybe b) a b

-- | <i>Deprecated: Renamed as <a>nothing_</a>.</i>
none_ :: Traversal' (Maybe a) ()


-- | Lenses allow you to use fields of the state of a state monad as if
--   they were variables in an imperative language. <a>use</a> is used to
--   retrieve the value of a variable, and <a>.=</a> and <a>%=</a> allow
--   you to set and modify a variable. C-style compound assignments are
--   also provided.
module Lens.Family2.State.Strict

-- | <pre>
--   zoom :: Monad m =&gt; Lens' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Lift a stateful operation on a field to a stateful operation on the
--   whole state. This is a good way to call a "subroutine" that only needs
--   access to part of the state.
--   
--   <pre>
--   zoom :: (Monad m, Monoid c) =&gt; Traversal' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Run the "subroutine" on each element of the traversal in turn and
--   <a>mconcat</a> all the results together.
--   
--   <pre>
--   zoom :: Monad m =&gt; Traversal' s a -&gt; StateT a m () -&gt; StateT s m ()
--   </pre>
--   
--   Run the "subroutine" on each element the traversal in turn.
zoom :: forall (m :: Type -> Type) c s a. Monad m => LensLike' (Zooming m c) s a -> StateT a m c -> StateT s m c

-- | <pre>
--   use :: MonadState s m =&gt; Getter s t a b -&gt; m a
--   </pre>
--   
--   Retrieve a field of the state
--   
--   <pre>
--   use :: (MonadState s m, Monoid a) =&gt; Fold s t a b -&gt; m a
--   </pre>
--   
--   Retrieve a monoidal summary of all the referenced fields from the
--   state
use :: MonadState s m => FoldLike a s t a b -> m a

-- | <pre>
--   uses :: (MonadState s m, Monoid r) =&gt; Fold s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve all the referenced fields from the state and foldMap the
--   results together with <tt>f :: a -&gt; r</tt>.
--   
--   <pre>
--   uses :: MonadState s m =&gt; Getter s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve a field of the state and pass it through the function <tt>f
--   :: a -&gt; r</tt>.
--   
--   <pre>
--   uses l f = f &lt;$&gt; use l
--   </pre>
uses :: MonadState s m => FoldLike r s t a b -> (a -> r) -> m r

-- | Modify a field of the state.
(%=) :: MonadState s m => Setter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Set a field of the state.
assign :: MonadState s m => Setter s s a b -> b -> m ()

-- | Set a field of the state.
(.=) :: MonadState s m => Setter s s a b -> b -> m ()
infix 4 .=

-- | <pre>
--   (%%=) :: MonadState s m =&gt; Lens s s a b -&gt; (a -&gt; (c, b)) -&gt; m c
--   </pre>
--   
--   Modify a field of the state while returning another value.
--   
--   <pre>
--   (%%=) :: (MonadState s m, Monoid c) =&gt; Traversal s s a b -&gt; (a -&gt; (c, b)) -&gt; m c
--   </pre>
--   
--   Modify each field of the state and return the <a>mconcat</a> of the
--   other values.
(%%=) :: MonadState s m => LensLike (Writer c) s s a b -> (a -> (c, b)) -> m c
infix 4 %%=

-- | Set a field of the state using the result of executing a stateful
--   command.
(<~) :: MonadState s m => Setter s s a b -> m b -> m ()
infixr 2 <~
(+=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 +=
(-=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 -=
(*=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 *=
(//=) :: (MonadState s m, Fractional a) => Setter' s a -> a -> m ()
infixr 4 //=
(&&=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 &&=
(||=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 ||=

-- | Monoidally append a value to all referenced fields of the state.
(<>=) :: (MonadState s m, Monoid a) => Setter' s a -> a -> m ()
infixr 4 <>=

-- | Strictly modify a field of the state.
(%!=) :: MonadState s m => Setter s s a b -> (a -> b) -> m ()
infix 4 %!=
(+!=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 +!=
(-!=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 -!=
(*!=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 *!=
(//!=) :: (MonadState s m, Fractional a) => Setter' s a -> a -> m ()
infixr 4 //!=
(&&!=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 &&!=
(||!=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 ||!=
(<>!=) :: (MonadState s m, Monoid a) => Setter' s a -> a -> m ()
infixr 4 <>!=
data () => Zooming (m :: Type -> Type) c a
type LensLike (f :: Type -> Type) s t a b = a -> f b -> s -> f t
type LensLike' (f :: Type -> Type) s a = a -> f a -> s -> f s
type FoldLike r s t a b = LensLike Constant r :: Type -> Type s t a b

-- | Constant functor.
data () => Constant a (b :: k)
type Setter s t a b = forall f. Identical f => LensLike f s t a b
type Setter' s a = forall f. Identical f => LensLike' f s a
class (Traversable f, Applicative f) => Identical (f :: Type -> Type)

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data () => StateT s (m :: Type -> Type) a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity


-- | Lenses allow you to use fields of the state of a state monad as if
--   they were variables in an imperative language. <a>use</a> is used to
--   retrieve the value of a variable, and <a>.=</a> and <a>%=</a> allow
--   you to set and modify a variable. C-style compound assignments are
--   also provided.
module Lens.Family2.State.Lazy

-- | <pre>
--   zoom :: Monad m =&gt; Lens' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Lift a stateful operation on a field to a stateful operation on the
--   whole state. This is a good way to call a "subroutine" that only needs
--   access to part of the state.
--   
--   <pre>
--   zoom :: (Monad m, Monoid c) =&gt; Traversal' s a -&gt; StateT a m c -&gt; StateT s m c
--   </pre>
--   
--   Run the "subroutine" on each element of the traversal in turn and
--   <a>mconcat</a> all the results together.
--   
--   <pre>
--   zoom :: Monad m =&gt; Traversal' s a -&gt; StateT a m () -&gt; StateT s m ()
--   </pre>
--   
--   Run the "subroutine" on each element the traversal in turn.
zoom :: forall (m :: Type -> Type) c s a. Monad m => LensLike' (Zooming m c) s a -> StateT a m c -> StateT s m c

-- | <pre>
--   use :: MonadState s m =&gt; Getter s t a b -&gt; m a
--   </pre>
--   
--   Retrieve a field of the state
--   
--   <pre>
--   use :: (MonadState s m, Monoid a) =&gt; Fold s t a b -&gt; m a
--   </pre>
--   
--   Retrieve a monoidal summary of all the referenced fields from the
--   state
use :: MonadState s m => FoldLike a s t a b -> m a

-- | <pre>
--   uses :: (MonadState s m, Monoid r) =&gt; Fold s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve all the referenced fields from the state and foldMap the
--   results together with <tt>f :: a -&gt; r</tt>.
--   
--   <pre>
--   uses :: MonadState s m =&gt; Getter s t a b -&gt; (a -&gt; r) -&gt; m r
--   </pre>
--   
--   Retrieve a field of the state and pass it through the function <tt>f
--   :: a -&gt; r</tt>.
--   
--   <pre>
--   uses l f = f &lt;$&gt; use l
--   </pre>
uses :: MonadState s m => FoldLike r s t a b -> (a -> r) -> m r

-- | Modify a field of the state.
(%=) :: MonadState s m => Setter s s a b -> (a -> b) -> m ()
infix 4 %=

-- | Set a field of the state.
assign :: MonadState s m => Setter s s a b -> b -> m ()

-- | Set a field of the state.
(.=) :: MonadState s m => Setter s s a b -> b -> m ()
infix 4 .=

-- | <pre>
--   (%%=) :: MonadState s m =&gt; Lens s s a b -&gt; (a -&gt; (c, b)) -&gt; m c
--   </pre>
--   
--   Modify a field of the state while returning another value.
--   
--   <pre>
--   (%%=) :: (MonadState s m, Monoid c) =&gt; Traversal s s a b -&gt; (a -&gt; (c, b)) -&gt; m c
--   </pre>
--   
--   Modify each field of the state and return the <a>mconcat</a> of the
--   other values.
(%%=) :: MonadState s m => LensLike (Writer c) s s a b -> (a -> (c, b)) -> m c
infix 4 %%=

-- | Set a field of the state using the result of executing a stateful
--   command.
(<~) :: MonadState s m => Setter s s a b -> m b -> m ()
infixr 2 <~
(+=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 +=
(-=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 -=
(*=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 *=
(//=) :: (MonadState s m, Fractional a) => Setter' s a -> a -> m ()
infixr 4 //=
(&&=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 &&=
(||=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 ||=

-- | Monoidally append a value to all referenced fields of the state.
(<>=) :: (MonadState s m, Monoid a) => Setter' s a -> a -> m ()
infixr 4 <>=

-- | Strictly modify a field of the state.
(%!=) :: MonadState s m => Setter s s a b -> (a -> b) -> m ()
infix 4 %!=
(+!=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 +!=
(-!=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 -!=
(*!=) :: (MonadState s m, Num a) => Setter' s a -> a -> m ()
infixr 4 *!=
(//!=) :: (MonadState s m, Fractional a) => Setter' s a -> a -> m ()
infixr 4 //!=
(&&!=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 &&!=
(||!=) :: MonadState s m => Setter' s Bool -> Bool -> m ()
infixr 4 ||!=
(<>!=) :: (MonadState s m, Monoid a) => Setter' s a -> a -> m ()
infixr 4 <>!=
data () => Zooming (m :: Type -> Type) c a
type LensLike (f :: Type -> Type) s t a b = a -> f b -> s -> f t
type LensLike' (f :: Type -> Type) s a = a -> f a -> s -> f s
type FoldLike r s t a b = LensLike Constant r :: Type -> Type s t a b

-- | Constant functor.
data () => Constant a (b :: k)
type Setter s t a b = forall f. Identical f => LensLike f s t a b
type Setter' s a = forall f. Identical f => LensLike' f s a
class (Traversable f, Applicative f) => Identical (f :: Type -> Type)

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data () => StateT s (m :: Type -> Type) a

-- | Minimal definition is either both of <tt>get</tt> and <tt>put</tt> or
--   just <tt>state</tt>
class Monad m => MonadState s (m :: Type -> Type) | m -> s

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

module Lens.Family2.State
